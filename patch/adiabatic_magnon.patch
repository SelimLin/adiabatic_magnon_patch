diff -urN file_ini/adiabatic_magnon.F file_modify/adiabatic_magnon.F
--- file_ini/adiabatic_magnon.F	1970-01-01 08:00:00.000000000 +0800
+++ file_modify/adiabatic_magnon.F	2024-07-13 10:37:23.000000000 +0800
@@ -0,0 +1,2117 @@
+#include "symbol.inc"
+
+MODULE magnon
+    use emlr 
+CONTAINS 
+    SUBROUTINE MAGNON_MAIN( &
+        HAMILTONIAN,P,WDES,NONLR_S,NONL_S,W0,LATT_CUR,LATT_INI, &
+        T_INFO,DYN,INFO,IO,MIX,KPOINTS,SYMM,GRID,GRID_SOFT, &
+        GRIDC,GRIDB,GRIDUS,C_TO_US,B_TO_C,SOFT_TO_C, &
+        CHTOT,DENCOR,CSTRF,CDIJ,CQIJ,CRHODE, &
+        N_MIX_PAW,RHOLM,CHDEN,SV,LMDIM,IRDMAX,NEDOS,EFERMI)
+    
+    IMPLICIT NONE
+    !=======================================================================
+    !  input/output variables
+    !=======================================================================
+    TYPE (ham_handle)  HAMILTONIAN
+    TYPE (type_info)   T_INFO        ! poscar description
+    TYPE (potcar)      P(T_INFO%NTYP)! pseudo potential
+    TYPE (wavedes)     WDES
+    TYPE (nonlr_struct) NONLR_S      ! non local projection operators in real space
+    TYPE (nonl_struct) NONL_S        ! non local projection operators in recip space
+    TYPE (wavespin)    W0            ! unperturbed wavefunctions
+    TYPE (latt)        LATT_CUR      ! lattice
+    TYPE (latt)        LATT_INI
+    TYPE (dynamics)    DYN
+    TYPE (info_struct) INFO
+    TYPE (in_struct)   IO
+    TYPE (mixing)      MIX
+    TYPE (kpoints_struct) KPOINTS
+    TYPE (symmetry)    SYMM
+    TYPE (grid_3d)     GRID       ! grid for wavefunctions
+    TYPE (grid_3d)     GRID_SOFT  ! grid for soft chargedensity
+    TYPE (grid_3d)     GRIDC      ! grid for potentials/charge
+    TYPE (grid_3d)     GRIDUS     ! temporary grid in us.F
+    TYPE (grid_3d)     GRIDB      ! Broyden grid
+    TYPE (transit)     B_TO_C     ! index table between GRIDB and GRIDC
+    TYPE (transit)     C_TO_US    ! index table between GRIDC and GRIDUS
+    TYPE (transit)     SOFT_TO_C  ! index table between GRID_SOFT and GRIDC
+
+    INTEGER LMDIM,IRDMAX,NEDOS
+    REAL(q) EFERMI
+
+    COMPLEX(q)  CHTOT(GRIDC%MPLWV,WDES%NCDIJ) ! charge-density in real / reciprocal space
+                                            ! \tilde n + \hat n
+                                            ! \tilde n : soft pseudo-charge-density
+                                            ! \hat n :  compensation charges
+    RGRID       DENCOR(GRIDC%RL%NP)           ! partial core
+                                            ! \tilde n_c : partial electronic core density
+    COMPLEX(q)  CSTRF(GRIDC%MPLWV,T_INFO%NTYP)
+    !  augmentation related quantities
+    OVERLAP  CDIJ(LMDIM,LMDIM,WDES%NIONS,WDES%NCDIJ), &
+        CQIJ(LMDIM,LMDIM,WDES%NIONS,WDES%NCDIJ), &
+        CRHODE(LMDIM,LMDIM,WDES%NIONS,WDES%NCDIJ)  ! one center occupancies
+    !  paw sphere charge density
+    INTEGER N_MIX_PAW
+    REAL(q) RHOLM(N_MIX_PAW,WDES%NCDIJ)
+    COMPLEX(q)  CHDEN(GRID_SOFT%MPLWV,WDES%NCDIJ)
+    !  charge-density and potential on soft grid
+    RGRID       SV(DIMREAL(GRID%MPLWV),WDES%NCDIJ)
+    !=======================================================================
+    !  local variables
+    !=======================================================================
+    TYPE (eigenf_cluster_pointer),POINTER :: DEG_CLUSTER(:,:)
+    REAL(q) :: DESUM,DESUM2                     ! change of energy
+    INTEGER :: ICOUEV                    ! number of H | phi> evaluations
+    ! RGRID   :: SV_EXT(DIMREAL(GRID%MPLWV),WDES%NCDIJ)
+    ! OVERLAP :: CDIJ_EXT(LMDIM,LMDIM,WDES%NIONS,WDES%NCDIJ)
+    ! ! wave function
+    ! TYPE (wavespin)     :: W0_KPQ            ! W0_k+q
+    ! TYPE (wavespin)     :: W0_KMQ            ! W0_k-q
+    ! TYPE (wavespin)     :: W1_KPQ            ! first order change of wavefunction
+    ! TYPE (wavespin)     :: W1_KMQ            ! first order change of wavefunction
+    COMPLEX(q),ALLOCATABLE ::  CV_EXT(:,:,:)    
+    COMPLEX(q),ALLOCATABLE ::  CV_IND(:,:,:)  
+    RGRID   :: SV_EXT(DIMREAL(GRID%MPLWV),WDES%NCDIJ)
+    RGRID   :: SV_IND(DIMREAL(GRID%MPLWV),WDES%NCDIJ)
+    COMPLEX(q) :: GAUSS_FIELD(GRIDC%MPLWV)
+    OVERLAP,ALLOCATABLE :: CDIJ_EXT(:,:,:,:,:),CRHODE1(:,:,:,:,:)
+    ! wave function
+    TYPE (wavespin)     :: W0_KPQ            ! W0_k+q
+    TYPE (wavespin)     :: W0_KMQ            ! W0_k-q
+    TYPE (wavespin),ALLOCATABLE     :: W1_KPQ(:)            ! first order change of wavefunction
+    TYPE (wavespin),ALLOCATABLE     :: W1_KMQ(:)            ! first order change of wavefunction
+    TYPE (wavespin),ALLOCATABLE     :: W1_KPQ_0(:)            ! first order change of wavefunction
+    TYPE (wavespin),ALLOCATABLE     :: W1_KMQ_0(:)            ! first order change of wavefunction
+    ! linear response using symmetry
+    TYPE (skpoints_trans)   :: KPOINTS_TRANS
+    INTEGER                 :: NKORIG
+    ! spin susceptibility
+    ! COMPLEX(q) :: CHI(GRIDC%MPLWV,4)     ! spin susceptibility
+    COMPLEX(q),ALLOCATABLE :: CHI(:,:,:)     ! spin susceptibility
+    COMPLEX(q),ALLOCATABLE :: CHI_G(:,:,:)     ! spin susceptibility
+    COMPLEX(q)  AECHG(GRIDC%MPLWV,WDES%NCDIJ),AECHG_SOFT(GRIDC%MPLWV,WDES%NCDIJ)
+    COMPLEX(q)  AECHG_G(GRIDC%MPLWV,WDES%NCDIJ)
+    COMPLEX(q),TARGET :: MAGINFO(GRIDC%RL%NP,WDES%NCDIJ), INVMNORM(GRIDC%RL%NP)
+    COMPLEX(q),POINTER:: MAGDIR(:,:), MNORM(:)
+    REAL(q):: MAGTOL
+    ! COMPLEX(q)  MAGDIR(GRIDC%RL%NP,3), MNORM(GRIDC%RL%NP)
+    COMPLEX(q) DMX_I(GRIDC%RL%NP),DMY_I(GRIDC%RL%NP),DMZ_I(GRIDC%RL%NP)
+    COMPLEX(q) DMX_J(GRIDC%RL%NP),DMY_J(GRIDC%RL%NP),DMZ_J(GRIDC%RL%NP)
+    COMPLEX(q),ALLOCATABLE :: CTMP(:) ! temporary result of matrix-matrix product
+    INTEGER    :: IGVEC
+
+    REAL(q) :: OMEGA
+    ! LOGICAL :: LOMEGA0
+    ! LOGICAL :: LSUBTRACT
+    ! q-vector
+    INTEGER :: NQVEC,NQPATH,NPATH,NPATH2
+    INTEGER :: IQVEC,IQPATH,IPATH
+    REAL(q), ALLOCATABLE :: QVECLIST(:,:)
+    REAL(q), ALLOCATABLE :: QVECPATH(:,:)
+    REAL(q) :: QVEC(3)
+    REAL(q) :: QVEC_CART(3)
+    LOGICAL :: LQVEC0
+    INTEGER :: GVEC(3)               ! G
+    REAL(q) :: GVEC_CART(3)
+    INTEGER :: GVEC_READ(3) ! temporary put here in order to give CHI OUTPUT
+    REAL(q) :: QPG_CART(3)           ! q+G
+    REAL(q), ALLOCATABLE :: KORIG(:,:)
+    REAL(q), ALLOCATABLE :: KPQ(:,:)
+    REAL(q), ALLOCATABLE :: KMQ(:,:)
+    ! strength of external field
+    REAL(q) :: B_DFPT(3)
+            ! electronic and magnetic field in unit eV
+
+    LOGICAL :: LBROT
+
+    INTEGER :: ISP,NI,NK,NT
+    ! input and output
+    INTEGER :: STAT
+
+    LOGICAL :: LFOUND
+    CHARACTER(LEN=80) :: INLINE
+    INTEGER :: IU6K                  ! OUTCAR k-points
+    ! control
+
+
+    REAL(q) :: ETA                   ! complex shift i*\eta
+                                ! improves stability in particular
+                                ! if degenerated eigenvalue pairs have not been resolved
+
+    ! mixing
+    INTEGER :: IMIX                  ! type of mixing
+    REAL(q) :: AMIX                  ! mixing parameter A
+    REAL(q) :: BMIX                  ! mixing parameter B
+    REAL(q) :: AMIX_MAG              ! mixing parameter A for magnetization
+    REAL(q) :: BMIX_MAG              ! mixing parameter B for magnetization
+    REAL(q) :: AMIN                  ! minimal mixing parameter A
+    REAL(q) :: WC
+    INTEGER :: MAXMIX
+    INTEGER :: MREMOVE
+    ! variables for W0_k+q and W0_k-q
+    REAL(q) :: EDIFF                 ! break condition
+    REAL(q) :: RMS                   ! change
+    REAL(q) :: TOTEN,TOTENL          ! energy
+    INTEGER :: NSIM
+    REAL(q) :: X,EXHF
+    INTEGER :: I,J,IALGO_SAVE
+    INTEGER :: NMAGION
+    INTEGER,ALLOCATABLE :: MAGIONLIST(:)
+    REAL(q) :: POSION(3),SIGMA_X,RINPL
+    REAL(q) :: U(3,3),S_(1),VT
+    COMPLEX(q),ALLOCATABLE :: H(:,:),S(:,:),V(:,:),STMP(:,:),Up(:,:)
+    INTEGER,ALLOCATABLE :: ipiv(:)
+    REAL(q), ALLOCATABLE:: LAMBDA(:)
+    COMPLEX(q), ALLOCATABLE:: LAMBDAC(:)
+    INTEGER :: ITER,NITER,I1,I2,I3,IP,IFAIL,LWORK,NITER_CORR
+    COMPLEX(q),ALLOCATABLE :: CWORK(:),SCAL(:)
+    REAL(q), ALLOCATABLE :: RWORK(:),RMST(:)
+    REAL(q), ALLOCATABLE :: OMEGARES(:),OMEGARES0(:),OMEGARES_(:)
+    COMPLEX(q)::CV_SUM(5) ! a temperary data
+    REAL(q):: RHO0_SOFT,RHO0_AUG,RHO0_AUG_G,CHBREAK_
+    REAL(q), EXTERNAL :: RHO0
+    INTEGER::NRES,NMAX,NSTART,NLS_,NCH_,ITYPE
+    LOGICAL::LDUMP,LINCV,LCORR
+    REAL(q)::strength,ESCAL
+
+    character(10) myString
+    NAMELIST /EMLR_PARA/ GVEC_READ,strength
+    NAMELIST /EMLR_PARA/ ETA,EPRO,STEP_LENGTH,LFERMI
+    NAMELIST /EMLR_PARA/ LBROT,LKSHIFT,LNOIMAG,LADAPT,LSOFT,LDUMP,LINCV,LCORR
+    NAMELIST /EMLR_PARA/ NCH,LCHUPD,CHBREAK,RCHBREAK,NITER,NMAX,NITER_CORR
+    NAMELIST /EMLR_PARA/ NLS,LSBREAK,LSDEPER,ESCAL
+    NAMELIST /EMLR_PARA/ IMIX,AMIX,BMIX,AMIX_MAG,BMIX_MAG,AMIN,WC,MAXMIX,MREMOVE,ITYPE
+
+    MAGDIR=>MAGINFO(:,2:4)
+    MNORM=>MAGINFO(:,1)
+#ifdef realmode
+    IF (IO%IU0>=0) WRITE(*,*)'DFPT does not support realmode, please remove -DNGXhalf or -DNGZhalf pre-compiler flag!'
+    STOP
+#endif
+
+    IF (.NOT. WDES%LNONCOLLINEAR) THEN
+    IF (IO%IU0>=0) WRITE(*,*)'DFPT REQUIRES NONCOLLINEAR CALCULATIONS!'
+    STOP
+    ENDIF
+
+    IONODE=0
+    NODE_ME=0
+#ifdef MPI
+    IONODE  = WDES%COMM%IONODE
+    NODE_ME = WDES%COMM%NODE_ME
+#endif
+
+    IF (IO%NWRITE>=3) THEN
+    IU6K  = IO%IU6
+    ELSE
+    IU6K  = -1
+    ENDIF
+
+    ! initialise
+    GVEC_READ   =(/0,0,0/)
+    strength    = 1
+    ETA         =0.02_q
+    STEP_LENGTH =1E-3_q
+    LFERMI      =.FALSE.
+    EPRO        = 0._q 
+    LNOIMAG     =.FALSE.
+    LADAPT      =.FALSE.
+    LSOFT       =.FALSE.
+    LDUMP       =.FALSE.
+    LINCV       =.FALSE.
+    LCORR       =.FALSE.
+
+    LBROT       =.TRUE.
+    LKSHIFT     =.TRUE.
+    LCHUPD(:)   =.TRUE.
+    NCH         =60
+    CHBREAK     =1E-2_q
+    RCHBREAK    =1E-10_q
+    NITER=3
+    NMAX=1
+    NITER_CORR=1
+
+    NLS     =6
+    LSBREAK =INFO%EBREAK/10
+    LSDEPER =INFO%DEPER
+    IMIX=MIX%IMIX
+    AMIX=MIX%AMIX
+    BMIX=MIX%BMIX
+    AMIX_MAG=MIX%AMIX_MAG
+    BMIX_MAG=MIX%BMIX_MAG
+    AMIN=MIX%AMIN
+    WC = MIX%WC
+    MAXMIX=MIX%MAXMIX
+    MREMOVE=MIX%MREMOVE
+    ITYPE=2
+    ESCAL=0.8
+
+    IALGO_SAVE=INFO%IALGO
+    INFO%IALGO=8
+
+    OPEN(UNIT=UNIT_EMLR_INPUT,FILE='EMLR_INPUT',FORM='FORMATTED',STATUS='UNKNOWN')
+    READ(UNIT_EMLR_INPUT,NML=EMLR_PARA, IOSTAT=STAT)
+    IF (STAT/=0) THEN
+    IF (IO%IU0>=0) WRITE(*,*) 'ERROR IN READING IN EMLR_PARA NAMELIST'
+    STOP
+    ENDIF
+    ! IF (NOMEGA<1) THEN
+    ! IF (IO%IU0>=0) WRITE(*,*) 'NOMEGA SHOULD BE POSITIVE INTEGER',NOMEGA
+    ! STOP
+    ! ENDIF
+
+    
+
+    ! read in qvec
+    REWIND(UNIT_EMLR_INPUT)
+    LFOUND=.FALSE.
+    DO
+    READ(UNIT_EMLR_INPUT,*,END=123)INLINE
+    IF (TRIM(ADJUSTL(INLINE))=='QVECLIST') THEN
+        LFOUND= .TRUE.
+        EXIT
+    ENDIF
+    ENDDO
+    123    CONTINUE
+    IF (.NOT.LFOUND) THEN
+    IF (IO%IU0>=0) WRITE(*,*) 'ERROR IN FOUNDING QVECLIST'
+    STOP
+    ENDIF
+
+    READ(UNIT_EMLR_INPUT,*,IOSTAT=STAT)NQPATH,NPATH
+    IF (STAT/=0) THEN
+    IF (IO%IU0>=0) WRITE(*,*) 'ERROR IN READING NQPATH AND NPATH'
+    STOP
+    ENDIF
+    IF (NQPATH<1) THEN
+    IF (IO%IU0>=0) WRITE(*,*) 'REQUIRE NQPATH >= 1 '
+    STOP
+    ENDIF
+    IF (NPATH<1) THEN
+    IF (IO%IU0>=0) WRITE(*,*) 'REQUIRE NPATH >= 1 '
+    STOP
+    ENDIF
+
+    IF (NQPATH==1) THEN
+    NPATH2=NPATH
+    ELSE
+    NPATH2=2*NPATH
+    ENDIF
+    ALLOCATE(QVECPATH(3,NPATH2))
+    DO IPATH=1,NPATH2
+    READ(UNIT_EMLR_INPUT,*,IOSTAT=STAT)QVECPATH(:,IPATH)
+    IF (STAT/=0) THEN
+        IF (IO%IU0>=0) WRITE(*,*) 'ERROR IN READING QVECLIST : ',IPATH
+        STOP
+    ENDIF
+    ENDDO
+
+    NQVEC=NQPATH*NPATH
+    ALLOCATE(QVECLIST(3,NQVEC))
+    IF (NQPATH==1) THEN
+    QVECLIST=QVECPATH
+    ELSE
+    IQVEC=0
+    DO IPATH=1,NPATH
+        DO IQPATH=1,NQPATH
+        IQVEC=IQVEC+1
+        QVECLIST(:,IQVEC)=(QVECPATH(:,IPATH*2)-QVECPATH(:,IPATH*2-1)) &
+                    & /(NQPATH-1)*(IQPATH-1)+QVECPATH(:,IPATH*2-1)
+        ENDDO
+    ENDDO
+    ENDIF
+
+    CLOSE(UNIT_EMLR_INPUT)
+
+    MIX%IMIX=IMIX
+    MIX%AMIX=AMIX
+    MIX%BMIX=BMIX
+    MIX%AMIX_MAG=AMIX_MAG
+    MIX%BMIX_MAG=BMIX_MAG
+    MIX%AMIN=AMIN
+    MIX%WC = WC
+    MIX%MAXMIX=MAXMIX
+    MIX%MREMOVE=MREMOVE
+    
+
+    ! 2*CSHIFT is used in subroutine EDDIAG_LR and LINEAR_RESPONSE_DIIS
+    CSHIFT=ABS(ETA)/2.0_q
+    STEP_BASE=STEP_LENGTH
+    IF (IO%IU0>=0) THEN
+    OPEN(UNIT=UNIT_EMLR_OUTPUT,FILE='EMLR_OUTPUT',STATUS='UNKNOWN')
+    OPEN(UNIT=UNIT_EMLR_CHI,FILE='EMLR_CHI',STATUS='UNKNOWN')
+    WRITE(UNIT_EMLR_OUTPUT,'("NQVEC               : ",I3)') NQVEC
+    DO IQVEC=1,NQVEC
+        WRITE(UNIT_EMLR_OUTPUT,'("QVEC                :",3(x,F7.4))') QVECLIST(:,IQVEC)
+    ENDDO
+    WRITE(UNIT_EMLR_OUTPUT,'("GVEC_INPUT          :",3(x,I3))') GVEC_READ
+    WRITE(UNIT_EMLR_OUTPUT,'("ETA (eV)            : ",F7.4)') ETA
+    WRITE(UNIT_EMLR_OUTPUT,'("STEP_LENGTH         : ",E11.4)') STEP_LENGTH
+    WRITE(UNIT_EMLR_OUTPUT,'("LFermi              : ",L3)') LFERMI
+    WRITE(UNIT_EMLR_OUTPUT,'("EPRO (eV)            : ",F7.4)') EPRO
+    WRITE(UNIT_EMLR_OUTPUT,'("LBROT               : ",L3)') LBROT
+    WRITE(UNIT_EMLR_OUTPUT,'("LKSHIFT             : ",L3)') LKSHIFT
+    WRITE(UNIT_EMLR_OUTPUT,'("LNOIMAG             : ",L3)') LNOIMAG
+    WRITE(UNIT_EMLR_OUTPUT,'("LADAPT             : ",L3)') LADAPT
+    WRITE(UNIT_EMLR_OUTPUT,'("LSOFT             : ",L3)') LSOFT
+    WRITE(UNIT_EMLR_OUTPUT,'("LDUMP             : ",L3)') LDUMP
+    WRITE(UNIT_EMLR_OUTPUT,'("LINCV             : ",L3)') LINCV
+    WRITE(UNIT_EMLR_OUTPUT,'("NCHARGE             : ",I3)') NCH
+    WRITE(UNIT_EMLR_OUTPUT,'("update channels     : ",4L3)') LCHUPD
+    WRITE(UNIT_EMLR_OUTPUT,'("CHBREAK             : ",E11.4)') CHBREAK
+    WRITE(UNIT_EMLR_OUTPUT,'("NLS             : ",I3)') NLS
+    WRITE(UNIT_EMLR_OUTPUT,'("LSBREAK         : ",E11.4)') LSBREAK
+    WRITE(UNIT_EMLR_OUTPUT,'("LSDEPER         : ",E11.4)') LSDEPER
+    WRITE(UNIT_EMLR_OUTPUT,'("IMIX                : ",I3)') MIX%IMIX
+    WRITE(UNIT_EMLR_OUTPUT,'("AMIX                : ",F7.4)') MIX%AMIX
+    WRITE(UNIT_EMLR_OUTPUT,'("BMIX                : ",F7.4)') MIX%BMIX
+    WRITE(UNIT_EMLR_OUTPUT,'("AMIX_MAG            : ",F7.4)') MIX%AMIX_MAG
+    WRITE(UNIT_EMLR_OUTPUT,'("BMIX_MAG            : ",F7.4)') MIX%BMIX_MAG
+    WRITE(UNIT_EMLR_OUTPUT,'("AMIN                : ",F7.4)') MIX%AMIN
+    WRITE(UNIT_EMLR_OUTPUT,'("WC                : ",F6.0)') MIX%WC
+    WRITE(UNIT_EMLR_OUTPUT,'("MAXMIX                : ",I3)')   MIX%MAXMIX
+    WRITE(UNIT_EMLR_OUTPUT,'("MREMOVE                : ",I3)')   MIX%MREMOVE
+    WRITE(UNIT_EMLR_OUTPUT,'("ITYPE                : ",I3)')   ITYPE
+    ENDIF
+    
+    EPRO = EPRO+EFERMI
+    
+    !AECHG in reciprocal space and (n,m) representation
+    CALL AUGCHG(WDES,GRID_SOFT,GRIDC,GRIDUS,C_TO_US, &
+            &     LATT_CUR,P,T_INFO,SYMM, INFO%LOVERL, SOFT_TO_C,&
+            &     LMDIM,CRHODE,AECHG,CHDEN,IRDMAX,.TRUE.,.FALSE.)
+    CALL AUGCHG_G(WDES, GRID_SOFT,GRIDC, &
+                  LATT_CUR,P,T_INFO,SYMM, INFO%LOVERL, SOFT_TO_C,&
+                  LMDIM,CRHODE,AECHG_G,CHDEN)
+
+    RHO0_SOFT= RHO0(GRID_SOFT, CHDEN(1,1))
+    RHO0_AUG= RHO0(GRIDC, AECHG(1,1))
+    RHO0_AUG_G= RHO0(GRIDC, AECHG_G(1,1))
+    IF (IO%IU0>=0) THEN
+        WRITE(UNIT_EMLR_OUTPUT,*) "soft         electrons", RHO0_SOFT
+        WRITE(UNIT_EMLR_OUTPUT,*) "total        electrons", RHO0_AUG
+        WRITE(UNIT_EMLR_OUTPUT,*) "total        electrons", RHO0_AUG_G
+    ENDIF
+
+    AECHG_SOFT=AECHG
+    DO ISP=1,WDES%NCDIJ
+        CALL SMOOTHER(GRIDC,AECHG_SOFT(:,ISP),LATT_CUR,SIGMA_X/4,[0._q,0._q,0._q])
+    ENDDO
+    ! transform the all-electron charge density to real space
+    DO ISP=1,WDES%NCDIJ
+        CALL FFT3D(AECHG(1,ISP),GRIDC,1)
+        CALL FFT3D(AECHG_G(1,ISP),GRIDC,1)
+        CALL FFT3D(AECHG_SOFT(1,ISP),GRIDC,1)
+    ENDDO
+    MAGRHO0= SUM(NORM2(ABS(AECHG_G(1:GRIDC%RL%NP,2:4)),DIM=2))/GRIDC%NPLWV
+    CALLMPI( M_sum_d(GRIDC%COMM,MAGRHO0,1))
+    IF (IO%IU0>=0) THEN
+        WRITE(UNIT_EMLR_OUTPUT,*) "total      |M|", MAGRHO0
+    ENDIF
+    
+    DO I=1,GRIDC%RL%NP
+        MNORM(I) = NORM2(ABS(AECHG_SOFT(I,2:4)))
+    ENDDO
+    ! determine the magnitude threshold MAGTOL of whether there are magnetization
+    ! this threshold is roughly 1/8 the mean magnetization over the region where magnetization is present 
+    CV_SUM(1)=SUM(MNORM(1:GRIDC%RL%NP))
+    CALLMPI( M_sum_z(GRIDC%COMM,CV_SUM(1),1))
+    MAGTOL = ABS(CV_SUM(1))/GRIDC%NPLWV
+    DO I = 1,10
+        CV_SUM(1)=0
+        CV_SUM(2)=0
+        DO J =1,GRIDC%RL%NP
+            IF (ABS(MNORM(J))>MAGTOL) THEN 
+                CV_SUM(1) = CV_SUM(1)+MNORM(J)
+                CV_SUM(2) = CV_SUM(2)+1
+            ENDIF
+        ENDDO
+        CALLMPI( M_sum_z(GRIDC%COMM,CV_SUM(1:2),2))
+        MAGTOL = ABS(CV_SUM(1)/CV_SUM(2))/8
+    ENDDO
+    ! MAGTOL=MAGTOL/2
+    DO I=1,GRIDC%RL%NP
+        INVMNORM(I) = MNORM(I)/(MNORM(I)**2+MAGTOL**2)
+        MAGDIR(I,1)=AECHG_SOFT(I,2)*INVMNORM(I)
+        MAGDIR(I,2)=AECHG_SOFT(I,3)*INVMNORM(I)
+        MAGDIR(I,3)=AECHG_SOFT(I,4)*INVMNORM(I)
+    ENDDO
+    NKORIG=WDES%NKPTS
+    NULLIFY(DEG_CLUSTER)
+
+    
+    !---------------------------------------------------------
+    io_begin
+    OPEN(UNIT=99,FILE='data/AECHG',STATUS='UNKNOWN')
+    io_end
+    DO ISP=1,WDES%NCDIJ
+        CALL OUTRL_CMPLX(GRIDC,99,.TRUE.,AECHG(:,ISP))
+    ENDDO
+    io_begin
+    CLOSE(99)
+    io_end
+    IF(LDUMP)THEN
+    !----------------------------------------------------------
+    io_begin
+    OPEN(UNIT=99,FILE='data/AECHG_G',STATUS='UNKNOWN')
+    io_end
+    DO ISP=1,WDES%NCDIJ
+        CALL OUTRL_CMPLX(GRIDC,99,.TRUE.,AECHG_G(:,ISP))
+    ENDDO
+    io_begin
+    CLOSE(99)
+    io_end
+    !----------------------------------------------------------
+    io_begin
+    OPEN(UNIT=99,FILE='data/MAGINFO',STATUS='UNKNOWN')
+    io_end
+    DO ISP=1,WDES%NCDIJ
+        CALL OUTRL_CMPLX(GRIDC,99,.TRUE.,MAGINFO(:,ISP))
+    ENDDO
+    io_begin
+    CLOSE(99)
+    io_end
+    ENDIF
+    !----------------------------------------------------------
+    io_begin
+    OPEN(UNIT=99,FILE='data/AECRHO',STATUS='UNKNOWN')
+    io_end
+    CALL OUTCRHO(99,WDES,T_INFO,LMDIM,CRHODE(:,:,:,:))
+    io_begin
+    CLOSE(99)
+    io_end
+    !----------------------------------------------------------
+    !----------------------------------------------------------
+
+    IF (SYMM%ISYM>0) THEN
+        ! switch off the symmetry since we can not expect any symmetry in external field in the following calculation
+        CALL NOSYMM(LATT_CUR%A,T_INFO%NTYP,T_INFO%NITYP,T_INFO%NIONS,SYMM%PTRANS, &
+                    SYMM%NROT,SYMM%NPTRANS,SYMM%ROTMAP,SYMM%MAGROT,WDES%ISPIN,IO%IU6)
+                ! reread k-points with LINVERSION=.FALSE. to generate full mesh
+        CALL RE_READ_KPOINTS(KPOINTS,LATT_CUR,.FALSE., &
+                T_INFO%NIONS,SYMM%ROTMAP,SYMM%MAGROT,SYMM%ISYM,IU6K,IO%IU0)
+        CALL KPAR_SYNC_ALL(WDES,W0)
+        CALL RE_GEN_LAYOUT( GRID, WDES, KPOINTS, LATT_CUR, LATT_CUR,IO%IU6, IO%IU0)
+        CALL PEAD_RESETUP_WDES(WDES, GRID, KPOINTS, LATT_CUR, LATT_CUR, IO) 
+        CALL REALLOCATE_WAVE(W0,GRID,WDES,NONL_S,T_INFO,P,LATT_CUR,KPOINTS_TRANS)
+        ! Loewdin perturbation theory to improve states at added k-points
+        CALL EDDIAG(HAMILTONIAN,GRID,LATT_CUR,NONLR_S,NONL_S,W0,WDES,SYMM, &
+        &    LMDIM,CDIJ,CQIJ,4,SV,T_INFO,P,IO%IU0,DESUM, NKSTART=NKORIG+1)
+        CALL KPAR_SYNC_ALL(WDES,W0)
+    ENDIF
+    CALL FIND_DEG_CLUSTERS(WDES,W0,DEG_CLUSTER)
+
+    ! record number of magnetic ion and their indices in the list of atom
+    NMAGION=0
+    DO NI = 1,T_INFO%NIONS
+        IF (NORM2(T_INFO%ATOMOM(1+(NI-1)*3:NI*3))>0.01) NMAGION=NMAGION+1 
+    ENDDO
+    ALLOCATE(MAGIONLIST(NMAGION))
+    NMAGION=0
+    DO NI = 1,T_INFO%NIONS
+        IF (NORM2(T_INFO%ATOMOM(1+(NI-1)*3:NI*3))>0.01) THEN 
+            NMAGION=NMAGION+1
+            MAGIONLIST(NMAGION)=NI
+        ENDIF 
+    ENDDO
+    NRES=2*NMAGION
+    NMAX=NMAX*NRES
+    NSTART=0
+    ALLOCATE(CV_EXT(GRIDC%MPLWV,WDES%NCDIJ,NMAX+NRES))
+    ALLOCATE(CDIJ_EXT(LMDIM,LMDIM,WDES%NIONS,WDES%NCDIJ,NMAX))
+    ALLOCATE(CV_IND(GRIDC%MPLWV,WDES%NCDIJ,NMAX))
+    ALLOCATE(CRHODE1(LMDIM,LMDIM,WDES%NIONS,WDES%NCDIJ,NMAX))
+    ALLOCATE(W1_KPQ(NMAX),W1_KMQ(NMAX))
+    ALLOCATE(CHI(GRIDC%MPLWV,WDES%NCDIJ,NMAX))
+    ALLOCATE(CHI_G(GRIDC%MPLWV,WDES%NCDIJ,NMAX))
+    ALLOCATE(CTMP(MAX(GRIDC%MPLWV*WDES%NCDIJ*(NMAX+1),LMDIM*LMDIM*WDES%NIONS*WDES%NCDIJ*(NMAX+1))))
+    ALLOCATE(H(NMAX,NMAX),S(NMAX,NMAX),V(NMAX,NMAX),STMP(NMAX,NMAX),Up(NMAX,NMAX))
+    ALLOCATE(LAMBDA(NMAX))
+    ALLOCATE(LAMBDAC(NMAX))
+    ALLOCATE(ipiv(NMAX))
+    LWORK=20
+    ALLOCATE(CWORK(20*NMAX),SCAL(NMAX))
+    ALLOCATE(RWORK(3*NMAX))
+    ALLOCATE(RMST(NMAX))
+    ALLOCATE(OMEGARES(NMAX),OMEGARES0(NMAX),OMEGARES_(NMAX))
+    IF (.NOT. ALLOCATED(SV1_KPQ_IND)) ALLOCATE(SV1_KPQ_IND(DIMREAL(GRID%MPLWV),WDES%NCDIJ))
+    IF (.NOT. ALLOCATED(SV1_KPQ_IND0)) ALLOCATE(SV1_KPQ_IND0(DIMREAL(GRID%MPLWV),WDES%NCDIJ))
+    IF (.NOT. ALLOCATED(CDIJ1_KPQ_IND)) ALLOCATE(CDIJ1_KPQ_IND(LMDIM,LMDIM,WDES%NIONS,WDES%NCDIJ))
+
+    IF(LCORR) ALLOCATE(W1_KPQ_0(1),W1_KMQ_0(1))
+    ! WRITE(*,*) "SIZE(CDIJ_EXT)",SIZE(CDIJ_EXT)
+    ! OVERLAP :: CDIJ_EXT(LMDIM,LMDIM,WDES%NIONS,WDES%NCDIJ)
+
+    NLS_=NLS
+    NCH_=NCH
+    CHBREAK_=CHBREAK
+    momentum: DO IQVEC=1,NQVEC
+    QVEC=QVECLIST(:,IQVEC)
+    CALL NEAREST_LATTICE_POINT(QVEC,GVEC,LATT_CUR)
+    GVEC=GVEC+GVEC_READ
+
+
+    ! DO ISP=1,3
+    !     GVEC(ISP) = GVEC_READ(ISP)+QVEC(ISP)-(MOD(QVEC(ISP)-0.5_q,1.0_q)+0.5_q)
+    !     QVEC(ISP) = QVEC(ISP)+GVEC_READ(ISP)-GVEC(ISP)
+    ! ENDDO
+
+    ! Notice that 2*pi is omitted which should be retrieved in the subroutine
+    QVEC_CART(1)=(QVEC(1)*LATT_CUR%B(1,1)+QVEC(2)*LATT_CUR%B(1,2)+QVEC(3)*LATT_CUR%B(1,3))
+    QVEC_CART(2)=(QVEC(1)*LATT_CUR%B(2,1)+QVEC(2)*LATT_CUR%B(2,2)+QVEC(3)*LATT_CUR%B(2,3))
+    QVEC_CART(3)=(QVEC(1)*LATT_CUR%B(3,1)+QVEC(2)*LATT_CUR%B(3,2)+QVEC(3)*LATT_CUR%B(3,3))
+    IF (SUM(QVEC_CART**2) < 1E-10_q) THEN
+        LQVEC0=.TRUE.
+        QVEC=0
+        QVEC_CART=0
+    ELSE
+        LQVEC0=.FALSE.
+    ENDIF
+
+    GVEC_CART(1)=(GVEC(1)*LATT_CUR%B(1,1)+GVEC(2)*LATT_CUR%B(1,2)+GVEC(3)*LATT_CUR%B(1,3))
+    GVEC_CART(2)=(GVEC(1)*LATT_CUR%B(2,1)+GVEC(2)*LATT_CUR%B(2,2)+GVEC(3)*LATT_CUR%B(2,3))
+    GVEC_CART(3)=(GVEC(1)*LATT_CUR%B(3,1)+GVEC(2)*LATT_CUR%B(3,2)+GVEC(3)*LATT_CUR%B(3,3))
+    QPG_CART=QVEC_CART+GVEC_CART
+
+    IF (IO%IU0>=0) THEN
+        WRITE(UNIT_EMLR_CHI,'("QVEC                :",3(x,F7.4))') QVEC
+        WRITE(UNIT_EMLR_CHI,141)
+     ENDIF
+     
+     141 FORMAT('       I        OMEGA        d OMEGA        r.rms          ')
+
+    !assign Gaussian packet like field centered at magnetic ions. Each magnetic ion have two transverse direction to assign 
+    IF (IO%IU0>=0) THEN
+        WRITE(UNIT_EMLR_OUTPUT,*) "NMAGION= ",NMAGION
+        WRITE(UNIT_EMLR_OUTPUT,*) "MAGIONLIST= ",MAGIONLIST
+    ENDIF
+    
+
+    CV_EXT=0
+    IF (LINCV) THEN 
+        IF (IO%IU0>=0) THEN
+            WRITE(UNIT_EMLR_OUTPUT,*) "reading user-provided external potential"
+        ENDIF
+        DO I = 1,NRES
+            write(myString,'("_",I2.2)') I
+                !---------------------------------------------------------
+                io_begin
+                OPEN(UNIT=99,FILE='data/CV_EXT'//TRIM(myString),STATUS='UNKNOWN')
+                io_end
+                DO ISP=1,WDES%NCDIJ
+                    CALL INRL_CMPLX(GRIDC,99,.TRUE.,CV_EXT(:,ISP,I))
+                    CALL FFT_RC_SCALE(CV_EXT(1,ISP,I),CV_EXT(1,ISP,I),GRIDC)
+                ENDDO
+                io_begin
+                CLOSE(99)
+                io_end
+        ENDDO
+        DO I = 1,NRES
+        CV_SUM(1) = 0
+            DO ISP=2,WDES%NCDIJ
+                CV_SUM(1) = CV_SUM(1)+SUM(CONJG(CV_EXT(1:GRIDC%RC%NP,ISP,I))*CV_EXT(1:GRIDC%RC%NP,ISP,I))
+            ENDDO
+            CALLMPI( M_sum_z(GRIDC%COMM,CV_SUM(1),1))
+            CALL ZDSCAL(GRIDC%MPLWV*WDES%NCDIJ, SQRT(2000/ABS(CV_SUM(1))), CV_EXT(1,1,I), 1)
+        ENDDO
+    ELSE
+        DO ISP =1,NMAGION
+            NI = MAGIONLIST(ISP)
+            NT = T_INFO%ITYP(NI)
+            POSION=T_INFO%POSION(:,NI)
+            SIGMA_X = P(NT)%RDEP/2
+            CALL CALC_SVD_REAL( T_INFO%ATOMOM(3*(NI-1)+1:3*NI), 3, 1, U, S_, VT )
+            ! I don't know whether the LAPACK algorithm is deterministic.
+            CALLMPI( M_bcast_d(WDES%COMM,U,9))
+            IF (IO%IU0>=0) THEN
+                WRITE(UNIT_EMLR_OUTPUT,*) "ION #",NI
+                WRITE(UNIT_EMLR_OUTPUT,'("POSITION :",3(x,F7.4))') POSION
+                WRITE(UNIT_EMLR_OUTPUT,*) "SIGMA_X :",SIGMA_X
+                WRITE(UNIT_EMLR_OUTPUT,'("ATOMOM= ",3(x,F7.4))') T_INFO%ATOMOM(3*(NI-1)+1:3*NI)
+                WRITE(UNIT_EMLR_OUTPUT,*) "U= "
+                DO I = 1,3
+                    WRITE(UNIT_EMLR_OUTPUT,"(3(x,F7.4))") U(I,:)
+                ENDDO
+            ENDIF
+            GAUSS_FIELD=0
+            IF (ITYPE==2) THEN
+                CALL GAUSS_CV(GRIDC,GAUSS_FIELD,LATT_CUR,POSION,SIGMA_X,QVEC)
+            ELSE IF (ITYPE==3) THEN
+                ! in order to "garantee" the excitation, we shift the gaussian wave into a non-symmetric position
+                CALL GAUSS_CV(GRIDC,GAUSS_FIELD,LATT_CUR,POSION+[SIGMA_X/LATT_CUR%ANORM(1),0._q,0._q],SIGMA_X,QVEC)
+                CALL GAUSS_CV(GRIDC,GAUSS_FIELD,LATT_CUR,POSION+[0._q,SIGMA_X/LATT_CUR%ANORM(2),0._q],SIGMA_X,QVEC)
+                CALL GAUSS_CV(GRIDC,GAUSS_FIELD,LATT_CUR,POSION+[0._q,0._q,SIGMA_X/LATT_CUR%ANORM(3)],SIGMA_X,QVEC)
+                GAUSS_FIELD=GAUSS_FIELD/3
+            ENDIF 
+            DO I = 1,2
+            DO J =1,3
+                CV_EXT(:,J+1,2*ISP-2+I)=GAUSS_FIELD*U(J,I+1)*strength
+            ENDDO
+            ENDDO 
+        ENDDO
+    ENDIF
+
+
+
+    ! The following is a smooth projection out of longtitudinal component of external field (in real space).
+    ! When magnetization density is small, it is unstable to directly calculate 
+    ! spin direction, which can be fluctuated due to numerical error. And we multiply an smooth cut-off
+    ! function so that the field is also small there.  
+    DO I =1,2*NMAGION
+        DO ISP=2,WDES%NCDIJ
+            CALL FFT3D(CV_EXT(1,ISP,I),GRIDC,1)
+        ENDDO
+        DO J =1,GRIDC%RL%NP
+            CV_EXT(J,2:4,I)= (CV_EXT(J,2:4,I)-DOT_PRODUCT(CV_EXT(J,2:4,I),MAGDIR(J,:))*MAGDIR(J,:))*(MNORM(J)*INVMNORM(J))
+        ENDDO
+        DO ISP=2,WDES%NCDIJ
+            CALL FFT_RC_SCALE(CV_EXT(1,ISP,I),CV_EXT(1,ISP,I),GRIDC)
+            CALL SETUNB(CV_EXT(1,ISP,I),GRIDC)
+        ENDDO
+    ENDDO
+    CDIJ_EXT=0
+    DO I =1,2*NMAGION
+        DO ISP=2,WDES%NCDIJ
+            ! CDIJ_EXT initialized to 0 in the CV_TO_CDIJ routine.
+            CALL CV_TO_CDIJ(WDES, P, T_INFO, INFO%LOVERL, LMDIM, CDIJ_EXT(:,:,:,ISP,I), QVEC,GRIDC,CV_EXT(:,ISP,I),LATT_CUR)
+        ENDDO
+    ENDDO
+
+    ALLOCATE(KORIG(3,WDES%NKPTS),KPQ(3,WDES%NKPTS),KMQ(3,WDES%NKPTS))
+    KORIG=WDES%VKPT(1:3,1:WDES%NKPTS)
+    DO NK=1,WDES%NKPTS
+        KPQ(:,NK)=KORIG(:,NK)+QVEC
+        KMQ(:,NK)=KORIG(:,NK)-QVEC
+    ENDDO
+    !=======================================================================
+    ! calculate W0_k+q and W0_k-q for sub-space rotation
+    !=======================================================================
+    EDIFF = 1E-13
+    NSIM=WDES%NSIM*2
+#ifdef MPI
+    NSIM=((WDES%NSIM*2+WDES%COMM_INTER%NCPU-1)/WDES%COMM_INTER%NCPU)*WDES%COMM_INTER%NCPU
+#endif
+
+    X=INFO%EBREAK
+    ! for some non obvious reasons
+    INFO%EBREAK=0.25*EDIFF
+    !=======================================================================
+    ! k+q
+    !=======================================================================
+    ! In this version of adiabatic magnon calculation, symmetry is switched off and full k-grid is employed 
+    ! during DFPT calculation. So for LKSHIFT = TRUE, symmetry can still be switched on for ground state calculation.
+    ! IF (LKSHIFT .AND. SYMM%ISYM /= -1) THEN
+    !     IF (IO%IU0>=0) WRITE(*,*) 'For LKSHIFT = .TRUE., ISYM should be set to -1'
+    !     STOP
+    ! ENDIF
+
+    WDES%VKPT(1:3,1:WDES%NKPTS)=KPQ
+    ! kinetic energy |k+q+G|^2
+    CALL SET_DATAKE(WDES, LATT_CUR%B)
+    ! non-local projector |p_k+q>
+    IF (.NOT. INFO%LREAL) THEN
+        CALL SPHER(GRID,NONL_S,P,WDES,LATT_CUR, 1)
+    ENDIF
+
+    IF (IO%IU0>=0) THEN
+        WRITE (IO%IU0,*) 'Wavefunctions W0_k+q for DFPT'
+    ENDIF
+
+    CALL ALLOCW(WDES,W0_KPQ)
+    CALL EMLR_COPYW(W0,W0_KPQ)
+    CALL PROALL(GRID,LATT_CUR,NONLR_S,NONL_S,W0_KPQ)
+    CALL ORTHCH(WDES, W0_KPQ, WDES%LOVERL, LMDIM, CQIJ)
+
+    TOTENL=0
+    DO I=1,15! INFO%NELM
+        CALL EDDAV(HAMILTONIAN,P, GRID,INFO,LATT_CUR,NONLR_S,NONL_S,W0_KPQ,WDES, NSIM, &
+            LMDIM,CDIJ,CQIJ, RMS,DESUM,ICOUEV, SV, EXHF, IO%IU6,IO%IU0, .FALSE., .TRUE., .FALSE.)
+
+        TOTEN=BANDSTRUCTURE_ENERGY(WDES,W0_KPQ)
+
+        IF (IO%IU0>=0) THEN
+        WRITE(IO%IU0,1000) I, TOTEN, TOTEN-TOTENL, DESUM, ICOUEV, RMS
+        ENDIF
+    1000   FORMAT('DAV: ',I3,'   ',E20.12,'   ',E12.5,'   ',E12.5,I6,'  ',E10.3)
+        IF(ABS(DESUM)<EDIFF.AND.ABS(TOTEN-TOTENL)<EDIFF) EXIT
+        TOTENL=TOTEN
+    ENDDO
+    CALL KPAR_SYNC_ALL(WDES,W0_KPQ)
+
+    ! For LKSHIFT = .TRUE., fermi weight of W0_kpq need to be calculated
+    IF (LKSHIFT) THEN
+        CALL EMLR_DEN(IO%IU0, WDES, W0_KPQ, KPOINTS, EFERMI, KPOINTS%SIGMA, NEDOS, 0, 0)
+    ENDIF
+
+    IF (LQVEC0) CALL EMLR_COPYW(W0,W0_KPQ)
+    !=======================================================================
+    ! k-q
+    !=======================================================================
+    IF (.NOT. LKSHIFT) THEN
+        WDES%VKPT(1:3,1:WDES%NKPTS)=KMQ
+        ! kinetic energy |k-q+G|^2
+        CALL SET_DATAKE(WDES, LATT_CUR%B)
+        ! non-local projector |p_k-q>
+        IF (.NOT. INFO%LREAL) THEN
+        CALL SPHER(GRID,NONL_S,P,WDES,LATT_CUR, 1)
+        ENDIF
+
+        IF (IO%IU0>=0) THEN
+        WRITE (IO%IU0,*) 'Wavefunctions W0_k-q for DFPT'
+        ENDIF
+
+        CALL ALLOCW(WDES,W0_KMQ)
+        CALL EMLR_COPYW(W0,W0_KMQ)
+        CALL PROALL(GRID,LATT_CUR,NONLR_S,NONL_S,W0_KMQ)
+        CALL ORTHCH(WDES, W0_KMQ, WDES%LOVERL, LMDIM, CQIJ)
+
+        TOTENL=0
+        DO I=1,10
+        CALL EDDAV(HAMILTONIAN,P, GRID,INFO,LATT_CUR,NONLR_S,NONL_S,W0_KMQ,WDES, NSIM, &
+                LMDIM,CDIJ,CQIJ, RMS,DESUM,ICOUEV, SV, EXHF, IO%IU6,IO%IU0, .FALSE., .TRUE., .FALSE.)
+
+        TOTEN=BANDSTRUCTURE_ENERGY(WDES,W0_KMQ)
+
+        IF (IO%IU0>=0) THEN
+            WRITE(IO%IU0,1000) I, TOTEN, TOTEN-TOTENL, DESUM, ICOUEV, RMS
+        ENDIF
+        IF(ABS(DESUM)<EDIFF.AND.ABS(TOTEN-TOTENL)<EDIFF) EXIT
+        TOTENL=TOTEN
+        ENDDO
+        CALL KPAR_SYNC_ALL(WDES,W0_KMQ)
+
+        IF (LQVEC0) CALL EMLR_COPYW(W0,W0_KMQ)
+    ENDIF
+    INFO%EBREAK=X    ! restore the break condition
+    WDES%VKPT(1:3,1:WDES%NKPTS)=KORIG
+    OMEGA=0
+    DO I =1,NMAX
+        CALL ALLOCW(WDES,W1_KPQ(I))
+        CALL ALLOCW(WDES,W1_KMQ(I))
+    ENDDO
+    IF (LCORR) THEN
+        CALL ALLOCW(WDES,W1_KPQ_0(1))
+        CALL ALLOCW(WDES,W1_KMQ_0(1))
+    ENDIF
+
+    OMEGARES=0
+    OMEGARES0=0
+    SV_IND=0
+    CV_IND=0
+iteration: DO ITER = 1,NITER
+        IF (ITER>2) THEN 
+            IF (SUM(ABS(OMEGARES(1:NRES)-OMEGARES0(1:NRES)))<2E-3_q) EXIT
+        ENDIF
+        ! prepare density response |s_i> from newly generated field |b_i>
+        DO I =NSTART+1,NSTART+NRES
+            ! set soft potential SV_EXT
+            DO ISP=1,WDES%NCDIJ
+                CALL CP_GRID(GRIDC,GRID_SOFT,SOFT_TO_C,CV_EXT(1,ISP,I),SV_EXT(1,ISP))
+                CALL SETUNB(SV_EXT(1,ISP),GRID_SOFT)
+                CALL FFT3D(SV_EXT(1,ISP),GRID_SOFT, 1)
+#ifdef realmode
+            CALLMPI( M_bcast_d(WDES%COMM_INTER, SV_EXT(1,ISP), GRID%RL%NP))
+#else
+            CALLMPI( M_bcast_z(WDES%COMM_INTER, SV_EXT(1,ISP), GRID%RL%NP))
+#endif
+            ENDDO
+            SV1_KPQ_IND=0
+            CDIJ1_KPQ_IND=0
+            CALL EMLR_KERNEL( &
+                HAMILTONIAN,P,WDES,NONLR_S,NONL_S,W0,LATT_CUR,LATT_INI, &
+                T_INFO,DYN,INFO,IO,MIX,KPOINTS,SYMM,GRID,GRID_SOFT, &
+                GRIDC,GRIDB,GRIDUS,C_TO_US,B_TO_C,SOFT_TO_C, &
+                CHTOT,DENCOR,CSTRF,CDIJ,CQIJ,CRHODE, &
+                N_MIX_PAW,RHOLM,SV,LMDIM,IRDMAX,NEDOS,EFERMI,DEG_CLUSTER,&
+                OMEGA,QVEC,W0_KPQ,W0_KMQ,W1_KPQ(I),W1_KMQ(I),SV_EXT,CDIJ_EXT(:,:,:,:,I),CHI(:,:,I),CHI_G(:,:,I),CRHODE1(:,:,:,:,I),GVEC)
+            SV_IND=SV1_KPQ_IND-SV1_KPQ_IND0
+            DO ISP=1,WDES%NCDIJ
+                CALL FFT_RC_SCALE(SV_IND(1,ISP),SV_IND(1,ISP),GRID_SOFT)
+                CALL CPB_GRID(GRIDC,GRID_SOFT,SOFT_TO_C,SV_IND(1,ISP),CV_IND(1,ISP,I))
+                CALL FFT3D(CHI(1,ISP,I),GRIDC,1)
+            ENDDO
+        ENDDO
+        ! temperarily keep content of H in V 
+        H=0
+        RINPL=1._q/GRIDC%NPLWV
+        ! WRITE(*,*) "GRIDC%NPLWV", GRIDC%NPLWV
+        DO I =1,NSTART+NRES
+        DO J =I,NSTART+NRES
+            CALL MANY_BODY_OVERLAP(W1_KPQ(I),W1_KPQ(J),WDES,CQIJ,CV_SUM(1))
+            CALL MANY_BODY_OVERLAP(W1_KMQ(J),W1_KMQ(I),WDES,CQIJ,CV_SUM(2))
+            H(I,J) = CV_SUM(1)-CV_SUM(2)
+            H(J,I) = CONJG(H(I,J))
+        ENDDO
+        ENDDO
+
+        S=0
+        DO I =1,NSTART+NRES
+        DO J =1,NSTART+NRES
+        DO ISP=2,WDES%NCDIJ
+            S(I,J)=S(I,J)+SUM(CONJG(CV_EXT(1:GRIDC%RC%NP,ISP,I))*CHI_G(1:GRIDC%RC%NP,ISP,J))
+        ENDDO 
+        ENDDO
+        ENDDO
+        CALLMPI( M_sum_z(GRIDC%COMM,S,NMAX*NMAX))
+
+        IF (IO%IU0>=0) THEN
+            WRITE(UNIT_EMLR_OUTPUT,*) "H'="
+            DO I = 1,NSTART+NRES
+                WRITE(UNIT_EMLR_OUTPUT,'(99(E12.5,"+",E12.5,"i   "))') H(I,1:NSTART+NRES)
+            ENDDO
+            WRITE(UNIT_EMLR_OUTPUT,*) "S'="
+            DO I = 1,NSTART+NRES
+                WRITE(UNIT_EMLR_OUTPUT,'(99(E12.5,"+",E12.5,"i   "))') S(I,1:NSTART+NRES)
+            ENDDO
+        ENDIF
+
+        IF (LNOIMAG) THEN
+            STMP=(S+CONJG(TRANSPOSE(S)))/2 
+        ELSEIF (LCORR) THEN
+            STMP = S
+            NCH=1
+            DO I =1,NSTART+NRES
+                ! set soft potential SV_EXT
+                DO ISP=1,WDES%NCDIJ
+                    CALL CP_GRID(GRIDC,GRID_SOFT,SOFT_TO_C,CV_EXT(1,ISP,I),SV_EXT(1,ISP))
+                    CALL SETUNB(SV_EXT(1,ISP),GRID_SOFT)
+                    CALL FFT3D(SV_EXT(1,ISP),GRID_SOFT, 1)
+#ifdef realmode
+                CALLMPI( M_bcast_d(WDES%COMM_INTER, SV_EXT(1,ISP), GRID%RL%NP))
+#else
+                CALLMPI( M_bcast_z(WDES%COMM_INTER, SV_EXT(1,ISP), GRID%RL%NP))
+#endif
+                ENDDO
+                SV1_KPQ_IND=0
+                CDIJ1_KPQ_IND=0
+                CALL EMLR_KERNEL( &
+                    HAMILTONIAN,P,WDES,NONLR_S,NONL_S,W0,LATT_CUR,LATT_INI, &
+                    T_INFO,DYN,INFO,IO,MIX,KPOINTS,SYMM,GRID,GRID_SOFT, &
+                    GRIDC,GRIDB,GRIDUS,C_TO_US,B_TO_C,SOFT_TO_C, &
+                    CHTOT,DENCOR,CSTRF,CDIJ,CQIJ,CRHODE, &
+                    N_MIX_PAW,RHOLM,SV,LMDIM,IRDMAX,NEDOS,EFERMI,DEG_CLUSTER,&
+                    OMEGA,QVEC,W0_KPQ,W0_KMQ,W1_KPQ_0(1),W1_KMQ_0(1),SV_EXT,CDIJ_EXT(:,:,:,:,I),CTMP(1),CTMP(GRIDC%MPLWV*WDES%NCDIJ+1),CTMP(2*GRIDC%MPLWV*WDES%NCDIJ+1),GVEC)
+                DO J =1,NSTART+NRES
+                    CALL MANY_BODY_OVERLAP(W1_KPQ_0(1),W1_KPQ(J),WDES,CQIJ,CV_SUM(1))
+                    CALL MANY_BODY_OVERLAP(W1_KMQ(J),W1_KMQ_0(1),WDES,CQIJ,CV_SUM(2))
+                    STMP(I,J)=STMP(I,J)+CMPLX(0._q,2._q)*2*CSHIFT*(CV_SUM(1)-CV_SUM(2))
+                ENDDO
+            ENDDO
+            IF (IO%IU0>=0) THEN
+                WRITE(UNIT_EMLR_OUTPUT,*) "STMP="
+                DO I = 1,NSTART+NRES
+                    WRITE(UNIT_EMLR_OUTPUT,'(99(E12.5,"+",E12.5,"i   "))') STMP(I,1:NSTART+NRES)
+                ENDDO
+            ENDIF
+            NCH=NCH_
+        ELSE 
+            STMP = S
+        ENDIF 
+
+        IF (LNOIMAG) THEN
+            ! Choleski-Householder algorithm to solve generalized eigenvalue problem.
+            ! WRITE(*,*) "SOLVING EIGENPROBLEM"
+            V=H
+            CALL ZHEGV &
+                    &  (1,'V','U',NSTART+NRES,V,NMAX,STMP,NMAX,LAMBDA, &
+                    &           CWORK(1),LWORK*(NSTART+NRES),RWORK(1),IFAIL)
+            PROFILING_STOP('zhegv')
+            IF (IFAIL/=0) THEN
+                IF (IO%IU6>=0) &
+                    WRITE(IO%IU6,209) IFAIL,0,0
+                IF (IO%IU0>=0) &
+                    WRITE(IO%IU0,209) IFAIL,0,0
+                STOP
+            ENDIF        
+        209             FORMAT('WARNING in ADIABATIC_MAGNON: call to ZHEGV failed, returncode =',I4,1X,I2,1X,I6)
+            ! I don't know whether the LAPACK algorithm is deterministic.
+        ELSE
+            ! calculate X that satisfies SX=H, X=S^-1*H
+            V=H
+            ! solve eigenproblem of X
+            CALL ZGESV( NSTART+NRES, NSTART+NRES, STMP, NMAX, IPIV, V, NMAX, IFAIL)
+            STMP=V
+            CALL ZGEEV( 'N', 'V', NSTART+NRES, STMP, NMAX, LAMBDAC, V, NMAX, V, &
+            &                  NMAX, CWORK,LWORK*(NSTART+NRES),RWORK, IFAIL )
+            LAMBDA(1:NSTART+NRES)=1/REAL(1/LAMBDAC(1:NSTART+NRES))
+            !sort the eigenvalue and eigenvectors according to the real part.
+            DO I = 1,NSTART+NRES
+                IPIV(I)=I
+            ENDDO
+            CALL DSORT_ASC(NSTART+NRES,LAMBDA,IPIV)
+            Up=V
+            DO I = 1,NSTART+NRES
+                V(:,I)=Up(:,IPIV(I))
+            ENDDO
+        ENDIF 
+        CALLMPI( M_bcast_z(WDES%COMM,V,NMAX*NMAX))
+        CALLMPI( M_bcast_d(WDES%COMM,LAMBDA,NMAX))
+        
+
+        ! we have to permutate the eigenstates, so that the magnon bands comes first
+        IF (IO%IU0>=0) THEN
+            WRITE(UNIT_EMLR_OUTPUT,*) "LAMBDA="
+            WRITE(UNIT_EMLR_OUTPUT,'(99(E12.5,"   "))') LAMBDA(1:NSTART+NRES)
+        ENDIF 
+
+        RWORK(1:NRES/2)=LAMBDA(1:NRES/2)
+        RWORK(NRES/2+1:NRES)=LAMBDA(NSTART+NRES/2+1:NSTART+NRES)
+        IF (NSTART>0) RWORK(NRES+1:NSTART+NRES)=LAMBDA(NRES/2+1:NSTART+NRES/2)
+        LAMBDA(1:NMAX)=RWORK(1:NMAX)
+
+        STMP(1:NMAX,1:NRES/2) = V(1:NMAX,1:NRES/2)
+        STMP(1:NMAX,NRES/2+1:NRES)=V(1:NMAX,NSTART+NRES/2+1:NSTART+NRES)
+        IF (NSTART>0) STMP(1:NMAX,NRES+1:NSTART+NRES)=V(1:NMAX,NRES/2+1:NSTART+NRES/2)
+        V(1:NMAX,1:NMAX)=STMP(1:NMAX,1:NMAX)
+
+        IF (IO%IU0>=0) THEN
+            WRITE(UNIT_EMLR_OUTPUT,*) "LAMBDA="
+            WRITE(UNIT_EMLR_OUTPUT,'(99(E12.5,"   "))') LAMBDA(1:NSTART+NRES)
+        ENDIF 
+
+        ! OUTPUT
+        OMEGARES0=OMEGARES
+        OMEGARES(1:NRES)=1/LAMBDA(1:NRES)
+        OMEGARES_=OMEGARES
+        SCAL = 1 
+        
+        ! rotate field and response
+        CALL GGEMM('N', 'N', GRIDC%MPLWV*WDES%NCDIJ , NSTART+NRES, NSTART+NRES, one, &
+                &   CV_EXT, GRIDC%MPLWV*WDES%NCDIJ, V, NMAX,  &
+                &   zero, CTMP, GRIDC%MPLWV*WDES%NCDIJ)
+        ! IF (IO%IU0>=0) WRITE(*,*) "COPY CV_EXT"
+        CALL ZCOPY(GRIDC%MPLWV*WDES%NCDIJ*(NSTART+NRES),CTMP,1,CV_EXT,1)
+        ! IF (IO%IU0>=0) WRITE(*,*) "DONE"
+        
+
+        IF (WDES%NIONS>0) THEN
+            CALL GGEMM('N', 'N', LMDIM*LMDIM*WDES%NIONS*WDES%NCDIJ , NSTART+NRES, NSTART+NRES, one, &
+                    &   CDIJ_EXT, LMDIM*LMDIM*WDES%NIONS*WDES%NCDIJ , V, NMAX,  &
+                    &   zero, CTMP, LMDIM*LMDIM*WDES%NIONS*WDES%NCDIJ)
+            ! IF (IO%IU0>=0) WRITE(*,*) "COPY CDIJ_EXT"
+            CALL ZCOPY(LMDIM*LMDIM*WDES%NIONS*WDES%NCDIJ*(NSTART+NRES),CTMP,1,CDIJ_EXT,1)
+            ! IF (IO%IU0>=0) WRITE(*,*) "DONE"
+        ENDIF
+
+        IF (WDES%NIONS>0) THEN
+            CALL GGEMM('N', 'N', LMDIM*LMDIM*WDES%NIONS*WDES%NCDIJ , NSTART+NRES, NSTART+NRES, one, &
+                    &   CRHODE1, LMDIM*LMDIM*WDES%NIONS*WDES%NCDIJ , V, NMAX,  &
+                    &   zero, CTMP, LMDIM*LMDIM*WDES%NIONS*WDES%NCDIJ)
+            ! IF (IO%IU0>=0) WRITE(*,*) "COPY CDIJ_EXT"
+            CALL ZCOPY(LMDIM*LMDIM*WDES%NIONS*WDES%NCDIJ*(NSTART+NRES),CTMP,1,CRHODE1,1)
+            ! IF (IO%IU0>=0) WRITE(*,*) "DONE"
+        ENDIF
+
+
+        CALL GGEMM('N', 'N', GRIDC%MPLWV*WDES%NCDIJ , NSTART+NRES, NSTART+NRES, one, &
+                &   CHI, GRIDC%MPLWV*WDES%NCDIJ, V, NMAX,  &
+                &   zero, CTMP, GRIDC%MPLWV*WDES%NCDIJ)
+        ! IF (IO%IU0>=0) WRITE(*,*) "COPY CHI"
+        CALL ZCOPY(GRIDC%MPLWV*WDES%NCDIJ*(NSTART+NRES),CTMP,1,CHI,1)
+        ! IF (IO%IU0>=0) WRITE(*,*) "DONE"
+
+
+        CALL GGEMM('N', 'N', GRIDC%MPLWV*WDES%NCDIJ , NSTART+NRES, NSTART+NRES, one, &
+                &   CHI_G, GRIDC%MPLWV*WDES%NCDIJ, V, NMAX,  &
+                &   zero, CTMP, GRIDC%MPLWV*WDES%NCDIJ)
+        ! IF (IO%IU0>=0) WRITE(*,*) "COPY CHI_G"
+        CALL ZCOPY(GRIDC%MPLWV*WDES%NCDIJ*(NSTART+NRES),CTMP,1,CHI_G,1)
+        ! IF (IO%IU0>=0) WRITE(*,*) "DONE"
+
+        CALL GGEMM('N', 'N', GRIDC%MPLWV*WDES%NCDIJ , NSTART+NRES, NSTART+NRES, one, &
+                &   CV_IND, GRIDC%MPLWV*WDES%NCDIJ, V, NMAX,  &
+                &   zero, CTMP, GRIDC%MPLWV*WDES%NCDIJ)
+        ! IF (IO%IU0>=0) WRITE(*,*) "COPY CV_EXT"
+        CALL ZCOPY(GRIDC%MPLWV*WDES%NCDIJ*(NSTART+NRES),CTMP,1,CV_IND,1)
+        ! IF (IO%IU0>=0) WRITE(*,*) "DONE"
+
+
+        CALL ROTATE_WAVE_ARRAY(W1_KPQ(1:NSTART+NRES),V(1:NSTART+NRES,1:NSTART+NRES),NSTART+NRES)
+        CALL ROTATE_WAVE_ARRAY(W1_KMQ(1:NSTART+NRES),CONJG(V(1:NSTART+NRES,1:NSTART+NRES)),NSTART+NRES)
+
+!OUTPUT intermediate results
+        IF (LDUMP) THEN
+            DO I =1,NRES
+                !OUTPUT external potential
+                    write(myString,'("_",I1"_",I2.2)') ITER,I
+                    !---------------------------------------------------------
+                    io_begin
+                    OPEN(UNIT=99,FILE='data/CV_EXT'//TRIM(myString),STATUS='UNKNOWN')
+                    io_end
+                    DO ISP=1,WDES%NCDIJ
+                        CALL FFT3D(CV_EXT(1,ISP,I),GRIDC,1)
+                        CALL OUTRL_CMPLX(GRIDC,99,.TRUE.,CV_EXT(:,ISP,I))
+                        CALL FFT_RC_SCALE(CV_EXT(1,ISP,I),CV_EXT(1,ISP,I),GRIDC)
+                    ENDDO
+                    io_begin
+                    CLOSE(99)
+                    io_end
+            ENDDO 
+            DO I =1,NRES
+                write(myString,'("_",I1"_",I2.2)') ITER,I
+                !----------------------------------------------------------
+                io_begin
+                OPEN(UNIT=99,FILE='data/CHI'//TRIM(myString),STATUS='UNKNOWN')
+                io_end
+                DO ISP=1,WDES%NCDIJ
+                    CALL OUTRL_CMPLX(GRIDC,99,.TRUE.,CHI(:,ISP,I))
+                ENDDO
+                io_begin
+                CLOSE(99)
+                io_end
+                !----------------------------------------------------------
+                io_begin
+                OPEN(UNIT=99,FILE='data/CHI_G'//TRIM(myString),STATUS='UNKNOWN')
+                io_end
+                DO ISP=1,WDES%NCDIJ
+                    CALL FFT3D(CHI_G(1,ISP,I),GRIDC,1)
+                    CALL OUTRL_CMPLX(GRIDC,99,.TRUE.,CHI_G(:,ISP,I))
+                    CALL FFT_RC_SCALE(CHI_G(1,ISP,I),CHI_G(1,ISP,I),GRIDC)
+                ENDDO
+                io_begin
+                CLOSE(99)
+                io_end
+                !----------------------------------------------------------
+                io_begin
+                OPEN(UNIT=99,FILE='data/CRHO'//TRIM(myString),STATUS='UNKNOWN')
+                io_end
+                CALL OUTCRHO(99,WDES,T_INFO,LMDIM,CRHODE1(:,:,:,:,I))
+                io_begin
+                CLOSE(99)
+                io_end
+                !----------------------------------------------------------
+            ENDDO
+        ENDIF
+        ! CHI only take part in CV_EXT calculation in below.
+        DO I =1,NSTART+NRES
+            DO ISP=1,WDES%NCDIJ
+                CALL FFT_RC_SCALE(CHI(1,ISP,I),CHI(1,ISP,I),GRIDC)
+                CALL SMOOTHER(GRIDC,CHI(1,ISP,I),LATT_CUR,SIGMA_X/4,QVEC)
+                CALL FFT3D(CHI(1,ISP,I),GRIDC,1)
+            ENDDO
+        ENDDO
+        ! compute the residual vector, the last eigenvector is saved in CV(:,:,I+NMAX)
+        STMP=0;Up=0
+        DO I =1,NRES
+        DO J =1,NRES
+        DO ISP=2,WDES%NCDIJ
+            STMP(I,J)=STMP(I,J)+SUM(CONJG(CV_EXT(1:GRIDC%RC%NP,ISP,I))*CV_EXT(1:GRIDC%RC%NP,ISP,J))
+            Up(I,J)=Up(I,J)+SUM(CONJG(CV_EXT(1:GRIDC%RC%NP,ISP,I))*CV_EXT(1:GRIDC%RC%NP,ISP,J+NMAX))
+        ENDDO
+        ENDDO
+        ENDDO
+        CALLMPI( M_sum_z(GRIDC%COMM,STMP,NMAX*NMAX))
+        CALLMPI( M_sum_z(GRIDC%COMM,Up,NMAX*NMAX))
+        CALL ZGESV( NRES, NRES, STMP, NMAX, IPIV, Up, NMAX, IFAIL)
+        PROFILING_STOP('zgesv')
+        IF (IFAIL/=0) THEN
+            IF (IO%IU6>=0) &
+                WRITE(IO%IU6,219) IFAIL,0,0
+            IF (IO%IU0>=0) &
+                WRITE(IO%IU0,219) IFAIL,0,0
+            STOP
+        ENDIF   
+        219             FORMAT('WARNING in ADIABATIC_MAGNON: call to ZGESV failed, returncode =',I4,1X,I2,1X,I6)
+        ! I don't know whether the LAPACK algorithm is deterministic.
+        CALLMPI( M_bcast_z(WDES%COMM,Up,NMAX*NMAX))
+        IF (IO%IU0>=0) THEN
+            WRITE(UNIT_EMLR_OUTPUT,*) "Abs(Up)="
+            DO I = 1,NRES
+                WRITE(UNIT_EMLR_OUTPUT,'(99(E12.5,"   "))') Abs(Up(I,1:NRES))
+            ENDDO
+        ENDIF
+
+        ! compute residual vector 
+        CALL GGEMM('N', 'N', GRIDC%MPLWV*WDES%NCDIJ , NRES, NRES, -one, &
+                &   CV_EXT(1,1,1), GRIDC%MPLWV*WDES%NCDIJ, Up, NMAX,  &
+                &   one, CV_EXT(1,1,1+NMAX), GRIDC%MPLWV*WDES%NCDIJ)
+
+        ! calculate |residual vector|/|eigenvector|
+        RMST=0
+        DO I = 1,NRES
+            CV_SUM=0
+            DO ISP=2,WDES%NCDIJ
+                CV_SUM(1)=CV_SUM(1)+SUM(ABS(CV_EXT(1:GRIDC%RC%NP,ISP,I)**2))
+                CV_SUM(2)=CV_SUM(2)+SUM(ABS(CV_EXT(1:GRIDC%RC%NP,ISP,I+NSTART)**2))
+                CV_SUM(3)=CV_SUM(3)+SUM(ABS(CV_EXT(1:GRIDC%RC%NP,ISP,I+NMAX)**2))
+                CV_SUM(4)=CV_SUM(4)+SUM(CV_EXT(1:GRIDC%RC%NP,ISP,I)*conjg(CHI_G(1:GRIDC%RC%NP,ISP,I)))
+                CV_SUM(5)=CV_SUM(5)+SUM(CV_EXT(1:GRIDC%RC%NP,ISP,I+NSTART)*conjg(CHI_G(1:GRIDC%RC%NP,ISP,I+NSTART)))
+            ENDDO
+            CALLMPI( M_sum_z(GRIDC%COMM,CV_SUM,5))
+            RMST(I) = ABS(CV_SUM(3)/CV_SUM(1))
+            LAMBDA(I)=ABS(CV_SUM(1)/CV_SUM(4))
+            LAMBDA(I+NSTART)=ABS(CV_SUM(2)/CV_SUM(5))
+        ENDDO
+        IF (ITER==1) RMST=1
+        IF (IO%IU0>=0) THEN
+            WRITE(UNIT_EMLR_OUTPUT,*) "field strength="
+            WRITE(UNIT_EMLR_OUTPUT,'(99(E12.5,"   "))') LAMBDA(1:NSTART+NRES)
+        ENDIF
+
+        ! save the current eigenvector
+        CALL ZCOPY(GRIDC%MPLWV*WDES%NCDIJ*NRES,CV_EXT,1,CV_EXT(1,1,NMAX+1),1)
+
+        IF (NSTART < NMAX-NRES) NSTART = NSTART+NRES
+        ! basis set expansion
+        DO I = 1,NRES
+            ! IF (ITER==1 .OR. NSTART==0) THEN
+            !     DO J = 1,GRIDC%RL%NP
+            !         CV_EXT(J,2,I+NSTART) = (0._q,1._q)*(MAGDIR(J,3-1)*CHI(J,4,I)-MAGDIR(J,4-1)*CHI(J,3,I))*INVMNORM(J)
+            !         CV_EXT(J,3,I+NSTART) = (0._q,1._q)*(MAGDIR(J,4-1)*CHI(J,2,I)-MAGDIR(J,2-1)*CHI(J,4,I))*INVMNORM(J)
+            !         CV_EXT(J,4,I+NSTART) = (0._q,1._q)*(MAGDIR(J,2-1)*CHI(J,3,I)-MAGDIR(J,3-1)*CHI(J,2,I))*INVMNORM(J)
+            !     ENDDO
+            !     CALL FFT_RC_SCALE(CV_EXT(1,2,I+NSTART),CV_EXT(1,2,I+NSTART),GRIDC)
+            !     CALL FFT_RC_SCALE(CV_EXT(1,3,I+NSTART),CV_EXT(1,3,I+NSTART),GRIDC)
+            !     CALL FFT_RC_SCALE(CV_EXT(1,4,I+NSTART),CV_EXT(1,4,I+NSTART),GRIDC)
+            ! ELSE 
+            !     CV_EXT(:,2,I+NSTART) = CV_EXT(:,2,I)
+            !     CV_EXT(:,3,I+NSTART) = CV_EXT(:,3,I)
+            !     CV_EXT(:,4,I+NSTART) = CV_EXT(:,4,I)
+            ! ENDIF
+            CV_EXT(:,:,I+NSTART) = 0
+            CV_EXT(:,2,I+NSTART) = CV_IND(:,2,I)
+            CV_EXT(:,3,I+NSTART) = CV_IND(:,3,I)
+            CV_EXT(:,4,I+NSTART) = CV_IND(:,4,I)
+            CV_SUM(1) = 0
+            DO ISP=2,WDES%NCDIJ
+                ! CALL SMOOTHER(GRIDC,CV_EXT(1,ISP,I+NSTART),LATT_CUR,SIGMA_X/3,QVEC)
+                CV_SUM(1) = CV_SUM(1)+SUM(CONJG(CV_EXT(1:GRIDC%RC%NP,ISP,I+NSTART))*CV_EXT(1:GRIDC%RC%NP,ISP,I+NSTART))
+            ENDDO
+            CALLMPI( M_sum_z(GRIDC%COMM,CV_SUM(1),1))
+            CALL ZDSCAL(GRIDC%MPLWV*WDES%NCDIJ, SQRT(2000/ABS(CV_SUM(1))), CV_EXT(1,1,I+NSTART), 1)
+            DO ISP=2,WDES%NCDIJ
+                ! CDIJ_EXT initialized to 0 in the CV_TO_CDIJ routine.
+                CALL CV_TO_CDIJ(WDES, P, T_INFO, INFO%LOVERL, LMDIM, CDIJ_EXT(:,:,:,ISP,I+NSTART), QVEC,GRIDC,CV_EXT(:,ISP,I+NSTART),LATT_CUR)
+            ENDDO
+        ENDDO
+
+        IF (IO%IU0>=0) THEN
+            WRITE(UNIT_EMLR_CHI,'("--------------------Iteration ",I3,"------------------")') ITER
+            DO I=1,NRES
+                WRITE(UNIT_EMLR_CHI,200) I,OMEGARES(I),OMEGARES(I)-OMEGARES0(I),RMST(I)
+            ENDDO
+        ENDIF
+        200 FORMAT('   ',I3,'   ',E12.5,'   ',E12.5,'   ',E12.5)
+    ENDDO iteration
+
+    ! Now we are faced with hard-to-converged DFPT, so we relax the convergence criterion
+    NLS=MAX(50,NLS_)
+    CHBREAK=MAX(1E-2_q,CHBREAK_)
+    CALL ZCOPY(GRIDC%MPLWV*WDES%NCDIJ*NRES,CV_EXT(1,1,NMAX+1),1,CV_EXT,1)
+    DO I =1,NRES
+        CV_SUM(1) = 0
+        DO ISP=2,WDES%NCDIJ
+            CV_SUM(1) = CV_SUM(1)+SUM(CONJG(CV_EXT(1:GRIDC%RC%NP,ISP,I))*CV_EXT(1:GRIDC%RC%NP,ISP,I))
+        ENDDO
+        CALLMPI( M_sum_z(GRIDC%COMM,CV_SUM(1),1))
+        CALL ZDSCAL(GRIDC%MPLWV*WDES%NCDIJ, SQRT(2000/ABS(CV_SUM(1))), CV_EXT(1,1,I), 1)
+        DO ISP=2,WDES%NCDIJ
+            ! CDIJ_EXT initialized to 0 in the CV_TO_CDIJ routine.
+            CALL CV_TO_CDIJ(WDES, P, T_INFO, INFO%LOVERL, LMDIM, CDIJ_EXT(:,:,:,ISP,I),QVEC,GRIDC,CV_EXT(:,ISP,I),LATT_CUR)
+        ENDDO
+    ENDDO
+    IF (.TRUE.) THEN
+        DO I =1,NRES
+            !OUTPUT external potential
+                write(myString,'("_X_",I2.2)') I
+                !---------------------------------------------------------
+                io_begin
+                OPEN(UNIT=99,FILE='data/CV_EXT'//TRIM(myString),STATUS='UNKNOWN')
+                io_end
+                DO ISP=1,WDES%NCDIJ
+                    CALL FFT3D(CV_EXT(1,ISP,I),GRIDC,1)
+                    CALL OUTRL_CMPLX(GRIDC,99,.TRUE.,CV_EXT(:,ISP,I))
+                    CALL FFT_RC_SCALE(CV_EXT(1,ISP,I),CV_EXT(1,ISP,I),GRIDC)
+                ENDDO
+                io_begin
+                CLOSE(99)
+                io_end
+        ENDDO 
+    ENDIF
+    OMEGARES0(1:NRES) = OMEGARES(1:NRES)
+correction: DO ITER = 1,NITER_CORR
+    IF (ITER==1) OMEGARES=OMEGARES*ESCAL ! adiabatic equation tends to overestimate magnon energy. 
+    DO I =1,NRES
+        IF (ITER>1) THEN
+            IF (ABS(OMEGARES0(I)-OMEGARES(I))<5E-4) THEN 
+                OMEGARES0(I)=OMEGARES(I)
+                CYCLE
+            ELSE 
+                OMEGARES0(I)=OMEGARES(I)
+            ENDIF
+        ENDIF
+        ! set soft potential SV_EXT
+        DO ISP=1,WDES%NCDIJ
+            CALL CP_GRID(GRIDC,GRID_SOFT,SOFT_TO_C,CV_EXT(1,ISP,I),SV_EXT(1,ISP))
+            CALL SETUNB(SV_EXT(1,ISP),GRID_SOFT)
+            CALL FFT3D(SV_EXT(1,ISP),GRID_SOFT, 1)
+#ifdef realmode
+        CALLMPI( M_bcast_d(WDES%COMM_INTER, SV_EXT(1,ISP), GRID%RL%NP))
+#else
+        CALLMPI( M_bcast_z(WDES%COMM_INTER, SV_EXT(1,ISP), GRID%RL%NP))
+#endif
+        ENDDO
+        SV1_KPQ_IND=0
+        CDIJ1_KPQ_IND=0
+        CALL EMLR_KERNEL( &
+            HAMILTONIAN,P,WDES,NONLR_S,NONL_S,W0,LATT_CUR,LATT_INI, &
+            T_INFO,DYN,INFO,IO,MIX,KPOINTS,SYMM,GRID,GRID_SOFT, &
+            GRIDC,GRIDB,GRIDUS,C_TO_US,B_TO_C,SOFT_TO_C, &
+            CHTOT,DENCOR,CSTRF,CDIJ,CQIJ,CRHODE, &
+            N_MIX_PAW,RHOLM,SV,LMDIM,IRDMAX,NEDOS,EFERMI,DEG_CLUSTER,&
+            OMEGARES(I),QVEC,W0_KPQ,W0_KMQ,W1_KPQ(I),W1_KMQ(I),SV_EXT,CDIJ_EXT(:,:,:,:,I),CHI(:,:,I),CHI_G(:,:,I),CRHODE1(:,:,:,:,I),GVEC)
+        SV_IND=SV1_KPQ_IND-SV1_KPQ_IND0
+        DO ISP=1,WDES%NCDIJ
+            CALL FFT_RC_SCALE(SV_IND(1,ISP),SV_IND(1,ISP),GRID_SOFT)
+            CALL CPB_GRID(GRIDC,GRID_SOFT,SOFT_TO_C,SV_IND(1,ISP),CV_IND(1,ISP,I))
+        ENDDO
+        CALL MANY_BODY_OVERLAP(W1_KPQ(I),W1_KPQ(I),WDES,CQIJ,CV_SUM(1))
+        CALL MANY_BODY_OVERLAP(W1_KMQ(I),W1_KMQ(I),WDES,CQIJ,CV_SUM(2))
+        
+        H(I,I) = CV_SUM(1)-CV_SUM(2)
+        S(I,I)=0
+        DO ISP=2,WDES%NCDIJ
+            S(I,I)=S(I,I)+SUM(CONJG(CV_EXT(1:GRIDC%RC%NP,ISP,I))*CHI_G(1:GRIDC%RC%NP,ISP,I))
+        ENDDO 
+        CALLMPI( M_sum_z(GRIDC%COMM,S(I,I),1))
+        IF (LCORR) THEN
+            NCH=1
+            SV1_KPQ_IND=0
+            CDIJ1_KPQ_IND=0
+            CALL EMLR_KERNEL( &
+                HAMILTONIAN,P,WDES,NONLR_S,NONL_S,W0,LATT_CUR,LATT_INI, &
+                T_INFO,DYN,INFO,IO,MIX,KPOINTS,SYMM,GRID,GRID_SOFT, &
+                GRIDC,GRIDB,GRIDUS,C_TO_US,B_TO_C,SOFT_TO_C, &
+                CHTOT,DENCOR,CSTRF,CDIJ,CQIJ,CRHODE, &
+                N_MIX_PAW,RHOLM,SV,LMDIM,IRDMAX,NEDOS,EFERMI,DEG_CLUSTER,&
+                OMEGARES(I),QVEC,W0_KPQ,W0_KMQ,W1_KPQ_0(1),W1_KMQ_0(1),SV_EXT,CDIJ_EXT(:,:,:,:,I),CTMP(1),CTMP(GRIDC%MPLWV*WDES%NCDIJ+1),CTMP(2*GRIDC%MPLWV*WDES%NCDIJ+1),GVEC)
+            NCH=NCH_
+            CALL MANY_BODY_OVERLAP(W1_KPQ_0(1),W1_KPQ(I),WDES,CQIJ,CV_SUM(3))
+            CALL MANY_BODY_OVERLAP(W1_KMQ(I),W1_KMQ_0(1),WDES,CQIJ,CV_SUM(4))
+            S(I,I)=S(I,I)+CMPLX(0._q,2._q)*2*CSHIFT*(CV_SUM(3)-CV_SUM(4))
+        ENDIF
+        STMP(I,I) = S(I,I)/H(I,I) 
+        LAMBDA(I) = REAL(STMP(I,I))
+        OMEGARES(I)=OMEGARES(I)+LAMBDA(I)
+    ENDDO
+    IF (IO%IU0>=0) THEN
+        WRITE(UNIT_EMLR_OUTPUT,*) "H'="
+        WRITE(UNIT_EMLR_OUTPUT,'(99(E12.5,"+",E12.5,"i   "))') (H(I,I) ,I=1,NRES)
+        WRITE(UNIT_EMLR_OUTPUT,*) "S'="
+        WRITE(UNIT_EMLR_OUTPUT,'(99(E12.5,"+",E12.5,"i   "))') (S(I,I) ,I=1,NRES)
+        WRITE(UNIT_EMLR_OUTPUT,*) "STMP="
+        WRITE(UNIT_EMLR_OUTPUT,'(99(E12.5,"+",E12.5,"i   "))') (STMP(I,I) ,I=1,NRES)
+    ENDIF
+
+
+    IF (IO%IU0>=0) THEN
+        WRITE(UNIT_EMLR_CHI,*) "Corrected Magnon Bands"
+        WRITE(UNIT_EMLR_CHI,*)'NB       OMEGA     broadening'
+        DO I=1,NRES
+        WRITE(UNIT_EMLR_CHI,'(I4,x,E12.5,x,E12.5)') I,OMEGARES(I),AIMAG(STMP(I,I))
+        ENDDO
+    ENDIF
+    IF (.TRUE.) THEN 
+        DO I =1,NRES
+            !OUTPUT external potential
+            write(myString,'("_IND_",I2.2)') I
+            !---------------------------------------------------------
+            io_begin
+            OPEN(UNIT=99,FILE='data/CV_EXT'//TRIM(myString),STATUS='UNKNOWN')
+            io_end
+            DO ISP=1,WDES%NCDIJ
+                CALL FFT3D(CV_IND(1,ISP,I),GRIDC,1)
+                CALL OUTRL_CMPLX(GRIDC,99,.TRUE.,CV_IND(:,ISP,I))
+            ENDDO
+            io_begin
+            CLOSE(99)
+            io_end
+        ENDDO
+    ENDIF 
+    ENDDO correction
+
+
+    IF (LDUMP) THEN
+        DO I =1,NRES
+            write(myString,'("_X_",I2.2)') I
+            !----------------------------------------------------------
+            io_begin
+            OPEN(UNIT=99,FILE='data/CHI'//TRIM(myString),STATUS='UNKNOWN')
+            io_end
+            DO ISP=1,WDES%NCDIJ
+                CALL FFT3D(CHI(1,ISP,I),GRIDC,1)
+                CALL OUTRL_CMPLX(GRIDC,99,.TRUE.,CHI(:,ISP,I))
+            ENDDO
+            io_begin
+            CLOSE(99)
+            io_end
+            !----------------------------------------------------------
+            io_begin
+            OPEN(UNIT=99,FILE='data/CHI_G'//TRIM(myString),STATUS='UNKNOWN')
+            io_end
+            DO ISP=1,WDES%NCDIJ
+                CALL FFT3D(CHI_G(1,ISP,I),GRIDC,1)
+                CALL OUTRL_CMPLX(GRIDC,99,.TRUE.,CHI_G(:,ISP,I))
+            ENDDO
+            io_begin
+            CLOSE(99)
+            io_end
+            !----------------------------------------------------------
+            io_begin
+            OPEN(UNIT=99,FILE='data/CRHO'//TRIM(myString),STATUS='UNKNOWN')
+            io_end
+            CALL OUTCRHO(99,WDES,T_INFO,LMDIM,CRHODE1(:,:,:,:,I))
+
+            io_begin
+            CLOSE(99)
+            io_end
+            !----------------------------------------------------------
+        ENDDO
+    ENDIF
+
+    
+
+    WDES%VKPT(1:3,1:WDES%NKPTS)=KORIG
+    ! kinetic energy |k+G|^2
+    CALL SET_DATAKE(WDES, LATT_CUR%B)
+    ! non-local projector |p_k>
+    IF (.NOT. INFO%LREAL) THEN
+    CALL SPHER(GRID,NONL_S,P,WDES,LATT_CUR, 1)
+    ENDIF
+    DEALLOCATE(KORIG,KPQ,KMQ)
+
+    IF (SYMM%ISYM>0) CALL DEALLOCATE_KPOINTS_TRANS(KPOINTS_TRANS)
+    NLS=NLS_
+    CHBREAK=CHBREAK_
+    ENDDO momentum
+
+    DO I = 1,NMAX
+        CALL DEALLOCW(W1_KPQ(I))
+        CALL DEALLOCW(W1_KMQ(I))
+    ENDDO
+    IF (LCORR) THEN
+        CALL DEALLOCW(W1_KPQ_0(1))
+        CALL DEALLOCW(W1_KMQ_0(1))
+    ENDIF
+    CALL DEALLOCW(W0_KPQ)
+    IF (.NOT. LKSHIFT) CALL DEALLOCW(W0_KMQ)
+    DEALLOCATE(QVECPATH,QVECLIST)
+    DEALLOCATE(MAGIONLIST)
+    DEALLOCATE(CV_EXT,CV_IND,CDIJ_EXT,CRHODE1)
+    DEALLOCATE(CHI,CHI_G,CTMP)
+    DEALLOCATE(H,S,V,STMP,LAMBDA)
+    DEALLOCATE(CWORK)
+    DEALLOCATE(RWORK)
+    DEALLOCATE(RMST)
+    DEALLOCATE(OMEGARES,OMEGARES0)
+    DEALLOCATE(SV1_KPQ_IND,SV1_KPQ_IND0,CDIJ1_KPQ_IND)
+    NULLIFY(MAGDIR);NULLIFY(MNORM)
+
+    CALL FREE_DEG_CLUSTERS(WDES,DEG_CLUSTER)
+
+    ! restore original symmetry
+    IF (SYMM%ISYM>0) THEN
+    DYN%VEL=0
+    CALL INISYM(LATT_CUR%A,T_INFO%POSION,DYN%VEL,T_INFO%LSFOR, &
+        T_INFO%LSDYN,T_INFO%NTYP,T_INFO%NITYP,T_INFO%NIONS, &
+        SYMM%PTRANS,SYMM%NROT,SYMM%NPTRANS,SYMM%ROTMAP,SYMM%TAU,SYMM%TAUROT,SYMM%WRKROT, &
+        SYMM%INDROT,T_INFO%ATOMOM,WDES%SAXIS,SYMM%MAGROT,WDES%NCDIJ,IO%IU6)
+#ifdef oldsym
+    CALL RE_READ_KPOINTS(KPOINTS,LATT_CUR, &
+        SYMM%ISYM>=0.AND..NOT.WDES%LSORBIT.AND..NOT.WDES%LSPIRAL, &
+        T_INFO%NIONS,SYMM%ROTMAP,SYMM%MAGROT,SYMM%ISYM,IU6K,IO%IU0)
+#else
+    CALL RE_READ_KPOINTS(KPOINTS,LATT_CUR, &
+        SYMM%ISYM>=0.AND..NOT.WDES%LNONCOLLINEAR, &
+        T_INFO%NIONS,SYMM%ROTMAP,SYMM%MAGROT,SYMM%ISYM,IU6K,IO%IU0)
+#endif
+    CALL RE_GEN_LAYOUT(GRID,WDES,KPOINTS,LATT_CUR,LATT_INI,IO%IU6,IO%IU0)
+    CALL REALLOCATE_WAVE(W0,GRID,WDES,NONL_S,T_INFO,P,LATT_CUR)
+    ENDIF
+
+    INFO%IALGO=IALGO_SAVE
+    CLOSE(UNIT_EMLR_OUTPUT)
+
+    END SUBROUTINE MAGNON_MAIN
+
+SUBROUTINE SMOOTHER(GRID,CV,LATT_CUR,SIGMA_X,QVEC)
+    ! this routine smooth given CV on the grid by convolve it with a gaussian wavepacket
+    ! the convolution is in the real space but the data CV input is on the reciprocal space. 
+    USE prec
+    USE mgrid
+    USE lattice
+    USE constant
+    IMPLICIT NONE
+
+    TYPE (grid_3d) GRID
+    COMPLEX(q) CV(GRID%RC%NROW,GRID%RC%NCOL)
+    TYPE (latt)        LATT_CUR      ! lattice
+    REAL(q) :: QVEC(3)
+    REAL(q) :: SIGMA_X
+    ! local
+    INTEGER :: GVEC(3)
+    INTEGER :: NC
+    INTEGER :: N1,N2,N3
+    REAL(q) :: GVEC_CART(3)
+
+    DO NC=1,GRID%RC%NCOL
+    DO N1=1,GRID%RC%NROW
+        GVEC(1)=GRID%LPCTX(N1)
+        N2=GRID%RC%I2(NC)
+        N3=GRID%RC%I3(NC)
+        GVEC(2)=GRID%LPCTY(N2)
+        GVEC(3)=GRID%LPCTZ(N3)
+        GVEC_CART = MATMUL(LATT_CUR%B,GVEC-QVEC)
+        CV(N1,NC)=CV(N1,NC)*EXP(-0.5_q*SUM(GVEC_CART**2)*(SIGMA_X*TPI)**2)
+    ENDDO
+    ENDDO
+
+END SUBROUTINE
+
+SUBROUTINE MANY_BODY_OVERLAP(W1,W2,WDES,CQIJ,RES)
+    USE prec 
+    USE wave
+    USE wave_high
+    IMPLICIT NONE
+    TYPE (wavespin) :: W1            ! first order change of wavefunction
+    TYPE (wavespin) :: W2            ! first order change of wavefunction
+    TYPE (wavedes)     WDES
+    OVERLAP :: CQIJ(:,:,:,:)
+    COMPLEX(q) :: RES
+    ! local variable
+    COMPLEX(q) ::C 
+    TYPE (wavedes1) WDES1            ! descriptor for one k-point
+    INTEGER :: N,ISP,NK
+
+    RES=0
+    DO ISP=1,WDES%ISPIN
+    DO NK=1,WDES%NKPTS
+        CALL SETWDES(WDES,WDES1,NK)
+    DO N =1,WDES%NBANDS
+        C=W1_DOT( ELEMENT(W1, WDES1, N, ISP) , ELEMENT(W2, WDES1, N, ISP),CQIJ) 
+        RES = RES+C*W1%FERWE(N,NK,ISP)*WDES%RSPIN*WDES%WTKPT(NK)
+    ENDDO
+    ENDDO 
+    ENDDO
+    ! INB communication already done in W1_DOT
+    CALLMPI( M_sum_z(WDES%COMM_INTER, RES, 1))
+    CALLMPI( M_sum_z(WDES%COMM_KINTER, RES, 1))
+END SUBROUTINE MANY_BODY_OVERLAP
+END MODULE MAGNON 
+
+SUBROUTINE DSORT_ASC(N,RA,RB)
+    use prec
+    REAL(q) RA(N),RRA
+    INTEGER RB(N),RRB
+
+    IF (N<=1) RETURN
+
+    L=N/2+1
+    IR=N
+10  CONTINUE
+    IF(L.GT.1)THEN
+       L=L-1
+       RRA=RA(L)
+       RRB=RB(L)
+    ELSE
+       RRA=RA(IR)
+       RRB=RB(IR)
+       RA(IR)=RA(1)
+       RB(IR)=RB(1)
+       IR=IR-1
+       IF(IR.EQ.1)THEN
+          RA(1)=RRA
+          RB(1)=RRB
+          RETURN
+       ENDIF
+    ENDIF
+    I=L
+    J=L+L
+20  IF(J.LE.IR)THEN
+       IF(J.LT.IR)THEN
+          IF(RA(J).LT.RA(J+1))J=J+1
+       ENDIF
+       IF(RRA.LT.RA(J))THEN
+          RA(I)=RA(J)
+          RB(I)=RB(J)
+          I=J
+          J=J+J
+       ELSE
+          J=IR+1
+       ENDIF
+       GO TO 20
+    ENDIF
+    RA(I)=RRA
+    RB(I)=RRB
+    GO TO 10
+END SUBROUTINE DSORT_ASC
+
+SUBROUTINE CALC_SVD_REAL( A, M, N, U, S, VT )
+    USE prec
+    IMPLICIT NONE
+    INTEGER   :: M,N      !number of rows and columns
+    REAL(q)   :: A(M,N)  !matrix to be decomposed
+    REAL(q)   :: U(M,M)  !left singular eigenvectors
+    REAL(q)   :: S(N)    !signular values
+    REAL(q)   :: VT(N,N) !right singular eigenvectors
+    !local
+    REAL(q)   :: AA(M,N)
+    INTEGER, PARAMETER   :: LWMAX=20000
+    INTEGER              :: LDA, LDU, LDVT
+    INTEGER              :: INFO, LWORK 
+    INTEGER              :: I,J
+    INTEGER              :: IWORK( 8*N )
+    REAL(q)              :: WORK(LWMAX)  ! We are confident
+
+
+    !first define leading dimensions
+    LDA = M
+    LDU = M
+    LDVT = N
+    AA=A
+    WORK=0
+    !Query the optimal workspace
+    LWORK = -1
+    CALL DGESDD( 'A', M, N, AA, LDA, S, U, LDU, VT,&
+                LDVT, WORK, LWORK, IWORK, INFO )
+    LWORK = MIN( LWMAX, INT( WORK( 1 ) ) )
+
+    !Compute SVD
+    CALL DGESDD( 'A', M, N, AA, LDA, S, U, LDU, VT,& 
+                LDVT, WORK, LWORK, IWORK, INFO )
+
+    !check for convergence
+    IF( INFO.GT.0 ) THEN
+       WRITE(*,*)'CAL_SVD_REAL Error: DGESDD failed to converge.',INFO
+       STOP
+    ENDIF
+
+    RETURN
+ ENDSUBROUTINE CALC_SVD_REAL
+
+SUBROUTINE GAUSS_CV(GRID,CV,LATT_CUR,CENTER,SIGMA_X,QVEC)
+    ! assign a real space Gaussian wavepacket centered at CENTER with spread SIGMA_X in the reciprocal grid.
+    USE prec
+    USE mgrid
+    USE lattice
+    USE constant
+    IMPLICIT NONE
+
+    TYPE (grid_3d) GRID
+    COMPLEX(q) CV(GRID%RC%NROW,GRID%RC%NCOL)
+    TYPE (latt)        LATT_CUR      ! lattice
+    REAL(q) :: CENTER(3),QVEC(3) !  In Cartesian coordinate
+    REAL(q) :: SIGMA_X
+    ! local
+    INTEGER :: GVEC(3)
+    INTEGER :: NC
+    INTEGER :: N1,N2,N3
+    REAL(q) :: GVEC_CART(3)
+
+    DO NC=1,GRID%RC%NCOL
+    DO N1=1,GRID%RC%NROW
+        GVEC(1)=GRID%LPCTX(N1)
+        N2=GRID%RC%I2(NC)
+        N3=GRID%RC%I3(NC)
+        GVEC(2)=GRID%LPCTY(N2)
+        GVEC(3)=GRID%LPCTZ(N3)
+        GVEC_CART = MATMUL(LATT_CUR%B,GVEC+QVEC)
+        CV(N1,NC)=CV(N1,NC)+EXP(-0.5_q*SUM(GVEC_CART**2)*(SIGMA_X*TPI)**2)*EXP(-CITPI*DOT_PRODUCT(GVEC,CENTER))
+    ENDDO
+    ENDDO
+END SUBROUTINE GAUSS_CV
+
+!=======================================================================
+! Non-local contribution to CDIJ from external field
+!=======================================================================
+SUBROUTINE CV_TO_CDIJ(WDES, P, T_INFO, LOVERL, LMDIM, CDIJ, QVEC,GRID,CV,LATT_CUR)
+    USE poscar
+    USE pseudo
+    USE wave
+    USE radial
+    USE us
+    USE paw
+    USE constant
+    USE asa
+    USE mgrid
+    USE lattice
+    IMPLICIT NONE
+
+    TYPE (type_info) T_INFO
+    TYPE (potcar),TARGET:: P(T_INFO%NTYP)
+    TYPE (wavedes) WDES
+    INTEGER LMDIM
+    OVERLAP CDIJ(LMDIM,LMDIM,WDES%NIONS)
+    LOGICAL LOVERL
+    REAL(q) QVEC(3)
+    TYPE (grid_3d) GRID
+    COMPLEX(q) CV(GRID%RC%NROW,GRID%RC%NCOL)
+    TYPE (latt)        LATT_CUR      ! lattice
+    ! local variables
+    COMPLEX(q) CWORK(GRID%NGX_rd,GRID%NGY,GRID%NGZ_rd)
+    INTEGER :: N1,NC,N2,N3 
+    INTEGER :: GVEC(3)
+
+    REAL(q) :: POSION(3)             ! Ri
+    COMPLEX(q) :: CREXP              ! e^(iG.Ri)
+    TYPE (potcar),POINTER:: PP
+    INTEGER NT,LYMAX,NI,NDIM,LMMAX,NIP,LYCAL
+    INTEGER K,L,M,LM
+    INTEGER, EXTERNAL :: MAXL_AUG,MAXL1
+    REAL(q) PVEC_CART(3)
+    REAL(q) PNORM,PX(1),PY(1),PZ(1)
+    REAL(q),ALLOCATABLE :: YLM(:,:)
+    REAL(q) :: PR,WEIGHT,SPHBESSEL
+    !REAL(q),ALLOCATABLE :: SPHBESSEL(:)
+    REAL(q),ALLOCATABLE :: POT(:,:)
+    REAL(q),ALLOCATABLE :: DDLM(:)
+    OVERLAP,ALLOCATABLE :: CTMP(:,:)
+    COMPLEX(q),ALLOCATABLE :: POTC(:,:)
+    ! needed to distribute over COMM_KINTER
+    INTEGER IDONE
+    LOGICAL LSKIP
+
+    !=======================================================================
+    ! quick return and allocation of work space
+    !=======================================================================
+    IF (.NOT.LOVERL .OR. MIMIC_US) THEN
+    RETURN
+    ENDIF
+
+    LYMAX =MAXL_AUG(T_INFO%NTYP,P)
+
+    NDIM=0
+    DO NT=1,T_INFO%NTYP
+    IF (ASSOCIATED(P(NT)%QPAW)) THEN
+        NDIM=MAX(NDIM, P(NT)%R%NMAX)
+    ENDIF
+    ENDDO
+
+    IF (NDIM == 0) THEN
+    RETURN
+    ENDIF
+
+    ALLOCATE(DDLM(LMDIM*LMDIM))
+    ALLOCATE(CTMP(LMDIM,LMDIM))
+    LMMAX=(LYMAX+1)**2
+
+    ALLOCATE(POT(NDIM, LMMAX))
+    ALLOCATE(POTC(NDIM, LMMAX))
+    ALLOCATE(YLM(1,LMMAX))
+    !ALLOCATE(SPHBESSEL(0:LYMAX))
+
+    ! collect distributed local potential 
+    CALL MRG_GRID_RC(GRID, CWORK, CV)   
+    !=======================================================================
+    ! cycle all ions
+    !=======================================================================
+    IDONE=0
+    CDIJ=0
+
+    ion: DO NI=1,T_INFO%NIONS
+    NIP=NI_LOCAL(NI, WDES%COMM_INB) ! local storage index
+    NT=T_INFO%ITYP(NI)
+
+    LSKIP=.FALSE.
+#ifdef MPI
+    ! DO_LOCAL represents a distribution of the work on the
+    ! one-center terms over the procs in COMM_INB and COMM_INTER (=COMM_KIN).
+    ! The following allows an additional round-robin distribution over COMM_KINTER as well.
+    IF (DO_LOCAL(NI)) THEN
+        IDONE=IDONE+1; LSKIP=(MOD(IDONE,WDES%COMM_KINTER%NCPU)+1/=WDES%COMM_KINTER%NODE_ME)
+    ENDIF
+#endif
+    ! if this element is not treated locally CYCLE
+    IF (.NOT. DO_LOCAL(NI).OR.LSKIP) CYCLE ion
+
+    PP=> PP_POINTER(P, NI, NT)
+
+    LYMAX =MAXL1(PP)*2
+    !-----------------------------------------------------------------------
+    ! e^(iq.r) = 4 \pi \sum_{lm} i^l j_l(qr) conjg[Y_lm(\hat q)] * Y_lm(\hat r)
+    ! POT_lm   = 4 \pi i^l j_l(qr) Y_lm(\hat q)
+    ! Y_lm is choosed to be real
+    ! multiply potentials by simpson weights
+    !-----------------------------------------------------------------------
+    POTC=0
+    ! multiply with e^(iG.Ri)
+    POSION=T_INFO%POSION(:,NI)
+    ! CDIJ(:,:,NIP)=CDIJ(:,:,NIP)*CREXP
+    DO N3=1,GRID%NGZ_rd ! == GRID%NGZ
+    DO N2=1,GRID%NGY 
+    DO N1=1,GRID%NGX_rd ! == GRID%NGX
+        GVEC(1)=GRID%LPCTX(N1)
+        GVEC(2)=GRID%LPCTY(N2)
+        GVEC(3)=GRID%LPCTZ(N3)
+        PVEC_CART = MATMUL(LATT_CUR%B,GVEC+QVEC)
+        PNORM=SQRT(SUM(PVEC_CART**2))
+        IF (PNORM < 1E-5_q ) THEN
+            PX(1)=0
+            PY(1)=0
+            PZ(1)=0
+            PNORM=0
+        ELSE
+            PX(1)=PVEC_CART(1)/PNORM
+            PY(1)=PVEC_CART(2)/PNORM
+            PZ(1)=PVEC_CART(3)/PNORM
+        ENDIF
+        CREXP=EXP(CITPI*(GVEC(1)*POSION(1)+GVEC(2)*POSION(2)+GVEC(3)*POSION(3)))
+        CALL SETYLM(LYMAX,1,YLM,PX,PY,PZ)
+        PNORM=PNORM*TPI
+        DO K=1,PP%R%NMAX
+            PR=PNORM*PP%R%R(K)
+            WEIGHT=PP%R%SI(K)
+            DO L=0,LYMAX
+                CALL SBESSEL(PR,SPHBESSEL,L)
+                DO M=0,2*L
+                    LM=L*L+M+1
+                    ! we divide POT by 2. Since RAD_PROJ and TRANS_DLM require the potential to be real
+                    ! in principle, This CV_TO_CDIJ routine can only be used in (n,m) representation. The 
+                    ! convention of transformation to (n,m) representation, however, differ between RC grid 
+                    ! and CDIJ.  This asks for a divsion by 2 here. 
+                    POTC(K,LM)=POTC(K,LM)+2*TPI*(0.0_q,1.0_q)**L*SPHBESSEL*YLM(1,LM)*WEIGHT*CWORK(N1,N2,N3)*CREXP
+                ENDDO
+            ENDDO
+        ENDDO
+    ENDDO
+    ENDDO
+    ENDDO
+
+    !-----------------------------------------------------------------------
+    ! D(ll',LM)= D(ll',LM)+ A *\int dr phi_l'(r) pot_lm(r) phi_l(r) dr
+    ! phi(r) = \sum_lmn Y_lm(r) w_ln(r) / r
+    !-----------------------------------------------------------------------
+    POT=REAL(POTC)
+    DDLM=0
+    CALL RAD_PROJ(POT, PP%R, 1._q, DDLM, PP%LMAX, PP%LPS, PP%WAE )
+    CALL RAD_PROJ(POT, PP%R,-1._q, DDLM, PP%LMAX, PP%LPS, PP%WPS )
+    !-----------------------------------------------------------------------
+    ! transform them using Clebsch Gordan coefficients and add to CDIJ
+    ! D(lm,l'm') =  sum C(LM,ll',mm') D(ll',LM)
+    ! where C(LM,ll',mm') = \int Y_LM Y_lm Y_l'm' d Omega
+    !-----------------------------------------------------------------------
+    CTMP=0
+    CALL TRANS_DLM(CTMP, DDLM, PP)
+    CDIJ(:,:,NIP)=CDIJ(:,:,NIP)+CTMP
+
+    ! imaginary part
+    POT=AIMAG(POTC)
+    DDLM=0
+    CALL RAD_PROJ(POT, PP%R, 1._q, DDLM, PP%LMAX, PP%LPS, PP%WAE )
+    CALL RAD_PROJ(POT, PP%R,-1._q, DDLM, PP%LMAX, PP%LPS, PP%WPS )
+    CTMP=0
+    CALL TRANS_DLM(CTMP, DDLM, PP)
+    CDIJ(:,:,NIP)=CDIJ(:,:,NIP)+(0._q,1._q)*CTMP
+
+    ENDDO ion
+    !=======================================================================
+    ! now distribute the DIJ to all nodes which hold DIJ (using global sum)
+    !=======================================================================
+#ifdef realmode
+    CALLMPI( M_sum_d(WDES%COMM_INTER, CDIJ, LMDIM*LMDIM*WDES%NIONS))
+    CALLMPI( M_sum_d(WDES%COMM_KINTER,CDIJ, LMDIM*LMDIM*WDES%NIONS))
+#else
+    CALLMPI( M_sum_d(WDES%COMM_INTER, CDIJ, LMDIM*LMDIM*WDES%NIONS*2))
+    CALLMPI( M_sum_d(WDES%COMM_KINTER,CDIJ, LMDIM*LMDIM*WDES%NIONS*2))
+#endif
+
+#ifdef debug
+    DO K=1,WDES%COMM%NCPU
+    IF (WDES%COMM%NODE_ME == K) THEN
+    DO NI=1,WDES%NIONS
+        CALL DUMP_DLLMM( "CDIJ",CDIJ(:,:,NI), PP)
+    ENDDO
+    WRITE(*,*)
+    ENDIF
+    CALL MPI_barrier( WDES%COMM%MPI_COMM, k )
+    ENDDO
+#endif
+
+    DEALLOCATE(POT, POTC, CTMP, DDLM,YLM)
+
+END SUBROUTINE CV_TO_CDIJ
+
+! This routine perform rotation among an array of many-body wavefunctions of length N.
+! V is a N-N matrix.
+! We perform the rotation orbital by orbitals.
+SUBROUTINE ROTATE_WAVE_ARRAY(W_ARRAY,V,N)
+    use prec
+    use wave
+    IMPLICIT NONE
+    INTEGER :: N
+    TYPE (wavespin)    :: W_ARRAY(N)
+    COMPLEX(q)         :: V(N,N)
+    ! local variable
+    TYPE(wavedes),POINTER:: WDES
+    COMPLEX(q), ALLOCATABLE:: CWWORK(:,:),CPWORK(:,:),CTMP(:)
+    INTEGER:: IB,IK,ISP,I
+    
+    WDES=>W_ARRAY(1)%WDES
+    ALLOCATE(CWWORK(WDES%NRPLWV,N))
+    ALLOCATE(CPWORK(WDES%NPROD,N))
+    ALLOCATE(CTMP(MAX(WDES%NRPLWV*N,WDES%NPROD*N)))
+    ! WRITE(*,*) "WDES%NRPLWV",WDES%NRPLWV
+    ! WRITE(*,*) "WDES%NPROD",WDES%NPROD
+    ! WRITE(*,*) "SIZE(CPTWFP)",SIZE(W_ARRAY(1)%CPTWFP,1)
+    
+    ! WRITE(*,*) "SIZE(CPROJ)",SIZE(W_ARRAY(1)%CPROJ,1)
+    DO ISP = 1,WDES%ISPIN
+    DO IK = 1,WDES%NKPTS
+    DO IB = 1,WDES%NBANDS
+        DO I=1,N
+            CWWORK(:,I)=W_ARRAY(I)%CPTWFP(:,IB,IK,ISP)
+            CPWORK(:,I)=W_ARRAY(I)%CPROJ(:,IB,IK,ISP)
+        ENDDO
+        CALL GGEMM('N', 'N', WDES%NRPLWV , N, N, one, &
+                &   CWWORK, WDES%NRPLWV, V, N,  &
+                &   zero, CTMP, WDES%NRPLWV)
+        DO I=1,N
+            W_ARRAY(I)%CPTWFP(:,IB,IK,ISP)=CTMP((I-1)*WDES%NRPLWV+1:I*WDES%NRPLWV)
+        ENDDO
+        CALL GGEMM('N', 'N', WDES%NPROD , N, N, one, &
+                &   CPWORK, WDES%NPROD, V, N,  &
+                &   zero, CTMP, WDES%NPROD)
+        DO I=1,N
+            W_ARRAY(I)%CPROJ(:,IB,IK,ISP)=CTMP((I-1)*WDES%NPROD+1:I*WDES%NPROD)
+        ENDDO
+    ENDDO
+    ENDDO
+    ENDDO
+    DEALLOCATE(CWWORK,CPWORK,CTMP)
+    NULLIFY(WDES)
+END SUBROUTINE ROTATE_WAVE_ARRAY
+
+SUBROUTINE MRG_GRID_RL_CMPLX(GRID, C, C_LOCAL)
+    USE mgrid
+    IMPLICIT NONE
+
+    TYPE (grid_3d) GRID
+#ifdef MPI
+    COMPLEX(q)   C_LOCAL(GRID%RL%NROW,GRID%RL%NCOL)
+    COMPLEX(q)   C(GRID%NGX,GRID%NGY,GRID%NGZ)
+    INTEGER NC,NX,NY,NZ
+
+    C=0
+    DO NC=1,GRID%RL%NCOL
+       NX= GRID%RL%I2(NC)
+       NY= GRID%RL%I3(NC)
+       DO NZ=1,GRID%NGZ
+          C(NX,NY,NZ)=C_LOCAL(NZ,NC)
+       ENDDO
+    ENDDO
+
+    CALLMPI( M_sum_z(GRID%COMM, C(1,1,1), GRID%NPLWV))
+#else
+    COMPLEX(q)  C_LOCAL(GRID%RL%NP)
+    COMPLEX(q)  C(GRID%RL%NP)
+
+    C(1:GRID%RL%NP)=C_LOCAL(1:GRID%RL%NP)
+#endif
+
+  END SUBROUTINE MRG_GRID_RL_CMPLX
+
+  SUBROUTINE DIS_GRID_RL_CMPLX(GRIDC, C, C_LOCAL)
+    USE mgrid
+    IMPLICIT NONE
+
+    TYPE (grid_3d) GRIDC
+#ifdef MPI
+    COMPLEX(q)  C_LOCAL(GRIDC%RL%NROW,GRIDC%RL%NCOL)
+    COMPLEX(q)   C(GRIDC%NGX,GRIDC%NGY,GRIDC%NGZ)
+    INTEGER NC,NX,NY,NZ
+
+    ! broadcast C to all nodes from IONODE
+    CALLMPI( M_bcast_z(GRIDC%COMM, C(1,1,1), GRIDC%NPLWV))
+    ! and pick up data
+    DO NC=1,GRIDC%RL%NCOL
+       NX= GRIDC%RL%I2(NC)
+       NY= GRIDC%RL%I3(NC)
+       DO NZ=1,GRIDC%NGZ
+          C_LOCAL(NZ,NC)=C(NX,NY,NZ)
+       ENDDO
+    ENDDO
+#else
+    COMPLEX(q) C_LOCAL(GRIDC%RL%NP)
+    COMPLEX(q)  C(GRIDC%RL%NP)
+
+    C_LOCAL(1:GRIDC%RL%NP)=C(1:GRIDC%RL%NP)
+#endif
+
+  END SUBROUTINE DIS_GRID_RL_CMPLX
+
+SUBROUTINE OUTRL_CMPLX(GRIDC, IU, LLONG,CHTOT)
+    USE prec
+    USE mpimy
+    USE mgrid
+    ! IMPLICIT COMPLEX(q) (C)
+    ! IMPLICIT REAL(q) (A-B,D-H,O-Z)
+    IMPLICIT NONE
+
+    TYPE (grid_3d) GRIDC
+    INTEGER :: IU
+    COMPLEX(q)  CHTOT(GRIDC%RC%NP)
+    LOGICAL LLONG        ! long or short format
+! work arrays
+    COMPLEX(q),  ALLOCATABLE ::  CWORK(:)
+    INTEGER NALLOC,NZ, NWRITE, NWRITTEN
+    CHARACTER (40) FORM
+    INTEGER ISTAT,NODE_ME,IONODE,N
+
+    NALLOC=GRIDC%NGX*GRIDC%NGY*GRIDC%NGZ
+
+    ALLOCATE(CWORK(GRIDC%NGX*GRIDC%NGY*GRIDC%NGZ),STAT=ISTAT)
+    IF (ISTAT>0) RETURN ! can not write the charge immediate exit
+
+    NODE_ME=0
+    IONODE =0
+#ifdef MPI
+    NODE_ME=GRIDC%COMM%NODE_ME
+    IONODE =GRIDC%COMM%IONODE
+#endif
+
+    IF (GRIDC%NPLWV/= GRIDC%NGX*GRIDC%NGY*GRIDC%NGZ) THEN
+      WRITE(*,*)'internal ERROR: OUTRL_CMPLX NPLWV is not compatible', &
+   &   ' with  NGX,NGY,NGZ'
+      WRITE(*,*)'   ',GRIDC%NPLWV,GRIDC%NGX,GRIDC%NGY,GRIDC%NGZ
+      STOP
+    ENDIF
+    CALL MRG_GRID_RL_CMPLX(GRIDC, CWORK, CHTOT)
+
+    FORM='(1(2X,E11.5,1X,E11.5))'
+    NWRITE=5
+
+    do_io WRITE(IU,'(3I5)') GRIDC%NGX,GRIDC%NGY,GRIDC%NGZ
+
+    NWRITTEN=0
+    io_begin
+    DO N=1,NALLOC
+        NWRITTEN=NWRITTEN+1
+        IF ( MOD(NWRITTEN,NWRITE)==0 ) THEN
+            WRITE(IU,FORM) CWORK(N)
+        ELSE
+            WRITE(IU,FORM,ADVANCE='NO') CWORK(N)
+        ENDIF
+    ENDDO
+    io_end
+    IF ( MOD(NWRITTEN,NWRITE)/=0 ) WRITE(IU,*)' '
+
+    DEALLOCATE(CWORK)
+
+    RETURN
+END SUBROUTINE
+
+SUBROUTINE INRL_CMPLX(GRIDC, IU, LLONG,CHTOT)
+    USE prec
+    USE mpimy
+    USE mgrid
+    ! IMPLICIT COMPLEX(q) (C)
+    ! IMPLICIT REAL(q) (A-B,D-H,O-Z)
+    IMPLICIT NONE
+
+    TYPE (grid_3d) GRIDC
+    INTEGER :: IU
+    COMPLEX(q)  CHTOT(GRIDC%RC%NP)
+    LOGICAL LLONG        ! long or short format
+! work arrays
+    REAL(q),  ALLOCATABLE ::  DWORK(:)
+    INTEGER NALLOC,NZ, NWRITE, NWRITTEN
+    CHARACTER (40) FORM
+    INTEGER ISTAT,NODE_ME,IONODE,N,NGX,NGY,NGZ
+
+    NALLOC=GRIDC%NGX*GRIDC%NGY*GRIDC%NGZ
+
+    ALLOCATE(DWORK(2*GRIDC%NGX*GRIDC%NGY*GRIDC%NGZ),STAT=ISTAT)
+    IF (ISTAT>0) RETURN ! can not write the charge immediate exit
+
+    NODE_ME=0
+    IONODE =0
+#ifdef MPI
+    NODE_ME=GRIDC%COMM%NODE_ME
+    IONODE =GRIDC%COMM%IONODE
+#endif
+    ! WRITE(*,*) "GRIDC%NCPU=", GRIDC%COMM%NCPU
+    ! WRITE(*,*) "GRIDC%IONODE=", IONODE
+    ! WRITE(*,*) "is this proc the io node? ", IONODE==NODE_ME
+    io_begin 
+    READ(IU,*) NGX,NGY,NGZ
+    IF (GRIDC%NGX/=NGX .OR. GRIDC%NGY/=NGY .OR. GRIDC%NGZ/=NGZ) THEN
+      WRITE(*,*)'internal ERROR: INRL_CMPLX is not compatible', &
+   &   ' with  NGX,NGY,NGZ'
+      WRITE(*,*)'   ',GRIDC%NGX,GRIDC%NGY,GRIDC%NGZ
+      STOP
+    ENDIF
+    READ(IU,*) (DWORK(N),N=1,2*NALLOC)
+    io_end
+    CALL DIS_GRID_RL_CMPLX(GRIDC, DWORK, CHTOT)
+    ! M_bcast_z is from ionode to all nodes in the MPI_COMM_WORLD
+    DEALLOCATE(DWORK)
+    RETURN
+END SUBROUTINE
+
+SUBROUTINE OUTCRHO(IU,WDES,T_INFO,LMDIM,CRHODE)
+    USE prec
+    USE wave
+    USE poscar
+    USE mpimy
+    implicit none
+    TYPE (type_info)   T_INFO
+    TYPE (wavedes)     WDES
+    INTEGER:: LMDIM,ISP,NI,NIP,IU
+    INTEGER:: NODE_ME,IONODE
+    OVERLAP :: CRHODE(LMDIM,LMDIM,WDES%NIONS,WDES%NCDIJ)
+    
+#ifdef MPI
+    ! in the MPI version CRHODE holds the contribution to the augmentation
+    ! occupation only for ions and bands which are local
+    ! CTMP holds all elements (merged)
+    ! to achive good load balancing CTMP is first merged, and then each node
+    ! calculates augmentation charges for his columns
+    OVERLAP,ALLOCATABLE :: CTMP(:,:,:,:)
+    ALLOCATE(CTMP(LMDIM,LMDIM,T_INFO%NIONS,WDES%NCDIJ))
+#else
+#define CTMP CRHODE
+#endif
+
+    NODE_ME=0
+    IONODE =0
+#ifdef MPI
+    NODE_ME=WDES%COMM%NODE_ME
+    IONODE =WDES%COMM%IONODE
+#endif
+
+
+
+#ifdef MPI
+!=======================================================================
+! merge CRHODE from all nodes
+! for simplicity I do this with M_sum_d but there are of course better
+! ways to do this
+!=======================================================================
+   CTMP=0
+   DO ISP=1,WDES%NCDIJ
+      DO NI=1,T_INFO%NIONS
+         NIP=NI_LOCAL(NI, WDES%COMM_INB)
+         IF (NIP/=0) THEN
+            CTMP(:,:,NI,ISP)=CRHODE(:,:,NIP,ISP)
+         ENDIF
+      ENDDO
+   ENDDO
+#ifdef realmode
+   CALLMPI( M_sum_d(WDES%COMM_INB,CTMP,LMDIM*LMDIM*T_INFO%NIONS*WDES%NCDIJ))
+#else
+   CALLMPI( M_sum_d(WDES%COMM_INB,CTMP,LMDIM*LMDIM*T_INFO%NIONS*WDES%NCDIJ*2))
+#endif
+#endif
+
+    do_io WRITE(IU,'(3I5)') LMDIM,T_INFO%NIONS,WDES%NCDIJ
+    do_io WRITE(IU,'(5(2X,E11.5,1X,E11.5))') CTMP
+
+#ifdef MPI
+DEALLOCATE(CTMP)
+#else
+#undef CTMP
+#endif
+
+END SUBROUTINE
\ No newline at end of file
diff -urN file_ini/aedens.F file_modify/aedens.F
--- file_ini/aedens.F	2024-07-13 10:37:12.000000000 +0800
+++ file_modify/aedens.F	2024-07-13 10:37:23.000000000 +0800
@@ -10,7 +10,7 @@
   INTERFACE
       SUBROUTINE AUGCHG(WDES, GRID_SOFT,GRIDC_,GRIDUS,C_TO_US, &
         LATT_CUR,P,T_INFO,SYMM, LOVERL, SOFT_TO_C,&
-        LMDIM,CRHODE, CHTOT_,CHDEN, IRDMAX ,LPSEUDO, LCORE)
+        LMDIM,CRHODE, CHTOT_,CHDEN, IRDMAX ,LPSEUDO, LCORE, QVEC_CART)
       USE prec
       USE base
       USE charge
@@ -41,6 +41,8 @@
       COMPLEX(q) CHTOT_(GRIDC_%MPLWV,WDES%NCDIJ)
       COMPLEX(q) CHDEN(GRID_SOFT%MPLWV,WDES%NCDIJ)
       LOGICAL LOVERL,LPSEUDO,LCORE
+      ! DFPT
+      REAL(q), OPTIONAL :: QVEC_CART(3)
     END SUBROUTINE
 
   END INTERFACE
@@ -321,7 +323,7 @@
 
       SUBROUTINE AUGCHG(WDES, GRID_SOFT,GRIDC_,GRIDUS,C_TO_US, &
         LATT_CUR,P,T_INFO,SYMM, LOVERL, SOFT_TO_C,&
-        LMDIM,CRHODE, CHTOT_,CHDEN, IRDMAX, LPSEUDO,LCORE)
+        LMDIM,CRHODE, CHTOT_,CHDEN, IRDMAX, LPSEUDO,LCORE, QVEC_CART)
       USE prec
       USE base
       USE charge
@@ -356,9 +358,12 @@
       RGRID,POINTER :: CHTOT(:)
       COMPLEX(q) CHDEN(GRID_SOFT%MPLWV,WDES%NCDIJ)
       LOGICAL   LOVERL,LADDITIONAL,LPSEUDO,LCORE
+      ! DFPT
+      REAL(q), OPTIONAL :: QVEC_CART(3)
+      REAL(q) QR_DFPT
 !  work arrays
       REAL(q)   RHOLM(256)
-      REAL(q),ALLOCATABLE ::   DIST(:),DEP(:),QIJ(:),SUM(:),YLM(:,:)
+      REAL(q),ALLOCATABLE ::   DIST(:),DEP(:),QIJ(:),DSUM(:),YLM(:,:)
       INTEGER,ALLOCATABLE ::   NLI(:)
       LOGICAL L_SYM
 !-MM- spin spiral stuff
@@ -396,7 +401,7 @@
       LMYDIM=(LYDIM+1)**2          ! number of lm pairs
 
       ALLOCATE( &
-     &          DIST(IRDMAX),DEP(IRDMAX),SUM(IRDMAX),YLM(IRDMAX,LMYDIM), &
+     &          DIST(IRDMAX),DEP(IRDMAX),DSUM(IRDMAX),YLM(IRDMAX,LMYDIM), &
      &          NLI(IRDMAX),QIJ(IRDMAX))
 
       IF (LADDITIONAL) THEN
@@ -518,15 +523,15 @@
      &        LMYDIM,LYMAX,YLM(1,1),IRDMAX,INDMAX, &
      &        DISX,DISY,DISZ,DIST(1),NLI(1),XS,YS,ZS)
 
-      SUM=0
+      DSUM=0
 !=======================================================================
 ! include only core charge density
 !=======================================================================
       IF (LCORE) THEN
-         SUM=0
+         DSUM=0
          CALL GETQIJ(0,0,P(NT),INDMAX,DIST(1:INDMAX),QIJ(1:INDMAX),.TRUE.)
          DO IND=1,INDMAX
-            SUM(IND)=SUM(IND)+QIJ(IND)*LATT_CUR%OMEGA/(2*SQRT(PI))
+            DSUM(IND)=DSUM(IND)+QIJ(IND)*LATT_CUR%OMEGA/(2*SQRT(PI))
          ENDDO
       ELSE
 !=======================================================================
@@ -564,7 +569,7 @@
 !DIR$ IVDEP
 !OCL NOVREC
             DO IND=1,INDMAX
-               SUM(IND)=SUM(IND)+QIJ(IND)*YLM(IND,INDYLM)*YLM(IND,INDPYL)*TFAKT
+               DSUM(IND)=DSUM(IND)+QIJ(IND)*YLM(IND,INDYLM)*YLM(IND,INDPYL)*TFAKT
             ENDDO
 
          ENDDO mp_loop
@@ -591,7 +596,7 @@
 !DIR$ IVDEP
 !OCL NOVREC
                DO IND=1,INDMAX
-                  SUM(IND)=SUM(IND)-DEP(IND)*YLM(IND,INDYLM)*TFAKT
+                  DSUM(IND)=DSUM(IND)-DEP(IND)*YLM(IND,INDYLM)*TFAKT
                ENDDO
             ENDDO
             ENDDO
@@ -602,8 +607,13 @@
 !=======================================================================
       SUMN=0
       DO IND=1,INDMAX
-        CHTOT(NLI(IND))=CHTOT(NLI(IND))+SUM(IND)
-        SUMN=SUMN+SUM(IND)
+        IF (PRESENT(QVEC_CART)) THEN
+           QR_DFPT=TPI*(QVEC_CART(1)*XS(IND)+QVEC_CART(2)*YS(IND)+QVEC_CART(3)*ZS(IND))
+           CHTOT(NLI(IND))=CHTOT(NLI(IND))+DSUM(IND)*EXP((0._q,-1._q)*QR_DFPT)
+        ELSE
+           CHTOT(NLI(IND))=CHTOT(NLI(IND))+DSUM(IND)
+        ENDIF
+        SUMN=SUMN+DSUM(IND)
       ENDDO
 !-----------------------------------------------------------------------
       ENDDO ion
@@ -614,7 +624,7 @@
 !-----------------------------------------------------------------------
       CALL FFT_RC_SCALE(CHTOT(1),CHTOT(1),GRIDC)
       IF (LADDITIONAL) CALL CP_GRID(GRIDUS,GRIDC_,C_TO_US,CHTOT(1),CHTOT_(1,ISP))
-#define debug
+!#define debug
 #ifdef debug
       RHO_AUG =RHO0(GRIDC_, CHTOT_(1,ISP))
       RHO_SOFT=RHO0(GRID_SOFT , CHDEN)
@@ -632,7 +642,7 @@
       ENDDO spin
 
       IF (LADDITIONAL) DEALLOCATE(CHTOT)
-      DEALLOCATE(DIST,DEP,SUM,YLM,NLI,QIJ,XS,YS,ZS)
+      DEALLOCATE(DIST,DEP,DSUM,YLM,NLI,QIJ,XS,YS,ZS)
 
       ENDIF overl
 #ifdef MPI
diff -urN file_ini/broyden.F file_modify/broyden.F
--- file_ini/broyden.F	1970-01-01 08:00:00.000000000 +0800
+++ file_modify/broyden.F	2024-07-13 10:37:23.000000000 +0800
@@ -0,0 +1,1831 @@
+#include "symbol.inc"
+! RCS:  $Id: broyden.F,v 1.3 2002/04/16 07:28:37 kresse Exp $
+#define USE_TMPBROYD
+!
+! you have the option to do the mixing on disc or in storage
+! if USE_TMPBROYD is defined required arrays are stored on disc
+! if it is not defined dynamic arrays are allocated as required
+#undef USE_TMPBROYD
+
+      MODULE broyden
+      USE prec
+      INCLUDE "broyden.inc"
+      SAVE tmp_storage
+      SAVE broyden_storage
+      CONTAINS
+
+!***********************************************************************
+!
+!  calling interface to BROYD
+!  this routine extracts the chargedensity on the small grid
+!  and calls the broyden-mixing
+!  for wavevectors, which are not contained in the small grid a simple
+!  mixing is used
+! NGX,NGY,NGZ     is the reduced grid on which Broyden mixing is done
+!                 corresponds to NGXB,NGYB,NGZB in main program
+! NGXC,NGYC,NGZC  is the full grid
+!
+!***********************************************************************
+
+      SUBROUTINE BRMIX( &
+         KINEDEN,GRIDB,GRIDC,IO,MIX,B_TO_C, &
+         NGIGA,CHTOT,CHTOTL,ISPIN,B,OMEGA, &
+         N_MIX_PAW, RHOLM, RHOLM_LAST, &
+         RMST,RMS,RMSP,WEIGHT,LWARN,IERRBR, &
+         N_RHO_ONE_CENTRE, RHO_ONE_CENTRE , RHO_ONE_CENTRE_LAST )
+      USE prec
+
+      USE base
+      USE mpimy
+      USE mgrid
+      USE charge
+      USE meta
+      IMPLICIT COMPLEX(q) (C)
+      IMPLICIT REAL(q) (A-B,D-H,O-Z)
+
+      TYPE (tau_handle)  KINEDEN
+      TYPE (grid_3d)     GRIDB
+      TYPE (grid_3d)     GRIDC
+      TYPE (transit)     B_TO_C
+      TYPE (in_struct)   IO
+      TYPE (mixing)      MIX
+
+      COMPLEX(q)   CHTOT(GRIDC%MPLWV,ISPIN),CHTOTL(GRIDC%MPLWV,ISPIN)
+      INTEGER      N_MIX_PAW
+      REAL(q)      RHOLM(N_MIX_PAW,ISPIN),RHOLM_LAST(N_MIX_PAW,ISPIN)
+      INTEGER,OPTIONAL :: N_RHO_ONE_CENTRE
+      REAL(q),OPTIONAL :: RHO_ONE_CENTRE(:),RHO_ONE_CENTRE_LAST(:)
+      REAL(q)      B(3,3)
+      LOGICAL LWARN
+! local variables
+      REAL(q)      OMEGA,FAKT,ISFAKT,SFAKT
+      SAVE IERR
+      DATA IERR /0/
+      INTEGER NDATA,NCHARGE
+      COMPLEX(q),ALLOCATABLE :: CWRK1(:),CWRK2(:),CWRK3(:),CWRK4(:),CHP(:)
+
+      PROFILING_START('brmix')
+
+      ! number of grid points to be mixed
+      NCHARGE= GRIDB%RC%NP*ISPIN
+      ! double NCHARGE to hold tau for metaGGA's
+      IF (LDO_METAGGA().AND.LMIX_TAU()) NCHARGE=2*NCHARGE
+      ! add number of occupancies to be mixed
+      NDATA  = NCHARGE+N_MIX_PAW*ISPIN
+      ! and the one-center density for the relaxed-core PAW
+      IF (PRESENT(N_RHO_ONE_CENTRE)) THEN
+         NDATA=NDATA+N_RHO_ONE_CENTRE
+      ENDIF
+
+      ALLOCATE( CWRK1(MAX(NGIGA,NDATA*2)),CWRK2(NDATA), &
+                CWRK3(NDATA),CWRK4(NDATA),CHP(NDATA))
+
+      NODE_ME=0
+      IONODE=0
+#ifdef MPI
+      NODE_ME= GRIDB%COMM%NODE_ME
+      IONODE = GRIDB%COMM%IONODE
+#endif
+      IDUMP=0     ! set to 1 on serial computers for add. inform.
+      io_begin
+      IDUMP=0     ! set to 1 on parallel computers
+      io_end
+
+      NUPDZ=-NGIGA/(MAX(NDATA,1))
+
+      CALLMPI ( M_max_i( GRIDB%COMM, NUPDZ ,1)) ! global minimum ;-)
+      NUPDZ=-NUPDZ
+
+!      IF (NDATA > GRIDC%MPLWV) THEN
+!         WRITE(*,*) 'Fatal error BRMIX: Insufficient workspace ...'
+!         STOP
+!      ENDIF
+
+      FAKT=1._q/OMEGA
+
+      TOTNEL=RHO0(GRIDC,CHTOT (1,1))
+      TOTOLD=RHO0(GRIDC,CHTOTL(1,1))
+
+! Set CHP (contains the metric to be used later):
+      MIXPMA=MIX%MIXPRE
+      IF (MIXPMA>=10) MIXPMA=MIXPMA-10
+! charge density metric
+      CALL BRPRE(GRIDB,CHP,B,MIXPMA,MIX%BMIX,MIX%LRESET.AND.(IDUMP/=0))
+
+! magnetisation density metric
+      MIXPMA=MIX%MIXPRE
+      ! special treatment for potential mixing (MIXPMA>10, e.g. OEP): 
+      ! in this case  both channels are treated in the same manner
+      IF (MIXPMA>=10) THEN
+        MIXPMA=MIXPMA-10
+      ELSE
+        MIXPMA=0._q
+      ENDIF
+      DO ISP=2,ISPIN
+         CALL BRPRE(GRIDB,CHP(GRIDB%RC%NP*(ISP-1)+1),B,MIXPMA,MIX%BMIX,MIX%LRESET.AND.(IDUMP/=0))
+      ENDDO
+
+! kinetic energy density metric
+      IF (LDO_METAGGA().AND.LMIX_TAU()) THEN
+         DO ISP=1,ISPIN
+            CALL BRPRE(GRIDB,CHP(GRIDB%RC%NP*(ISP-1+ISPIN)+1),B,MIXPMA,MIX%BMIX,MIX%LRESET.AND.(IDUMP/=0))
+!           CHP(GRIDB%RC%NP*(ISP-1+ISPIN)+1:GRIDB%RC%NP*(ISP+ISPIN))=CHP(GRIDB%RC%NP*(ISP-1+ISPIN)+1:GRIDB%RC%NP*(ISP+ISPIN))
+            CHP(GRIDB%RC%NP*(ISP-1+ISPIN)+1:GRIDB%RC%NP*(ISP+ISPIN))=CHP(GRIDB%RC%NP*(ISP-1+ISPIN)+1:GRIDB%RC%NP*(ISP+ISPIN))*1.E-4_q
+         ENDDO
+      ENDIF
+
+! Copy CHTOT to CWRK3 and CHTOTL to CWRK4 - reduction to a smaller mesh:
+
+      NP=NCHARGE
+
+      DO ISP=1,ISPIN
+         ! copy charge and magnetization
+         CALL CP_GRID(GRIDC,GRIDB,B_TO_C,CHTOT(1,ISP), CWRK3(GRIDB%RC%NP*(ISP-1)+1))
+         CALL CP_GRID(GRIDC,GRIDB,B_TO_C,CHTOTL(1,ISP),CWRK4(GRIDB%RC%NP*(ISP-1)+1))
+         ! copy kinetic energy density
+         IF (LDO_METAGGA().AND.LMIX_TAU()) THEN
+            CALL CP_GRID(GRIDC,GRIDB,B_TO_C,KINEDEN%TAU(1,ISP), CWRK3(GRIDB%RC%NP*(ISP-1+ISPIN)+1))
+            CALL CP_GRID(GRIDC,GRIDB,B_TO_C,KINEDEN%TAUL(1,ISP),CWRK4(GRIDB%RC%NP*(ISP-1+ISPIN)+1))
+         ENDIF
+         ! one center occupancy matrix
+         CWRK3(NP+1:NP+N_MIX_PAW)  =RHOLM(:,ISP)-RHOLM_LAST(:,ISP)
+         CWRK4(NP+1:NP+N_MIX_PAW)  =RHOLM_LAST(:,ISP)
+         CHP  (NP+1:NP+N_MIX_PAW)  =RHOLM(:,ISP)-RHOLM_LAST(:,ISP)
+         NP=NP+N_MIX_PAW
+      ENDDO
+
+      ! additional terms for relaxed core methods
+      IF (PRESENT(N_RHO_ONE_CENTRE)) THEN
+         CWRK3(NP+1:NP+N_RHO_ONE_CENTRE)=RHO_ONE_CENTRE-RHO_ONE_CENTRE_LAST
+         CWRK4(NP+1:NP+N_RHO_ONE_CENTRE)=RHO_ONE_CENTRE_LAST
+         CHP  (NP+1:NP+N_RHO_ONE_CENTRE)=RHO_ONE_CENTRE-RHO_ONE_CENTRE_LAST
+         NP=NP+N_RHO_ONE_CENTRE
+      ENDIF
+
+      IF (NP /= NDATA) THEN
+         WRITE(*,*) 'internal error 1 in BRMIX',NP,NDATA ; STOP
+      ENDIF
+
+! straight mixing for components which are not mixed by the Pulay mixer
+      AMIX0=0.8_q
+      BMIX0=0.001_q
+      CALL SETG0(GRIDC,CWRK1,B,MIX%INIMIX,AMIX0,BMIX0,MIX%AMIN,.FALSE.)
+      RMST=0._q
+      RMS_tau=0._q
+!-----------------------------------------------------------------------
+! calculation of norm of residual on full grid !
+! and mix all components
+!-----------------------------------------------------------------------
+      DO ISP=1,ISPIN
+         ! charge density
+         DO I=1,GRIDC%RC%NP
+            N1= MOD((I-1),GRIDC%RC%NROW) +1
+            NC= (I-1)/GRIDC%RC%NROW+1
+            N2= GRIDC%RC%I2(NC)
+            N3= GRIDC%RC%I3(NC)
+            SETFACT1
+            SETFACT
+            RMST=RMST+FAKT*MULFACT CONJG(CHTOT(I,ISP)-CHTOTL(I,ISP))* &
+     &           (CHTOT(I,ISP)-CHTOTL(I,ISP))
+            ALPHA=CWRK1(I)
+            CHTOT(I,ISP)=(1._q-ALPHA)*CHTOTL(I,ISP)+ALPHA*CHTOT(I,ISP)
+         ENDDO
+         ! kinetic energy density
+         IF (LDO_METAGGA().AND.LMIX_TAU()) THEN
+            DO I=1,GRIDC%RC%NP
+               N1= MOD((I-1),GRIDC%RC%NROW) +1
+               NC= (I-1)/GRIDC%RC%NROW+1
+               N2= GRIDC%RC%I2(NC)
+               N3= GRIDC%RC%I3(NC)
+               SETFACT1
+               SETFACT
+
+!              RMST=RMST+FAKT*MULFACT CONJG(KINEDEN%TAU(I,ISP)-KINEDEN%TAUL(I,ISP))* &
+!    &              (KINEDEN%TAU(I,ISP)-KINEDEN%TAUL(I,ISP))
+               RMS_tau=RMS_tau+FAKT*MULFACT CONJG(KINEDEN%TAU(I,ISP)-KINEDEN%TAUL(I,ISP))* &
+     &              (KINEDEN%TAU(I,ISP)-KINEDEN%TAUL(I,ISP))
+
+               ALPHA=CWRK1(I)
+               KINEDEN%TAU(I,ISP)=(1._q-ALPHA)*KINEDEN%TAUL(I,ISP)+ALPHA*KINEDEN%TAU(I,ISP)
+            ENDDO
+         ENDIF
+         ! one center terms
+         DO I=1,N_MIX_PAW
+            DEL =(RHOLM(I,ISP)-RHOLM_LAST(I,ISP))
+            RMST=RMST+DEL*DEL
+         ENDDO
+      ENDDO
+
+      ! additional terms for relaxed core methods
+      IF (PRESENT(N_RHO_ONE_CENTRE)) THEN
+         DO I=1,N_RHO_ONE_CENTRE
+            DEL =(RHO_ONE_CENTRE(I)-RHO_ONE_CENTRE_LAST(I))
+            RMST=RMST+DEL*DEL
+         ENDDO
+      ENDIF
+
+      CALLMPI( M_sum_d(GRIDC%COMM, RMST, 1))
+      CALLMPI( M_sum_d(GRIDC%COMM, RMS_tau, 1))
+      RMST=SQRT(RMST)
+      RMS_tau=SQRT(RMS_tau)
+!-----------------------------------------------------------------------
+! residual vector on reduced grid (i.e. difference CHTOT-CHTOTL)
+! store in CWRK3, CHP is set to metric * CWRK3
+!-----------------------------------------------------------------------
+      SFAKT=SQRT(FAKT)
+      DO ISP=1,ISPIN
+         ! charge density
+!DIR$ IVDEP
+!OCL NOVREC
+         DO I=1,GRIDB%RC%NP
+            IP= I+(ISP-1)*GRIDB%RC%NP
+            N1= MOD((I-1),GRIDB%RC%NROW) +1
+            NC= (I-1)/GRIDB%RC%NROW+1
+            N2= GRIDB%RC%I2(NC)
+            N3= GRIDB%RC%I3(NC)
+            SETFACT1
+            SETSQRT
+            CWRK3(IP)=MULFACT (CWRK3(IP)-CWRK4(IP))*SFAKT
+            CWRK4(IP)=MULFACT  CWRK4(IP)*SFAKT
+         ENDDO
+         ! kinetic energy density
+         IF (LDO_METAGGA().AND.LMIX_TAU()) THEN
+            DO I=1,GRIDB%RC%NP
+               IP= I+(ISP-1+ISPIN)*GRIDB%RC%NP
+               N1= MOD((I-1),GRIDB%RC%NROW) +1
+               NC= (I-1)/GRIDB%RC%NROW+1
+               N2= GRIDB%RC%I2(NC)
+               N3= GRIDB%RC%I3(NC)
+               SETFACT1
+               SETSQRT
+               CWRK3(IP)=MULFACT (CWRK3(IP)-CWRK4(IP))*SFAKT
+               CWRK4(IP)=MULFACT  CWRK4(IP)*SFAKT
+            ENDDO
+         ENDIF
+      ENDDO
+
+    ! Do not mix the G=0 component here ...
+      CALL SET_RHO0(GRIDB, CWRK3(1), 0._q)
+
+    ! set CHP = metric * (CHTOT-CHTOTL):
+      ! charge and magnetization
+      DO I=1,GRIDB%RC%NP*ISPIN
+         CHP(I)=CWRK3(I)*CHP(I)
+      ENDDO
+      ! kinetic energy density
+      IF (LDO_METAGGA().AND.LMIX_TAU()) THEN
+         DO I=GRIDB%RC%NP*ISPIN+1,2*GRIDB%RC%NP*ISPIN
+            CHP(I)=CWRK3(I)*CHP(I)
+         ENDDO
+      ENDIF
+
+!-----------------------------------------------------------------------
+! Start mixing (given as input to BROYD on array CWRK1 if reset ...):
+!-----------------------------------------------------------------------
+      IF (MIX%LRESET) THEN
+         ! set initial step or mixing for charge
+         CALL SETG0(GRIDB,CWRK1,B,MIX%INIMIX,MIX%AMIX,MIX%BMIX,MIX%AMIN,(IDUMP/=0))
+         NP=NCHARGE
+         ! one center terms
+         CWRK1 (NP+1:NP+N_MIX_PAW)= MIN(MIX%AMIX,0.5_q)
+         NP=NP+N_MIX_PAW
+
+         ! set initial step for magnetization
+         INIMA=MIX%INIMIX
+         DO ISP=2,ISPIN
+            CALL SETG0(GRIDB,CWRK1(GRIDB%RC%NP*(ISP-1)+1),B,INIMA,MIX%AMIX_MAG,MIX%BMIX_MAG,MIX%AMIN,(IDUMP/=0))
+            ! one center terms
+            CWRK1(NP+1:NP+N_MIX_PAW)  = MIN(MIX%AMIX_MAG,2.0_q)
+            NP=NP+N_MIX_PAW
+         ENDDO
+
+         ! set initial step for kinetic energy density
+         IF (LDO_METAGGA().AND.LMIX_TAU()) THEN
+            DO ISP=1,ISPIN
+               CALL SETG0(GRIDB,CWRK1(GRIDB%RC%NP*(ISP-1+ISPIN)+1),B,INIMA,MIX%AMIX_MAG,MIX%BMIX_MAG,MIX%AMIN,(IDUMP/=0))
+            ENDDO
+         ENDIF
+
+         ! initial mixing for relaxed core method
+         IF (PRESENT(N_RHO_ONE_CENTRE)) THEN
+            CWRK1(NP+1:NP+N_RHO_ONE_CENTRE)= MIX%AMIX
+            NP=NP+N_RHO_ONE_CENTRE
+         ENDIF
+
+         IF (NP /= NDATA) THEN
+            WRITE(*,*) 'internal error 2 in BRMIX',NP,NDATA ; STOP
+         ENDIF
+      ENDIF
+! Broyden mixing:
+      IB=0
+      IF (MIX%WC==0._q) IB=1
+      IF (IERR/=0) MIX%LRESET=.TRUE.
+      IERR=0
+
+      CALL BROYD(NDATA,CWRK3,CWRK4,CHP,MIX%WC,IB,NUPDZ, &
+                 IABS(MIX%MAXMIX),MIX%MAXMIX>0 .AND. .NOT. MIX%HARD_RESET,MIX%MREMOVE,B,MAX(NGIGA,NDATA*2), &
+                 CWRK1,CWRK2,MIX%LRESET,MIX%IUBROY,IO%LOPEN,IO%ICMPLX,IO%MRECL, &
+                 RMS,RMSP,WEIGHT,MIX%NEIG,MIX%EIGENVAL,MIX%AMEAN,IERR &
+#ifdef MPI
+                 ,GRIDC%COMM &
+#endif
+                )
+
+      IF (MIX%LRESET) MIX%HARD_RESET=.FALSE.
+
+      DWRITE0 'rms are',RMS,RMSP,RMST
+
+! Hmmm ... . Disk was full? Invalid/corrupted file TMPBROYD? Or???
+      IF (IERR/=0) THEN
+! 'last chance': get some disk space and reset mixing at next step:
+#ifdef USE_TMPBROYD
+         CALL CLEAN(MIX%IUBROY)
+#endif
+! we can not only do 'simple mixing' here (take initial mixing ...):
+! this has been done 'on entry' --- just forget the following update!
+         GOTO 50
+      ENDIF
+!-----------------------------------------------------------------------
+! now CWRK4 (representing the image of CHTOTL) containes the mixed
+! density - expand to the larger grid and update CHTOT ... :
+!-----------------------------------------------------------------------
+      ISFAKT=1._q/SFAKT
+      SUM_=0
+      NP=NCHARGE
+
+      DO ISP=1,ISPIN
+         ! charge density
+!DIR$ IVDEP
+!OCL NOVREC
+         DO I=1,GRIDB%RC%NP
+            IP= I+(ISP-1)*GRIDB%RC%NP
+            N1= MOD((I-1),GRIDB%RC%NROW) +1
+            NC= (I-1)/GRIDB%RC%NROW+1
+            N2= GRIDB%RC%I2(NC)
+            N3= GRIDB%RC%I3(NC)
+
+            SETFACT1
+            SETISQRT
+            CWRK4(IP)= MULFACT CWRK4(IP)*ISFAKT
+            SUM_=SUM_+CWRK4(IP)*CONJG(CWRK4(IP))
+         ENDDO
+         CALL CPB_GRID(GRIDC,GRIDB,B_TO_C,CWRK4(GRIDB%RC%NP*(ISP-1)+1),CHTOT(1,ISP))
+
+         ! kinetic energy density
+         IF (LDO_METAGGA().AND.LMIX_TAU()) THEN
+            DO I=1,GRIDB%RC%NP
+               IP= I+(ISP-1+ISPIN)*GRIDB%RC%NP
+               N1= MOD((I-1),GRIDB%RC%NROW) +1
+               NC= (I-1)/GRIDB%RC%NROW+1
+               N2= GRIDB%RC%I2(NC)
+               N3= GRIDB%RC%I3(NC)
+
+               SETFACT1
+               SETISQRT
+               CWRK4(IP)= MULFACT CWRK4(IP)*ISFAKT
+            ENDDO
+            CALL CPB_GRID(GRIDC,GRIDB,B_TO_C,CWRK4(GRIDB%RC%NP*(ISP-1+ISPIN)+1),KINEDEN%TAU(1,ISP))
+         ENDIF
+
+         ! one center terms
+         RHOLM(:,ISP) = CWRK4(NP+1:NP+N_MIX_PAW)
+         NP=NP+N_MIX_PAW
+      ENDDO
+
+      IF (PRESENT(N_RHO_ONE_CENTRE)) THEN
+         RHO_ONE_CENTRE=CWRK4(NP+1:NP+N_RHO_ONE_CENTRE)
+         NP=NP+N_RHO_ONE_CENTRE
+      ENDIF
+
+      IF (NP /= NDATA) THEN
+         WRITE(*,*) 'internal error 3 in BRMIX',NP,NDATA ; STOP
+      ENDIF
+
+      CALLMPI( M_sum_d(GRIDC%COMM, SUM_, 1))
+      DWRITE0 'summed soft charge is',SUM_
+
+! Check whether charge density changed
+     io_begin
+      IF (ABS(TOTNEL-TOTOLD)>1E-5_q*ABS(TOTNEL) .AND. LWARN) WRITE(*,11) TOTOLD,TOTNEL
+   11 FORMAT('BRMIX: very serious problems',/ &
+             ' the old and the new charge density differ',/ &
+             ' old charge density: ',F11.5,' new',F11.5)
+     io_end
+      CALL SET_RHO0(GRIDC, CHTOT(1,1), TOTNEL)
+! copy CHTOT to CHTOTL
+   50 IERRBR=IERR
+! We average CHTOT over the KPAR (possibly slighty) different instances ... first the summation
+      CALLMPI( M_bcast_z(GRIDC%COMM_KINTER,CHTOT(1,1),SIZE(CHTOT)))
+      SUM_=0
+      DO ISP=1,ISPIN
+         DO I=1,GRIDC%RC%NP
+            CHTOTL(I,ISP)=CHTOT(I,ISP)
+            SUM_=SUM_+CHTOT(I,ISP)*CONJG(CHTOT(I,ISP))
+         ENDDO
+      ENDDO
+! copy kinetic energy density
+      IF (LDO_METAGGA().AND.LMIX_TAU()) THEN
+! TAU needs to be averaged over KPAR instances as well
+         CALLMPI( M_bcast_z(GRIDC%COMM_KINTER,KINEDEN%TAU(1,1),SIZE(KINEDEN%TAU)))
+         DO ISP=1,ISPIN
+            DO I=1,GRIDC%RC%NP
+               KINEDEN%TAUL(I,ISP)=KINEDEN%TAU(I,ISP)
+            ENDDO
+         ENDDO
+      ENDIF
+! copy occupancies
+#ifdef MPI
+      CALL M_bcast_d(GRIDC%COMM_KINTER,RHOLM(1,1),SIZE(RHOLM))
+#endif 
+      RHOLM_LAST=RHOLM
+! copy one-center densities
+      IF (PRESENT(N_RHO_ONE_CENTRE)) THEN
+         RHO_ONE_CENTRE_LAST=RHO_ONE_CENTRE
+      ENDIF
+
+      CALLMPI( M_sum_d(GRIDC%COMM, SUM_, 1))
+      DWRITE0 'summed charge is',SUM_
+
+      DEALLOCATE(CWRK1,CWRK2,CWRK3,CWRK4,CHP)
+
+      PROFILING_STOP('brmix')
+
+      RETURN
+      END SUBROUTINE
+
+
+!***********************************************************************
+!
+! Find the zero of a function vector F(X) of a vector X using the
+! second form of the modified Broyden scheme of Vanderbilt and Louie
+! as "described" in D. Johnsons paper (PRB 38, 12807 [Dec. 1988]).
+! (don't take this comment too serious, Johnson's paper contains at
+!  least 6 hard errors, which we have corrected ...)
+!
+! details can be found in
+! G. Kresse, J. Furthmueller,  Comput. Mat. Sci. 6, 15-50 (1996)
+! (written by  jF with contributions of gK [small corrections only])
+!
+! there is a routine in VASP which is much easier to understand and
+! does more or less the same see dynbr.F,
+! this routine is so complicated
+! because it can use a file to save the iteration history
+!
+!***********************************************************************
+
+      SUBROUTINE BROYD(NDIM,F,X,FP,WC,IB,NUPDZ,MAXIT,LKEEP,REMOVE, &
+     &                  B,NGIGA,WRK1,WRK2,INI,IU,LOPEN,ICMPLX,MRECL, &
+     &                  RMS,RMSP,WEIGHT,NEIG,EIGENVAL,AMEAN,IERR &
+#ifdef MPI
+                        ,COMM &
+#endif
+                       )
+      USE prec
+      USE mpimy
+      IMPLICIT REAL(q) (A-H,O-Z)
+
+#ifdef MPI
+      TYPE (communic) COMM
+#endif
+
+      PARAMETER(WEIMAX=33._q)
+      LOGICAL INI,LOPEN,LREDUC
+      LOGICAL LKEEP     ! keep Hessian matrix even at reset
+      COMPLEX(q) CTMP
+      COMPLEX(q) F(NDIM),X(NDIM),FP(NDIM),WRK1(NGIGA),WRK2(NDIM)
+      REAL(q)    B(3,3)
+
+      REAL(q)    BETAQ(MAXIT,MAXIT),AMAT(MAXIT,MAXIT),BETA(MAXIT,MAXIT)
+      REAL(q)    AUX(MAXIT,MAX(8,MAXIT)),VV(MAXIT)
+      REAL(q)    GP(MAXIT,MAXIT),SP(MAXIT,MAXIT)
+
+      INTEGER    IOD(3),INDEX(MAXIT)
+      REAL(q)    AUXR(MAXIT),AUXI(MAXIT),AUXBET(MAXIT)
+      COMPLEX(q) AUXC(MAXIT)
+      REAL(q)    EIGENVAL(512)
+
+      REAL(q), ALLOCATABLE,SAVE :: WI(:),FINF(:,:), &
+                      GMAT(:,:),SMAT(:,:)
+      SAVE ITER,ICALL,IOD,LASTIT
+      DATA ITER /0/,ICALL /0/,LASTIT /0/
+
+      INTEGER REMOVE   ! how many vectors are removed once MAXMIX is reached
+
+      PROFILING_START('broyd')
+
+#if defined(USE_TMPBROYD) && defined(MPI)
+      MPI + use of file for MIXING is not supported please undef USE_TMPBROYD
+#endif
+      NODE_ME=0
+      IONODE =0
+#ifdef MPI
+      NODE_ME= COMM%NODE_ME
+      IONODE = COMM%IONODE
+#endif
+      NEIG=0
+!=======================================================================
+! First call: initialise some I/O-things ...
+!=======================================================================
+      IF (ICALL==0) THEN
+         ALLOCATE(WI(MAXIT),FINF(MAXIT,MAXIT), &
+                  GMAT(MAXIT,MAXIT),SMAT(MAXIT,MAXIT))
+         WI=0
+         FINF=0
+         GMAT=0
+         SMAT=0
+
+         IRECL=NDIM*ICMPLX
+! Save some I/O-data ... :
+         IOD(1)=IU
+         IOD(2)=-1
+         IOD(3)=1
+         ICALL=1
+
+#ifdef USE_TMPBROYD
+! Open the save file for iteration data ... :
+         IF (LOPEN) THEN
+            OPEN(UNIT=IU,FILE='TMPBROYD',ACCESS='DIRECT', &
+     &                                    FORM='UNFORMATTED',RECL=IRECL)
+         ELSE
+            OPEN(UNIT=IU,ACCESS='DIRECT',FORM='UNFORMATTED',RECL=IRECL)
+         END IF
+#else
+         CALL BRNULL()
+#endif
+      END IF
+!=======================================================================
+! calculate some necessary quantities
+!=======================================================================
+
+! Restart of mixing forced externally by setting INI = .TRUE. (this must
+! be used for example after an ionic step / setup of a new geometry):
+      IF (INI .AND. ITER/=0 ) THEN
+      IF (.NOT. LKEEP .OR. MAXIT-ITER < -1 ) THEN
+          ITER=0
+          LASTIT=0
+      ELSE
+! keep mixing information alive (i.e. use it as an initial approximation
+! for  the present charge dielectric function)
+         ITER=ITER-1
+         LASTIT=ITER
+      ENDIF
+      ENDIF
+! usually it makes no sense to proceed if one cannot converge after so
+! many steps - if there is some little hope at all, then by removing
+! vectors from the iteration history
+! currently REMOVE vectors are removed if MAXIT is reached
+      IF (ITER == MAXIT ) THEN
+         ISHIFT=MIN(REMOVE,ITER)
+!        WRITE(*,*) 'removing ',ISHIFT,' from iteration history'
+         ITER  =ITER-ISHIFT
+         LASTIT=MAX(0,LASTIT-ISHIFT)
+         ! shift all saved arrays and vectors
+         CALL BR_SHIFT_MATRIX(GMAT,MAXIT,ITER,ISHIFT)
+         CALL BR_SHIFT_MATRIX(SMAT,MAXIT,ITER,ISHIFT)
+         CALL BR_SHIFT_MATRIX(FINF,MAXIT,ITER,ISHIFT)
+         CALL BR_SHIFT_VEC   (WI,1,ITER,ISHIFT)
+         ! shift all stored vectors
+         DO I=1,ITER-1
+            CALL BRGET(NDIM,WRK1,'F',I+ISHIFT,IOD,ITER,IERR)
+            CALL BRGET(NDIM,WRK2,'U',I+ISHIFT,IOD,ITER,IERR)
+            CALL BRSAV(NDIM,WRK1,'F',I,IOD,ITER,IERR)
+            CALL BRSAV(NDIM,WRK2,'U',I,IOD,ITER,IERR)
+            CALL BRGET(NDIM,WRK1,'Z',I+ISHIFT,IOD,ITER,IERR)
+            CALL BRSAV(NDIM,WRK1,'Z',I,IOD,ITER,IERR)
+         ENDDO
+      ENDIF
+! Restart of mixing if MAXIT is the same as ITER
+! not effective with the few lines above
+      ITER=MOD(ITER,MAXIT)
+! Increment iteration counter:
+      ITER=ITER+1
+! Number of previous iteration:
+      ITERM1=ITER-1
+! Change of vector |X>
+      SUM_=0
+      SUMP=0
+      DO I=1,NDIM
+         SUMP=SUMP+CONJG(F(I))*FP(I)
+         SUM_=SUM_  +CONJG(F(I))*F(I)
+      ENDDO
+      CALLMPI( M_sum_d(COMM, SUM_, 1))
+      CALLMPI( M_sum_d(COMM, SUMP, 1))
+      RMSP=SQRT(SUMP)
+      RMS =SQRT(SUM_)
+      DWRITE0 'rms',RMS,RMSP
+! Relative weight (W_iter/W_0) used for the current iteration ... :
+      IF (WC>=0._q) THEN
+        WI(ITER)=WC
+      ELSE
+! Try to set weights automatically (not recommended)
+        WI(ITER)=0.01_q*ABS(WC)/SUMP
+      END IF
+! Do not allow too strange weights ... :
+      IF (WI(ITER) < 1)     WI(ITER)=1
+      IF (WI(ITER) > 1E6  ) WI(ITER)=1E6
+      IF (WC==0 )           WI(ITER)=100
+
+! Here Broydens 2nd method (slightly generalized) can be switched on:
+      IF (IB/=0) THEN
+         DO I=1,ITERM1
+           WI(I)=0
+         ENDDO
+         DO I=MAX(1,ITERM1-IB+1),ITERM1
+           WI(I)=100
+         ENDDO
+      ENDIF
+! it is possible to give all iterations including LASTIT
+! zero weight
+! this means that information collected up to LASTIT is overwritten
+! when updating the Hessian matrix
+!      WI(1:LASTIT)=0
+
+      WEIGHT=WI(ITER)
+!=======================================================================
+! First iteration is a conventional linear mixing using G^(1):
+!=======================================================================
+      IF (ITER==1 .OR.INI) THEN
+         IF (.NOT.INI) THEN
+! Can only be reset by ITER>MAXIT here, try again initial start mixing:
+            IF (NODE_ME /= IONODE) &
+            WRITE(*,*) 'Iteration count exceeded MAXIT =',MAXIT
+! Get initial (diagonal) mixing used previously ... :
+            CALL BRGET(NDIM,WRK1,'G',ITER,IOD,ITER,IERR)
+            IF (IERR/=0) THEN
+               PROFILING_STOP('broyd')
+               RETURN
+            END IF
+         END IF
+         IF (ITER==1) THEN
+#ifdef USE_TMPBROYD
+      ! Delete and reopen file TMPBROYD (or clean temproray work area)...
+           CALL CLEAN(IU)
+#else
+           CALL CLBROYD(IU)
+#endif
+       ! allocate for next 4 steps
+           CALL BRSAV(NDIM,F,'Z',ITER+3,IOD,ITER+3,IERR)
+         ENDIF
+! First save some things needed later: |XLAST>, |F^(1)> and |FP^(1)>:
+         CALL BRSAV(NDIM,FP,'P',ITER,IOD,ITER,IERR)
+         IF (IERR/=0) THEN
+            PROFILING_STOP('broyd')
+            RETURN
+         END IF
+         CALL BRSAV(NDIM,X,'X',ITER,IOD,ITER,IERR)
+         IF (IERR/=0) THEN
+            PROFILING_STOP('broyd')
+            RETURN
+         END IF
+         CALL BRSAV(NDIM,F,'I',ITER,IOD,ITER,IERR)
+         IF (IERR/=0) THEN
+            PROFILING_STOP('broyd')
+            RETURN
+         END IF
+! Now save also the start mixing G^(1) supplied on array WRK1:
+         CALL BRSAV(NDIM,WRK1,'G',ITER,IOD,ITER,IERR)
+         IF (IERR/=0) THEN
+            PROFILING_STOP('broyd')
+            RETURN
+         END IF
+
+         GOTO 2000
+! Mix (here we need no metric because for simple linear mixing
+! using a diagonal G0 the result is the same with and without metric.):
+         DO I=1,NDIM
+           X(I)=X(I)+WRK1(I)*F(I)
+         ENDDO
+! That is all for the first ... :
+         PROFILING_STOP('broyd')
+         RETURN
+      END IF
+
+      IF (MOD(ITER,5)==1) THEN
+! force allocation in junks of 5 data blocks to avoid memory fragmentation
+         CALL BRSAV(NDIM,F,'Z',ITER+3,IOD,ITER+3,IERR)
+      ENDIF
+!=======================================================================
+! BROYDEN updating for ITER > 1 ... :
+!=======================================================================
+!Get |F> and |FP> from last iteration
+      CALL BRGET(NDIM,WRK1,'P',ITERM1,IOD,ITER,IERR)
+      IF (IERR/=0) THEN
+         PROFILING_STOP('broyd')
+         RETURN
+      END IF
+      CALL BRGET(NDIM,WRK2,'I',ITERM1,IOD,ITER,IERR)
+      IF (IERR/=0) THEN
+         PROFILING_STOP('broyd')
+         RETURN
+      END IF
+! Save actual |F> and |FP>:
+      CALL BRSAV(NDIM,F,'I',ITER,IOD,ITER,IERR)
+      IF (IERR/=0) THEN
+         PROFILING_STOP('broyd')
+         RETURN
+      END IF
+      CALL BRSAV(NDIM,FP,'P',ITER,IOD,ITER,IERR)
+      IF (IERR/=0) THEN
+         PROFILING_STOP('broyd')
+         RETURN
+      END IF
+      DO I=1,NDIM
+       ! |FP^(iter)>-|FP^(iter-1)>:
+         FP(I)=FP(I)-WRK1(I)
+       ! |F^(iter)>-|F^(iter-1)>:
+        F(I)=F(I)-WRK2(I)
+      ENDDO
+! Norm of this vector (with integration weights/metric. included ...):
+      FNORM=0._q
+      DO  I=1,NDIM
+        FNORM=FNORM+FP(I)*CONJG(F(I))
+      ENDDO
+      CALLMPI( M_sum_d( COMM, FNORM, 1))
+      FNORM=1._q/SQRT(FNORM)
+! Build |Delta F^(iter-1)>, |Delta FP^(iter-1)>:
+      DO I=1,NDIM
+         FP(I)=FP(I)*FNORM
+         F(I)=F(I)*FNORM
+      ENDDO
+! Save |Delta F^(iter-1)>:
+      CALL BRSAV(NDIM,F,'F',ITERM1,IOD,ITER,IERR)
+      IF (IERR/=0) THEN
+         PROFILING_STOP('broyd')
+         RETURN
+      END IF
+! Get |X^(iter-1)> from last iteration:
+      CALL BRGET(NDIM,WRK2,'X',ITERM1,IOD,ITER,IERR)
+      IF (IERR/=0) THEN
+         PROFILING_STOP('broyd')
+         RETURN
+      END IF
+! Save actual |X^(iter)>:
+      CALL BRSAV(NDIM,X,'X',ITER,IOD,ITER,IERR)
+      IF (IERR/=0) THEN
+         PROFILING_STOP('broyd')
+         RETURN
+      END IF
+! Build |Delta X^(iter-1)> = (|X^(iter)>-|X^(iter-1)>)/||F||_w :
+      DO I=1,NDIM
+        WRK1(I)=(X(I)-WRK2(I))*FNORM
+      ENDDO
+! Vector |U^(iter-1)> = G^(1) |Delta F^(iter-1)> + |Delta X^(iter-1)>:
+      CALL BRGET(NDIM,WRK2,'G',ITER,IOD,ITER,IERR)
+      IF (IERR/=0) THEN
+         PROFILING_STOP('broyd')
+         RETURN
+      END IF
+      DO I=1,NDIM
+        CTMP=WRK1(I)
+        WRK1(I)=WRK2(I)*F(I)
+        WRK1(I+NDIM)=CTMP+WRK2(I)*F(I)
+        WRK2(I)=CTMP+WRK2(I)*F(I)
+      ENDDO
+! Save |U^(iter-1)>:
+      CALL BRSAV(NDIM,WRK2,'U',ITERM1,IOD,ITER,IERR)
+      IF (IERR/=0) THEN
+         PROFILING_STOP('broyd')
+         RETURN
+      END IF
+!=======================================================================
+! Matrix FINF: we must only add the elements (iter-1,j) and (j,iter-1):
+!   FINF(j,iter-1) = <D F(j) | metric |  D F(iter-1) >
+!=======================================================================
+      DO J=1,ITERM1
+         CALL BRGET(NDIM,WRK2,'F',J,IOD,ITER,IERR)
+         IF (IERR/=0) THEN
+            PROFILING_STOP('broyd')
+            RETURN
+         END IF
+         SUM_=0
+         DO I=1,NDIM
+           SUM_=SUM_+CONJG(WRK2(I))*FP(I)
+         ENDDO
+
+         FINF(J,ITERM1)=SUM_
+         FINF(ITERM1,J)=SUM_
+
+         SUM1=0
+         SUM2=0
+        !  SUM1=<D F(j)| G(1) |D F(iter-1)>
+        !  SUM2=<D F(j)| U^(iter-1)> = <D F(j)| G(m)-G(1) | D F^(iter-1)>
+         DO I=1,NDIM
+           SUM1=SUM1+CONJG(WRK2(I))*WRK1(I)
+           SUM2=SUM2-CONJG(WRK2(I))*WRK1(I+NDIM)
+         ENDDO
+         SMAT(J,ITERM1)=SUM1
+         SMAT(ITERM1,J)=SUM1
+         GMAT(J,ITERM1)=SUM2
+      ENDDO
+
+      CALL BRGET(NDIM,WRK1,'F',ITERM1,IOD,ITER,IERR)
+
+      DO J=1,ITERM1
+         CALL BRGET(NDIM,WRK2,'U',J,IOD,ITER,IERR)
+         IF (IERR/=0) THEN
+            PROFILING_STOP('broyd')
+            RETURN
+         END IF
+       ! SUM_=<D F(iter-1)| U^(j)>
+         SUM_=0
+         DO I=1,NDIM
+           SUM_=SUM_+CONJG(WRK1(I))*WRK2(I)
+         ENDDO
+         GMAT(ITERM1,J)=-SUM_
+      ENDDO
+
+      CALLMPI( M_sum_d(COMM, SMAT(1,ITERM1), ITERM1))
+      CALLMPI( M_sum_d(COMM, FINF(1,ITERM1), ITERM1))
+      CALLMPI( M_sum_d(COMM, GMAT(1,ITERM1), ITERM1))
+      CALLMPI( M_sum_d(COMM, GMAT(ITERM1,1:ITERM1), ITERM1-1))
+      FINF(ITERM1,ITERM1)=1._q
+
+      ! correct transposed elements
+      DO J=1,ITERM1-1
+        FINF(ITERM1,J)=FINF(J,ITERM1)
+        SMAT(ITERM1,J)=SMAT(J,ITERM1)
+      ENDDO
+
+! Matrix A:
+      DO J=1,ITERM1
+      AMAT(J,J)=1._q+WI(J)*WI(J)*FINF(J,J)
+      DO K=1,J-1
+         AMAT(J,K)=FINF(J,K)*WI(J)*WI(K)
+         AMAT(K,J)=FINF(K,J)*WI(K)*WI(J)
+      ENDDO
+      ENDDO
+      IDUMP=0
+      io_begin
+      IF (IDUMP==1) THEN
+        WRITE(*,*)
+        WRITE(*,*)'AMAT'
+        DO I=1,ITERM1
+          WRITE(*,'(10F10.4)') (AMAT (I,J),J=1,ITERM1)
+        ENDDO
+        WRITE(*,*)'FINF'
+        DO I=1,ITERM1
+          WRITE(*,'(10F10.4)') (FINF(I,J),J=1,ITERM1)
+        ENDDO
+      ENDIF
+      io_end
+
+
+! Matrix Beta:
+      IF (ITERM1==1) THEN
+! Trivial case: A is a 1x1 matrix ...
+         BETA(1,1)=1._q/AMAT(1,1)
+      ELSE
+! General case: Invert matrix A ...
+         CALL INVERS(AMAT,ITERM1,MAXIT,BETA,AUX,INDEX,VV)
+      END IF
+!=======================================================================
+!  solve eigenvalue problem
+!   G e = lambda G^1 e
+!  where G is the approximation of the Hessian matrix
+!  works only for Pulay mixing because we assume  G |d F> = | d X>
+!=======================================================================
+     io_begin
+      DO I=1,ITERM1
+      DO J=1,ITERM1
+        GP(I,J)=GMAT(I,J)
+        SP(I,J)=SMAT(I,J)
+      ENDDO
+      ENDDO
+
+      IDUMP=0
+      IF (IDUMP==1) THEN
+        WRITE(*,*)'SMAT'
+        DO  I=1,ITERM1
+          WRITE(*,'(10F10.4)') (SP(I,J),J=1,ITERM1)
+        ENDDO
+        WRITE(*,*)'GMAT'
+        DO I=1,ITERM1
+          WRITE(*,'(10F10.4)') (GP(I,J),J=1,ITERM1)
+        ENDDO
+      ENDIF
+      INFO=1
+      IF (INFO/=0) THEN
+#ifdef essl
+        CALL DGEGV(0,GP,MAXIT,SP,MAXIT,AUXC,AUXBET,AUX,1,ITERM1, &
+       &        AUX,MAX(8*MAXIT,MAXIT*MAXIT))
+#else
+        CALL DGEGV('N','N',ITERM1,GP,MAXIT,SP,MAXIT,AUXR,AUXI,AUXBET, &
+       &        AUX,1,AUX,1,AUX,MAX(8*MAXIT,MAXIT*MAXIT),INFO)
+        AUXC= CMPLX( AUXR , AUXI ,KIND=q)
+#endif
+        NEIG=ITERM1
+        DO I=1,ITERM1
+          EIGENVAL(I)= ABS(AUXC(I)/MAX(AUXBET(I),1E-10_q)+1)
+        ENDDO
+        AMEAN=0
+        DO I=1,ITERM1
+          AMEAN=AMEAN+ABS(AUXC(I)/MAX(AUXBET(I),1E-10_q)+1)
+        END DO
+        AMEAN=AMEAN/ITERM1
+      ENDIF
+     io_end
+!=======================================================================
+! Calculate BETAQ used in the update of Z.(formula in Johnsons paper is
+! wrong if weights are not equal, here is the correct version - by gK):
+! a few comments here:
+!   for Pulays      approach BETAQ is strictly 0 (equ. 103)
+!   for Broydens 2. approach BETAQ and BETA have the structure
+!            BETAQ     1   0   0      BETA=0 except for
+!                      0   1   0      BETA(ITERM1,ITERM1)=1
+!                      0   0   1
+!                     g_1 g_2  g_3
+!            (see equ. 104 and 105 in gK)
+!=======================================================================
+      LREDUC=.TRUE.
+      BETAQ=0
+      DO I=1,ITERM1
+        LREDUC=LREDUC.AND.(WI(I)>=WEIMAX)
+        DO IT=1,ITERM1-1
+          BETAQ(I,IT)=0._q
+          DO J=1,ITERM1
+            BETAQ(I,IT)=BETAQ(I,IT)-WI(I)*BETA(I,J)*WI(J)*FINF(J,IT)
+          ENDDO
+        ENDDO
+        BETAQ(I,I)=BETAQ(I,I)+1
+      ENDDO
+
+      IDUMP=0
+      io_begin
+      IF (IDUMP==1) THEN
+        WRITE(*,*)'BETA'
+        DO I=1,ITERM1
+          WRITE(*,'(10F10.4)') (BETA (I,J)*WI(I)*WI(J),J=1,ITERM1)
+        ENDDO
+        WRITE(*,*)'BETAQ'
+        DO I=1,ITERM1
+          WRITE(*,'(10F10.4)') (BETAQ(I,J),J=1,ITERM1-1)
+        ENDDO
+      ENDIF
+      io_end
+      IDUMP=0
+
+! Reload |FP^(iter)>:
+      CALL BRGET(NDIM,FP,'P',ITER,IOD,ITER,IERR)
+      IF (IERR/=0) THEN
+         PROFILING_STOP('broyd')
+         RETURN
+      END IF
+!=======================================================================
+! update all the vectors |Z_it^(m-1)> - if WRK1 is dimensioned large
+! enough several vectors Z are updated simultaneously to reduce I/O!
+!=======================================================================
+      DO IT=1,ITERM1,NUPDZ
+! Number of vectors to be updated simultaneously:
+         NUPDM=MIN(NUPDZ,ITERM1-IT+1)
+         DO I=1,NDIM*NUPDM
+           WRK1(I)=(0._q,0._q)
+         ENDDO
+! Sum_{im=1,iter-2} BETAQ_{it,im} |Z_im^(iter-2)> - warning, do not be
+! confused: array F is here used as a workarray ... !
+         IF (.NOT.LREDUC) THEN
+! Remark: this part is not used at all if all weigths are very large!
+            DO IM=1,ITERM1-1
+! Selective treatment for steps with "smaller" weights ... :
+               IF (WI(IM)>=(10._q*WEIMAX)) CYCLE
+               CALL BRGET(NDIM,F,'Z',IM,IOD,ITER,IERR)
+               IF (IERR/=0) THEN
+                  PROFILING_STOP('broyd')
+                  RETURN
+               END IF
+               DO IUPD=0,NUPDM-1
+                  IF (BETAQ(IT+IUPD,IM)==0._q) CYCLE
+                  IOFF=IUPD*NDIM
+                  DO I=1,NDIM
+                  WRK1(I+IOFF)=WRK1(I+IOFF)+BETAQ(IT+IUPD,IM)*F(I)
+                  ENDDO
+               ENDDO
+            ENDDO
+         ENDIF
+! Add sum_{im=1,iter-1} WI_im WI_it BETA_{it,im} |U^(im)>:
+         DO IM=1,ITERM1
+            CALL BRGET(NDIM,F,'U',IM,IOD,ITER,IERR)
+            IF (IERR/=0) THEN
+               PROFILING_STOP('broyd')
+               RETURN
+            END IF
+            DO IUPD=0,NUPDM-1
+               IOFF=IUPD*NDIM
+               DO  I=1,NDIM
+               WRK1(I+IOFF)=WRK1(I+IOFF)+ &
+     &                          WI(IT+IUPD)*WI(IM)*BETA(IT+IUPD,IM)*F(I)
+               ENDDO
+            ENDDO
+         ENDDO
+         IF (LREDUC) THEN
+! Save |Z>-vectors (only allowed in reduced version for large weigths):
+            DO IUPD=0,NUPDM-1
+               IOFF=IUPD*NDIM
+               CALL BRSAV(NDIM,WRK1(1+IOFF),'Z',IT+IUPD,IOD,ITER,IERR)
+               IF (IERR/=0) THEN
+                  PROFILING_STOP('broyd')
+                  RETURN
+               END IF
+            ENDDO
+         ELSE
+! Save temporarily (we may not yet destroy the old |Z>-vectors!):
+            DO IUPD=0,NUPDM-1
+               IOFF=IUPD*NDIM
+               IF (WI(IT+IUPD)<(10._q*WEIMAX)) THEN
+                 CALL BRSAV(NDIM,WRK1(1+IOFF),'T',IT+IUPD,IOD,ITER,IERR)
+                 IF (IERR/=0) THEN
+                    PROFILING_STOP('broyd')
+                    RETURN
+                 END IF
+               ELSE
+! ... except unused |Z>-vectors (iterations with large weights):
+                 CALL BRSAV(NDIM,WRK1(1+IOFF),'Z',IT+IUPD,IOD,ITER,IERR)
+                 IF (IERR/=0) THEN
+                    PROFILING_STOP('broyd')
+                    RETURN
+                 END IF
+               ENDIF
+            ENDDO
+         ENDIF
+      ENDDO
+
+! Finally swap all updated |Z_it^(iter-1)> from temporary records 'T'
+! to records 'Z' (if necessary) to be prepared for the next step ... :
+      DO IT=1,ITERM1
+         IF ((.NOT.LREDUC).AND.(WI(IT)<(10._q*WEIMAX))) THEN
+            CALL BRGET(NDIM,WRK1,'T',IT,IOD,ITER,IERR)
+            IF (IERR/=0) THEN
+               PROFILING_STOP('broyd')
+               RETURN
+            END IF
+            CALL BRSAV(NDIM,WRK1,'Z',IT,IOD,ITER,IERR)
+            IF (IERR/=0) THEN
+               PROFILING_STOP('broyd')
+               RETURN
+            END IF
+         ENDIF
+      ENDDO
+!=======================================================================
+! calculate (G-G^(1)) |F^(iter)>
+!=======================================================================
+ 2000 CONTINUE
+
+! Reload |FP^(iter)>:
+      CALL BRGET(NDIM,FP,'P',ITER,IOD,ITER,IERR)
+
+      DO IT=1,ITERM1
+! Get the |Delta F^(it)>:
+            CALL BRGET(NDIM,F,'F',IT,IOD,ITER,IERR)
+            IF (IERR/=0) THEN
+               PROFILING_STOP('broyd')
+               RETURN
+            END IF
+            SUM_=0._q
+! Build <Delta F^(it)|FP^(iter)>:
+            DO I=1,NDIM
+              SUM_=SUM_+CONJG(F(I))*FP(I)
+            ENDDO
+            CALLMPI ( M_sum_d(COMM, SUM_, 1))
+! Subtract |Z_it^(iter-1)><Delta F^(it)|FP^(iter)> from |X^(iter)>:
+            CALL BRGET(NDIM,WRK1(1),'Z',IT,IOD,ITER,IERR)
+            DO I=1,NDIM
+              X(I)=X(I)-SUM_*WRK1(I)
+            ENDDO
+      ENDDO
+!=======================================================================
+! calculate G^(1) |F^(iter)>
+!=======================================================================
+! Reload |F^(iter)>:
+      CALL BRGET(NDIM,F,'I',ITER,IOD,ITER,IERR)
+      IF (IERR/=0) THEN
+         PROFILING_STOP('broyd')
+         RETURN
+      END IF
+! Reload start mixing G^(1):
+      CALL BRGET(NDIM,WRK1,'G',ITER,IOD,ITER,IERR)
+      IF (IERR/=0) THEN
+         PROFILING_STOP('broyd')
+         RETURN
+      END IF
+! Add G^(1) |F^(iter)> to vector |X^(iter)>:
+      DO I=1,NDIM
+        X(I)=X(I)+WRK1(I)*F(I)
+      ENDDO
+
+! Now we have the output vector |X(iter+1)> and all is done - good bye:
+#ifndef USE_TMPBROYD
+      CALL BRRMTMP()
+#endif
+
+      PROFILING_STOP('broyd')
+
+      RETURN
+      END SUBROUTINE
+
+!************************* SUBROUTINE SETG0 ****************************
+!
+! set the initial inverse Jacobi matrix G^(1)
+! use a Kerker like matrix or simple mixing
+!
+!***********************************************************************
+
+      SUBROUTINE SETG0(GRIDB,G0,B,IMIX,AMIX,BMIX,AMIN,LW)
+      USE prec
+      USE mpimy
+      USE mgrid
+      IMPLICIT REAL(q) (A-H,O-Z)
+
+      TYPE (grid_3d) GRIDB
+
+! Sets up initial mixing ...
+      LOGICAL LW
+      COMPLEX(q) G0(GRIDB%RC%NP)
+      REAL(q)    B(3,3)
+
+      PROFILING_START('setg0')
+
+      TPI=8._q*ATAN(1._q)
+      IF (IMIX==2) THEN
+
+! 'No mixing'
+
+         IF (LW) WRITE(*,*) 'Initial mixing matrix = unity matrix (no mixing!)'
+         G0=1._q
+      ELSE IF (IMIX==1) THEN
+
+! Kerker mixing:
+
+         IF (LW) WRITE(*,*) &
+           'Initial mixing = Kerker mixing. AMIX=',AMIX,'    BMIX=',BMIX
+         FLAM=BMIX**2
+         G0MIN=1E10_q
+         IND0=0
+         DO K=1,GRIDB%RC%NP
+            N1= MOD((K-1),GRIDB%RC%NROW) +1
+            NC= (K-1)/GRIDB%RC%NROW+1
+            N2= GRIDB%RC%I2(NC)
+            N3= GRIDB%RC%I3(NC)
+
+            IGX=GRIDB%LPCTX(N1)
+            IGY=GRIDB%LPCTY(N2)
+            IGZ=GRIDB%LPCTZ(N3)
+            GX=IGX*B(1,1)+IGY*B(1,2)+IGZ*B(1,3)
+            GY=IGX*B(2,1)+IGY*B(2,2)+IGZ*B(2,3)
+            GZ=IGX*B(3,1)+IGY*B(3,2)+IGZ*B(3,3)
+            GSQU=(GX*GX+GY*GY+GZ*GZ)*TPI*TPI
+            G0(K)=MAX(AMIX*GSQU/(GSQU+FLAM),AMIN)
+            IF (N1==1 .AND. N2==1 .AND. N3==1) THEN
+              IND0=K
+            ELSE
+              G0MIN=MIN(G0MIN,AMIX*GSQU/(GSQU+FLAM))
+            ENDIF
+         ENDDO
+         G0MIN=-G0MIN; CALLMPI ( M_max_d( GRIDB%COMM, G0MIN,1))
+         IF (IND0/=0) G0(IND0)=-G0MIN
+      ELSE
+
+! Linear mixing using only AMIX:
+
+         IF (LW) WRITE(*,*) 'Initial mixing = linear mixing. ALP =',AMIX
+         G0=AMIX
+      END IF
+
+      PROFILING_STOP('setg0')
+
+      RETURN
+      END SUBROUTINE
+
+!************************* SUBROUTINE BRPRE ****************************
+!
+! set up metric, it is assumed that small components are more
+! important than large G-componentes, therefore
+! 1   inverse of Kerker like matrix with automatic determination
+!     such that long wave lenght components are weighted 10 times stronger
+! 2   inverse of Kerker like matrix with automatic determination
+!     such that long wave lenght components are weighted 100 times stronger
+! 3   inverse Kerker metric determined by BMIX
+! 4-5 weight the long wave vectors more strongly (not very reasonable)
+! else no metric is used
+!
+!***********************************************************************
+
+
+      SUBROUTINE BRPRE(GRIDB,P,B,MIXPRE,BMIX,LWRITE)
+      USE prec
+
+      USE mpimy
+      USE mgrid
+      IMPLICIT REAL(q) (A-H,O-Z)
+
+      TYPE (grid_3d)  GRIDB
+
+      PARAMETER(FACMAX=20._q)
+
+      LOGICAL LWRITE
+      COMPLEX(q) P(GRIDB%RC%NP)
+      REAL(q)    B(3,3)
+
+      PROFILING_START('brpre')
+!
+      TPI=8._q*ATAN(1._q)
+      IF ((MIXPRE<1).OR.(MIXPRE>5)) THEN
+! Unknown type: 'No metric':
+         IF (LWRITE) WRITE(*,*) 'Routine BRPRE: No metric'
+         P=1.0_q
+      ELSE
+         IF (MIXPRE==1 .OR. MIXPRE==2 .OR. MIXPRE==4 .OR. MIXPRE==5) THEN
+! (Inverse) Hartree like metric (not really exactly - it is
+! essentially an inverse Kerker-type metric with automatically
+! adjusted parameter BMIX so that the maximum differences between the
+! maximum and minimum weights are about a given predefined value ...):
+            FACMAX_=FACMAX
+            IF (MIXPRE==2.OR. MIXPRE==5) FACMAX_=FACMAX*10
+
+            IF (LWRITE) WRITE(*,*) 'Routine BRPRE: ''Kerker-metric'''
+! Get smallest Q-vector (Q_min^2):
+            GSQUM=1.E30_q
+            DO K=1,GRIDB%RC%NP
+               N1= MOD((K-1),GRIDB%RC%NROW) +1
+               NC= (K-1)/GRIDB%RC%NROW+1
+               N2= GRIDB%RC%I2(NC)
+               N3= GRIDB%RC%I3(NC)
+
+               IGX=GRIDB%LPCTX(N1)
+               IGY=GRIDB%LPCTY(N2)
+               IGZ=GRIDB%LPCTZ(N3)
+               GX=IGX*B(1,1)+IGY*B(1,2)+IGZ*B(1,3)
+               GY=IGX*B(2,1)+IGY*B(2,2)+IGZ*B(2,3)
+               GZ=IGX*B(3,1)+IGY*B(3,2)+IGZ*B(3,3)
+               GSQU=(GX*GX+GY*GY+GZ*GZ)*TPI*TPI
+               IF (GSQU>1.E-10_q) GSQUM=MIN(GSQUM,GSQU)
+            ENDDO
+! Set 'automatic BMIX':
+            GSQUM=-GSQUM
+            CALLMPI( M_max_d(GRIDB%COMM, GSQUM, 1))
+            GSQUM=-GSQUM
+            FLAM=(FACMAX_-1._q)*GSQUM
+            IF (LWRITE) WRITE(*,*) '               Automatic BMIX_pre =',SQRT(FLAM)
+         ELSE
+! (Inverse) Kerker-mixing like metric:
+            IF (LWRITE) WRITE(*,*) 'Routine BRPRE: Kerker-metric with BMIX =',BMIX
+            FLAM=BMIX**2
+         END IF
+! Now set up the metric:
+         IF (MIXPRE==1 .OR. MIXPRE==2 .OR. MIXPRE==3) THEN
+         DO K=1,GRIDB%RC%NP
+            N1= MOD((K-1),GRIDB%RC%NROW) +1
+            NC= (K-1)/GRIDB%RC%NROW+1
+            N2= GRIDB%RC%I2(NC)
+            N3= GRIDB%RC%I3(NC)
+
+            IGX=GRIDB%LPCTX(N1)
+            IGY=GRIDB%LPCTY(N2)
+            IGZ=GRIDB%LPCTZ(N3)
+            GX=IGX*B(1,1)+IGY*B(1,2)+IGZ*B(1,3)
+            GY=IGX*B(2,1)+IGY*B(2,2)+IGZ*B(2,3)
+            GZ=IGX*B(3,1)+IGY*B(3,2)+IGZ*B(3,3)
+            GSQU=(GX*GX+GY*GY+GZ*GZ)*TPI*TPI
+            P(K)=(GSQU+FLAM)/MAX(GSQU,1.E-10_q)
+         ENDDO
+         ELSE
+         IF (LWRITE) WRITE(*,*) 'using inverse metric'
+         DO K=1,GRIDB%RC%NP
+            N1= MOD((K-1),GRIDB%RC%NROW) +1
+            NC= (K-1)/GRIDB%RC%NROW+1
+            N2= GRIDB%RC%I2(NC)
+            N3= GRIDB%RC%I3(NC)
+
+            IGX=GRIDB%LPCTX(N1)
+            IGY=GRIDB%LPCTY(N2)
+            IGZ=GRIDB%LPCTZ(N3)
+            GX=IGX*B(1,1)+IGY*B(1,2)+IGZ*B(1,3)
+            GY=IGX*B(2,1)+IGY*B(2,2)+IGZ*B(2,3)
+            GZ=IGX*B(3,1)+IGY*B(3,2)+IGZ*B(3,3)
+            GSQU=(GX*GX+GY*GY+GZ*GZ)*TPI*TPI
+            P(K)=MAX(GSQU,1.E-10_q)/(GSQU+FLAM)
+         ENDDO
+         ENDIF
+      END IF
+
+      PROFILING_STOP('brpre')
+
+      RETURN
+      END SUBROUTINE
+
+!************************* SUBROUTINE BRGRID ***************************
+!
+! Set up the grid size to be used for Broyden mixing (the rest will be
+! mixed using conventional linear mixing or Kerker mixing ...):
+!***********************************************************************
+
+      SUBROUTINE BRGRID(GRID,GRIDB,ENMAX,IU6,B)
+      USE prec
+      USE mpimy
+      USE mgrid
+
+      IMPLICIT REAL(q) (A-H,O-Z)
+
+      TYPE (grid_3d)     GRID
+      TYPE (grid_3d)     GRIDB
+
+      PARAMETER(SCALE=1._q,EUNITS=3.8100198741_q)
+      DIMENSION B(3,3)
+
+      PROFILING_START('brgrid')
+
+      TPI=8._q*ATAN(1._q)
+! The 'cutoff' were to truncate the grid is a matter of taste and a
+! matter of empirical experiences. A surely not too bad guess is to
+! take some value around the wavefunction-cutoff (parameter "SCALE"
+! gives us some freedom for adjustement to some special multiple of
+! GCUT_pw). Usually the mesh for the charge density is cut at 2*GCUT
+! (or some value close to it) - so this would lead to approximately
+! half size of the grid in each direction ... . The crude experience
+! is that within 1.5-1.7*GCUT one finds already 99.9999...% of all
+! charges - so cutting the grid here almost nothing would be left
+! outside the Broyden-grid (except for augmentation charges which
+! occur for ultrasoft potentials). Already within GCUT one should
+! have most of the charge (80%] and all(99.9999%] of the really
+! bad converging components which need treatment by a Broyden-mixing.
+      GCUTSQ=ENMAX/EUNITS*SCALE
+      GRIDB%NGX=0
+      GRIDB%NGY=0
+      GRIDB%NGZ=0
+! Find largest indexes for all Q-vectors with Q^2 < THRESH * Q_min^2:
+      col: DO NC=1,GRID%RC%NCOL
+      N2= GRID%RC%I2(NC)
+      N3= GRID%RC%I3(NC)
+      row: DO N1=1,GRID%RC%NROW
+
+         IGZ=GRID%LPCTZ(N3)
+         IGY=GRID%LPCTY(N2)
+         IGX=GRID%LPCTX(N1)
+
+         GX=IGX*B(1,1)+IGY*B(1,2)+IGZ*B(1,3)
+         GY=IGX*B(2,1)+IGY*B(2,2)+IGZ*B(2,3)
+         GZ=IGX*B(3,1)+IGY*B(3,2)+IGZ*B(3,3)
+         GSQU=(GX*GX+GY*GY+GZ*GZ)*TPI*TPI
+         IF (GSQU>GCUTSQ) CYCLE
+         GRIDB%NGX=MAX(ABS(IGX),GRIDB%NGX)
+         GRIDB%NGY=MAX(ABS(IGY),GRIDB%NGY)
+         GRIDB%NGZ=MAX(ABS(IGZ),GRIDB%NGZ)
+
+      ENDDO row
+      ENDDO col
+      GRIDB%NGX=MIN(2*GRIDB%NGX+1,GRID%NGX)
+      GRIDB%NGY=MIN(2*GRIDB%NGY+1,GRID%NGY)
+      GRIDB%NGZ=MIN(2*GRIDB%NGZ+1,GRID%NGZ)
+
+      CALLMPI ( M_max_i(GRID%COMM, GRIDB%NGX, 1))
+      CALLMPI ( M_max_i(GRID%COMM, GRIDB%NGY, 1))
+      CALLMPI ( M_max_i(GRID%COMM, GRIDB%NGZ, 1))
+      IF (IU6>=0) &
+      WRITE(IU6,1) GRIDB%NGX,GRIDB%NGY,GRIDB%NGZ, &
+                   GRID%NGX ,GRID%NGY ,GRID%NGZ , &
+                   GRIDB%NGX*GRIDB%NGY*GRIDB%NGZ
+      
+    1 FORMAT(' Broyden mixing: mesh for mixing (old mesh)'/ &
+     &        '   NGX =',I3,'   NGY =',I3,'   NGZ =',I3/ &
+     &        '  (NGX  =',I3,'   NGY  =',I3,'   NGZ  =',I3,')'/ &
+     &        '  gives a total of ',I6,' points'/)
+
+      PROFILING_STOP('brgrid')
+
+      RETURN
+      END SUBROUTINE
+
+!************************* SUBROUTINE BRSAV ****************************
+!
+! Save a vector necessary for Broyden mixing
+! in each iteration 3 datasets are used
+!  F   gradient vector   |Delta F> (|F> for last iteration!!!)
+!  Z   vector Z as defined in Johnsons paper (and corrected by gK)
+!  U   vector U as defined in Johnsons paper
+!      i.e |U> = G^(1) |Delta F> + |Delta X>:
+!  the first 3 records of the file  (or broyden_storage)
+!  are used to store
+!  G   start mixing G^(1)
+!  X   |X^(iter)> (used as |X^(iter-1)> in next iteration)
+!  P   metric * residual vector |FP^(iter)>
+!  in addition temporary 'swap  areas' are used
+!  T   temporary
+!***********************************************************************
+
+
+      SUBROUTINE BRSAV(NDIM,DATA,WHAT,ITER,IOD,ITNOW,IERR)
+      USE prec
+      IMPLICIT REAL(q) (A-H,O-Z)
+
+      CHARACTER (1) WHAT
+      COMPLEX(q) DATA
+      DIMENSION DATA(NDIM),IOD(3)
+
+      PROFILING_START('brsav')
+
+      IERR=0
+#ifdef USE_TMPBROYD
+        IU=IOD(1)
+        SELECT CASE (WHAT)
+          CASE ('F')
+            IREC=3*ITER+2
+          CASE ('U')
+            IREC=3*ITER+3
+          CASE ('Z')
+            IREC=3*ITER+4
+          CASE ('G')
+            IREC=1
+          CASE ('X')
+            IREC=2
+          CASE ('P')
+            IREC=3
+          CASE ('I')
+            IREC=4
+          CASE ('T')
+          ! 'T' is put at the very end of the file
+            IREC=3*ITNOW+1+ITER
+        END SELECT
+
+        WRITE(IU,REC=IREC,ERR=2) CMPLX(DATA,KIND=qs)
+
+        PROFILING_STOP('brsav')
+
+        RETURN
+ 2      IERR=1
+
+      PROFILING_STOP('brsav')
+
+      RETURN
+#else
+      IF (WHAT=='T') THEN
+        CALL dyn_put(tmp_storage,NDIM,ITER,DATA,IERR)
+      ELSE
+        SELECT CASE (WHAT)
+          CASE ('F')
+            IREC=3*ITER+2
+          CASE ('U')
+            IREC=3*ITER+3
+          CASE ('Z')
+            IREC=3*ITER+4
+          CASE ('G')
+            IREC=1
+          CASE ('X')
+            IREC=2
+          CASE ('P')
+            IREC=3
+          CASE ('I')
+            IREC=4
+        END SELECT
+        CALL dyn_put(broyden_storage,NDIM,IREC,DATA,IERR)
+      ENDIF
+
+      PROFILING_STOP('brsav')
+
+      RETURN
+#endif
+      END SUBROUTINE
+
+!************************* SUBROUTINE BRGET ****************************
+!
+! Get some data stored previously (conventions see routine BRSAV):
+!
+!***********************************************************************
+
+      SUBROUTINE BRGET(NDIM,DATA,WHAT,ITER,IOD,ITNOW,IERR)
+      USE prec
+      IMPLICIT REAL(q) (A-H,O-Z)
+
+      CHARACTER (1) WHAT
+      COMPLEX(q) DATA
+      DIMENSION DATA(NDIM),IOD(3)
+      COMPLEX(qs) DATA_TMP(NDIM)
+
+      PROFILING_START('brget')
+
+      IERR=0
+#ifdef USE_TMPBROYD
+        IU=IOD(1)
+        SELECT CASE (WHAT)
+          CASE ('F')
+            IREC=3*ITER+2
+          CASE ('U')
+            IREC=3*ITER+3
+          CASE ('Z')
+            IREC=3*ITER+4
+          CASE ('G')
+            IREC=1
+          CASE ('X')
+            IREC=2
+          CASE ('P')
+            IREC=3
+          CASE ('I')
+            IREC=4
+          CASE ('T')
+          ! 'T' is put at the very end of the file
+            IREC=3*ITNOW+1+ITER
+        END SELECT
+
+        READ(IU,REC=IREC,ERR=2) DATA_TMP
+        DATA=DATA_TMP
+
+        PROFILING_STOP('brget')
+
+        RETURN
+ 2      IERR=1
+
+      PROFILING_STOP('brget')
+
+      RETURN
+#else
+      IF (WHAT=='T') THEN
+        CALL dyn_get(tmp_storage,NDIM,ITER,DATA,IERR)
+      ELSE
+        SELECT CASE (WHAT)
+          CASE ('F')
+            IREC=3*ITER+2
+          CASE ('U')
+            IREC=3*ITER+3
+          CASE ('Z')
+            IREC=3*ITER+4
+          CASE ('G')
+            IREC=1
+          CASE ('X')
+            IREC=2
+          CASE ('P')
+            IREC=3
+          CASE ('I')
+            IREC=4
+        END SELECT
+        CALL dyn_get(broyden_storage,NDIM,IREC,DATA,IERR)
+      ENDIF
+
+      PROFILING_STOP('brget')
+
+      RETURN
+#endif
+      END SUBROUTINE
+
+!***********************************************************************
+!
+!  remove temporary data
+!
+!***********************************************************************
+      SUBROUTINE CLBROYD(IUBROY)
+      USE prec
+      IMPLICIT REAL(q) (A-H,O-Z)
+#ifdef USE_TMPBROYD
+      CLOSE(IUBROY,STATUS='DELETE',ERR=100)
+  100 CONTINUE
+#else
+      CALL dyn_free(tmp_storage)
+      CALL dyn_free(broyden_storage)
+#endif
+      RETURN
+      END SUBROUTINE
+
+#ifndef USE_TMPBROYD
+
+!***********************************************************************
+!
+!  remove tmp_storage
+!
+!***********************************************************************
+      SUBROUTINE BRRMTMP()
+      USE prec
+      IMPLICIT REAL(q) (A-H,O-Z)
+      CALL dyn_free(tmp_storage)
+      RETURN
+      END SUBROUTINE
+
+!***********************************************************************
+!
+!  remove temporary data
+!
+!***********************************************************************
+      SUBROUTINE BRNULL()
+      USE prec
+      IMPLICIT REAL(q) (A-H,O-Z)
+      NULLIFY(tmp_storage)
+      NULLIFY(broyden_storage)
+      RETURN
+
+      END SUBROUTINE
+
+
+!***********************************************************************
+! dynamic storage retrival system by gK
+! dyn_put   puts one complex array <data(ndim)> at position <irec> in a
+!           list <root>, the list is extened dynamically if required
+! dyn_get   retrives one complex array data(ndim) from position irec
+! dyn_free  frees the whole list
+! MIND:     ierr is not jet supported (not used at all!)
+!
+! written recursively because it is much shorter
+! the problem with an iterative implementation is that there is nothing
+! like a pointer to a pointer in F90, therefore we would have
+! complicated IF cases for initial node in the list
+! (whereas dummy arguments to pointer pass their association status back
+!  to the CALLER, in some way they behave like pointers to pointer)
+!***********************************************************************
+
+      RECURSIVE SUBROUTINE dyn_put(root,ndim,irec,data,ierr)
+      IMPLICIT NONE
+      INTEGER :: irec,ierr,ndim
+      COMPLEX(q) data(ndim)
+      TYPE (dyn_storage),POINTER :: root
+
+      IF (.NOT.ASSOCIATED(root)) THEN
+         ALLOCATE(root)
+         NULLIFY(root%store)
+         ALLOCATE(root%store(ndim))
+         NULLIFY(root%next)
+      ENDIF
+      IF (irec==1) THEN
+        IF  (.NOT.ASSOCIATED(root%store)) THEN
+          ALLOCATE(root%store(ndim))
+        ENDIF
+        root%store= data
+      ELSE
+        CALL dyn_put(root%next,ndim,irec-1,data,ierr)
+      ENDIF
+      END SUBROUTINE dyn_put
+
+
+      RECURSIVE SUBROUTINE dyn_get(root,ndim,irec,data,ierr)
+      IMPLICIT NONE
+      INTEGER :: irec,ierr,ndim
+      COMPLEX(q) data(ndim)
+      TYPE (dyn_storage),POINTER :: root
+
+      IF (.NOT.ASSOCIATED(root)) THEN
+         WRITE(*,*)'BROYDEN: fatal error: dyn_get leaf not allocate'
+         STOP
+         ALLOCATE(root)
+         NULLIFY(root%store)
+         NULLIFY(root%next)
+      ENDIF
+      IF (irec==1) THEN
+        IF  (.NOT.ASSOCIATED(root%store)) THEN
+          WRITE(*,*)'BROYDEN: fatal error: dyn_get store not allocated'
+          STOP
+        ENDIF
+        data=root%store
+      ELSE
+        CALL dyn_get(root%next,ndim,irec-1,data,ierr)
+      ENDIF
+      END SUBROUTINE dyn_get
+
+
+      RECURSIVE SUBROUTINE dyn_free(root)
+      IMPLICIT NONE
+      TYPE (dyn_storage),POINTER :: root
+
+      IF (.NOT.ASSOCIATED(root)) RETURN
+      CALL dyn_free(root%next)
+      IF (ASSOCIATED(root%store)) DEALLOCATE(root%store)
+      DEALLOCATE(root)
+      NULLIFY(root)
+      RETURN
+      END SUBROUTINE dyn_free
+#endif
+      END MODULE
+
+!***********************************************************************
+! SOME SMALL HELPER ROUTINES
+! Inverts a square matrix using routines of "NUMERICAL RECIPES",
+!   W. Press et al., Cambridge U.P., 1987.
+! Arguments:
+!   A   : Input square matrix
+!   N   : Input dimension of the matrix
+!   NP  : Input first physical dimension of matrices A and B
+!   B   : Output inverse matrix. Make B=A for 'in place' inversion
+!   AUX : Auxiliary array of minimun size N*N. If A and B are different
+!         and matrix A needs not be preserved, you can make AUX=A
+! Written by Jose Soler (JSOLER AT EMDUAM11) 22/4/90.
+! Modified by J. Furthmueller 11/12/92
+!
+!***********************************************************************
+      SUBROUTINE INVERS(A,N,NP,B,AUX,INDEX,VV)
+      USE prec
+
+      IMPLICIT REAL(q) (A-H,O-Z)
+      PARAMETER (ZERO=0._q,ONE=1._q)
+      DIMENSION A(NP,NP),B(NP,NP),AUX(NP,NP),INDEX(N),VV(N)
+!
+      DO I=1,N
+       DO J=1,N
+          AUX(J,I)=A(J,I)
+       ENDDO
+      ENDDO
+      CALL LUDCM(AUX,N,NP,INDEX,VV)
+      DO 30 I=1,N
+         DO 20 J=1,N
+            B(J,I)=ZERO
+   20    CONTINUE
+         B(I,I)=ONE
+         CALL LUBKS(AUX,N,NP,INDEX,B(1,I))
+   30 CONTINUE
+      END SUBROUTINE
+
+      SUBROUTINE LUDCM(A,N,NP,INDX,VV)
+      USE prec
+      IMPLICIT REAL(q) (A-H,O-Z)
+!
+! Decomposes a matrix in upper-lower triangular form.
+! Ref: W. Press et al., "NUMERICAL RECIPES", Cambridge U.P., 1987
+!
+      PARAMETER (TINY=1.E-20_q, ZERO=0._q,ONE=1._q)
+      DIMENSION A(NP,NP),INDX(N),VV(N)
+!
+      DO 12 I=1,N
+         AAMAX=ZERO
+         DO 11 J=1,N
+            IF (ABS(A(I,J))>AAMAX) AAMAX=ABS(A(I,J))
+  11     CONTINUE
+         IF (AAMAX==ZERO) CALL ERROR(' LUDCMP',' SINGULAR MATRIX ',-3)
+         VV(I)=ONE/AAMAX
+  12  CONTINUE
+      DO 19 J=1,N
+         IF (J>1) THEN
+            DO 14 I=1,J-1
+               SUM=A(I,J)
+               IF (I>1) THEN
+                  DO 13 K=1,I-1
+                     SUM=SUM-A(I,K)*A(K,J)
+  13              CONTINUE
+                  A(I,J)=SUM
+               END IF
+  14        CONTINUE
+         ENDIF
+         AAMAX=ZERO
+         DO 16 I=J,N
+            SUM=A(I,J)
+            IF (J>1) THEN
+               DO 15 K=1,J-1
+                  SUM=SUM-A(I,K)*A(K,J)
+  15           CONTINUE
+               A(I,J)=SUM
+            END IF
+            DUM=VV(I)*ABS(SUM)
+            IF (DUM>=AAMAX) THEN
+               IMAX=I
+               AAMAX=DUM
+            END IF
+  16     CONTINUE
+         IF (J/=IMAX) THEN
+            DO 17 K=1,N
+               DUM=A(IMAX,K)
+               A(IMAX,K)=A(J,K)
+               A(J,K)=DUM
+  17        CONTINUE
+            VV(IMAX)=VV(J)
+         END IF
+         INDX(J)=IMAX
+         IF (J/=N) THEN
+            IF (A(J,J)==ZERO) A(J,J)=TINY
+            DUM=ONE/A(J,J)
+            DO 18 I=J+1,N
+               A(I,J)=A(I,J)*DUM
+  18        CONTINUE
+         END IF
+  19  CONTINUE
+      IF (A(N,N)==ZERO) A(N,N)=TINY
+      RETURN
+      END SUBROUTINE
+
+
+!***********************************************************************
+!
+! Solves a system of linear equations in combination with 'LUDCMP'
+! Ref: W. Press et al., "NUMERICAL RECIPES", Cambridge U.P., 1987
+!
+!***********************************************************************
+      SUBROUTINE LUBKS(A,N,NP,INDX,B)
+      USE prec
+      IMPLICIT REAL(q) (A-H,O-Z)
+      PARAMETER (ZERO=0._q)
+      DIMENSION A(NP,NP),INDX(N),B(N)
+!
+      II=0
+      DO 12 I=1,N
+         LL=INDX(I)
+         SUM=B(LL)
+         B(LL)=B(I)
+         IF (II/=0) THEN
+            DO 11 J=II,I-1
+               SUM=SUM-A(I,J)*B(J)
+  11        CONTINUE
+         ELSE IF (SUM/=ZERO) THEN
+            II=I
+         END IF
+         B(I)=SUM
+  12  CONTINUE
+      DO 14 I=N,1,-1
+         SUM=B(I)
+         IF (I<N) THEN
+            DO 13 J=I+1,N
+               SUM=SUM-A(I,J)*B(J)
+  13        CONTINUE
+         END IF
+         B(I)=SUM/A(I,I)
+  14  CONTINUE
+      RETURN
+      END SUBROUTINE
diff -urN file_ini/charge.F file_modify/charge.F
--- file_ini/charge.F	2024-07-13 10:37:12.000000000 +0800
+++ file_modify/charge.F	2024-07-13 10:37:23.000000000 +0800
@@ -299,31 +299,35 @@
 !
 !***********************************************************************
 
-      SUBROUTINE SOFT_CHARGE1(GRID,GRID_SOFT,W0,W1,WDES, CHDEN)
+      SUBROUTINE SOFT_CHARGE1(GRID,GRID_SOFT,W0,W1,WDES, CHDEN,W2,W0_)
       USE prec
       USE mpimy
       USE mgrid
       USE wave
       USE wave_mpi
-      IMPLICIT NONE 
+      IMPLICIT NONE
 
       TYPE (wavedes)     WDES
-      TYPE (wavespin)    W0
-      TYPE (wavespin)    W1
+      TYPE (wavespin)    W0            ! W0_k
+      TYPE (wavespin)    W1            ! W1_k+q
+      TYPE (wavespin), OPTIONAL :: W2  ! W1_k-q (LKSHIFT = .FALSE.)
+                                       ! W1_k   (LKSHIFT = .TRUE.)
+      TYPE (wavespin), OPTIONAL :: W0_  ! W0_k+q (LKSHIFT = .TRUE.)
       TYPE (grid_3d)     GRID,GRID_SOFT
-      COMPLEX(q)   CHDEN(GRID_SOFT%MPLWV,WDES%NCDIJ)
+      COMPLEX(q)   CHDEN(GRID_SOFT%MPLWV,WDES%NCDIJ) ! OUTPUT \tilde n
 
     ! work arrays
       RGRID,   ALLOCATABLE :: CDWORK(:,:)
-      COMPLEX(q), ALLOCATABLE :: CPTDUM0(:), CPTDUM1(:)
+      COMPLEX(q), ALLOCATABLE :: CPTDUM0(:), CPTDUM1(:), CPTDUM2(:), CPTDUM0_(:)
       INTEGER ISPINOR, ISPINOR_, ISP, NK, N, NPL, M, MM, MM_, I
-      REAL(q) :: WEIGHT0, WEIGHT1
+      REAL(q) :: WEIGHT0, WEIGHT1, WEIGHT2, WEIGHT0_
 
       ! MPLWV is the allocation in complex words
-      ! hence if CDWORK is REAL one needs to double the allocation 
+      ! hence if CDWORK is REAL one needs to double the allocation
       ALLOCATE(CDWORK(GRID%MPLWV*2,WDES%NCDIJ), &
            CPTDUM0(GRID%MPLWV*WDES%NRSPINORS),CPTDUM1(GRID%MPLWV*WDES%NRSPINORS))
-
+      IF (PRESENT(W2)) ALLOCATE(CPTDUM2(GRID%MPLWV*WDES%NRSPINORS))
+      IF (PRESENT(W0_)) ALLOCATE(CPTDUM0_(GRID%MPLWV*WDES%NRSPINORS))
       CDWORK=0
 !=======================================================================
 ! loop over k-points and bands
@@ -337,8 +341,11 @@
 
          WEIGHT0=WDES%RSPIN*WDES%WTKPT(NK)*W0%FERWE(N,NK,ISP)
          WEIGHT1=WDES%RSPIN*WDES%WTKPT(NK)*W1%FERWE(N,NK,ISP)
-         IF (WEIGHT0==0 .AND. WEIGHT1==0) CYCLE
-
+         WEIGHT2=0
+         WEIGHT0_=0
+         IF (PRESENT(W2)) WEIGHT2=WDES%RSPIN*WDES%WTKPT(NK)*W2%FERWE(N,NK,ISP)
+         IF (PRESENT(W0_)) WEIGHT0_=WDES%RSPIN*WDES%WTKPT(NK)*W0_%FERWE(N,NK,ISP)
+         IF (WEIGHT0==0 .AND. WEIGHT1==0 .AND. WEIGHT2==0 .AND. WEIGHT0_==0) CYCLE
          NPL=WDES%NGVECTOR(NK)
 !=======================================================================
 ! fourier-transformation of wave-function
@@ -347,16 +354,31 @@
          DO ISPINOR=0,WDES%NRSPINORS-1
             CALL FFTWAV(NPL,WDES%NINDPW(1,NK),CPTDUM0(1+ISPINOR*GRID%MPLWV),W0%CPTWFP(1+ISPINOR*NPL,N,NK,ISP),GRID)
             CALL FFTWAV(NPL,WDES%NINDPW(1,NK),CPTDUM1(1+ISPINOR*GRID%MPLWV),W1%CPTWFP(1+ISPINOR*NPL,N,NK,ISP),GRID)
+            IF (PRESENT(W2)) CALL FFTWAV(NPL,WDES%NINDPW(1,NK),CPTDUM2(1+ISPINOR*GRID%MPLWV),W2%CPTWFP(1+ISPINOR*NPL,N,NK,ISP),GRID)
+            IF (PRESENT(W0_)) CALL FFTWAV(NPL,WDES%NINDPW(1,NK),CPTDUM0_(1+ISPINOR*GRID%MPLWV),W0_%CPTWFP(1+ISPINOR*NPL,N,NK,ISP),GRID)
          ENDDO
          spinor: DO ISPINOR=0,WDES%NRSPINORS-1 
          DO ISPINOR_=0,WDES%NRSPINORS-1 
             DO M=1,GRID%RL%NP
               MM =M+ISPINOR *GRID%MPLWV
               MM_=M+ISPINOR_*GRID%MPLWV
-              CDWORK(M,ISP+ISPINOR_+2*ISPINOR)=CDWORK(M,ISP+ISPINOR_+2*ISPINOR)+ &
-                   CPTDUM0(MM)*CONJG(CPTDUM0(MM_))*WEIGHT1+ &
-                   CPTDUM0(MM)*CONJG(CPTDUM1(MM_))*WEIGHT0+ &
-                   CPTDUM1(MM)*CONJG(CPTDUM0(MM_))*WEIGHT0
+              IF (PRESENT(W2)) THEN
+                 CDWORK(M,ISP+ISPINOR_+2*ISPINOR)=CDWORK(M,ISP+ISPINOR_+2*ISPINOR)+ &
+                      CPTDUM0(MM)*CONJG(CPTDUM0(MM_))*(WEIGHT1+(0._q,1._q)*WEIGHT2)+ &
+                      CPTDUM1(MM)*CONJG(CPTDUM0(MM_))*WEIGHT0
+                 IF (PRESENT(W0_)) THEN
+                    CDWORK(M,ISP+ISPINOR_+2*ISPINOR)=CDWORK(M,ISP+ISPINOR_+2*ISPINOR)+ &
+                       CPTDUM0_(MM)*CONJG(CPTDUM2(MM_))*WEIGHT0_
+                 ELSE
+                    CDWORK(M,ISP+ISPINOR_+2*ISPINOR)=CDWORK(M,ISP+ISPINOR_+2*ISPINOR)+ &
+                       CPTDUM0(MM)*CONJG(CPTDUM2(MM_))*WEIGHT0
+                 ENDIF
+              ELSE
+                 CDWORK(M,ISP+ISPINOR_+2*ISPINOR)=CDWORK(M,ISP+ISPINOR_+2*ISPINOR)+ &
+                      CPTDUM0(MM)*CONJG(CPTDUM0(MM_))*WEIGHT1+ &
+                      CPTDUM0(MM)*CONJG(CPTDUM1(MM_))*WEIGHT0+ &
+                      CPTDUM1(MM)*CONJG(CPTDUM0(MM_))*WEIGHT0
+              ENDIF
            ENDDO
         ENDDO
         ENDDO spinor
@@ -384,7 +406,8 @@
       ENDDO
 
       DEALLOCATE(CDWORK, CPTDUM0, CPTDUM1)
-
+      IF (PRESENT(W2)) DEALLOCATE(CPTDUM2)
+      IF (PRESENT(W0_)) DEALLOCATE(CPTDUM0_)
       RETURN
       END SUBROUTINE
 
diff -urN file_ini/emlr_broyden.F file_modify/emlr_broyden.F
--- file_ini/emlr_broyden.F	1970-01-01 08:00:00.000000000 +0800
+++ file_modify/emlr_broyden.F	2024-07-13 10:37:23.000000000 +0800
@@ -0,0 +1,3327 @@
+#include "symbol.inc"
+! RCS:  $Id: broyden.F,v 1.3 2002/04/16 07:28:37 kresse Exp $
+#define USE_TMPBROYD
+!
+! you have the option to do the mixing on disc or in storage
+! if USE_TMPBROYD is defined required arrays are stored on disc
+! if it is not defined dynamic arrays are allocated as required
+#undef USE_TMPBROYD
+
+!***********************************************************************
+!
+!  calling interface to BROYD
+!  this routine extracts the chargedensity on the small grid
+!  and calls the broyden-mixing
+!  for wavevectors, which are not contained in the small grid a simple
+!  mixing is used
+! NGX,NGY,NGZ     is the reduced grid on which Broyden mixing is done
+!                 corresponds to NGXB,NGYB,NGZB in main program
+! NGXC,NGYC,NGZC  is the full grid
+!
+!***********************************************************************
+
+   SUBROUTINE EMLR_BRMIX( &
+      GRIDB,GRIDC,IO,MIX,B_TO_C, &
+      NGIGA,CHTOT,CHTOTL,CHTOT2,CHTOTL2,ISPIN,B,OMEGA, &
+      N_MIX_PAW, RHOLM, RHOLM_LAST, &
+      RMST,RMS,RMSP,WEIGHT,LWARN,IERRBR,LQVEC0,LSOFT)
+   USE prec
+   USE broyden
+   USE base
+   USE mpimy
+   USE mgrid
+   USE charge
+   IMPLICIT COMPLEX(q) (C)
+   IMPLICIT REAL(q) (A-B,D-H,O-Z)
+
+   TYPE (grid_3d)     GRIDB
+   TYPE (grid_3d)     GRIDC
+   TYPE (transit)     B_TO_C
+   TYPE (in_struct)   IO
+   TYPE (mixing)      MIX
+
+   COMPLEX(q)   CHTOT(GRIDC%MPLWV,ISPIN),CHTOTL(GRIDC%MPLWV,ISPIN)
+   COMPLEX(q)   CHTOT2(GRIDC%MPLWV,ISPIN),CHTOTL2(GRIDC%MPLWV,ISPIN)
+   INTEGER      N_MIX_PAW
+   REAL(q)   RHOLM(N_MIX_PAW,ISPIN),RHOLM_LAST(N_MIX_PAW,ISPIN)
+   REAL(q)      B(3,3)
+   REAL(q), intent(inout)::RMST 
+   REAL(q) RMST_
+   LOGICAL LWARN
+   LOGICAL LQVEC0
+   LOGICAL LSOFT
+! local variables
+   REAL(q)      OMEGA,FAKT,ISFAKT,SFAKT
+   LOGICAL , SAVE:: LBAD=.FALSE.
+   SAVE IERR
+   DATA IERR /0/
+   INTEGER NDATA,NCHARGE
+   COMPLEX(q),ALLOCATABLE :: CWRK1(:),CWRK2(:),CWRK3(:),CWRK4(:),CHP(:),CWRK5(:)
+   COMPLEX(q) CSUM1,CSUM2,CSUM3
+
+   PROFILING_START('brmix')
+
+   IF (LBAD) THEN
+      MIX%LRESET=.TRUE.
+      LBAD=.FALSE.
+   ENDIF
+   ! number of grid points to be mixed
+   NCHARGE= GRIDB%RC%NP*ISPIN
+   ! double NCHARGE : add CHTOT_AH
+   NCHARGE=2*NCHARGE
+   ! add number of occupancies to be mixed
+   NDATA  = NCHARGE+N_MIX_PAW*ISPIN
+
+   ALLOCATE( CWRK1(MAX(NGIGA,NDATA*2)),CWRK2(NDATA), &
+               CWRK3(NDATA),CWRK4(NDATA),CHP(NDATA),CWRK5(NDATA))
+
+   NODE_ME=0
+   IONODE=0
+#ifdef MPI
+   NODE_ME= GRIDB%COMM%NODE_ME
+   IONODE = GRIDB%COMM%IONODE
+#endif
+   IDUMP=0     ! set to 1 on serial computers for add. inform.
+   io_begin
+   IDUMP=0     ! set to 1 on parallel computers
+   io_end
+
+   NUPDZ=-NGIGA/(MAX(NDATA,1))
+
+   CALLMPI ( M_max_i( GRIDB%COMM, NUPDZ ,1)) ! global minimum ;-)
+   NUPDZ=-NUPDZ
+   io_begin
+   WRITE(*,*) 'NUPDZ',NUPDZ
+   io_end
+!      IF (NDATA > GRIDC%MPLWV) THEN
+!         WRITE(*,*) 'Fatal error BRMIX: Insufficient workspace ...'
+!         STOP
+!      ENDIF
+
+   FAKT=1._q/OMEGA
+
+   IF (LQVEC0) THEN
+      TOTNEL=RHO0(GRIDC,CHTOT (1,1))
+      TOTOLD=RHO0(GRIDC,CHTOTL(1,1))
+      TOTNEL2=RHO0(GRIDC,CHTOT2 (1,1))
+      TOTOLD2=RHO0(GRIDC,CHTOTL2(1,1))
+   ENDIF
+
+! Set CHP (contains the metric to be used later):
+   MIXPMA=MIX%MIXPRE
+   IF (MIXPMA>=10) MIXPMA=MIXPMA-10
+! charge density metric
+   CALL BRPRE(GRIDB,CHP,B,MIXPMA,MIX%BMIX,MIX%LRESET.AND.(IDUMP/=0))
+
+! magnetisation density metric
+   MIXPMA=MIX%MIXPRE
+   ! special treatment for potential mixing (MIXPMA>10, e.g. OEP): 
+   ! in this case  both channels are treated in the same manner
+   IF (MIXPMA>=10) THEN
+      MIXPMA=MIXPMA-10
+   ELSE
+      MIXPMA=0._q
+   ENDIF
+   DO ISP=2,ISPIN
+      CALL BRPRE(GRIDB,CHP(GRIDB%RC%NP*(ISP-1)+1),B,MIXPMA,MIX%BMIX,MIX%LRESET.AND.(IDUMP/=0))
+   ENDDO
+
+! kinetic energy density metric
+   CHP(NCHARGE/2+1:NCHARGE)=CHP(1:NCHARGE/2)
+
+! Copy CHTOT to CWRK3 and CHTOTL to CWRK4 - reduction to a smaller mesh:
+
+   NP=NCHARGE
+
+   DO ISP=1,ISPIN
+      ! copy charge and magnetization
+      CALL CP_GRID(GRIDC,GRIDB,B_TO_C,CHTOT(1,ISP), CWRK3(GRIDB%RC%NP*(ISP-1)+1))
+      CALL CP_GRID(GRIDC,GRIDB,B_TO_C,CHTOTL(1,ISP),CWRK4(GRIDB%RC%NP*(ISP-1)+1))
+      ! copy kinetic energy density
+      CALL CP_GRID(GRIDC,GRIDB,B_TO_C,CHTOT2(1,ISP), CWRK3(GRIDB%RC%NP*(ISP-1+ISPIN)+1))
+      CALL CP_GRID(GRIDC,GRIDB,B_TO_C,CHTOTL2(1,ISP),CWRK4(GRIDB%RC%NP*(ISP-1+ISPIN)+1))
+      ! one center occupancy matrix
+      CWRK3(NP+1:NP+N_MIX_PAW)  =RHOLM(:,ISP)-RHOLM_LAST(:,ISP)
+      CWRK4(NP+1:NP+N_MIX_PAW)  =RHOLM_LAST(:,ISP)
+      IF(MIX%IMIX==6) THEN
+         CHP  (NP+1:NP+N_MIX_PAW)  =(RHOLM(:,ISP)-RHOLM_LAST(:,ISP))
+      ELSE
+         CHP  (NP+1:NP+N_MIX_PAW)  =(RHOLM(:,ISP)-RHOLM_LAST(:,ISP))*10
+      ENDIF 
+      NP=NP+N_MIX_PAW
+   ENDDO
+
+   IF (NP /= NDATA) THEN
+      WRITE(*,*) 'internal error 1 in BRMIX',NP,NDATA ; STOP
+   ENDIF
+
+! straight mixing for components which are not mixed by the Pulay mixer
+   AMIX0=0.8_q
+   BMIX0=0.001_q
+   CALL SETG0(GRIDC,CWRK1,B,MIX%INIMIX,AMIX0,BMIX0,MIX%AMIN,.FALSE.)
+   RMST_=0._q
+!-----------------------------------------------------------------------
+! calculation of norm of residual on full grid !
+! and mix all components
+!-----------------------------------------------------------------------
+   DO ISP=1,ISPIN
+      ! charge density
+      DO I=1,GRIDC%RC%NP
+         N1= MOD((I-1),GRIDC%RC%NROW) +1
+         NC= (I-1)/GRIDC%RC%NROW+1
+         N2= GRIDC%RC%I2(NC)
+         N3= GRIDC%RC%I3(NC)
+         SETFACT1
+         SETFACT
+         RMST_=RMST_+FAKT*MULFACT CONJG(CHTOT(I,ISP)-CHTOTL(I,ISP))* &
+   &           (CHTOT(I,ISP)-CHTOTL(I,ISP))
+         RMST_=RMST_+FAKT*MULFACT CONJG(CHTOT2(I,ISP)-CHTOTL2(I,ISP))* &
+   &           (CHTOT2(I,ISP)-CHTOTL2(I,ISP))
+
+         ! ALPHA=CWRK1(I)
+         ! CHTOT(I,ISP)=(1._q-ALPHA)*CHTOTL(I,ISP)+ALPHA*CHTOT(I,ISP)
+         ! CHTOT2(I,ISP)=(1._q-ALPHA)*CHTOTL2(I,ISP)+ALPHA*CHTOT2(I,ISP)
+      ENDDO
+      ! one center terms
+      DO I=1,N_MIX_PAW
+         DEL =(RHOLM(I,ISP)-RHOLM_LAST(I,ISP))
+         RMST_=RMST_+DEL*DEL
+      ENDDO
+   ENDDO
+
+   CALLMPI( M_sum_d(GRIDC%COMM, RMST_, 1))
+   RMST_=SQRT(RMST_)
+   IF (ABS(RMST_)>ABS(RMST)*10) THEN 
+         CWRK1=1 ! ALPHA -> 1
+         LBAD=.TRUE.
+         MIX%IMIX=4 ! switch to more conservative algorithm.
+   ENDIF
+   RMST=RMST_
+
+   DO ISP=1,ISPIN
+      ! charge density
+      DO I=1,GRIDC%RC%NP
+         ALPHA=CWRK1(I)
+         CHTOT(I,ISP)=(1._q-ALPHA)*CHTOTL(I,ISP)+ALPHA*CHTOT(I,ISP)
+         CHTOT2(I,ISP)=(1._q-ALPHA)*CHTOTL2(I,ISP)+ALPHA*CHTOT2(I,ISP)
+      ENDDO
+   ENDDO
+!-----------------------------------------------------------------------
+! residual vector on reduced grid (i.e. difference CHTOT-CHTOTL)
+! store in CWRK3, CHP is set to metric * CWRK3
+!-----------------------------------------------------------------------
+   SFAKT=SQRT(FAKT)
+   DO ISP=1,ISPIN
+      ! charge density
+!DIR$ IVDEP
+!OCL NOVREC
+      DO I=1,GRIDB%RC%NP
+         IP= I+(ISP-1)*GRIDB%RC%NP
+         N1= MOD((I-1),GRIDB%RC%NROW) +1
+         NC= (I-1)/GRIDB%RC%NROW+1
+         N2= GRIDB%RC%I2(NC)
+         N3= GRIDB%RC%I3(NC)
+         SETFACT1
+         SETSQRT
+         CWRK3(IP)=MULFACT (CWRK3(IP)-CWRK4(IP))*SFAKT
+         CWRK4(IP)=MULFACT  CWRK4(IP)*SFAKT
+
+         IP= I+(ISP-1+ISPIN)*GRIDB%RC%NP
+         CWRK3(IP)=MULFACT (CWRK3(IP)-CWRK4(IP))*SFAKT
+         CWRK4(IP)=MULFACT  CWRK4(IP)*SFAKT
+      ENDDO
+   ENDDO
+
+   ! Do not mix the G=0 component here ...
+   IF (LQVEC0) THEN
+      CALL SET_RHO0(GRIDB, CWRK3(1), 0._q)
+      CALL SET_RHO0(GRIDB, CWRK3(NCHARGE/2+1), 0._q)
+   ENDIF
+
+   ! set CHP = metric * (CHTOT-CHTOTL):
+   ! charge and magnetization
+   DO I=1,2*GRIDB%RC%NP*ISPIN
+      CHP(I)=CWRK3(I)*CHP(I)
+   ENDDO
+   IF (LBAD) GOTO 2000
+!-----------------------------------------------------------------------
+! Start mixing (given as input to BROYD on array CWRK1 if reset ...):
+!-----------------------------------------------------------------------
+   IF (MIX%LRESET) THEN
+      ! set initial step or mixing for charge
+      CALL SETG0(GRIDB,CWRK1,B,MIX%INIMIX,MIX%AMIX,MIX%BMIX,MIX%AMIN,(IDUMP/=0))
+      NP=NCHARGE
+      ! one center terms
+      CWRK1 (NP+1:NP+N_MIX_PAW)= MIN(MIX%AMIX,0.5_q)
+      NP=NP+N_MIX_PAW
+
+      ! set initial step for magnetization
+      INIMA=MIX%INIMIX
+      DO ISP=2,ISPIN
+         CALL SETG0(GRIDB,CWRK1(GRIDB%RC%NP*(ISP-1)+1),B,INIMA,MIX%AMIX_MAG,MIX%BMIX_MAG,MIX%AMIN,(IDUMP/=0))
+         ! one center terms
+         CWRK1(NP+1:NP+N_MIX_PAW)  = MIN(MIX%AMIX_MAG,2.0_q)
+         NP=NP+N_MIX_PAW
+      ENDDO
+
+      ! set initial step for kinetic energy density
+      CWRK1(NCHARGE/2+1:NCHARGE)=CWRK1(1:NCHARGE/2)
+
+      IF (NP /= NDATA) THEN
+         WRITE(*,*) 'internal error 2 in BRMIX',NP,NDATA ; STOP
+      ENDIF
+   ENDIF
+! Broyden mixing:
+   IB=0
+   IF (MIX%WC==0._q) IB=1
+   IF (IERR/=0) MIX%LRESET=.TRUE.
+   IERR=0
+   IF (.NOT. LSOFT) THEN 
+      IF (MIX%IMIX==4) THEN 
+      CALL BROYD_1(NDATA,CWRK3,CWRK4,CHP,MIX%WC,IB,NUPDZ, &
+               IABS(MIX%MAXMIX),MIX%MAXMIX>0 .AND. .NOT. MIX%HARD_RESET,MIX%MREMOVE,B,MAX(NGIGA,NDATA*2), &
+               CWRK1,CWRK2,MIX%LRESET,MIX%IUBROY,IO%LOPEN,IO%ICMPLX,IO%MRECL, &
+               RMS,RMSP,WEIGHT,MIX%NEIG,MIX%EIGENVAL,MIX%AMEAN,IERR,1.0_q &
+#ifdef MPI
+               ,GRIDC%COMM &
+#endif
+               )
+      ELSE IF(MIX%IMIX==5) THEN 
+      CALL BROYD_1(NDATA,CWRK3,CWRK4,CHP,MIX%WC,IB,NUPDZ, &
+            IABS(MIX%MAXMIX),MIX%MAXMIX>0 .AND. .NOT. MIX%HARD_RESET,MIX%MREMOVE,B,MAX(NGIGA,NDATA*2), &
+            CWRK1,CWRK2,MIX%LRESET,MIX%IUBROY,IO%LOPEN,IO%ICMPLX,IO%MRECL, &
+            RMS,RMSP,WEIGHT,MIX%NEIG,MIX%EIGENVAL,MIX%AMEAN,IERR,0.01_q &
+#ifdef MPI
+               ,GRIDC%COMM &
+#endif
+         )
+      ELSE IF(MIX%IMIX==6) THEN 
+      CALL BROYD_1(NDATA,CWRK3,CWRK4,CHP,MIX%WC,IB,NUPDZ, &
+            IABS(MIX%MAXMIX),MIX%MAXMIX>0 .AND. .NOT. MIX%HARD_RESET,MIX%MREMOVE,B,MAX(NGIGA,NDATA*2), &
+            CWRK1,CWRK2,MIX%LRESET,MIX%IUBROY,IO%LOPEN,IO%ICMPLX,IO%MRECL, &
+            RMS,RMSP,WEIGHT,MIX%NEIG,MIX%EIGENVAL,MIX%AMEAN,IERR,1.0_q &
+#ifdef MPI
+            ,GRIDC%COMM &
+#endif
+            )
+
+      ELSE IF(MIX%IMIX==7) THEN 
+      CALL MSR1(NDATA,CWRK3,CWRK4,CHP,MIX%WC,IB,NUPDZ, &
+            IABS(MIX%MAXMIX),MIX%MAXMIX>0 .AND. .NOT. MIX%HARD_RESET,MIX%MREMOVE,B,MAX(NGIGA,NDATA*2), &
+            CWRK1,CWRK2,MIX%LRESET,MIX%IUBROY,IO%LOPEN,IO%ICMPLX,IO%MRECL, &
+            RMS,RMSP,WEIGHT,MIX%NEIG,MIX%EIGENVAL,MIX%AMEAN,IERR &
+#ifdef MPI
+      ,GRIDC%COMM &
+#endif
+         )
+      ENDIF
+
+   ELSE
+
+   CALL MLS1(NDATA,CWRK3,CWRK4,CHP,MIX%WC,IB,NUPDZ, &
+               IABS(MIX%MAXMIX),.NOT. MIX%HARD_RESET,MIX%MREMOVE,B,MAX(NGIGA,NDATA*2), &
+               CWRK1,CWRK2,MIX%LRESET,MIX%IUBROY,IO%LOPEN,IO%ICMPLX,IO%MRECL, &
+               RMS,RMSP,WEIGHT,MIX%NEIG,MIX%EIGENVAL,MIX%AMEAN,IERR &
+#ifdef MPI
+               ,GRIDC%COMM &
+#endif
+               )
+   ENDIF
+
+2000  CONTINUE
+   IF (MIX%LRESET) MIX%HARD_RESET=.FALSE.
+
+   DWRITE0 'rms are',RMS,RMSP,RMST
+
+! Hmmm ... . Disk was full? Invalid/corrupted file TMPBROYD? Or???
+   IF (IERR/=0) THEN
+! 'last chance': get some disk space and reset mixing at next step:
+#ifdef USE_TMPBROYD
+      CALL CLEAN(MIX%IUBROY)
+#endif
+! we can not only do 'simple mixing' here (take initial mixing ...):
+! this has been done 'on entry' --- just forget the following update!
+      GOTO 50
+   ENDIF
+!-----------------------------------------------------------------------
+! now CWRK4 (representing the image of CHTOTL) containes the mixed
+! density - expand to the larger grid and update CHTOT ... :
+!-----------------------------------------------------------------------
+   ISFAKT=1._q/SFAKT
+   SUM_=0
+   NP=NCHARGE
+
+   DO ISP=1,ISPIN
+      ! charge density
+!DIR$ IVDEP
+!OCL NOVREC
+      DO I=1,GRIDB%RC%NP
+         IP= I+(ISP-1)*GRIDB%RC%NP
+         N1= MOD((I-1),GRIDB%RC%NROW) +1
+         NC= (I-1)/GRIDB%RC%NROW+1
+         N2= GRIDB%RC%I2(NC)
+         N3= GRIDB%RC%I3(NC)
+
+         SETFACT1
+         SETISQRT
+         CWRK4(IP)= MULFACT CWRK4(IP)*ISFAKT
+         SUM_=SUM_+CWRK4(IP)*CONJG(CWRK4(IP))
+
+         IP= I+(ISP-1+ISPIN)*GRIDB%RC%NP
+         CWRK4(IP)= MULFACT CWRK4(IP)*ISFAKT
+         SUM_=SUM_+CWRK4(IP)*CONJG(CWRK4(IP))
+      ENDDO
+      CALL CPB_GRID(GRIDC,GRIDB,B_TO_C,CWRK4(GRIDB%RC%NP*(ISP-1)+1),CHTOT(1,ISP))
+      CALL CPB_GRID(GRIDC,GRIDB,B_TO_C,CWRK4(GRIDB%RC%NP*(ISP-1+ISPIN)+1),CHTOT2(1,ISP))
+
+      ! one center terms
+      RHOLM(:,ISP) = CWRK4(NP+1:NP+N_MIX_PAW)
+      NP=NP+N_MIX_PAW
+   ENDDO
+
+   IF (NP /= NDATA) THEN
+      WRITE(*,*) 'internal error 3 in BRMIX',NP,NDATA ; STOP
+   ENDIF
+
+   CALLMPI( M_sum_d(GRIDC%COMM, SUM_, 1))
+   DWRITE0 'summed soft charge is',SUM_
+
+! Check whether charge density changed
+   IF (LQVEC0) THEN
+      io_begin
+      IF (ABS(TOTNEL-TOTOLD)>1E-5_q*ABS(TOTNEL) .AND. LWARN) WRITE(*,11) TOTOLD,TOTNEL
+      IF (ABS(TOTNEL2-TOTOLD2)>1E-5_q*ABS(TOTNEL2) .AND. LWARN) WRITE(*,11) TOTOLD2,TOTNEL2
+11 FORMAT('BRMIX: very serious problems',/ &
+            ' the old and the new charge density differ',/ &
+            ' old charge density: ',F11.5,' new',F11.5)
+      io_end
+      CALL SET_RHO0(GRIDC, CHTOT(1,1), TOTNEL)
+      CALL SET_RHO0(GRIDC, CHTOT2(1,1), TOTNEL2)
+   ENDIF
+
+! copy CHTOT to CHTOTL
+50 IERRBR=IERR
+! We average CHTOT over the KPAR (possibly slighty) different instances ... first the summation
+   CALLMPI( M_bcast_z(GRIDC%COMM_KINTER,CHTOT(1,1),SIZE(CHTOT)))
+   CALLMPI( M_bcast_z(GRIDC%COMM_KINTER,CHTOT2(1,1),SIZE(CHTOT2)))
+
+   DO ISP=1,ISPIN
+      CALL FFT3D(CHTOT(1,ISP),GRIDC,1)
+      CALL FFT3D(CHTOT2(1,ISP),GRIDC,1)
+      CHTOT(1:GRIDC%RL%NP,ISP)=REAL(CHTOT(1:GRIDC%RL%NP,ISP),kind=q)
+      CHTOT2(1:GRIDC%RL%NP,ISP)=REAL(CHTOT2(1:GRIDC%RL%NP,ISP),kind=q)
+      CALL FFT_RC_SCALE(CHTOT(1,ISP),CHTOT(1,ISP),GRIDC)
+      CALL FFT_RC_SCALE(CHTOT2(1,ISP),CHTOT2(1,ISP),GRIDC)
+   ENDDO
+
+   SUM_=0
+   DO ISP=1,ISPIN
+      DO I=1,GRIDC%RC%NP
+         ! CHTOTL(I,ISP)=CHTOT(I,ISP)
+         SUM_=SUM_+CHTOT(I,ISP)*CONJG(CHTOT(I,ISP))
+
+         ! CHTOTL2(I,ISP)=CHTOT2(I,ISP)
+         SUM_=SUM_+CHTOT2(I,ISP)*CONJG(CHTOT2(I,ISP))
+      ENDDO
+   ENDDO
+! copy occupancies
+#ifdef MPI
+   CALL M_bcast_d(GRIDC%COMM_KINTER,RHOLM(1,1),SIZE(RHOLM))
+#endif 
+   ! RHOLM_LAST=RHOLM
+
+   CALLMPI( M_sum_d(GRIDC%COMM, SUM_, 1))
+   DWRITE0 'summed charge is',SUM_
+
+   DEALLOCATE(CWRK1,CWRK2,CWRK3,CWRK4,CHP,CWRK5)
+
+   PROFILING_STOP('brmix')
+
+   RETURN
+   END SUBROUTINE
+
+! EMLR_BRMIX for complex density
+   SUBROUTINE EMLR_CBRMIX( &
+      GRIDB,GRIDC,IO,MIX,B_TO_C, &
+      NGIGA,CHTOT_H,CHTOTL_H,CHTOT_AH,CHTOTL_AH,ISPIN,B,OMEGA, &
+      TN_MIX_PAW, RHOLM_HAH, RHOLM_LAST_HAH, &
+      RMST,RMS,RMSP,WEIGHT,LWARN,IERRBR,LQVEC0)
+   USE prec
+   USE broyden
+   USE base
+   USE mpimy
+   USE mgrid
+   USE charge
+   IMPLICIT COMPLEX(q) (C)
+   IMPLICIT REAL(q) (A-B,D-H,O-Z)
+
+   TYPE (grid_3d)     GRIDB
+   TYPE (grid_3d)     GRIDC
+   TYPE (transit)     B_TO_C
+   TYPE (in_struct)   IO
+   TYPE (mixing)      MIX
+   COMPLEX(q)   CHTOT_H(GRIDC%MPLWV,ISPIN),CHTOTL_H(GRIDC%MPLWV,ISPIN)
+   COMPLEX(q)   CHTOT_AH(GRIDC%MPLWV,ISPIN),CHTOTL_AH(GRIDC%MPLWV,ISPIN)
+   INTEGER      TN_MIX_PAW,N_MIX_PAW
+   REAL(q)   RHOLM_HAH(TN_MIX_PAW,ISPIN),RHOLM_LAST_HAH(TN_MIX_PAW,ISPIN)
+
+   COMPLEX(q)   CHTOT(GRIDC%MPLWV,ISPIN),CHTOTL(GRIDC%MPLWV,ISPIN)
+   COMPLEX(q)   RHOLM(TN_MIX_PAW/2,ISPIN),RHOLM_LAST(TN_MIX_PAW/2,ISPIN)
+   REAL(q)      B(3,3)
+   LOGICAL LWARN
+   LOGICAL LQVEC0
+! local variables
+   REAL(q)      OMEGA,FAKT,ISFAKT,SFAKT
+   SAVE IERR
+   DATA IERR /0/
+   INTEGER NDATA,NCHARGE
+   COMPLEX(q),ALLOCATABLE :: CWRK1(:),CWRK2(:),CWRK3(:),CWRK4(:),CHP(:)
+
+   PROFILING_START('brmix')
+   ! initialize complex density
+   N_MIX_PAW=TN_MIX_PAW/2
+   DO ISP=1,ISPIN
+      CALL FFT3D(CHTOT_H(1,ISP),GRIDC,1)
+      CALL FFT3D(CHTOT_AH(1,ISP),GRIDC,1)
+      CHTOT(1:GRIDC%RL%NP,ISP) = REAL(CHTOT_H(1:GRIDC%RL%NP,ISP))+(0._q,1._q)*REAL(CHTOT_AH(1:GRIDC%RL%NP,ISP))
+      CALL FFT_RC_SCALE(CHTOT(1,ISP),CHTOT(1,ISP),GRIDC)
+   ENDDO
+   ! CHTOT = CHTOT_H+(0._q,1._q)*CHTOT_AH
+   CHTOTL = CHTOTL_H+(0._q,1._q)*CHTOTL_AH
+   RHOLM = RHOLM_HAH(1:N_MIX_PAW,:)+(0._q,1._q)*RHOLM_HAH(N_MIX_PAW+1:2*N_MIX_PAW,:)
+   RHOLM_LAST = RHOLM_LAST_HAH(1:N_MIX_PAW,:)+(0._q,1._q)*RHOLM_LAST_HAH(N_MIX_PAW+1:2*N_MIX_PAW,:)
+
+   ! number of grid points to be mixed
+   NCHARGE= GRIDB%RC%NP*ISPIN
+   ! add number of occupancies to be mixed
+   NDATA  = NCHARGE+N_MIX_PAW*ISPIN
+
+   ALLOCATE( CWRK1(MAX(NGIGA,NDATA*2)),CWRK2(NDATA), &
+               CWRK3(NDATA),CWRK4(NDATA),CHP(NDATA))
+
+   NODE_ME=0
+   IONODE=0
+#ifdef MPI
+   NODE_ME= GRIDB%COMM%NODE_ME
+   IONODE = GRIDB%COMM%IONODE
+#endif
+   IDUMP=0     ! set to 1 on serial computers for add. inform.
+   io_begin
+   IDUMP=0     ! set to 1 on parallel computers
+   io_end
+
+   NUPDZ=-NGIGA/(MAX(NDATA,1))
+
+   CALLMPI ( M_max_i( GRIDB%COMM, NUPDZ ,1)) ! global minimum ;-)
+   NUPDZ=-NUPDZ
+
+!      IF (NDATA > GRIDC%MPLWV) THEN
+!         WRITE(*,*) 'Fatal error BRMIX: Insufficient workspace ...'
+!         STOP
+!      ENDIF
+
+   FAKT=1._q/OMEGA
+
+   IF (LQVEC0) THEN
+      TOTNEL_H=RHO0(GRIDC,CHTOT_H (1,1))
+      TOTOLD_H=RHO0(GRIDC,CHTOTL_H(1,1))
+      TOTNEL_AH=RHO0(GRIDC,CHTOT_AH (1,1))
+      TOTOLD_AH=RHO0(GRIDC,CHTOTL_AH(1,1))
+   ENDIF
+! Set CHP (contains the metric to be used later):
+   MIXPMA=MIX%MIXPRE
+   IF (MIXPMA>=10) MIXPMA=MIXPMA-10
+! charge density metric
+   CALL BRPRE(GRIDB,CHP,B,MIXPMA,MIX%BMIX,MIX%LRESET.AND.(IDUMP/=0))
+
+! magnetisation density metric
+   MIXPMA=MIX%MIXPRE
+   ! special treatment for potential mixing (MIXPMA>10, e.g. OEP): 
+   ! in this case  both channels are treated in the same manner
+   IF (MIXPMA>=10) THEN
+      MIXPMA=MIXPMA-10
+   ELSE
+      MIXPMA=0._q
+   ENDIF
+   DO ISP=2,ISPIN
+      CALL BRPRE(GRIDB,CHP(GRIDB%RC%NP*(ISP-1)+1),B,MIXPMA,MIX%BMIX,MIX%LRESET.AND.(IDUMP/=0))
+   ENDDO
+
+! Copy CHTOT to CWRK3 and CHTOTL to CWRK4 - reduction to a smaller mesh:
+
+   NP=NCHARGE
+
+   DO ISP=1,ISPIN
+      ! copy charge and magnetization
+      CALL CP_GRID(GRIDC,GRIDB,B_TO_C,CHTOT(1,ISP), CWRK3(GRIDB%RC%NP*(ISP-1)+1))
+      CALL CP_GRID(GRIDC,GRIDB,B_TO_C,CHTOTL(1,ISP),CWRK4(GRIDB%RC%NP*(ISP-1)+1))
+      ! one center occupancy matrix
+      CWRK3(NP+1:NP+N_MIX_PAW)  =RHOLM(:,ISP)-RHOLM_LAST(:,ISP)
+      CWRK4(NP+1:NP+N_MIX_PAW)  =RHOLM_LAST(:,ISP)
+      CHP  (NP+1:NP+N_MIX_PAW)  =(RHOLM(:,ISP)-RHOLM_LAST(:,ISP))*10
+      NP=NP+N_MIX_PAW
+   ENDDO
+
+   IF (NP /= NDATA) THEN
+      WRITE(*,*) 'internal error 1 in BRMIX',NP,NDATA ; STOP
+   ENDIF
+
+! straight mixing for components which are not mixed by the Pulay mixer
+   AMIX0=0.8_q
+   BMIX0=0.001_q
+   CALL SETG0(GRIDC,CWRK1,B,MIX%INIMIX,AMIX0,BMIX0,MIX%AMIN,.FALSE.)
+   RMST=0._q
+!-----------------------------------------------------------------------
+! calculation of norm of residual on full grid !
+! and mix all components
+!-----------------------------------------------------------------------
+   DO ISP=1,ISPIN
+      ! charge density
+      DO I=1,GRIDC%RC%NP
+         N1= MOD((I-1),GRIDC%RC%NROW) +1
+         NC= (I-1)/GRIDC%RC%NROW+1
+         N2= GRIDC%RC%I2(NC)
+         N3= GRIDC%RC%I3(NC)
+         SETFACT1
+         SETFACT
+         RMST=RMST+FAKT*MULFACT CONJG(CHTOT(I,ISP)-CHTOTL(I,ISP))* &
+   &           (CHTOT(I,ISP)-CHTOTL(I,ISP))
+
+         ALPHA=CWRK1(I)
+         CHTOT(I,ISP)=(1._q-ALPHA)*CHTOTL(I,ISP)+ALPHA*CHTOT(I,ISP)
+      ENDDO
+      ! one center terms
+      DO I=1,N_MIX_PAW
+         CDEL =(RHOLM(I,ISP)-RHOLM_LAST(I,ISP))
+         RMST=RMST+CONJG(CDEL)*CDEL
+      ENDDO
+   ENDDO
+
+   CALLMPI( M_sum_d(GRIDC%COMM, RMST, 1))
+   RMST=SQRT(RMST)
+!-----------------------------------------------------------------------
+! residual vector on reduced grid (i.e. difference CHTOT-CHTOTL)
+! store in CWRK3, CHP is set to metric * CWRK3
+!-----------------------------------------------------------------------
+   SFAKT=SQRT(FAKT)
+   DO ISP=1,ISPIN
+      ! charge density
+!DIR$ IVDEP
+!OCL NOVREC
+      DO I=1,GRIDB%RC%NP
+         IP= I+(ISP-1)*GRIDB%RC%NP
+         N1= MOD((I-1),GRIDB%RC%NROW) +1
+         NC= (I-1)/GRIDB%RC%NROW+1
+         N2= GRIDB%RC%I2(NC)
+         N3= GRIDB%RC%I3(NC)
+         SETFACT1
+         SETSQRT
+         CWRK3(IP)=MULFACT (CWRK3(IP)-CWRK4(IP))*SFAKT
+         CWRK4(IP)=MULFACT  CWRK4(IP)*SFAKT
+
+      ENDDO
+   ENDDO
+
+   ! Do not mix the G=0 component here ...
+   IF (LQVEC0) THEN
+      CALL SET_RHO0(GRIDB, CWRK3(1), 0._q)
+   ENDIF
+
+   ! set CHP = metric * (CHTOT-CHTOTL):
+   ! charge and magnetization
+   DO I=1,GRIDB%RC%NP*ISPIN
+      CHP(I)=CWRK3(I)*CHP(I)
+   ENDDO
+
+!-----------------------------------------------------------------------
+! Start mixing (given as input to BROYD on array CWRK1 if reset ...):
+!-----------------------------------------------------------------------
+   IF (MIX%LRESET) THEN
+      ! set initial step or mixing for charge
+      CALL SETG0(GRIDB,CWRK1,B,MIX%INIMIX,MIX%AMIX,MIX%BMIX,MIX%AMIN,(IDUMP/=0))
+      NP=NCHARGE
+      ! one center terms
+      CWRK1 (NP+1:NP+N_MIX_PAW)= MIN(MIX%AMIX,0.5_q)
+      NP=NP+N_MIX_PAW
+
+      ! set initial step for magnetization
+      INIMA=MIX%INIMIX
+      DO ISP=2,ISPIN
+         CALL SETG0(GRIDB,CWRK1(GRIDB%RC%NP*(ISP-1)+1),B,INIMA,MIX%AMIX_MAG,MIX%BMIX_MAG,MIX%AMIN,(IDUMP/=0))
+         ! one center terms
+         CWRK1(NP+1:NP+N_MIX_PAW)  = MIN(MIX%AMIX_MAG,2.0_q)
+         NP=NP+N_MIX_PAW
+      ENDDO
+
+      IF (NP /= NDATA) THEN
+         WRITE(*,*) 'internal error 2 in BRMIX',NP,NDATA ; STOP
+      ENDIF
+   ENDIF
+! Broyden mixing:
+   IB=0
+   IF (MIX%WC==0._q) IB=1
+   IF (IERR/=0) MIX%LRESET=.TRUE.
+   IERR=0
+   CALL MSR1(NDATA,CWRK3,CWRK4,CHP,MIX%WC,IB,NUPDZ, &
+               IABS(MIX%MAXMIX),MIX%MAXMIX>0 .AND. .NOT. MIX%HARD_RESET,MIX%MREMOVE,B,MAX(NGIGA,NDATA*2), &
+               CWRK1,CWRK2,MIX%LRESET,MIX%IUBROY,IO%LOPEN,IO%ICMPLX,IO%MRECL, &
+               RMS,RMSP,WEIGHT,MIX%NEIG,MIX%EIGENVAL,MIX%AMEAN,IERR &
+#ifdef MPI
+               ,GRIDC%COMM &
+#endif
+               )
+   IF (MIX%LRESET) MIX%HARD_RESET=.FALSE.
+   DWRITE0 'rms are',RMS,RMSP,RMST
+
+! Hmmm ... . Disk was full? Invalid/corrupted file TMPBROYD? Or???
+   IF (IERR/=0) THEN
+! 'last chance': get some disk space and reset mixing at next step:
+#ifdef USE_TMPBROYD
+      CALL CLEAN(MIX%IUBROY)
+#endif
+! we can not only do 'simple mixing' here (take initial mixing ...):
+! this has been done 'on entry' --- just forget the following update!
+      GOTO 50
+   ENDIF
+!-----------------------------------------------------------------------
+! now CWRK4 (representing the image of CHTOTL) containes the mixed
+! density - expand to the larger grid and update CHTOT ... :
+!-----------------------------------------------------------------------
+   ISFAKT=1._q/SFAKT
+   SUM_=0
+   NP=NCHARGE
+
+   DO ISP=1,ISPIN
+      ! charge density
+!DIR$ IVDEP
+!OCL NOVREC
+      DO I=1,GRIDB%RC%NP
+         IP= I+(ISP-1)*GRIDB%RC%NP
+         N1= MOD((I-1),GRIDB%RC%NROW) +1
+         NC= (I-1)/GRIDB%RC%NROW+1
+         N2= GRIDB%RC%I2(NC)
+         N3= GRIDB%RC%I3(NC)
+
+         SETFACT1
+         SETISQRT
+         CWRK4(IP)= MULFACT CWRK4(IP)*ISFAKT
+         SUM_=SUM_+CWRK4(IP)*CONJG(CWRK4(IP))
+      ENDDO
+      CALL CPB_GRID(GRIDC,GRIDB,B_TO_C,CWRK4(GRIDB%RC%NP*(ISP-1)+1),CHTOT(1,ISP))
+
+      ! one center terms
+      RHOLM(:,ISP) = CWRK4(NP+1:NP+N_MIX_PAW)
+      NP=NP+N_MIX_PAW
+   ENDDO
+
+   IF (NP /= NDATA) THEN
+      WRITE(*,*) 'internal error 3 in BRMIX',NP,NDATA ; STOP
+   ENDIF
+
+   CALLMPI( M_sum_d(GRIDC%COMM, SUM_, 1))
+   DWRITE0 'summed soft charge is',SUM_
+
+! copy CHTOT to CHTOTL
+50 IERRBR=IERR
+
+
+! We average CHTOT over the KPAR (possibly slighty) different instances ... first the summation
+   CALLMPI( M_bcast_z(GRIDC%COMM_KINTER,CHTOT(1,1),SIZE(CHTOT)))
+   DO ISP=1,ISPIN
+      CALL FFT3D(CHTOT(1,ISP),GRIDC,1)
+      CHTOT_H(1:GRIDC%RL%NP,ISP) = REAL(CHTOT(1:GRIDC%RL%NP,ISP))
+      CHTOT_AH(1:GRIDC%RL%NP,ISP) = AIMAG(CHTOT(1:GRIDC%RL%NP,ISP))
+      CALL FFT_RC_SCALE(CHTOT_H(1,ISP),CHTOT_H(1,ISP),GRIDC)
+      CALL FFT_RC_SCALE(CHTOT_AH(1,ISP),CHTOT_AH(1,ISP),GRIDC)
+   ENDDO
+! Check whether charge density changed
+   IF (LQVEC0) THEN
+      io_begin
+      IF (ABS(TOTNEL_H-TOTOLD_H)>1E-5_q*ABS(TOTNEL_H) .AND. LWARN) WRITE(*,11) TOTOLD_H,TOTNEL_H
+      IF (ABS(TOTNEL_AH-TOTOLD_AH)>1E-5_q*ABS(TOTNEL_AH) .AND. LWARN) WRITE(*,11) TOTOLD_AH,TOTNEL_AH
+11 FORMAT('BRMIX: very serious problems',/ &
+            ' the old and the new charge density differ',/ &
+            ' old charge density: ',F11.5,' new',F11.5)
+      io_end
+      CALL SET_RHO0(GRIDC, CHTOT_H(1,1), TOTNEL_H)
+      CALL SET_RHO0(GRIDC, CHTOT_AH(1,1), TOTNEL_AH)
+   ENDIF
+   SUM_=0
+   DO ISP=1,ISPIN
+      DO I=1,GRIDC%RC%NP
+         ! CHTOTL_H(I,ISP)=CHTOT_H(I,ISP)
+         SUM_=SUM_+CHTOT_H(I,ISP)*CONJG(CHTOT_H(I,ISP))
+         ! CHTOTL_AH(I,ISP)=CHTOT_AH(I,ISP)
+         SUM_=SUM_+CHTOT_AH(I,ISP)*CONJG(CHTOT_AH(I,ISP))
+      ENDDO
+   ENDDO
+! copy occupancies
+#ifdef MPI
+   CALL M_bcast_z(GRIDC%COMM_KINTER,RHOLM(1,1),SIZE(RHOLM))
+#endif 
+   RHOLM_HAH(1:N_MIX_PAW,:)=REAL(RHOLM)
+   RHOLM_HAH(N_MIX_PAW+1:2*N_MIX_PAW,:)=AIMAG(RHOLM)
+   ! RHOLM_LAST_HAH=RHOLM_HAH
+   CALLMPI( M_sum_d(GRIDC%COMM, SUM_, 1))
+   DWRITE0 'summed charge is',SUM_
+
+   DEALLOCATE(CWRK1,CWRK2,CWRK3,CWRK4,CHP)
+
+   PROFILING_STOP('brmix')
+   RETURN
+   END SUBROUTINE
+   
+!***********************************************************************
+!
+! Find the zero of a function vector F(X) of a vector X using the
+! second form of the modified Broyden scheme of Vanderbilt and Louie
+! as "described" in D. Johnsons paper (PRB 38, 12807 [Dec. 1988]).
+! (don't take this comment too serious, Johnson's paper contains at
+!  least 6 hard errors, which we have corrected ...)
+!
+! details can be found in
+! G. Kresse, J. Furthmueller,  Comput. Mat. Sci. 6, 15-50 (1996)
+! (written by  jF with contributions of gK [small corrections only])
+!
+! there is a routine in VASP which is much easier to understand and
+! does more or less the same see dynbr.F,
+! this routine is so complicated
+! because it can use a file to save the iteration history
+!
+!***********************************************************************
+
+   SUBROUTINE MSR1(NDIM,F,X,FP,WC,IB,NUPDZ,MAXIT,LKEEP,REMOVE, &
+      &                  B,NGIGA,WRK1,WRK2,INI,IU,LOPEN,ICMPLX,MRECL, &
+      &                  RMS,RMSP,WEIGHT,NEIG,EIGENVAL,AMEAN,IERR &
+#ifdef MPI
+                           ,COMM &
+#endif
+                        )
+         USE prec
+         USE mpimy
+         USE broyden
+         IMPLICIT COMPLEX(q) (C)
+         IMPLICIT REAL(q) (A-B,D-H,O-Z)
+   
+#ifdef MPI
+         TYPE (communic) COMM
+#endif
+   
+         PARAMETER(WEIMAX=33._q)
+         LOGICAL INI,LOPEN,LREDUC
+         LOGICAL LKEEP     ! keep Hessian matrix even at reset
+         COMPLEX(q) CTMP
+         COMPLEX(q) F(NDIM),X(NDIM),FP(NDIM),WRK1(NGIGA),WRK2(NDIM)
+         REAL(q)    B(3,3)
+   
+         COMPLEX(q)    BETAQ(MAXIT,MAXIT)
+         COMPLEX(q) AMAT(MAXIT,MAXIT),BETA(MAXIT,MAXIT)
+         COMPLEX(q)    AUX(MAXIT,MAX(8,MAXIT)),VV(MAXIT)
+         COMPLEX(q)    GP(MAXIT,MAXIT),SP(MAXIT,MAXIT)
+   
+         INTEGER    IOD(3),IPIV(MAXIT)
+         REAL(q)    AUXR(MAXIT,MAX(8,MAXIT)),S(MAXIT)
+         COMPLEX(q) AUXC(MAXIT),AUXBET(MAXIT)
+         REAL(q)    EIGENVAL(512)
+      
+         REAL(q), ALLOCATABLE,SAVE :: WI(:)
+         COMPLEX(q), ALLOCATABLE,SAVE :: FINF(:,:), GMAT(:,:),SMAT(:,:)
+         SAVE ITER,ICALL,IOD,LASTIT
+         DATA ITER /0/,ICALL /0/,LASTIT /0/
+   
+         INTEGER REMOVE   ! how many vectors are removed once MAXMIX is reached
+   
+         PROFILING_START('broyd')
+   
+#if defined(USE_TMPBROYD) && defined(MPI)
+         MPI + use of file for MIXING is not supported please undef USE_TMPBROYD
+#endif
+         NODE_ME=0
+         IONODE =0
+#ifdef MPI
+         NODE_ME= COMM%NODE_ME
+         IONODE = COMM%IONODE
+#endif
+         NEIG=0
+   !=======================================================================
+   ! First call: initialise some I/O-things ...
+   !=======================================================================
+         IF (ICALL==0) THEN
+            ALLOCATE(WI(MAXIT),FINF(MAXIT,MAXIT), &
+                     GMAT(MAXIT,MAXIT),SMAT(MAXIT,MAXIT))
+            WI=0
+            FINF=0
+            GMAT=0
+            SMAT=0
+   
+            IRECL=NDIM*ICMPLX
+   ! Save some I/O-data ... :
+            IOD(1)=IU
+            IOD(2)=-1
+            IOD(3)=1
+            ICALL=1
+   
+#ifdef USE_TMPBROYD
+   ! Open the save file for iteration data ... :
+            IF (LOPEN) THEN
+               OPEN(UNIT=IU,FILE='TMPBROYD',ACCESS='DIRECT', &
+      &                                    FORM='UNFORMATTED',RECL=IRECL)
+            ELSE
+               OPEN(UNIT=IU,ACCESS='DIRECT',FORM='UNFORMATTED',RECL=IRECL)
+            END IF
+#else
+            CALL BRNULL()
+#endif
+         END IF
+   !=======================================================================
+   ! calculate some necessary quantities
+   !=======================================================================
+   
+   ! Restart of mixing forced externally by setting INI = .TRUE. (this must
+   ! be used for example after an ionic step / setup of a new geometry):
+         IF (INI .AND. ITER/=0 ) THEN
+         IF (.NOT. LKEEP .OR. MAXIT-ITER < -1 ) THEN
+            ITER=0
+            LASTIT=0
+         ELSE
+   ! keep mixing information alive (i.e. use it as an initial approximation
+   ! for  the present charge dielectric function)
+            ITER=ITER-1
+            LASTIT=ITER
+         ENDIF
+         ENDIF
+   ! usually it makes no sense to proceed if one cannot converge after so
+   ! many steps - if there is some little hope at all, then by removing
+   ! vectors from the iteration history
+   ! currently REMOVE vectors are removed if MAXIT is reached
+         IF (ITER == MAXIT ) THEN
+            ISHIFT=MIN(REMOVE,ITER)
+   !        WRITE(*,*) 'removing ',ISHIFT,' from iteration history'
+            ITER  =ITER-ISHIFT
+            LASTIT=MAX(0,LASTIT-ISHIFT)
+            ! shift all saved arrays and vectors
+            CALL BR_SHIFT_CMATRIX(GMAT,MAXIT,ITER,ISHIFT)
+            CALL BR_SHIFT_CMATRIX(SMAT,MAXIT,ITER,ISHIFT)
+            CALL BR_SHIFT_CMATRIX(FINF,MAXIT,ITER,ISHIFT)
+            CALL BR_SHIFT_VEC   (WI,1,ITER,ISHIFT)
+            ! shift all stored vectors
+            DO I=1,ITER-1
+               CALL BRGET_1(NDIM,WRK1,'F',I+ISHIFT,IOD,ITER,IERR)
+               CALL BRGET_1(NDIM,WRK2,'U',I+ISHIFT,IOD,ITER,IERR)
+               CALL BRSAV_1(NDIM,WRK1,'F',I,IOD,ITER,IERR)
+               CALL BRSAV_1(NDIM,WRK2,'U',I,IOD,ITER,IERR)
+               CALL BRGET_1(NDIM,WRK1,'Z',I+ISHIFT,IOD,ITER,IERR)
+               CALL BRSAV_1(NDIM,WRK1,'Z',I,IOD,ITER,IERR)
+               CALL BRGET_1(NDIM,WRK1,'W',I+ISHIFT,IOD,ITER,IERR)
+               CALL BRSAV_1(NDIM,WRK1,'W',I,IOD,ITER,IERR)
+               CALL BRGET_1(NDIM,WRK1,'D',I+ISHIFT,IOD,ITER,IERR)
+               CALL BRSAV_1(NDIM,WRK1,'D',I,IOD,ITER,IERR)
+            ENDDO
+         ENDIF
+   ! Restart of mixing if MAXIT is the same as ITER
+   ! not effective with the few lines above
+         ITER=MOD(ITER,MAXIT)
+   ! Increment iteration counter:
+         ITER=ITER+1
+   ! Number of previous iteration:
+         ITERM1=ITER-1
+   ! Change of vector |X>
+         SUM_=0
+         SUMP=0
+         DO I=1,NDIM
+            SUMP=SUMP+CONJG(F(I))*FP(I)
+            SUM_=SUM_  +CONJG(F(I))*F(I)
+         ENDDO
+         CALLMPI( M_sum_d(COMM, SUM_, 1))
+         CALLMPI( M_sum_d(COMM, SUMP, 1))
+         RMSP=SQRT(SUMP)
+         RMS =SQRT(SUM_)
+         DWRITE0 'rms',RMS,RMSP
+   ! Relative weight (W_iter/W_0) used for the current iteration ... :
+         IF (WC>=0._q) THEN
+         WI(ITER)=WC
+         ELSE
+   ! Try to set weights automatically (not recommended)
+         WI(ITER)=0.01_q*ABS(WC)/SUMP
+         END IF
+   ! Do not allow too strange weights ... :
+         IF (WI(ITER) < 1)     WI(ITER)=1
+         IF (WI(ITER) > 1E6  ) WI(ITER)=1E6
+         IF (WC==0 )           WI(ITER)=100
+   
+   ! Here Broydens 2nd method (slightly generalized) can be switched on:
+         IF (IB/=0) THEN
+            DO I=1,ITERM1
+            WI(I)=0
+            ENDDO
+            DO I=MAX(1,ITERM1-IB+1),ITERM1
+            WI(I)=100
+            ENDDO
+         ENDIF
+   ! it is possible to give all iterations including LASTIT
+   ! zero weight
+   ! this means that information collected up to LASTIT is overwritten
+   ! when updating the Hessian matrix
+   !      WI(1:LASTIT)=0
+   
+         WEIGHT=WI(ITER)
+   !=======================================================================
+   ! First iteration is a conventional linear mixing using G^(1):
+   !=======================================================================
+         IF (ITER==1 .OR.INI) THEN
+            IF (.NOT.INI) THEN
+   ! Can only be reset by ITER>MAXIT here, try again initial start mixing:
+               IF (NODE_ME /= IONODE) &
+               WRITE(*,*) 'Iteration count exceeded MAXIT =',MAXIT
+   ! Get initial (diagonal) mixing used previously ... :
+               CALL BRGET_1(NDIM,WRK1,'G',ITER,IOD,ITER,IERR)
+               IF (IERR/=0) THEN
+                  PROFILING_STOP('broyd')
+                  RETURN
+               END IF
+            END IF
+            IF (ITER==1) THEN
+#ifdef USE_TMPBROYD
+         ! Delete and reopen file TMPBROYD (or clean temproray work area)...
+            CALL CLEAN(IU)
+#else
+            CALL CLBROYD(IU)
+#endif
+         ! allocate for next 4 steps
+            CALL BRSAV_1(NDIM,F,'Z',ITER+3,IOD,ITER+3,IERR)
+            ENDIF
+   ! First save some things needed later: |XLAST>, |F^(1)> and |FP^(1)>:
+            CALL BRSAV_1(NDIM,FP,'P',ITER,IOD,ITER,IERR)
+            IF (IERR/=0) THEN
+               PROFILING_STOP('broyd')
+               RETURN
+            END IF
+            CALL BRSAV_1(NDIM,X,'X',ITER,IOD,ITER,IERR)
+            IF (IERR/=0) THEN
+               PROFILING_STOP('broyd')
+               RETURN
+            END IF
+            CALL BRSAV_1(NDIM,F,'I',ITER,IOD,ITER,IERR)
+            IF (IERR/=0) THEN
+               PROFILING_STOP('broyd')
+               RETURN
+            END IF
+   ! Now save also the start mixing G^(1) supplied on array WRK1:
+            CALL BRSAV_1(NDIM,WRK1,'G',ITER,IOD,ITER,IERR)
+            IF (IERR/=0) THEN
+               PROFILING_STOP('broyd')
+               RETURN
+            END IF
+   
+            GOTO 2000
+   ! Mix (here we need no metric because for simple linear mixing
+   ! using a diagonal G0 the result is the same with and without metric.):
+            DO I=1,NDIM
+            X(I)=X(I)+WRK1(I)*F(I)
+            ENDDO
+   ! That is all for the first ... :
+            PROFILING_STOP('broyd')
+            RETURN
+         END IF
+   
+         IF (MOD(ITER,5)==1) THEN
+   ! force allocation in junks of 5 data blocks to avoid memory fragmentation
+            CALL BRSAV_1(NDIM,F,'Z',ITER+3,IOD,ITER+3,IERR)
+         ENDIF
+   !=======================================================================
+   ! BROYDEN updating for ITER > 1 ... :
+   !=======================================================================
+   !Get |F> and |FP> from last iteration
+         CALL BRGET_1(NDIM,WRK1,'P',ITERM1,IOD,ITER,IERR)
+         IF (IERR/=0) THEN
+            PROFILING_STOP('broyd')
+            RETURN
+         END IF
+         CALL BRGET_1(NDIM,WRK2,'I',ITERM1,IOD,ITER,IERR)
+         IF (IERR/=0) THEN
+            PROFILING_STOP('broyd')
+            RETURN
+         END IF
+   ! Save actual |F> and |FP>:
+         CALL BRSAV_1(NDIM,F,'I',ITER,IOD,ITER,IERR)
+         IF (IERR/=0) THEN
+            PROFILING_STOP('broyd')
+            RETURN
+         END IF
+         CALL BRSAV_1(NDIM,FP,'P',ITER,IOD,ITER,IERR)
+         IF (IERR/=0) THEN
+            PROFILING_STOP('broyd')
+            RETURN
+         END IF
+         DO I=1,NDIM
+         ! |FP^(iter)>-|FP^(iter-1)>:
+            FP(I)=FP(I)-WRK1(I)
+         ! |F^(iter)>-|F^(iter-1)>:
+         F(I)=F(I)-WRK2(I)
+         ENDDO
+   ! Norm of this vector (with integration weights/metric. included ...):
+         FNORM=0._q
+         DO  I=1,NDIM
+         FNORM=FNORM+FP(I)*CONJG(F(I))
+         ENDDO
+         CALLMPI( M_sum_d( COMM, FNORM, 1))
+         io_begin
+         WRITE(*,*) "iteration _ MSR1", ITERM1
+         WRITE(*,*) "FNORM",FNORM
+         io_end
+         FNORM=1._q/SQRT(FNORM)
+   ! Build |Delta F^(iter-1)>, |Delta FP^(iter-1)>:
+         DO I=1,NDIM
+            FP(I)=FP(I)*FNORM
+            F(I)=F(I)*FNORM
+         ENDDO
+   ! Save |Delta F^(iter-1)>:
+         CALL BRSAV_1(NDIM,F,'F',ITERM1,IOD,ITER,IERR)
+         CALL BRSAV_1(NDIM,FP,'D',ITERM1,IOD,ITER,IERR)
+         IF (IERR/=0) THEN
+            PROFILING_STOP('broyd')
+            RETURN
+         END IF
+   ! Get |X^(iter-1)> from last iteration:
+         CALL BRGET_1(NDIM,WRK2,'X',ITERM1,IOD,ITER,IERR)
+         IF (IERR/=0) THEN
+            PROFILING_STOP('broyd')
+            RETURN
+         END IF
+   ! Save actual |X^(iter)>:
+         CALL BRSAV_1(NDIM,X,'X',ITER,IOD,ITER,IERR)
+         IF (IERR/=0) THEN
+            PROFILING_STOP('broyd')
+            RETURN
+         END IF
+   ! Build |Delta X^(iter-1)> = (|X^(iter)>-|X^(iter-1)>)/||F||_w :
+         DO I=1,NDIM
+         WRK1(I)=(X(I)-WRK2(I))*FNORM
+         ENDDO
+         CALL BRSAV_1(NDIM,WRK1,'W',ITERM1,IOD,ITER,IERR)
+   ! Vector |U^(iter-1)> = G^(1) |Delta F^(iter-1)> + |Delta X^(iter-1)>:
+         CALL BRGET_1(NDIM,WRK2,'G',ITER,IOD,ITER,IERR)
+         IF (IERR/=0) THEN
+            PROFILING_STOP('broyd')
+            RETURN
+         END IF
+         DO I=1,NDIM
+         CTMP=WRK1(I)
+         WRK1(I)=WRK2(I)*F(I)
+         WRK1(I+NDIM)=CTMP+WRK2(I)*F(I)
+         WRK2(I)=CTMP+WRK2(I)*F(I)
+         ENDDO
+   ! Save |U^(iter-1)>:
+         CALL BRSAV_1(NDIM,WRK2,'U',ITERM1,IOD,ITER,IERR)
+         IF (IERR/=0) THEN
+            PROFILING_STOP('broyd')
+            RETURN
+         END IF
+
+         DO J=1,ITERM1
+         CALL BRGET_1(NDIM,WRK2,'F',J,IOD,ITER,IERR)
+         CSUM1=0
+         CSUM2=0
+         !  SUM1=<D F(j)| G(1) |D F(iter-1)>
+         !  SUM2=<D F(j)| U^(iter-1)> = <D F(j)| G(m)-G(1) | D F^(iter-1)>
+         DO I=1,NDIM
+            CSUM1=SUM1+CONJG(WRK2(I))*WRK1(I)
+            CSUM2=CSUM2-CONJG(WRK2(I))*WRK1(I+NDIM)
+         ENDDO
+         SMAT(J,ITERM1)=CSUM1
+         SMAT(ITERM1,J)=CONJG(CSUM1)
+         GMAT(J,ITERM1)=CSUM2
+      ENDDO
+
+   ! calculate |D W(iter-1)>=|D F(iter-1)> + alpha |D X(iter-1)>
+   ! alpha = max(1.0, <D F(j) | metric |  D F(j) >/<D X(j) | metric |  D F(j) >)
+   ! <D F(j) | metric |  D F(j) >=1
+      CALL BRGET_1(NDIM,WRK1,'W',ITERM1,IOD,ITER,IERR)
+      CSUM=0
+      SUM1=0
+      DO I=1,NDIM
+         CSUM=CSUM+CONJG(WRK1(I))*FP(I) ! DX(iter-1) can be reproduced by WRK1(I+NDIM)-WRK1(I)
+         SUM1=SUM1+CONJG(WRK1(I))*WRK1(I)
+      ENDDO
+      CALLMPI( M_sum_z( COMM, CSUM, 1))
+      CALLMPI( M_sum_d( COMM, SUM1, 1))
+      io_begin
+      WRITE(*,*) "<rho|metric|R(rho)>",CSUM
+      WRITE(*,*) "<rho|rho>",SUM1
+      io_end
+      DO I=1,NDIM
+      !    ! WRK1(I)=F(I)
+         WRK1(I)=(F(I)-0.1_q*WRK1(I))*MIN(1.0_q,ABS(10._q/CSUM))
+      !    ! WRK1(I)=(F(I)+WRK1(I)*SIGN(1.0_q,REAL(CSUM)))*MIN(1.0_q,ABS(1.0_q/CSUM))
+      !    ! WRK1(I)=WRK1(I)*SIGN(1.0_q,SUM_)
+      ENDDO
+      CALL BRSAV_1(NDIM,WRK1,'W',ITERM1,IOD,ITER,IERR)
+   !=======================================================================
+   ! Matrix FINF: we must only add the elements (iter-1,j) and (j,iter-1):
+   !   FINF(iter-1,j) = <D F(iter-1) | metric |  W F(j) >
+   !   FINF(j,iter-1) = <D F(j) | metric |  D W(iter-1) >
+   !   the transpose if its inverse is used
+   !=======================================================================
+         
+         DO J=1,ITERM1
+            CALL BRGET_1(NDIM,WRK1,'W',J,IOD,ITER,IERR) !'W' stands for |Delta W>
+            IF (IERR/=0) THEN
+               PROFILING_STOP('broyd')
+               RETURN
+            END IF
+            CSUM_=0
+            DO I=1,NDIM
+            CSUM_=CSUM_+CONJG(FP(I))*WRK1(I)! DX(iter-1) can be reproduced by WRK1(I+NDIM)-WRK1(I)
+            ENDDO
+            FINF(ITERM1,J)=REAL(CSUM_,kind=q)
+         ENDDO
+         DO J=1,ITERM1
+         CALL BRGET_1(NDIM,WRK2,'D',J,IOD,ITER,IERR)  !'D' stands for metric|Delta F>
+         IF (IERR/=0) THEN
+            PROFILING_STOP('broyd')
+            RETURN
+         END IF
+         CSUM_=0
+         DO I=1,NDIM
+            CSUM_=CSUM_+CONJG(WRK2(I))*WRK1(I)! DX(iter-1) can be reproduced by WRK1(I+NDIM)-WRK1(I)
+         ENDDO
+         FINF(J,ITERM1)=REAL(CSUM_,kind=q)
+      ENDDO
+
+         CALL BRGET_1(NDIM,WRK1,'F',ITERM1,IOD,ITER,IERR)
+         DO J=1,ITERM1
+            CALL BRGET_1(NDIM,WRK2,'U',J,IOD,ITER,IERR)
+            IF (IERR/=0) THEN
+               PROFILING_STOP('broyd')
+               RETURN
+            END IF
+         ! SUM_=<D F(iter-1)| U^(j)>
+            CSUM_=0
+            DO I=1,NDIM
+            CSUM_=CSUM_+CONJG(WRK1(I))*WRK2(I)
+            ENDDO
+            GMAT(ITERM1,J)=-CSUM_
+         ENDDO
+         CALLMPI( M_sum_z(COMM, FINF(1,ITERM1), ITERM1))
+         CALLMPI( M_sum_z(COMM, FINF(ITERM1,1:ITERM1-1), ITERM1-1)) 
+
+      !  IDUMP=1
+      !  io_begin
+      !  IF (IDUMP==1) THEN
+      !    WRITE(*,*) 
+      !    WRITE(*,*)'FINF my'
+      !    DO I=1,ITERM1
+      !      WRITE(*,'(99F16.8)') (FINF(I,J),J=1,ITERM1)
+      !    ENDDO
+      !  ENDIF
+      !  io_end
+      !  IDUMP=0
+      !  DO J=1,ITERM1
+      !    CALL BRGET_1(NDIM,WRK2,'F',J,IOD,ITER,IERR)
+      !    IF (IERR/=0) THEN
+      !       PROFILING_STOP('broyd')
+      !       RETURN
+      !    END IF
+      !    SUM_=0
+      !    DO I=1,NDIM
+      !      SUM_=SUM_+CONJG(WRK2(I))*FP(I)
+      !    ENDDO
+
+      !    FINF(J,ITERM1)=SUM_
+      !    FINF(ITERM1,J)=SUM_
+      ! ENDDO
+      ! CALLMPI( M_sum_z(COMM, FINF(1,ITERM1), ITERM1))
+      ! FINF(ITERM1,ITERM1)=1._q
+      ! DO J=1,ITERM1-1
+      !    FINF(ITERM1,J)=FINF(J,ITERM1)
+      ! ENDDO
+
+         CALLMPI( M_sum_z(COMM, SMAT(1,ITERM1), ITERM1))
+      !  CALLMPI( M_sum_z(COMM, FINF(1,ITERM1), ITERM1))
+      !  CALLMPI( M_sum_z(COMM, FINF(ITERM1,1:ITERM1-1), ITERM1-1))
+         CALLMPI( M_sum_z(COMM, GMAT(1,ITERM1), ITERM1))
+         CALLMPI( M_sum_z(COMM, GMAT(ITERM1,1:ITERM1-1), ITERM1-1))
+   
+         ! correct transposed elements
+         DO J=1,ITERM1-1
+         SMAT(ITERM1,J)=CONJG(SMAT(J,ITERM1))
+         ENDDO
+   
+   ! Matrix A:
+         DO J=1,ITERM1
+         AMAT(J,J)=0._q+WI(J)*WI(J)*FINF(J,J)
+         DO K=1,J-1
+            AMAT(J,K)=FINF(J,K)*WI(J)*WI(K)
+            AMAT(K,J)=FINF(K,J)*WI(K)*WI(J)
+         ENDDO
+         ENDDO
+         IDUMP=0
+         io_begin
+         IF (IDUMP==1) THEN
+         WRITE(*,*) 
+         WRITE(*,*)'FINF'
+         DO I=1,ITERM1
+            WRITE(*,'(99F16.8)') (FINF(I,J),J=1,ITERM1)
+         ENDDO
+         ENDIF
+         io_end
+   
+   ! Matrix Beta:
+         IF (ITERM1==1) THEN
+   ! Trivial case: A is a 1x1 matrix ...
+            BETA(1,1)=1._q/AMAT(1,1)
+         ELSE
+   ! General case: Invert matrix A ...
+         !  CALL INVERSZ(AMAT,ITERM1,MAXIT,BETA,AUX,IPIV,VV)
+         CALL SVD_INVERSZ(AMAT,ITERM1,MAXIT,1.0_q,BETA,S)
+         END IF
+         io_begin
+         WRITE(*,*) 
+         WRITE(*,*)'singular value of AMAT'
+         WRITE(*,'(99F16.8)') (S(J),J=1,ITERM1)
+         io_end
+   !=======================================================================
+   !  solve eigenvalue problem
+   !   G e = lambda G^1 e
+   !  where G is the approximation of the Hessian matrix
+   !  works only for Pulay mixing because we assume  G |d F> = | d X>
+   !=======================================================================
+      io_begin
+         DO I=1,ITERM1
+         DO J=1,ITERM1
+         GP(I,J)=GMAT(I,J)
+         SP(I,J)=SMAT(I,J)
+         ENDDO
+         ENDDO
+   
+         IDUMP=0
+         IF (IDUMP==1) THEN
+         WRITE(*,*)'SMAT'
+         DO  I=1,ITERM1
+            WRITE(*,'(10F16.8)') (SP(I,J),J=1,ITERM1)
+         ENDDO
+         WRITE(*,*)'GMAT'
+         DO I=1,ITERM1
+            WRITE(*,'(10F16.8)') (GP(I,J),J=1,ITERM1)
+         ENDDO
+         ENDIF
+         INFO=1
+         IF (INFO/=0) THEN
+#ifdef essl
+         CALL ZGGEV(0,GP,MAXIT,SP,MAXIT,AUXC,AUXBET,AUX,1,ITERM1, &
+         &        AUX,MAX(8*MAXIT,MAXIT*MAXIT),AUXR)
+#else
+         CALL ZGGEV('N','N',ITERM1,GP,MAXIT,SP,MAXIT,AUXC,AUXBET, &
+         &        AUX,1,AUX,1,AUX,MAX(8*MAXIT,MAXIT*MAXIT),AUXR,INFO)
+         ! AUXC= CMPLX( AUXR , AUXI ,KIND=q)
+#endif
+         NEIG=ITERM1
+         DO I=1,ITERM1
+            EIGENVAL(I)= ABS(AUXC(I)/MAX(ABS(AUXBET(I)),1E-10_q)+1)
+         ENDDO
+         AMEAN=0
+         DO I=1,ITERM1
+            AMEAN=AMEAN+ABS(AUXC(I)/MAX(ABS(AUXBET(I)),1E-10_q)+1)
+         END DO
+         AMEAN=AMEAN/ITERM1
+         ENDIF
+      io_end
+   !=======================================================================
+   ! Calculate BETAQ used in the update of Z.(formula in Johnsons paper is
+   ! wrong if weights are not equal, here is the correct version - by gK):
+   ! a few comments here:
+   !   for Pulays      approach BETAQ is strictly 0 (equ. 103)
+   !   for Broydens 2. approach BETAQ and BETA have the structure
+   !            BETAQ     1   0   0      BETA=0 except for
+   !                      0   1   0      BETA(ITERM1,ITERM1)=1
+   !                      0   0   1
+   !                     g_1 g_2  g_3
+   !            (see equ. 104 and 105 in gK)
+   !=======================================================================
+         LREDUC=.TRUE.
+         BETAQ=0
+      !  DO I=1,ITERM1
+      !    LREDUC=LREDUC.AND.(WI(I)>=WEIMAX)
+      !    DO IT=1,ITERM1-1
+      !      BETAQ(I,IT)=0._q
+      !      DO J=1,ITERM1
+      !        BETAQ(I,IT)=BETAQ(I,IT)-WI(I)*BETA(I,J)*WI(J)*FINF(J,IT)
+      !      ENDDO
+      !    ENDDO
+      !    BETAQ(I,I)=BETAQ(I,I)+1
+      !  ENDDO
+   
+      !  IDUMP=0
+      !  io_begin
+      !  IF (IDUMP==1) THEN
+      !    WRITE(*,*)'BETA'
+      !    DO I=1,ITERM1
+      !      WRITE(*,'(10F16.8)') (BETA (I,J)*WI(I)*WI(J),J=1,ITERM1)
+      !    ENDDO
+      !    WRITE(*,*)'BETAQ'
+      !    DO I=1,ITERM1
+      !      WRITE(*,'(10F16.8)') (BETAQ(I,J),J=1,ITERM1-1)
+      !    ENDDO
+      !  ENDIF
+      !  io_end
+      !  IDUMP=0
+   
+   ! Reload |FP^(iter)>:
+         CALL BRGET_1(NDIM,FP,'P',ITER,IOD,ITER,IERR)
+         IF (IERR/=0) THEN
+            PROFILING_STOP('broyd')
+            RETURN
+         END IF
+   !=======================================================================
+   ! update all the vectors |Z_it^(m-1)> - if WRK1 is dimensioned large
+   ! enough several vectors Z are updated simultaneously to reduce I/O!
+   !=======================================================================
+         DO IT=1,ITERM1,NUPDZ
+   ! Number of vectors to be updated simultaneously:
+            NUPDM=MIN(NUPDZ,ITERM1-IT+1)
+            DO I=1,NDIM*NUPDM
+            WRK1(I)=(0._q,0._q)
+            ENDDO
+   ! Sum_{im=1,iter-2} BETAQ_{it,im} |Z_im^(iter-2)> - warning, do not be
+   ! confused: array F is here used as a workarray ... !
+            IF (.NOT.LREDUC) THEN
+   ! Remark: this part is not used at all if all weigths are very large!
+               DO IM=1,ITERM1-1
+   ! Selective treatment for steps with "smaller" weights ... :
+                  IF (WI(IM)>=(10._q*WEIMAX)) CYCLE
+                  CALL BRGET_1(NDIM,F,'Z',IM,IOD,ITER,IERR)
+                  IF (IERR/=0) THEN
+                     PROFILING_STOP('broyd')
+                     RETURN
+                  END IF
+                  DO IUPD=0,NUPDM-1
+                     IF (BETAQ(IT+IUPD,IM)==0._q) CYCLE
+                     IOFF=IUPD*NDIM
+                     DO I=1,NDIM
+                     WRK1(I+IOFF)=WRK1(I+IOFF)+BETAQ(IT+IUPD,IM)*F(I)
+                     ENDDO
+                  ENDDO
+               ENDDO
+            ENDIF
+   ! Add sum_{im=1,iter-1} WI_im WI_it BETA_{it,im} |U^(im)>:
+            DO IM=1,ITERM1
+               CALL BRGET_1(NDIM,F,'U',IM,IOD,ITER,IERR)
+               IF (IERR/=0) THEN
+                  PROFILING_STOP('broyd')
+                  RETURN
+               END IF
+               DO IUPD=0,NUPDM-1
+                  IOFF=IUPD*NDIM
+                  DO  I=1,NDIM
+                  WRK1(I+IOFF)=WRK1(I+IOFF)+ &
+      &                          WI(IT+IUPD)*WI(IM)*BETA(IT+IUPD,IM)*F(I)
+                  ENDDO
+               ENDDO
+            ENDDO
+            IF (LREDUC) THEN
+   ! Save |Z>-vectors (only allowed in reduced version for large weigths):
+               DO IUPD=0,NUPDM-1
+                  IOFF=IUPD*NDIM
+                  CALL BRSAV_1(NDIM,WRK1(1+IOFF),'Z',IT+IUPD,IOD,ITER,IERR)
+                  IF (IERR/=0) THEN
+                     PROFILING_STOP('broyd')
+                     RETURN
+                  END IF
+               ENDDO
+            ELSE
+   ! Save temporarily (we may not yet destroy the old |Z>-vectors!):
+               DO IUPD=0,NUPDM-1
+                  IOFF=IUPD*NDIM
+                  IF (WI(IT+IUPD)<(10._q*WEIMAX)) THEN
+                  CALL BRSAV_1(NDIM,WRK1(1+IOFF),'T',IT+IUPD,IOD,ITER,IERR)
+                  IF (IERR/=0) THEN
+                     PROFILING_STOP('broyd')
+                     RETURN
+                  END IF
+                  ELSE
+   ! ... except unused |Z>-vectors (iterations with large weights):
+                  CALL BRSAV_1(NDIM,WRK1(1+IOFF),'Z',IT+IUPD,IOD,ITER,IERR)
+                  IF (IERR/=0) THEN
+                     PROFILING_STOP('broyd')
+                     RETURN
+                  END IF
+                  ENDIF
+               ENDDO
+            ENDIF
+         ENDDO
+   
+   ! Finally swap all updated |Z_it^(iter-1)> from temporary records 'T'
+   ! to records 'Z' (if necessary) to be prepared for the next step ... :
+         DO IT=1,ITERM1
+            IF ((.NOT.LREDUC).AND.(WI(IT)<(10._q*WEIMAX))) THEN
+               CALL BRGET_1(NDIM,WRK1,'T',IT,IOD,ITER,IERR)
+               IF (IERR/=0) THEN
+                  PROFILING_STOP('broyd')
+                  RETURN
+               END IF
+               CALL BRSAV_1(NDIM,WRK1,'Z',IT,IOD,ITER,IERR)
+               IF (IERR/=0) THEN
+                  PROFILING_STOP('broyd')
+                  RETURN
+               END IF
+            ENDIF
+         ENDDO
+   !=======================================================================
+   ! calculate (G-G^(1)) |F^(iter)>
+   !=======================================================================
+   2000 CONTINUE
+   
+   ! Reload |FP^(iter)>:
+         CALL BRGET_1(NDIM,FP,'P',ITER,IOD,ITER,IERR)
+   
+         DO IT=1,ITERM1
+   ! Get the |Delta X^(it)>:
+               CALL BRGET_1(NDIM,F,'W',IT,IOD,ITER,IERR)
+               IF (IERR/=0) THEN
+                  PROFILING_STOP('broyd')
+                  RETURN
+               END IF
+               CSUM_=0._q
+   ! Build <Delta X^(it)|FP^(iter)>:
+               DO I=1,NDIM
+               CSUM_=CSUM_+CONJG(F(I))*FP(I)
+               ENDDO
+               CALLMPI ( M_sum_z(COMM, CSUM_, 1))
+   ! Subtract |Z_it^(iter-1)><Delta X^(it)|FP^(iter)> from |X^(iter)>:
+               CALL BRGET_1(NDIM,WRK1(1),'Z',IT,IOD,ITER,IERR)
+               DO I=1,NDIM
+               X(I)=X(I)-CSUM_*WRK1(I)
+               ENDDO
+         ENDDO
+   !=======================================================================
+   ! calculate G^(1) |F^(iter)>
+   !=======================================================================
+   ! Reload |F^(iter)>:
+         CALL BRGET_1(NDIM,F,'I',ITER,IOD,ITER,IERR)
+         IF (IERR/=0) THEN
+            PROFILING_STOP('broyd')
+            RETURN
+         END IF
+   ! Reload start mixing G^(1):
+         CALL BRGET_1(NDIM,WRK1,'G',ITER,IOD,ITER,IERR)
+         IF (IERR/=0) THEN
+            PROFILING_STOP('broyd')
+            RETURN
+         END IF
+   ! Add G^(1) |F^(iter)> to vector |X^(iter)>:
+         DO I=1,NDIM
+         X(I)=X(I)+WRK1(I)*F(I)
+         ENDDO
+   
+   ! Now we have the output vector |X(iter+1)> and all is done - good bye:
+#ifndef USE_TMPBROYD
+         CALL BRRMTMP()
+#endif
+   
+         PROFILING_STOP('broyd')
+   
+         RETURN
+         END SUBROUTINE
+
+
+SUBROUTINE MLS1(NDIM,F,X,FP,WC,IB,NUPDZ,MAXIT,LKEEP,REMOVE, &
+&                  B,NGIGA,WRK1,WRK2,INI,IU,LOPEN,ICMPLX,MRECL, &
+&                  RMS,RMSP,WEIGHT,NEIG,EIGENVAL,AMEAN,IERR &
+#ifdef MPI
+                     ,COMM &
+#endif
+                  )
+   USE prec
+   USE mpimy
+   USE broyden
+   IMPLICIT COMPLEX(q) (C)
+   IMPLICIT REAL(q) (A-B,D-H,O-Z)
+
+#ifdef MPI
+   TYPE (communic) COMM
+#endif
+
+   PARAMETER(WEIMAX=33._q)
+   LOGICAL INI,LOPEN,LREDUC
+   LOGICAL LKEEP     ! keep Hessian matrix even at reset
+   COMPLEX(q) CTMP
+   COMPLEX(q) F(NDIM),X(NDIM),FP(NDIM),WRK1(NGIGA),WRK2(NDIM)
+   REAL(q)    B(3,3)
+
+   COMPLEX(q)    BETAQ(MAXIT,MAXIT)
+   COMPLEX(q)    AMAT(MAXIT,MAXIT),ALPHA(MAXIT,MAXIT),BETA(MAXIT,MAXIT),GAM(MAXIT,MAXIT)
+   COMPLEX(q)    VB(MAXIT),VA(MAXIT),VC(MAXIT)
+   COMPLEX(q)    AUX(MAXIT,MAX(8,MAXIT)),VV(MAXIT)
+   COMPLEX(q)    GP(MAXIT,MAXIT),SP(MAXIT,MAXIT)
+   COMPLEX(q)    U(MAXIT,MAXIT),T(MAXIT,MAXIT)
+
+   INTEGER    IOD(3),IPIV(MAXIT)
+   REAL(q)    AUXR(MAXIT,MAX(8,MAXIT)),S(MAXIT),D(MAXIT),SCAL,SMIN,DMAX,DMIN
+   COMPLEX(q) AUXC(MAXIT),AUXBET(MAXIT)
+   REAL(q)    EIGENVAL(512)
+
+   REAL(q), ALLOCATABLE,SAVE :: WI(:),W(:)
+   LOGICAL,SAVE:: LSOFT,LDONE !handle soft mode problem
+   
+   COMPLEX(q), ALLOCATABLE,SAVE :: FINF(:,:),WINF(:,:),WINW(:,:),GMAT(:,:),SMAT(:,:)
+   SAVE ITER,ICALL,IOD,LASTIT
+   DATA ITER /0/,ICALL /0/,LASTIT /0/
+
+   INTEGER REMOVE   ! how many vectors are removed once MAXMIX is reached
+
+   PROFILING_START('broyd')
+
+#if defined(USE_TMPBROYD) && defined(MPI)
+   MPI + use of file for MIXING is not supported please undef USE_TMPBROYD
+#endif
+   NODE_ME=0
+   IONODE =0
+#ifdef MPI
+   NODE_ME= COMM%NODE_ME
+   IONODE = COMM%IONODE
+#endif
+   NEIG=0
+!=======================================================================
+! First call: initialise some I/O-things ...
+!=======================================================================
+   IF (ICALL==0) THEN
+      ALLOCATE(WI(MAXIT),W(MAXIT),&
+               FINF(MAXIT,MAXIT),WINF(MAXIT,MAXIT),WINW(MAXIT,MAXIT), &
+               GMAT(MAXIT,MAXIT),SMAT(MAXIT,MAXIT))
+      WI=0
+      W=0
+      FINF=0
+      WINF=0
+      WINW=0
+      GMAT=0
+      SMAT=0
+
+      IRECL=NDIM*ICMPLX
+! Save some I/O-data ... :
+      IOD(1)=IU
+      IOD(2)=-1
+      IOD(3)=1
+      ICALL=1
+
+#ifdef USE_TMPBROYD
+! Open the save file for iteration data ... :
+      IF (LOPEN) THEN
+         OPEN(UNIT=IU,FILE='TMPBROYD',ACCESS='DIRECT', &
+&                                    FORM='UNFORMATTED',RECL=IRECL)
+      ELSE
+         OPEN(UNIT=IU,ACCESS='DIRECT',FORM='UNFORMATTED',RECL=IRECL)
+      END IF
+#else
+      CALL BRNULL()
+#endif
+   END IF
+!=======================================================================
+! calculate some necessary quantities
+!=======================================================================
+
+! Restart of mixing forced externally by setting INI = .TRUE. (this must
+! be used for example after an ionic step / setup of a new geometry):
+   IF (INI .AND. ITER/=0 ) THEN
+   LDONE=.FALSE.
+!  IF (.NOT. LKEEP .OR. MAXIT-ITER < -1 ) THEN
+   io_begin
+      WRITE(*,*) "initial way 1"
+      WRITE(*,*) "LKEEP", LKEEP
+      WRITE(*,*) "ITER", ITER
+   io_end
+      ITER=0
+      LASTIT=0
+!  ELSE
+! keep mixing information alive (i.e. use it as an initial approximation
+! for  the present charge dielectric function)
+!    io_begin
+!    WRITE(*,*) "initial way 2"
+!    WRITE(*,*) "LKEEP", LKEEP
+!    WRITE(*,*) "ITER",ITER
+!    io_end
+!     ITER=ITER-1
+!     LASTIT=ITER
+!  ENDIF
+   ENDIF
+! usually it makes no sense to proceed if one cannot converge after so
+! many steps - if there is some little hope at all, then by removing
+! vectors from the iteration history
+! currently REMOVE vectors are removed if MAXIT is reached
+!  IF(.NOT. LKEEP) LSOFT=.TRUE.
+   IF(.NOT. LKEEP) THEN 
+   LSOFT=.TRUE.
+   LDONE=.FALSE.
+   ENDIF
+   IF (LDONE) THEN 
+   ITER=0
+   ENDIF
+   IF (ITER == MAXIT ) THEN
+      ISHIFT=MIN(REMOVE,ITER)
+!        WRITE(*,*) 'removing ',ISHIFT,' from iteration history'
+      ITER  =ITER-ISHIFT
+      LASTIT=MAX(0,LASTIT-ISHIFT)
+      ! shift all saved arrays and vectors
+      CALL BR_SHIFT_CMATRIX(GMAT,MAXIT,ITER,ISHIFT)
+      CALL BR_SHIFT_CMATRIX(SMAT,MAXIT,ITER,ISHIFT)
+      CALL BR_SHIFT_CMATRIX(FINF,MAXIT,ITER,ISHIFT)
+      CALL BR_SHIFT_CMATRIX(WINF,MAXIT,ITER,ISHIFT)
+      CALL BR_SHIFT_CMATRIX(WINW,MAXIT,ITER,ISHIFT)
+      CALL BR_SHIFT_VEC   (WI,1,ITER,ISHIFT)
+      CALL BR_SHIFT_VEC   (W,1,ITER,ISHIFT)
+      ! shift all stored vectors
+      DO I=1,ITER-1
+         CALL BRGET_1(NDIM,WRK1,'F',I+ISHIFT,IOD,ITER,IERR)
+         CALL BRGET_1(NDIM,WRK2,'U',I+ISHIFT,IOD,ITER,IERR)
+         CALL BRSAV_1(NDIM,WRK1,'F',I,IOD,ITER,IERR)
+         CALL BRSAV_1(NDIM,WRK2,'U',I,IOD,ITER,IERR)
+         CALL BRGET_1(NDIM,WRK1,'Z',I+ISHIFT,IOD,ITER,IERR)
+         CALL BRSAV_1(NDIM,WRK1,'Z',I,IOD,ITER,IERR)
+         CALL BRGET_1(NDIM,WRK1,'W',I+ISHIFT,IOD,ITER,IERR)
+         CALL BRSAV_1(NDIM,WRK1,'W',I,IOD,ITER,IERR)
+         CALL BRGET_1(NDIM,WRK1,'D',I+ISHIFT,IOD,ITER,IERR)
+         CALL BRSAV_1(NDIM,WRK1,'D',I,IOD,ITER,IERR)
+      ENDDO
+   ENDIF
+! Restart of mixing if MAXIT is the same as ITER
+! not effective with the few lines above
+   ITER=MOD(ITER,MAXIT)
+! Increment iteration counter:
+   ITER=ITER+1
+! Number of previous iteration:
+   ITERM1=ITER-1
+! Change of vector |X>
+   SUM_=0
+   SUMP=0
+   DO I=1,NDIM
+      SUMP=SUMP+CONJG(F(I))*FP(I)
+      SUM_=SUM_  +CONJG(F(I))*F(I)
+   ENDDO
+   CALLMPI( M_sum_d(COMM, SUM_, 1))
+   CALLMPI( M_sum_d(COMM, SUMP, 1))
+   RMSP=SQRT(SUMP)
+   RMS =SQRT(SUM_)
+   DWRITE0 'rms',RMS,RMSP
+! Relative weight (W_iter/W_0) used for the current iteration ... :
+   IF (WC>=0._q) THEN
+   WI(ITER)=WC
+   ELSE
+! Try to set weights automatically (not recommended)
+   WI(ITER)=0.01_q*ABS(WC)/SUMP
+   END IF
+! Do not allow too strange weights ... :
+   IF (WI(ITER) < 1)     WI(ITER)=1
+   IF (WI(ITER) > 1E6  ) WI(ITER)=1E6
+   IF (WC==0 )           WI(ITER)=100
+
+! Here Broydens 2nd method (slightly generalized) can be switched on:
+   IF (IB/=0) THEN
+      DO I=1,ITERM1
+      WI(I)=0
+      ENDDO
+      DO I=MAX(1,ITERM1-IB+1),ITERM1
+      WI(I)=100
+      ENDDO
+   ENDIF
+! it is possible to give all iterations including LASTIT
+! zero weight
+! this means that information collected up to LASTIT is overwritten
+! when updating the Hessian matrix
+!      WI(1:LASTIT)=0
+
+   WEIGHT=WI(ITER)
+   io_begin
+   WRITE(*,*) "this iteration ITER", ITER
+io_end
+!=======================================================================
+! First iteration is a conventional linear mixing using G^(1):
+!=======================================================================
+   IF (ITER==1 .OR.INI) THEN
+   IF (LDONE) THEN 
+      ITER=0
+      LDONE=.FALSE.
+      GOTO 3000
+      ENDIF
+      IF (.NOT.INI) THEN
+! Can only be reset by ITER>MAXIT here, try again initial start mixing:
+         IF (NODE_ME /= IONODE) &
+         WRITE(*,*) 'Iteration count exceeded MAXIT =',MAXIT
+! Get initial (diagonal) mixing used previously ... :
+         CALL BRGET_1(NDIM,WRK1,'G',ITER,IOD,ITER,IERR)
+         IF (IERR/=0) THEN
+            PROFILING_STOP('broyd')
+            RETURN
+         END IF
+      END IF
+      IF (ITER==1) THEN
+#ifdef USE_TMPBROYD
+   ! Delete and reopen file TMPBROYD (or clean temproray work area)...
+      CALL CLEAN(IU)
+#else
+      CALL CLBROYD(IU)
+#endif
+   ! allocate for next 4 steps
+      CALL BRSAV_1(NDIM,F,'Z',ITER+3,IOD,ITER+3,IERR)
+      ENDIF
+! First save some things needed later: |XLAST>, |F^(1)> and |FP^(1)>:
+      CALL BRSAV_1(NDIM,FP,'P',ITER,IOD,ITER,IERR)
+      IF (IERR/=0) THEN
+         PROFILING_STOP('broyd')
+         RETURN
+      END IF
+      CALL BRSAV_1(NDIM,X,'X',ITER,IOD,ITER,IERR)
+      IF (IERR/=0) THEN
+         PROFILING_STOP('broyd')
+         RETURN
+      END IF
+      CALL BRSAV_1(NDIM,F,'I',ITER,IOD,ITER,IERR)
+      IF (IERR/=0) THEN
+         PROFILING_STOP('broyd')
+         RETURN
+      END IF
+! Now save also the start mixing G^(1) supplied on array WRK1:
+      CALL BRSAV_1(NDIM,WRK1,'G',ITER,IOD,ITER,IERR)
+      IF (IERR/=0) THEN
+         PROFILING_STOP('broyd')
+         RETURN
+      END IF
+
+      GOTO 2000
+! Mix (here we need no metric because for simple linear mixing
+! using a diagonal G0 the result is the same with and without metric.):
+      DO I=1,NDIM
+      X(I)=X(I)+WRK1(I)*F(I)
+      ENDDO
+! That is all for the first ... :
+      PROFILING_STOP('broyd')
+      RETURN
+   END IF
+
+   IF (MOD(ITER,5)==1) THEN
+! force allocation in junks of 5 data blocks to avoid memory fragmentation
+      CALL BRSAV_1(NDIM,F,'Z',ITER+3,IOD,ITER+3,IERR)
+   ENDIF
+!=======================================================================
+! BROYDEN updating for ITER > 1 ... :
+!=======================================================================
+!Get |F> and |FP> from last iteration
+   CALL BRGET_1(NDIM,WRK1,'P',ITERM1,IOD,ITER,IERR)
+   IF (IERR/=0) THEN
+      PROFILING_STOP('broyd')
+      RETURN
+   END IF
+   CALL BRGET_1(NDIM,WRK2,'I',ITERM1,IOD,ITER,IERR)
+   IF (IERR/=0) THEN
+      PROFILING_STOP('broyd')
+      RETURN
+   END IF
+! Save actual |F> and |FP>:
+   CALL BRSAV_1(NDIM,F,'I',ITER,IOD,ITER,IERR)
+   IF (IERR/=0) THEN
+      PROFILING_STOP('broyd')
+      RETURN
+   END IF
+   CALL BRSAV_1(NDIM,FP,'P',ITER,IOD,ITER,IERR)
+   IF (IERR/=0) THEN
+      PROFILING_STOP('broyd')
+      RETURN
+   END IF
+   DO I=1,NDIM
+   ! |FP^(iter)>-|FP^(iter-1)>:
+      FP(I)=FP(I)-WRK1(I)
+   ! |F^(iter)>-|F^(iter-1)>:
+   F(I)=F(I)-WRK2(I)
+   ENDDO
+! Norm of this vector (with integration weights/metric. included ...):
+   FNORM=0._q
+   DO  I=1,NDIM
+   FNORM=FNORM+FP(I)*CONJG(F(I))
+   ENDDO
+   CALLMPI( M_sum_d( COMM, FNORM, 1))
+   io_begin
+   WRITE(*,*) "iteration _ MLS1", ITERM1
+   WRITE(*,*) "FNORM",FNORM
+   io_end
+   FNORM=1._q/SQRT(FNORM)
+! Build |Delta F^(iter-1)>, |Delta FP^(iter-1)>:
+   DO I=1,NDIM
+      FP(I)=FP(I)*FNORM
+      F(I)=F(I)*FNORM
+   ENDDO
+! Save |Delta F^(iter-1)>:
+   CALL BRSAV_1(NDIM,F,'F',ITERM1,IOD,ITER,IERR)
+   CALL BRSAV_1(NDIM,FP,'D',ITERM1,IOD,ITER,IERR)
+   IF (IERR/=0) THEN
+      PROFILING_STOP('broyd')
+      RETURN
+   END IF
+! Get |X^(iter-1)> from last iteration:
+   CALL BRGET_1(NDIM,WRK2,'X',ITERM1,IOD,ITER,IERR)
+   IF (IERR/=0) THEN
+      PROFILING_STOP('broyd')
+      RETURN
+   END IF
+! Save actual |X^(iter)>:
+   CALL BRSAV_1(NDIM,X,'X',ITER,IOD,ITER,IERR)
+   IF (IERR/=0) THEN
+      PROFILING_STOP('broyd')
+      RETURN
+   END IF
+! Build |Delta X^(iter-1)> = (|X^(iter)>-|X^(iter-1)>)/||F||_w :
+   SUM1=0
+   DO I=1,NDIM
+   WRK1(I)=(X(I)-WRK2(I))*FNORM
+   SUM1=SUM1+CONJG(WRK1(I))*WRK1(I)
+   ENDDO
+   CALL BRSAV_1(NDIM,WRK1,'U',ITERM1,IOD,ITER,IERR) !X
+   CALLMPI( M_sum_d( COMM, SUM1, 1))
+   W(ITERM1)=SQRT(SUM1)!MAX(1.0_q,SQRT(SQRT(SUM1)))
+
+! Vector |U^(iter-1)> = G^(1) |Delta F^(iter-1)> + |Delta X^(iter-1)>:
+   CALL BRGET_1(NDIM,WRK2,'G',ITER,IOD,ITER,IERR)
+   IF (IERR/=0) THEN
+      PROFILING_STOP('broyd')
+      RETURN
+   END IF
+   DO I=1,NDIM
+   CTMP=WRK1(I)
+   WRK1(I)=WRK2(I)*F(I)
+   WRK1(I+NDIM)=CTMP+WRK2(I)*F(I)
+   WRK2(I)=WRK2(I)*CTMP
+   ENDDO
+! Save |U^(iter-1)>:
+   CALL BRSAV_1(NDIM,WRK1,'Z',ITERM1,IOD,ITER,IERR) !G.F
+   IF (IERR/=0) THEN
+      PROFILING_STOP('broyd')
+      RETURN
+   END IF
+
+   DO J=1,ITERM1
+   CALL BRGET_1(NDIM,WRK2,'F',J,IOD,ITER,IERR)
+   CSUM1=0
+   CSUM2=0
+   !  SUM1=<D F(j)| G(1) |D F(iter-1)>
+   !  SUM2=<D F(j)| U^(iter-1)> = <D F(j)| G(m)-G(1) | D F^(iter-1)>
+   DO I=1,NDIM
+      CSUM1=SUM1+CONJG(WRK2(I))*WRK1(I)
+      CSUM2=CSUM2-CONJG(WRK2(I))*WRK1(I+NDIM)
+   ENDDO
+   SMAT(J,ITERM1)=CSUM1
+   SMAT(ITERM1,J)=CONJG(CSUM1)
+   GMAT(J,ITERM1)=CSUM2
+ENDDO
+
+! calculate |D W(iter-1)>=|D F(iter-1)> + alpha |D X(iter-1)>
+   ! alpha = max(1.0, <D F(j) | metric |  D F(j) >/<D X(j) | metric |  D F(j) >)
+   ! <D F(j) | metric |  D F(j) >=1
+CALL BRGET_1(NDIM,WRK1,'U',ITERM1,IOD,ITER,IERR)
+CSUM=0
+SUM1=0
+DO I=1,NDIM
+   CSUM=CSUM+CONJG(WRK1(I))*FP(I) ! DX(iter-1) can be reproduced by WRK1(I+NDIM)-WRK1(I)
+   SUM1=SUM1+CONJG(WRK1(I))*WRK1(I)
+ENDDO
+CALLMPI( M_sum_z( COMM, CSUM, 1))
+CALLMPI( M_sum_d( COMM, SUM1, 1))
+io_begin
+WRITE(*,*) "<rho|metric|R(rho)>",CSUM
+WRITE(*,*) "<rho|rho>",SUM1
+io_end
+! SUM_=MAX(1.0_q,ABS(1.0_q/CSUM))*SIGN(1.0_q,REAL(CSUM))
+DO I=1,NDIM
+   ! WRK1(I)=F(I)
+   ! WRK1(I)=(F(I)+WRK1(I))*MIN(1.0_q,ABS(10._q/CSUM))
+   WRK1(I)=(F(I)+WRK1(I)*SIGN(1.0_q,REAL(CSUM)))*MIN(1.0_q,ABS(1.0_q/CSUM))
+   ! WRK1(I)=WRK1(I)*SIGN(1.0_q,SUM_)
+ENDDO
+CALL BRSAV_1(NDIM,WRK1,'W',ITERM1,IOD,ITER,IERR)
+!=======================================================================
+! Matrix FINF: we must only add the elements (iter-1,j) and (j,iter-1):
+!   FINF(iter-1,j) = <D F(iter-1) | metric |  D F(j) >
+!   FINF(j,iter-1) = FINF(iter-1,j)*
+!   WINF(iter-1,j) = <D W(iter-1) | metric |  D F(j) >
+!   WINF(j,iter-1) = <D W(j) | metric |  D F(iter-1) >
+!   WINW(iter-1,j) = <D W(iter-1) |D W(j) >
+!   WINW(j,iter-1) = <D W(j) |D W(iter-1) >
+!=======================================================================
+   
+   CALL BRGET_1(NDIM,WRK2,'U',ITERM1,IOD,ITER,IERR)
+   DO J=1,ITERM1
+   CALL BRGET_1(NDIM,WRK1,'U',J,IOD,ITER,IERR) !'W' stands for |Delta W>
+   IF (IERR/=0) THEN
+      PROFILING_STOP('broyd')
+      RETURN
+   END IF
+   CSUM1=0
+   DO I=1,NDIM
+      CSUM1=CSUM1+CONJG(WRK1(I))*WRK2(I)! 
+   ENDDO
+   WINW(J,ITERM1)=REAL(CSUM1,kind=q)
+   WINW(ITERM1,J)=WINW(J,ITERM1)
+ENDDO
+
+   DO J=1,ITERM1
+      CALL BRGET_1(NDIM,WRK1,'W',J,IOD,ITER,IERR) !'W' stands for |Delta W>
+      IF (IERR/=0) THEN
+         PROFILING_STOP('broyd')
+         RETURN
+      END IF
+      CSUM1=0
+      DO I=1,NDIM
+      CSUM1=CSUM1+CONJG(WRK1(I))*FP(I)! 
+      ENDDO
+      WINF(J,ITERM1)=REAL(CSUM1,kind=q)
+   ENDDO
+   DO J=1,ITERM1
+   CALL BRGET_1(NDIM,WRK2,'D',J,IOD,ITER,IERR)  !'D' stands for metric|Delta F>
+   IF (IERR/=0) THEN
+      PROFILING_STOP('broyd')
+      RETURN
+   END IF
+   CSUM1=0
+   CSUM2=0
+   DO I=1,NDIM
+      CSUM1=CSUM1+CONJG(F(I))*WRK2(I) 
+      CSUM2=CSUM2+CONJG(WRK1(I))*WRK2(I) ! WRK1 now equals to W(iter-1)
+   ENDDO
+   FINF(ITERM1,J)=REAL(CSUM1,kind=q)
+   FINF(J,ITERM1)=FINF(ITERM1,J)
+   WINF(ITERM1,J)=REAL(CSUM2,kind=q)
+ENDDO
+
+   CALL BRGET_1(NDIM,WRK1,'F',ITERM1,IOD,ITER,IERR)
+   DO J=1,ITERM1
+      CALL BRGET_1(NDIM,WRK2,'U',J,IOD,ITER,IERR)
+      IF (IERR/=0) THEN
+         PROFILING_STOP('broyd')
+         RETURN
+      END IF
+   ! SUM_=<D F(iter-1)| U^(j)>
+      CSUM_=0
+      DO I=1,NDIM
+      CSUM_=CSUM_+CONJG(WRK1(I))*WRK2(I)
+      ENDDO
+      GMAT(ITERM1,J)=-CSUM_
+   ENDDO
+   CALLMPI( M_sum_z(COMM, FINF(1,ITERM1), ITERM1))
+   CALLMPI( M_sum_z(COMM, FINF(ITERM1,1:ITERM1-1), ITERM1-1))
+   CALLMPI( M_sum_z(COMM, WINF(1,ITERM1), ITERM1))
+   CALLMPI( M_sum_z(COMM, WINF(ITERM1,1:ITERM1-1), ITERM1-1))
+   CALLMPI( M_sum_z(COMM, WINW(1,ITERM1), ITERM1))
+   CALLMPI( M_sum_z(COMM, WINW(ITERM1,1:ITERM1-1), ITERM1-1))
+
+   CALLMPI( M_sum_z(COMM, SMAT(1,ITERM1), ITERM1))
+   CALLMPI( M_sum_z(COMM, GMAT(1,ITERM1), ITERM1))
+   CALLMPI( M_sum_z(COMM, GMAT(ITERM1,1:ITERM1-1), ITERM1-1))
+
+   ! correct transposed elements
+   DO J=1,ITERM1-1
+   SMAT(ITERM1,J)=CONJG(SMAT(J,ITERM1))
+   ENDDO
+
+! Matrix A:
+   DO J=1,ITERM1
+   AMAT(J,J)=0._q+FINF(J,J)*10000!*W(J)*W(J)
+   DO K=1,J-1
+      AMAT(J,K)=FINF(J,K)*10000!*W(J)*W(K)
+      AMAT(K,J)=FINF(K,J)*10000!*W(K)*W(J)
+   ENDDO
+   ENDDO
+   IDUMP=1
+!  io_begin
+!  WRITE(*,*) 
+! WRITE(*,*)'AMAT'
+! DO I=1,ITERM1
+!    WRITE(*,'(99F16.8)') (AMAT (I,J),J=1,ITERM1)
+! ENDDO
+!  io_end
+! Matrix ALPHA:
+   IF (ITERM1==1) THEN
+! Trivial case: A is a 1x1 matrix ...
+      ALPHA(1,1)=1._q/AMAT(1,1)
+      S(1) = ABS(AMAT(1,1))
+   ELSE
+! General case: Invert matrix A ...
+   !  CALL INVERSZ(AMAT,ITERM1,MAXIT,BETA,AUX,IPIV,VV)
+   CALL SVD_INVERSZ(AMAT,ITERM1,MAXIT,1.0_q,ALPHA,S)
+   END IF
+   io_begin
+   WRITE(*,*) 
+   WRITE(*,*)'singular value of 10000*FINF'
+   WRITE(*,'(99F16.8)') (S(J),J=1,ITERM1)
+   io_end
+DO J=1,ITERM1
+DO K=1,ITERM1
+   ALPHA(J,K)=ALPHA(J,K)*10000!*W(J)*W(K)
+ENDDO
+ENDDO
+SMIN = minval(S(1:ITERM1)) ! inspect linear dependence
+
+! Matrix A:
+   DO J=1,ITERM1
+   AMAT(J,J)=0._q+WINF(J,J)*10000
+   DO K=1,J-1
+      AMAT(J,K)=WINF(J,K)*10000
+      AMAT(K,J)=WINF(K,J)*10000
+   ENDDO
+   ENDDO
+   IDUMP=1
+!    io_begin
+!    WRITE(*,*) 
+!    WRITE(*,*)'AMAT'
+!    DO I=1,ITERM1
+!       WRITE(*,'(99F16.8)') (AMAT (I,J),J=1,ITERM1)
+!    ENDDO
+!  io_end
+! Matrix BETA:
+   IF (ITERM1==1) THEN
+! Trivial case: A is a 1x1 matrix ...
+      BETA(1,1)=1._q/AMAT(1,1)
+   ELSE
+! General case: Invert matrix A ...
+      !  CALL INVERSZ(AMAT,ITERM1,MAXIT,BETA,AUX,IPIV,VV)
+      CALL SVD_INVERSZ(AMAT,ITERM1,MAXIT,1.0_q,BETA,S)
+   END IF
+   io_begin
+   WRITE(*,*) 
+   WRITE(*,*)'singular value of 10000*WINF'
+   WRITE(*,'(99F16.8)') (S(J),J=1,ITERM1)
+   io_end
+   DO J=1,ITERM1
+   DO K=1,ITERM1
+      BETA(J,K)=BETA(J,K)*10000
+   ENDDO
+   ENDDO
+
+   BETA = ALPHA
+! we want to inspect soft modes
+CALL SVDZ(WINW,ITERM1,MAXIT,T,D,GAM)
+io_begin
+WRITE(*,*) 
+WRITE(*,*)'singular value of WINW'
+WRITE(*,'(99F16.8)') (D(J),J=1,ITERM1)
+io_end
+
+IF (LSOFT) THEN
+   DO I = 1,ITERM1
+      D(I) = SQRT(D(I))
+   ENDDO
+!-----------------------------------------------------------------------------
+! ALPHA
+   CALL GGEMM('C', 'N', ITERM1, ITERM1, ITERM1, one, &
+                  &   T, MAXIT, FINF, MAXIT,  &
+                  &   zero, GAM, MAXIT)
+   CALL GGEMM('N', 'N', ITERM1, ITERM1, ITERM1, one, &
+   &   GAM, MAXIT, T, MAXIT,  &
+   &   zero, AMAT, MAXIT)
+   SCAL=1E10
+   DO J=1,ITERM1
+   DO K=1,ITERM1
+      AMAT(J,K)=AMAT(J,K)/(D(J)*D(K)+1E-12)*SCAL
+   ENDDO
+   ENDDO
+   CALL SVD_INVERSZ(AMAT,ITERM1,MAXIT,1.0_q,ALPHA,S)
+   DMAX = maxval(S(1:ITERM1))/SCAL
+   ! CALL SVDZ(AMAT,ITERM1,MAXIT,U,S,GAM)
+   DO J=1,ITERM1
+   DO K=1,ITERM1
+      ALPHA(J,K)=ALPHA(J,K)/(D(J)*D(K)+1E-12)*SCAL
+   ENDDO
+   ENDDO
+   CALL GGEMM('N', 'N', ITERM1, ITERM1, ITERM1, one, &
+                  &   T, MAXIT, ALPHA, MAXIT,  &
+                  &   zero, GAM, MAXIT)
+   CALL GGEMM('N', 'C', ITERM1, ITERM1, ITERM1, one, &
+   &   GAM, MAXIT, T, MAXIT,  &
+   &   zero, ALPHA, MAXIT)
+! BETA   
+   CALL GGEMM('C', 'N', ITERM1, ITERM1, ITERM1, one, &
+               &   T, MAXIT, FINF, MAXIT,  &
+               &   zero, GAM, MAXIT)
+   CALL GGEMM('N', 'N', ITERM1, ITERM1, ITERM1, one, &
+   &   GAM, MAXIT, T, MAXIT,  &
+   &   zero, AMAT, MAXIT)
+   IF (DMAX>1E3 .OR. SMIN<1E-4) THEN 
+      SCAL=1E12
+      LDONE=.TRUE.
+      LSOFT=.FALSE.
+   ELSEIF (ITER==MAXIT) THEN
+      SCAL=1E12
+      LDONE=.TRUE.
+      LSOFT=.FALSE.
+   ELSE 
+      SCAL=1E2
+   ENDIF
+   DO J=1,ITERM1
+   DO K=1,ITERM1
+      AMAT(J,K)=AMAT(J,K)/(D(J)*D(K)+1E-12)*SCAL
+   ENDDO
+   ENDDO
+   CALL SVD_INVERSZ(AMAT,ITERM1,MAXIT,1.0_q,BETA,S)
+   ! CALL SVDZ(AMAT,ITERM1,MAXIT,U,S,GAM)
+   DO J=1,ITERM1
+   DO K=1,ITERM1
+      BETA(J,K)=BETA(J,K)/(D(J)*D(K)+1E-12)*SCAL
+   ENDDO
+   ENDDO
+   CALL GGEMM('N', 'N', ITERM1, ITERM1, ITERM1, one, &
+               &   T, MAXIT, BETA, MAXIT,  &
+               &   zero, GAM, MAXIT)
+   CALL GGEMM('N', 'C', ITERM1, ITERM1, ITERM1, one, &
+   &   GAM, MAXIT, T, MAXIT,  &
+   &   zero, BETA, MAXIT)
+   io_begin
+   WRITE(*,*) 
+   WRITE(*,*)'singular value of R^+R'
+   WRITE(*,'(99F16.8)') (S(J)/SCAL,J=1,ITERM1)
+   io_end
+ENDIF
+!=======================================================================
+! calculate VA = ALPHA <DF|FP>, VB=BETA <DW|FP>
+!=======================================================================
+2000 CONTINUE
+! WRITE(*,*)'I am fine 1'
+! Reload |FP^(iter)>:
+   CALL BRGET_1(NDIM,FP,'P',ITER,IOD,ITER,IERR)
+
+   DO IT=1,ITERM1
+! Get the |DF^(it)>:
+   CALL BRGET_1(NDIM,F,'F',IT,IOD,ITER,IERR)
+   IF (IERR/=0) THEN
+      PROFILING_STOP('broyd')
+      RETURN
+   END IF
+   CSUM_=0._q
+! Build <DF^(it)|FP^(iter)>:
+   DO I=1,NDIM
+   CSUM_=CSUM_+CONJG(F(I))*FP(I)
+   ENDDO
+   CALLMPI ( M_sum_z(COMM, CSUM_, 1))
+   VV(IT)=REAL(CSUM_,kind=q)
+   ENDDO
+! calculate ALPHA * VV
+CALL GGEMV('N', ITERM1, ITERM1, one, ALPHA, MAXIT, VV, 1, zero, VA, 1)
+CALL GGEMV('N', ITERM1, ITERM1, one, BETA, MAXIT, VV, 1, zero, VB, 1)
+
+DO IT=1,ITERM1
+! Get the |DX^(it)>:
+   CALL BRGET_1(NDIM,WRK1,'W',IT,IOD,ITER,IERR)
+   IF (IERR/=0) THEN
+      PROFILING_STOP('broyd')
+      RETURN
+   END IF
+   CSUM_=0._q
+! Build <DX^(it)|FP^(iter)>:
+   DO I=1,NDIM
+   CSUM_=CSUM_+CONJG(WRK1(I))*FP(I)
+   ENDDO
+   CALLMPI ( M_sum_z(COMM, CSUM_, 1))
+   VV(IT)=REAL(CSUM_,kind=q)
+ENDDO
+! calculate BETA * VV
+! CALL GGEMV('N', ITERM1, ITERM1, one, BETA, MAXIT, VV, 1, zero, VB, 1)
+! ! calculate BETA*WINF*VA
+!    CALL GGEMV('N', ITERM1, ITERM1, one, WINF, MAXIT, VA, 1, zero, VV, 1)
+!    CALL GGEMV('N', ITERM1, ITERM1, one, BETA, MAXIT, VV, 1, zero, VC, 1)
+! calculate X-G^m|F^(iter)>
+DO IT=1,ITERM1
+   ! CALL BRGET_1(NDIM,F,'W',IT,IOD,ITER,IERR)  !W
+   CALL BRGET_1(NDIM,WRK1,'U',IT,IOD,ITER,IERR)  !X
+   CALL BRGET_1(NDIM,WRK2,'Z',IT,IOD,ITER,IERR)  !G.F
+   DO I=1,NDIM
+      ! X(I)=X(I)-VA(IT)*(F(I)+WRK1(I))-(VB(IT)-VC(IT))*WRK2(I)
+      X(I)=X(I)-VB(IT)*WRK1(I)-VA(IT)*WRK2(I)
+      ! X(I)=X(I)-VA(IT)*WRK1(I)-VA(IT)*WRK2(I)
+   ENDDO
+ENDDO
+! WRITE(*,*)'I am fine 2'
+!=======================================================================
+! calculate G^(1) |F^(iter)>
+!=======================================================================
+! Reload |F^(iter)>:
+   CALL BRGET_1(NDIM,F,'I',ITER,IOD,ITER,IERR)
+   IF (IERR/=0) THEN
+      PROFILING_STOP('broyd')
+      RETURN
+   END IF
+! Reload start mixing G^(1):
+   CALL BRGET_1(NDIM,WRK1,'G',ITER,IOD,ITER,IERR)
+   IF (IERR/=0) THEN
+      PROFILING_STOP('broyd')
+      RETURN
+   END IF
+! Add G^(1) |F^(iter)> to vector |X^(iter)>:
+   DO I=1,NDIM 
+   X(I)=X(I)+WRK1(I)*F(I)
+   ENDDO
+!  WRITE(*,*)'I am fine 3'
+! CALL BRGET_1(NDIM,WRK1,'X',ITER,IOD,ITER,IERR)
+! DO IT=1,ITERM1
+!    CALL BRGET_1(NDIM,WRK2,'W',IT,IOD,ITER,IERR)  
+!    DO I=1,NDIM
+!       WRK1(I)=WRK1(I)-VA(IT)*WRK2(I)
+!    ENDDO
+! ENDDO
+! CALL BRSAV_1(NDIM,WRK1,'X',ITER,IOD,ITER,IERR)
+
+! CSUM=0
+! DO I=1,NDIM
+!    CSUM = CSUM + CONJG(WRK2(I))*(X(I)-WRK1(I))
+! ENDDO
+! CALLMPI ( M_sum_z(COMM, CSUM, 1))
+! io_begin
+! WRITE(*,*) 
+! WRITE(*,*) '<W(iter-1)|rho(iter)-rho(iter-1)>',CSUM
+! io_end
+
+! CALL BRGET_1(NDIM,WRK1,'I',ITER,IOD,ITER,IERR)
+! DO IT=1,ITERM1
+!    CALL BRGET_1(NDIM,WRK2,'F',IT,IOD,ITER,IERR)  
+!    DO I=1,NDIM
+!       WRK1(I)=WRK1(I)-VA(IT)*WRK2(I)
+!    ENDDO
+! ENDDO
+! CALL BRSAV_1(NDIM,WRK1,'I',ITER,IOD,ITER,IERR)
+
+! CALL BRGET_1(NDIM,WRK1,'P',ITER,IOD,ITER,IERR)
+! DO IT=1,ITERM1
+!    CALL BRGET_1(NDIM,WRK2,'D',IT,IOD,ITER,IERR)  
+!    DO I=1,NDIM
+!       WRK1(I)=WRK1(I)-VA(IT)*WRK2(I)
+!    ENDDO
+! ENDDO
+! CALL BRSAV_1(NDIM,WRK1,'P',ITER,IOD,ITER,IERR)
+3000 CONTINUE
+! IF (LSOFT .AND. ITER>1) THEN
+!    IF (ITERM1==MAXIT-1) THEN
+!       ITER=0
+!    ELSEIF (DMAX>1E4 .OR. SMIN<1E-4) THEN 
+!    !  LSOFT=.FALSE.
+!      ITER=0
+!    ENDIF
+! ENDIF
+! Now we have the output vector |X(iter+1)> and all is done - good bye:
+#ifndef USE_TMPBROYD
+   CALL BRRMTMP()
+#endif
+
+   PROFILING_STOP('broyd')
+
+   RETURN
+   END SUBROUTINE
+
+
+!************************* SUBROUTINE BRSAV_1 ****************************
+!
+! Save a vector necessary for Broyden mixing
+! in each iteration 3 datasets are used
+!  F   gradient vector   |Delta F> (|F> for last iteration!!!)
+!  Z   vector Z as defined in Johnsons paper (and corrected by gK)
+!  U   vector U as defined in Johnsons paper
+!      i.e |U> = G^(1) |Delta F> + |Delta X>:
+!  W   |Delta W>:
+!  D   metric|Delta F>
+!  the first 3 records of the file  (or broyden_storage)
+!  are used to store
+!  G   start mixing G^(1)
+!  X   |X^(iter)> (used as |X^(iter-1)> in next iteration)
+!  P   metric * residual vector |FP^(iter)>
+!  in addition temporary 'swap  areas' are used
+!  T   temporary
+!***********************************************************************
+
+
+         SUBROUTINE BRSAV_1(NDIM,DATA,WHAT,ITER,IOD,ITNOW,IERR)
+         USE prec
+         USE broyden
+         IMPLICIT REAL(q) (A-H,O-Z)
+   
+         CHARACTER (1) WHAT
+         COMPLEX(q) DATA
+         DIMENSION DATA(NDIM),IOD(3)
+   
+         PROFILING_START('BRSAV_1')
+   
+         IERR=0
+#ifdef USE_TMPBROYD
+            IU=IOD(1)
+            SELECT CASE (WHAT)
+               CASE ('F')
+               IREC=5*ITER+0
+               CASE ('U')
+               IREC=5*ITER+1
+               CASE ('Z')
+               IREC=5*ITER+2
+               CASE ('W')
+               IREC=5*ITER+3
+               CASE ('D')
+               IREC=5*ITER+4
+               CASE ('G')
+               IREC=1
+               CASE ('X')
+               IREC=2
+               CASE ('P')
+               IREC=3
+               CASE ('I')
+               IREC=4
+               CASE ('T')
+               IREC=5*ITNOW+ITER
+            END SELECT
+   
+            WRITE(IU,REC=IREC,ERR=2) CMPLX(DATA,KIND=q)
+   
+            PROFILING_STOP('BRSAV_1')
+   
+            RETURN
+      2      IERR=1
+   
+         PROFILING_STOP('BRSAV_1')
+   
+         RETURN
+#else
+         IF (WHAT=='T') THEN
+            CALL dyn_put(tmp_storage,NDIM,ITER,DATA,IERR)
+         ELSE
+            SELECT CASE (WHAT)
+            CASE ('F')
+               IREC=5*ITER+0
+            CASE ('U')
+               IREC=5*ITER+1
+            CASE ('Z')
+               IREC=5*ITER+2
+            CASE ('W')
+               IREC=5*ITER+3
+            CASE ('D')
+               IREC=5*ITER+4
+            CASE ('G')
+               IREC=1
+            CASE ('X')
+               IREC=2
+            CASE ('P')
+               IREC=3
+            CASE ('I')
+               IREC=4
+            END SELECT
+            CALL dyn_put(broyden_storage,NDIM,IREC,DATA,IERR)
+         ENDIF
+   
+         PROFILING_STOP('BRSAV_1')
+   
+         RETURN
+#endif
+         END SUBROUTINE
+   
+   !************************* SUBROUTINE BRGET_1 ****************************
+   !
+   ! Get some data stored previously (conventions see routine BRSAV_1):
+   !
+   !***********************************************************************
+   
+         SUBROUTINE BRGET_1(NDIM,DATA,WHAT,ITER,IOD,ITNOW,IERR)
+         USE prec
+         USE broyden
+         IMPLICIT REAL(q) (A-H,O-Z)
+   
+         CHARACTER (1) WHAT
+         COMPLEX(q) DATA
+         DIMENSION DATA(NDIM),IOD(3)
+         COMPLEX(q) DATA_TMP(NDIM)
+   
+         PROFILING_START('BRGET_1')
+   
+         IERR=0
+#ifdef USE_TMPBROYD
+            IU=IOD(1)
+            SELECT CASE (WHAT)
+            CASE ('F')
+               IREC=5*ITER+0
+            CASE ('U')
+               IREC=5*ITER+1
+            CASE ('Z')
+               IREC=5*ITER+2
+            CASE ('W')
+               IREC=5*ITER+3
+            CASE ('D')
+               IREC=5*ITER+4
+            CASE ('G')
+               IREC=1
+            CASE ('X')
+               IREC=2
+            CASE ('P')
+               IREC=3
+            CASE ('I')
+               IREC=4
+            CASE ('T')
+               IREC=5*ITNOW+ITER
+            END SELECT
+   
+            READ(IU,REC=IREC,ERR=2) DATA_TMP
+            DATA=DATA_TMP
+   
+            PROFILING_STOP('BRGET_1')
+   
+            RETURN
+      2      IERR=1
+   
+         PROFILING_STOP('BRGET_1')
+   
+         RETURN
+#else
+         IF (WHAT=='T') THEN
+            CALL dyn_get(tmp_storage,NDIM,ITER,DATA,IERR)
+         ELSE
+            SELECT CASE (WHAT)
+            CASE ('F')
+               IREC=5*ITER+0
+            CASE ('U')
+               IREC=5*ITER+1
+            CASE ('Z')
+               IREC=5*ITER+2
+            CASE ('W')
+               IREC=5*ITER+3
+            CASE ('D')
+               IREC=5*ITER+4
+            CASE ('G')
+               IREC=1
+            CASE ('X')
+               IREC=2
+            CASE ('P')
+               IREC=3
+            CASE ('I')
+               IREC=4
+            END SELECT
+            CALL dyn_get(broyden_storage,NDIM,IREC,DATA,IERR)
+         ENDIF
+   
+         PROFILING_STOP('BRGET_1')
+   
+         RETURN
+#endif
+         END SUBROUTINE
+
+!=======================================================================
+! removes NSHIFT elements from a matrix AMAT
+! NORDER is the final rank of the matrix
+!=======================================================================
+
+SUBROUTINE BR_SHIFT_CMATRIX(AMAT,NDIM,NORDER,ISHIFT)
+   USE prec
+   COMPLEX(q) AMAT(NDIM,NDIM)     ! matrix from which to remove elements
+   INTEGER NDIM                ! leading dimension of matrix
+   INTEGER NORDER              ! final rank of matrix
+   INTEGER ISHIFT              ! magnitude of shift
+
+   DO I=1,NORDER
+      DO J=1,NORDER
+         AMAT(I,J)=AMAT(I+ISHIFT,J+ISHIFT)
+      ENDDO
+   ENDDO
+   END SUBROUTINE BR_SHIFT_CMATRIX
+
+   SUBROUTINE INVERSZ(A,N,LDA,B,AUX,IPIV,VV)
+      use prec
+   !  INVERS(AMAT,ITERM1,MAXIT,BETA,AUX,IPIV,VV)
+      INTEGER :: N,LDA
+      INTEGER :: lwork,I,J
+      INTEGER :: info
+      COMPLEX(q) :: A(LDA,LDA),B(LDA,LDA),AUX(LDA,LDA),VV(N)
+      INTEGER :: IPIV(N)
+      COMPLEX(q):: work(4*N)
+      EXTERNAL :: ZGETRF,ZGETRI
+
+      LWORK=4*N !c this should be optimized using ILAENV
+
+      DO I=1,N
+         DO J=1,N
+            AUX(J,I)=A(J,I)
+         ENDDO
+      ENDDO
+
+      CALL ZGETRF( N, N, AUX, LDA, IPIV, INFO )
+
+      IF (INFO==0) THEN
+         CALL ZGETRI( N, AUX, LDA, IPIV, WORK, LWORK, INFO )
+         IF (INFO .NE. 0) THEN
+            WRITE(*,'(A,I3,A)') 'INVERSE_Z(ZGETRI):',INFO
+            STOP
+         ENDIF
+      ELSE
+         WRITE(*,'(A,I3,A)') 'INVERSE_Z(ZGETRF):',INFO 
+         STOP
+      ENDIF 
+      DO I=1,N
+         DO J=1,N
+            B(J,I)=AUX(J,I)
+         ENDDO
+      ENDDO
+      END SUBROUTINE INVERSZ
+
+   SUBROUTINE SVD_INVERSZ(A,N,LDA,ETA,B,S)
+      use prec
+      IMPLICIT NONE
+   !  INVERS(AMAT,ITERM1,MAXIT,BETA,AUX,IPIV,VV)
+      INTEGER :: N,LDA
+      COMPLEX(q) :: A(LDA,LDA),B(LDA,LDA)
+      REAL(q):: ETA
+   ! local variable
+      COMPLEX(q) :: AMAT(N,N),U(N,N),VT(N,N),SMAT(N,N)
+      REAL(q) :: S(N),smax
+      INTEGER, PARAMETER   :: LWMAX=20000
+      COMPLEX(q) :: WORK(LWMAX) ! enough for N<=100
+      REAL(q) :: RWORK(N*(5*N+7)+100)
+      INTEGER :: LWORK,I,J
+      INTEGER :: IWORK(8*N)
+      INTEGER :: INFO
+      
+      AMAT=A(1:N,1:N)
+
+      WORK=0
+      !Query the optimal workspace
+      LWORK = -1
+      CALL ZGESDD( 'A', N, N, AMAT, N, S, U, N , VT,&
+               N, WORK, LWORK,RWORK,IWORK, INFO)
+
+      LWORK = MIN( LWMAX, INT( WORK( 1 ) ) )
+
+      CALL ZGESDD( 'A', N, N, AMAT, N, S, U, N , VT,&
+               N, WORK, LWORK,RWORK,IWORK, INFO)
+      !check for convergence
+      IF( INFO.GT.0 ) THEN
+         WRITE(*,*)'CAL_SVD_REAL Error: DGESDD failed to converge.',INFO
+         STOP
+      ENDIF
+
+      ! smax = MAXVAL(ABS(S(1:N)))*ETA
+      smax = MIN(ETA,2E-4_q*MAXVAL(ABS(S(1:N))))
+      ! smax=0
+
+      SMAT=0._q
+      DO I = 1,N
+         SMAT(I,I) = ABS(S(I))/(S(I)**2+smax**2)
+      ENDDO
+
+      SMAT = MATMUL(SMAT,conjg(transpose(U)))
+      B(1:N,1:N) = MATMUL(conjg(transpose(VT)),SMAT)
+      END SUBROUTINE SVD_INVERSZ
+
+      SUBROUTINE SVDZ(A,N,LDA,U,S,VT)
+      use prec
+      IMPLICIT NONE
+   !  INVERS(AMAT,ITERM1,MAXIT,BETA,AUX,IPIV,VV)
+      INTEGER :: N,LDA
+      COMPLEX(q) :: A(LDA,LDA),U(LDA,LDA),VT(LDA,LDA)
+      REAL(q):: ETA
+   ! local variable
+      COMPLEX(q) :: AMAT(N,N)
+      REAL(q) :: S(LDA)
+      INTEGER, PARAMETER   :: LWMAX=20000
+      COMPLEX(q) :: WORK(LWMAX) ! enough for N<=100
+      REAL(q) :: RWORK(N*(5*N+7)+100)
+      INTEGER :: LWORK,I,J
+      INTEGER :: IWORK(8*N)
+      INTEGER :: INFO
+      
+      AMAT=A(1:N,1:N)
+
+      WORK=0
+      !Query the optimal workspace
+      LWORK = -1
+      CALL ZGESDD( 'A', N, N, AMAT, N, S, U, LDA , VT,&
+               LDA, WORK, LWORK,RWORK,IWORK, INFO)
+
+      LWORK = MIN( LWMAX, INT( WORK( 1 ) ) )
+
+      CALL ZGESDD( 'A', N, N, AMAT, N, S, U, LDA , VT,&
+               LDA, WORK, LWORK,RWORK,IWORK, INFO)
+      !check for convergence
+      IF( INFO.GT.0 ) THEN
+         WRITE(*,*)'CAL_SVD_REAL Error: DGESDD failed to converge.',INFO
+         STOP
+      ENDIF
+      END SUBROUTINE SVDZ
+
+
+
+      SUBROUTINE BROYD_1(NDIM,F,X,FP,WC,IB,NUPDZ,MAXIT,LKEEP,REMOVE, &
+      &                  B,NGIGA,WRK1,WRK2,INI,IU,LOPEN,ICMPLX,MRECL, &
+      &                  RMS,RMSP,WEIGHT,NEIG,EIGENVAL,AMEAN,IERR,ETA &
+#ifdef MPI
+                           ,COMM &
+#endif
+                        )
+         USE prec
+         USE mpimy
+         use broyden
+         IMPLICIT COMPLEX(q) (C)
+         IMPLICIT REAL(q) (A-B,D-H,O-Z)
+   
+#ifdef MPI
+         TYPE (communic) COMM
+#endif
+   
+         PARAMETER(WEIMAX=33._q)
+         LOGICAL INI,LOPEN,LREDUC
+         LOGICAL LKEEP     ! keep Hessian matrix even at reset
+         COMPLEX(q) CTMP
+         COMPLEX(q) F(NDIM),X(NDIM),FP(NDIM),WRK1(NGIGA),WRK2(NDIM)
+         REAL(q)    B(3,3)
+   
+         COMPLEX(q)    BETAQ(MAXIT,MAXIT),AMAT(MAXIT,MAXIT),BETA(MAXIT,MAXIT)
+         COMPLEX(q)    AUX(MAXIT,MAX(8,MAXIT)),VV(MAXIT)
+         REAL(q)    GP(MAXIT,MAXIT),SP(MAXIT,MAXIT)
+   
+         INTEGER    IOD(3),INDEX(MAXIT)
+         REAL(q)    AUXR(MAXIT),AUXI(MAXIT),AUXBET(MAXIT),S(MAXIT)
+         COMPLEX(q) AUXC(MAXIT)
+         REAL(q)    EIGENVAL(512),ETA
+   
+         REAL(q), ALLOCATABLE,SAVE :: WI(:)
+         COMPLEX(q), ALLOCATABLE,SAVE :: FINF(:,:), GMAT(:,:),SMAT(:,:)
+         SAVE ITER,ICALL,IOD,LASTIT
+         DATA ITER /0/,ICALL /0/,LASTIT /0/
+   
+         INTEGER REMOVE   ! how many vectors are removed once MAXMIX is reached
+   
+         PROFILING_START('broyd')
+   
+#if defined(USE_TMPBROYD) && defined(MPI)
+         MPI + use of file for MIXING is not supported please undef USE_TMPBROYD
+#endif
+         NODE_ME=0
+         IONODE =0
+#ifdef MPI
+         NODE_ME= COMM%NODE_ME
+         IONODE = COMM%IONODE
+#endif
+         NEIG=0
+   !=======================================================================
+   ! First call: initialise some I/O-things ...
+   !=======================================================================
+         IF (ICALL==0) THEN
+            ALLOCATE(WI(MAXIT),FINF(MAXIT,MAXIT), &
+                     GMAT(MAXIT,MAXIT),SMAT(MAXIT,MAXIT))
+            WI=0
+            FINF=0
+            GMAT=0
+            SMAT=0
+   
+            IRECL=NDIM*ICMPLX
+   ! Save some I/O-data ... :
+            IOD(1)=IU
+            IOD(2)=-1
+            IOD(3)=1
+            ICALL=1
+   
+#ifdef USE_TMPBROYD
+   ! Open the save file for iteration data ... :
+            IF (LOPEN) THEN
+               OPEN(UNIT=IU,FILE='TMPBROYD',ACCESS='DIRECT', &
+      &                                    FORM='UNFORMATTED',RECL=IRECL)
+            ELSE
+               OPEN(UNIT=IU,ACCESS='DIRECT',FORM='UNFORMATTED',RECL=IRECL)
+            END IF
+#else
+            CALL BRNULL()
+#endif
+         END IF
+   !=======================================================================
+   ! calculate some necessary quantities
+   !=======================================================================
+   
+   ! Restart of mixing forced externally by setting INI = .TRUE. (this must
+   ! be used for example after an ionic step / setup of a new geometry):
+         IF (INI .AND. ITER/=0 ) THEN
+         IF (.NOT. LKEEP .OR. MAXIT-ITER < -1 ) THEN
+            ITER=0
+            LASTIT=0
+         ELSE
+   ! keep mixing information alive (i.e. use it as an initial approximation
+   ! for  the present charge dielectric function)
+            ITER=ITER-1
+            LASTIT=ITER
+         ENDIF
+         ENDIF
+   ! usually it makes no sense to proceed if one cannot converge after so
+   ! many steps - if there is some little hope at all, then by removing
+   ! vectors from the iteration history
+   ! currently REMOVE vectors are removed if MAXIT is reached
+         IF (ITER == MAXIT ) THEN
+            ISHIFT=MIN(REMOVE,ITER)
+   !        WRITE(*,*) 'removing ',ISHIFT,' from iteration history'
+            ITER  =ITER-ISHIFT
+            LASTIT=MAX(0,LASTIT-ISHIFT)
+            ! shift all saved arrays and vectors
+            CALL BR_SHIFT_CMATRIX(GMAT,MAXIT,ITER,ISHIFT)
+            CALL BR_SHIFT_CMATRIX(SMAT,MAXIT,ITER,ISHIFT)
+            CALL BR_SHIFT_CMATRIX(FINF,MAXIT,ITER,ISHIFT)
+            CALL BR_SHIFT_VEC   (WI,1,ITER,ISHIFT)
+            ! shift all stored vectors
+            DO I=1,ITER-1
+            CALL BRGET_1(NDIM,WRK1,'F',I+ISHIFT,IOD,ITER,IERR)
+            CALL BRGET_1(NDIM,WRK2,'U',I+ISHIFT,IOD,ITER,IERR)
+            CALL BRSAV_1(NDIM,WRK1,'F',I,IOD,ITER,IERR)
+            CALL BRSAV_1(NDIM,WRK2,'U',I,IOD,ITER,IERR)
+            CALL BRGET_1(NDIM,WRK1,'Z',I+ISHIFT,IOD,ITER,IERR)
+            CALL BRSAV_1(NDIM,WRK1,'Z',I,IOD,ITER,IERR)
+            CALL BRGET_1(NDIM,WRK1,'W',I+ISHIFT,IOD,ITER,IERR)
+            CALL BRSAV_1(NDIM,WRK1,'W',I,IOD,ITER,IERR)
+            CALL BRGET_1(NDIM,WRK1,'D',I+ISHIFT,IOD,ITER,IERR)
+            CALL BRSAV_1(NDIM,WRK1,'D',I,IOD,ITER,IERR)
+            ENDDO
+         ENDIF
+   ! Restart of mixing if MAXIT is the same as ITER
+   ! not effective with the few lines above
+         ITER=MOD(ITER,MAXIT)
+   ! Increment iteration counter:
+         ITER=ITER+1
+   ! Number of previous iteration:
+         ITERM1=ITER-1
+   ! Change of vector |X>
+         SUM_=0
+         SUMP=0
+         DO I=1,NDIM
+            SUMP=SUMP+CONJG(F(I))*FP(I)
+            SUM_=SUM_  +CONJG(F(I))*F(I)
+         ENDDO
+         CALLMPI( M_sum_d(COMM, SUM_, 1))
+         CALLMPI( M_sum_d(COMM, SUMP, 1))
+         RMSP=SQRT(SUMP)
+         RMS =SQRT(SUM_)
+         DWRITE0 'rms',RMS,RMSP
+   ! Relative weight (W_iter/W_0) used for the current iteration ... :
+         IF (WC>=0._q) THEN
+         WI(ITER)=WC
+         ELSE
+   ! Try to set weights automatically (not recommended)
+         WI(ITER)=0.01_q*ABS(WC)/SUMP
+         END IF
+   ! Do not allow too strange weights ... :
+         IF (WI(ITER) < 1)     WI(ITER)=1
+         IF (WI(ITER) > 1E6  ) WI(ITER)=1E6
+         IF (WC==0 )           WI(ITER)=100
+   
+   ! Here Broydens 2nd method (slightly generalized) can be switched on:
+         IF (IB/=0) THEN
+            DO I=1,ITERM1
+            WI(I)=0
+            ENDDO
+            DO I=MAX(1,ITERM1-IB+1),ITERM1
+            WI(I)=100
+            ENDDO
+         ENDIF
+   ! it is possible to give all iterations including LASTIT
+   ! zero weight
+   ! this means that information collected up to LASTIT is overwritten
+   ! when updating the Hessian matrix
+   !      WI(1:LASTIT)=0
+   
+         WEIGHT=WI(ITER)
+   !=======================================================================
+   ! First iteration is a conventional linear mixing using G^(1):
+   !=======================================================================
+         IF (ITER==1 .OR.INI) THEN
+            IF (.NOT.INI) THEN
+   ! Can only be reset by ITER>MAXIT here, try again initial start mixing:
+               IF (NODE_ME /= IONODE) &
+               WRITE(*,*) 'Iteration count exceeded MAXIT =',MAXIT
+   ! Get initial (diagonal) mixing used previously ... :
+               CALL BRGET_1(NDIM,WRK1,'G',ITER,IOD,ITER,IERR)
+               IF (IERR/=0) THEN
+                  PROFILING_STOP('broyd')
+                  RETURN
+               END IF
+            END IF
+            IF (ITER==1) THEN
+#ifdef USE_TMPBROYD
+         ! Delete and reopen file TMPBROYD (or clean temproray work area)...
+            CALL CLEAN(IU)
+#else
+            CALL CLBROYD(IU)
+#endif
+         ! allocate for next 4 steps
+            CALL BRSAV_1(NDIM,F,'Z',ITER+3,IOD,ITER+3,IERR)
+            ENDIF
+   ! First save some things needed later: |XLAST>, |F^(1)> and |FP^(1)>:
+            CALL BRSAV_1(NDIM,FP,'P',ITER,IOD,ITER,IERR)
+            IF (IERR/=0) THEN
+               PROFILING_STOP('broyd')
+               RETURN
+            END IF
+            CALL BRSAV_1(NDIM,X,'X',ITER,IOD,ITER,IERR)
+            IF (IERR/=0) THEN
+               PROFILING_STOP('broyd')
+               RETURN
+            END IF
+            CALL BRSAV_1(NDIM,F,'I',ITER,IOD,ITER,IERR)
+            IF (IERR/=0) THEN
+               PROFILING_STOP('broyd')
+               RETURN
+            END IF
+   ! Now save also the start mixing G^(1) supplied on array WRK1:
+            CALL BRSAV_1(NDIM,WRK1,'G',ITER,IOD,ITER,IERR)
+            IF (IERR/=0) THEN
+               PROFILING_STOP('broyd')
+               RETURN
+            END IF
+   
+            GOTO 2000
+   ! Mix (here we need no metric because for simple linear mixing
+   ! using a diagonal G0 the result is the same with and without metric.):
+            DO I=1,NDIM
+            X(I)=X(I)+WRK1(I)*F(I)
+            ENDDO
+   ! That is all for the first ... :
+            PROFILING_STOP('broyd')
+            RETURN
+         END IF
+   
+         IF (MOD(ITER,5)==1) THEN
+   ! force allocation in junks of 5 data blocks to avoid memory fragmentation
+            CALL BRSAV_1(NDIM,F,'Z',ITER+3,IOD,ITER+3,IERR)
+         ENDIF
+   !=======================================================================
+   ! BROYDEN updating for ITER > 1 ... :
+   !=======================================================================
+   !Get |F> and |FP> from last iteration
+         CALL BRGET_1(NDIM,WRK1,'P',ITERM1,IOD,ITER,IERR)
+         IF (IERR/=0) THEN
+            PROFILING_STOP('broyd')
+            RETURN
+         END IF
+         CALL BRGET_1(NDIM,WRK2,'I',ITERM1,IOD,ITER,IERR)
+         IF (IERR/=0) THEN
+            PROFILING_STOP('broyd')
+            RETURN
+         END IF
+   ! Save actual |F> and |FP>:
+         CALL BRSAV_1(NDIM,F,'I',ITER,IOD,ITER,IERR)
+         IF (IERR/=0) THEN
+            PROFILING_STOP('broyd')
+            RETURN
+         END IF
+         CALL BRSAV_1(NDIM,FP,'P',ITER,IOD,ITER,IERR)
+         IF (IERR/=0) THEN
+            PROFILING_STOP('broyd')
+            RETURN
+         END IF
+         DO I=1,NDIM
+         ! |FP^(iter)>-|FP^(iter-1)>:
+            FP(I)=FP(I)-WRK1(I)
+         ! |F^(iter)>-|F^(iter-1)>:
+         F(I)=F(I)-WRK2(I)
+         ENDDO
+   ! Norm of this vector (with integration weights/metric. included ...):
+         FNORM=0._q
+         DO  I=1,NDIM
+         FNORM=FNORM+FP(I)*CONJG(F(I))
+         ENDDO
+         CALLMPI( M_sum_d( COMM, FNORM, 1))
+         io_begin
+         WRITE(*,*) "iteration _ BROYD_1", ITERM1
+         WRITE(*,*) "FNORM",FNORM
+         io_end
+         FNORM=1._q/SQRT(FNORM)
+   ! Build |Delta F^(iter-1)>, |Delta FP^(iter-1)>:
+         DO I=1,NDIM
+            FP(I)=FP(I)*FNORM
+            F(I)=F(I)*FNORM
+         ENDDO
+   ! Save |Delta F^(iter-1)>:
+         CALL BRSAV_1(NDIM,F,'F',ITERM1,IOD,ITER,IERR)
+         CALL BRSAV_1(NDIM,FP,'D',ITERM1,IOD,ITER,IERR)
+         IF (IERR/=0) THEN
+            PROFILING_STOP('broyd')
+            RETURN
+         END IF
+   ! Get |X^(iter-1)> from last iteration:
+         CALL BRGET_1(NDIM,WRK2,'X',ITERM1,IOD,ITER,IERR)
+         IF (IERR/=0) THEN
+            PROFILING_STOP('broyd')
+            RETURN
+         END IF
+   ! Save actual |X^(iter)>:
+         CALL BRSAV_1(NDIM,X,'X',ITER,IOD,ITER,IERR)
+         IF (IERR/=0) THEN
+            PROFILING_STOP('broyd')
+            RETURN
+         END IF
+   ! Build |Delta X^(iter-1)> = (|X^(iter)>-|X^(iter-1)>)/||F||_w :
+         DO I=1,NDIM
+         WRK1(I)=(X(I)-WRK2(I))*FNORM
+         ENDDO
+      CSUM=0
+      SUM1=0
+      DO I=1,NDIM
+         CSUM=CSUM+CONJG(WRK1(I))*FP(I) ! DX(iter-1) can be reproduced by WRK1(I+NDIM)-WRK1(I)
+         SUM1=SUM1+CONJG(WRK1(I))*WRK1(I)
+      ENDDO
+      CALLMPI( M_sum_z( COMM, CSUM, 1))
+      CALLMPI( M_sum_d( COMM, SUM1, 1))
+      io_begin
+      WRITE(*,*) "<rho|metric|R(rho)>",CSUM
+      WRITE(*,*) "<rho|rho>",SUM1
+      io_end
+         CALL BRSAV_1(NDIM,WRK1,'W',ITERM1,IOD,ITER,IERR)
+   ! Vector |U^(iter-1)> = G^(1) |Delta F^(iter-1)> + |Delta X^(iter-1)>:
+         CALL BRGET_1(NDIM,WRK2,'G',ITER,IOD,ITER,IERR)
+         IF (IERR/=0) THEN
+            PROFILING_STOP('broyd')
+            RETURN
+         END IF
+         DO I=1,NDIM
+         CTMP=WRK1(I)
+         WRK1(I)=WRK2(I)*F(I)
+         WRK1(I+NDIM)=CTMP+WRK2(I)*F(I)
+         WRK2(I)=CTMP+WRK2(I)*F(I)
+         ENDDO
+   ! Save |U^(iter-1)>:
+         CALL BRSAV_1(NDIM,WRK2,'U',ITERM1,IOD,ITER,IERR)
+         IF (IERR/=0) THEN
+            PROFILING_STOP('broyd')
+            RETURN
+         END IF
+         ! calculate W
+         CALL BRGET_1(NDIM,WRK2,'W',ITERM1,IOD,ITER,IERR)
+         DO I=1,NDIM
+         WRK2(I)=F(I)
+         ENDDO
+         CALL BRSAV_1(NDIM,WRK2,'W',ITERM1,IOD,ITER,IERR)
+   !=======================================================================
+   ! Matrix FINF: we must only add the elements (iter-1,j) and (j,iter-1):
+   !   FINF(j,iter-1) = <D F(j) | metric |  D F(iter-1) >
+   !=======================================================================
+         DO J=1,ITERM1
+            CALL BRGET_1(NDIM,WRK2,'W',J,IOD,ITER,IERR)
+            IF (IERR/=0) THEN
+               PROFILING_STOP('broyd')
+               RETURN
+            END IF
+            CSUM_=0
+            DO I=1,NDIM
+            CSUM_=CSUM_+CONJG(WRK2(I))*FP(I)
+            ENDDO
+   
+            FINF(J,ITERM1)=REAL(CSUM_)
+            FINF(ITERM1,J)=REAL(CSUM_)
+
+            CALL BRGET_1(NDIM,WRK2,'F',J,IOD,ITER,IERR)
+            SUM1=0
+            SUM2=0
+         !  SUM1=<D F(j)| G(1) |D F(iter-1)>
+         !  SUM2=<D F(j)| U^(iter-1)> = <D F(j)| G(m)-G(1) | D F^(iter-1)>
+            DO I=1,NDIM
+            SUM1=SUM1+CONJG(WRK2(I))*WRK1(I)
+            SUM2=SUM2-CONJG(WRK2(I))*WRK1(I+NDIM)
+            ENDDO
+            SMAT(J,ITERM1)=SUM1
+            SMAT(ITERM1,J)=SUM1
+            GMAT(J,ITERM1)=SUM2
+         ENDDO
+   
+         CALL BRGET_1(NDIM,WRK1,'F',ITERM1,IOD,ITER,IERR)
+   
+         DO J=1,ITERM1
+            CALL BRGET_1(NDIM,WRK2,'U',J,IOD,ITER,IERR)
+            IF (IERR/=0) THEN
+               PROFILING_STOP('broyd')
+               RETURN
+            END IF
+         ! SUM_=<D F(iter-1)| U^(j)>
+            SUM_=0
+            DO I=1,NDIM
+            SUM_=SUM_+CONJG(WRK1(I))*WRK2(I)
+            ENDDO
+            GMAT(ITERM1,J)=-SUM_
+         ENDDO
+   
+         CALLMPI( M_sum_z(COMM, SMAT(1,ITERM1), ITERM1))
+         CALLMPI( M_sum_z(COMM, FINF(1,ITERM1), ITERM1))
+         CALLMPI( M_sum_z(COMM, GMAT(1,ITERM1), ITERM1))
+         CALLMPI( M_sum_z(COMM, GMAT(ITERM1,1:ITERM1), ITERM1-1))
+         FINF(ITERM1,ITERM1)=1._q
+   
+         ! correct transposed elements
+         DO J=1,ITERM1-1
+         FINF(ITERM1,J)=FINF(J,ITERM1)
+         SMAT(ITERM1,J)=SMAT(J,ITERM1)
+         ENDDO
+   
+   ! Matrix A:
+         DO J=1,ITERM1
+         AMAT(J,J)=0._q+WI(J)*WI(J)*FINF(J,J)
+         DO K=1,J-1
+            AMAT(J,K)=FINF(J,K)*WI(J)*WI(K)
+            AMAT(K,J)=FINF(K,J)*WI(K)*WI(J)
+         ENDDO
+         ENDDO
+         IDUMP=0
+         io_begin
+         IF (IDUMP==1) THEN
+         WRITE(*,*) 
+         WRITE(*,*)'AMAT'
+         DO I=1,ITERM1
+            WRITE(*,'(99F16.8)') (AMAT (I,J),J=1,ITERM1)
+         ENDDO
+         WRITE(*,*)'FINF'
+         DO I=1,ITERM1
+            WRITE(*,'(99F16.8)') (FINF(I,J),J=1,ITERM1)
+         ENDDO
+         ENDIF
+         io_end
+   
+   
+   ! Matrix Beta:
+         IF (ITERM1==1) THEN
+   ! Trivial case: A is a 1x1 matrix ...
+            BETA(1,1)=1._q/AMAT(1,1)
+         ELSE
+   ! General case: Invert matrix A ...
+         !  CALL INVERSZ(AMAT,ITERM1,MAXIT,BETA,AUX,INDEX,VV)
+         CALL SVD_INVERSZ(AMAT,ITERM1,MAXIT,ETA,BETA,S)
+         io_begin
+            WRITE(*,*) "singular value of FINF"
+            WRITE(*,'(99F16.8)') (S(J)/10000,J=1,ITERM1)
+         io_end
+         END IF
+         CALLMPI( M_bcast_z(COMM,BETA(1,1),SIZE(BETA)))
+   !=======================================================================
+   !  solve eigenvalue problem
+   !   G e = lambda G^1 e
+   !  where G is the approximation of the Hessian matrix
+   !  works only for Pulay mixing because we assume  G |d F> = | d X>
+   !=======================================================================
+      io_begin
+         DO I=1,ITERM1
+         DO J=1,ITERM1
+         GP(I,J)=GMAT(I,J)
+         SP(I,J)=SMAT(I,J)
+         ENDDO
+         ENDDO
+   
+         IDUMP=0
+         IF (IDUMP==1) THEN
+         WRITE(*,*)'SMAT'
+         DO  I=1,ITERM1
+            WRITE(*,'(10F16.8)') (SP(I,J),J=1,ITERM1)
+         ENDDO
+         WRITE(*,*)'GMAT'
+         DO I=1,ITERM1
+            WRITE(*,'(10F16.8)') (GP(I,J),J=1,ITERM1)
+         ENDDO
+         ENDIF
+         INFO=1
+         IF (INFO/=0) THEN
+#ifdef essl
+         CALL DGEGV(0,GP,MAXIT,SP,MAXIT,AUXC,AUXBET,AUX,1,ITERM1, &
+         &        AUX,MAX(8*MAXIT,MAXIT*MAXIT))
+#else
+         CALL DGEGV('N','N',ITERM1,GP,MAXIT,SP,MAXIT,AUXR,AUXI,AUXBET, &
+         &        AUX,1,AUX,1,AUX,MAX(8*MAXIT,MAXIT*MAXIT),INFO)
+         AUXC= CMPLX( AUXR , AUXI ,KIND=q)
+#endif
+         NEIG=ITERM1
+         DO I=1,ITERM1
+            EIGENVAL(I)= ABS(AUXC(I)/MAX(AUXBET(I),1E-10_q)+1)
+         ENDDO
+         AMEAN=0
+         DO I=1,ITERM1
+            AMEAN=AMEAN+ABS(AUXC(I)/MAX(AUXBET(I),1E-10_q)+1)
+         END DO
+         AMEAN=AMEAN/ITERM1
+         ENDIF
+      io_end
+   !=======================================================================
+   ! Calculate BETAQ used in the update of Z.(formula in Johnsons paper is
+   ! wrong if weights are not equal, here is the correct version - by gK):
+   ! a few comments here:
+   !   for Pulays      approach BETAQ is strictly 0 (equ. 103)
+   !   for Broydens 2. approach BETAQ and BETA have the structure
+   !            BETAQ     1   0   0      BETA=0 except for
+   !                      0   1   0      BETA(ITERM1,ITERM1)=1
+   !                      0   0   1
+   !                     g_1 g_2  g_3
+   !            (see equ. 104 and 105 in gK)
+   !=======================================================================
+         LREDUC=.TRUE.
+         BETAQ=0
+      !  DO I=1,ITERM1
+      !    LREDUC=LREDUC.AND.(WI(I)>=WEIMAX)
+      !    DO IT=1,ITERM1-1
+      !      BETAQ(I,IT)=0._q
+      !      DO J=1,ITERM1
+      !        BETAQ(I,IT)=BETAQ(I,IT)-WI(I)*BETA(I,J)*WI(J)*FINF(J,IT)
+      !      ENDDO
+      !    ENDDO
+      !    BETAQ(I,I)=BETAQ(I,I)+1
+      !  ENDDO
+   
+      !  IDUMP=0
+      !  io_begin
+      !  IF (IDUMP==1) THEN
+      !    WRITE(*,*)'BETA'
+      !    DO I=1,ITERM1
+      !      WRITE(*,'(10F16.8)') (BETA (I,J)*WI(I)*WI(J),J=1,ITERM1)
+      !    ENDDO
+      !    WRITE(*,*)'BETAQ'
+      !    DO I=1,ITERM1
+      !      WRITE(*,'(10F16.8)') (BETAQ(I,J),J=1,ITERM1-1)
+      !    ENDDO
+      !  ENDIF
+      !  io_end
+      !  IDUMP=0
+   
+   ! Reload |FP^(iter)>:
+         CALL BRGET_1(NDIM,FP,'P',ITER,IOD,ITER,IERR)
+         IF (IERR/=0) THEN
+            PROFILING_STOP('broyd')
+            RETURN
+         END IF
+   !=======================================================================
+   ! update all the vectors |Z_it^(m-1)> - if WRK1 is dimensioned large
+   ! enough several vectors Z are updated simultaneously to reduce I/O!
+   !=======================================================================
+         DO IT=1,ITERM1,NUPDZ
+   ! Number of vectors to be updated simultaneously:
+            NUPDM=MIN(NUPDZ,ITERM1-IT+1)
+            DO I=1,NDIM*NUPDM
+            WRK1(I)=(0._q,0._q)
+            ENDDO
+   ! Sum_{im=1,iter-2} BETAQ_{it,im} |Z_im^(iter-2)> - warning, do not be
+   ! confused: array F is here used as a workarray ... !
+            IF (.NOT.LREDUC) THEN
+   ! Remark: this part is not used at all if all weigths are very large!
+               DO IM=1,ITERM1-1
+   ! Selective treatment for steps with "smaller" weights ... :
+                  IF (WI(IM)>=(10._q*WEIMAX)) CYCLE
+                  CALL BRGET_1(NDIM,F,'Z',IM,IOD,ITER,IERR)
+                  IF (IERR/=0) THEN
+                     PROFILING_STOP('broyd')
+                     RETURN
+                  END IF
+                  DO IUPD=0,NUPDM-1
+                     IF (BETAQ(IT+IUPD,IM)==0._q) CYCLE
+                     IOFF=IUPD*NDIM
+                     DO I=1,NDIM
+                     WRK1(I+IOFF)=WRK1(I+IOFF)+BETAQ(IT+IUPD,IM)*F(I)
+                     ENDDO
+                  ENDDO
+               ENDDO
+            ENDIF
+   ! Add sum_{im=1,iter-1} WI_im WI_it BETA_{it,im} |U^(im)>:
+            DO IM=1,ITERM1
+               CALL BRGET_1(NDIM,F,'U',IM,IOD,ITER,IERR)
+               IF (IERR/=0) THEN
+                  PROFILING_STOP('broyd')
+                  RETURN
+               END IF
+               DO IUPD=0,NUPDM-1
+                  IOFF=IUPD*NDIM
+                  DO  I=1,NDIM
+                  WRK1(I+IOFF)=WRK1(I+IOFF)+ &
+      &                          WI(IT+IUPD)*WI(IM)*BETA(IT+IUPD,IM)*F(I)
+                  ENDDO
+               ENDDO
+            ENDDO
+            IF (LREDUC) THEN
+   ! Save |Z>-vectors (only allowed in reduced version for large weigths):
+               DO IUPD=0,NUPDM-1
+                  IOFF=IUPD*NDIM
+                  CALL BRSAV_1(NDIM,WRK1(1+IOFF),'Z',IT+IUPD,IOD,ITER,IERR)
+                  IF (IERR/=0) THEN
+                     PROFILING_STOP('broyd')
+                     RETURN
+                  END IF
+               ENDDO
+            ELSE
+   ! Save temporarily (we may not yet destroy the old |Z>-vectors!):
+               DO IUPD=0,NUPDM-1
+                  IOFF=IUPD*NDIM
+                  IF (WI(IT+IUPD)<(10._q*WEIMAX)) THEN
+                  CALL BRSAV_1(NDIM,WRK1(1+IOFF),'T',IT+IUPD,IOD,ITER,IERR)
+                  IF (IERR/=0) THEN
+                     PROFILING_STOP('broyd')
+                     RETURN
+                  END IF
+                  ELSE
+   ! ... except unused |Z>-vectors (iterations with large weights):
+                  CALL BRSAV_1(NDIM,WRK1(1+IOFF),'Z',IT+IUPD,IOD,ITER,IERR)
+                  IF (IERR/=0) THEN
+                     PROFILING_STOP('broyd')
+                     RETURN
+                  END IF
+                  ENDIF
+               ENDDO
+            ENDIF
+         ENDDO
+   
+   ! Finally swap all updated |Z_it^(iter-1)> from temporary records 'T'
+   ! to records 'Z' (if necessary) to be prepared for the next step ... :
+         DO IT=1,ITERM1
+            IF ((.NOT.LREDUC).AND.(WI(IT)<(10._q*WEIMAX))) THEN
+               CALL BRGET_1(NDIM,WRK1,'T',IT,IOD,ITER,IERR)
+               IF (IERR/=0) THEN
+                  PROFILING_STOP('broyd')
+                  RETURN
+               END IF
+               CALL BRSAV_1(NDIM,WRK1,'Z',IT,IOD,ITER,IERR)
+               IF (IERR/=0) THEN
+                  PROFILING_STOP('broyd')
+                  RETURN
+               END IF
+            ENDIF
+         ENDDO
+   !=======================================================================
+   ! calculate (G-G^(1)) |F^(iter)>
+   !=======================================================================
+   2000 CONTINUE
+   
+   ! Reload |FP^(iter)>:
+         CALL BRGET_1(NDIM,FP,'P',ITER,IOD,ITER,IERR)
+   
+         DO IT=1,ITERM1
+   ! Get the |Delta F^(it)>:
+               CALL BRGET_1(NDIM,F,'W',IT,IOD,ITER,IERR)
+               IF (IERR/=0) THEN
+                  PROFILING_STOP('broyd')
+                  RETURN
+               END IF
+               CSUM_=0._q
+   ! Build <Delta F^(it)|FP^(iter)>:
+               DO I=1,NDIM
+               CSUM_=CSUM_+CONJG(F(I))*FP(I)
+               ENDDO
+               CALLMPI ( M_sum_z(COMM, CSUM_, 1))
+   ! Subtract |Z_it^(iter-1)><Delta F^(it)|FP^(iter)> from |X^(iter)>:
+               CALL BRGET_1(NDIM,WRK1(1),'Z',IT,IOD,ITER,IERR)
+               DO I=1,NDIM
+               X(I)=X(I)-CSUM_*WRK1(I)
+               ENDDO
+         ENDDO
+   !=======================================================================
+   ! calculate G^(1) |F^(iter)>
+   !=======================================================================
+   ! Reload |F^(iter)>:
+         CALL BRGET_1(NDIM,F,'I',ITER,IOD,ITER,IERR)
+         IF (IERR/=0) THEN
+            PROFILING_STOP('broyd')
+            RETURN
+         END IF
+   ! Reload start mixing G^(1):
+         CALL BRGET_1(NDIM,WRK1,'G',ITER,IOD,ITER,IERR)
+         IF (IERR/=0) THEN
+            PROFILING_STOP('broyd')
+            RETURN
+         END IF
+   ! Add G^(1) |F^(iter)> to vector |X^(iter)>:
+         DO I=1,NDIM
+         X(I)=X(I)+WRK1(I)*F(I)
+         ENDDO
+   
+   ! Now we have the output vector |X(iter+1)> and all is done - good bye:
+#ifndef USE_TMPBROYD
+         CALL BRRMTMP()
+#endif
+   
+         PROFILING_STOP('broyd')
+   
+         RETURN
+         END SUBROUTINE
diff -urN file_ini/emlr.F file_modify/emlr.F
--- file_ini/emlr.F	1970-01-01 08:00:00.000000000 +0800
+++ file_modify/emlr.F	2024-07-13 10:37:23.000000000 +0800
@@ -0,0 +1,2867 @@
+#include "symbol.inc"
+
+MODULE emlr
+   USE base
+   USE lattice
+   USE finite_differences
+   USE charge
+   USE pseudo
+   USE lattice
+   USE force
+   USE nonl_high
+   USE msymmetry
+   USE mpimy
+   USE mgrid
+   USE mkpoints
+   USE constant
+   USE poscar
+   USE wave
+   USE pot
+   USE ini
+   USE pawm
+   USE hamil_lr
+   USE rmm_diis_lr
+   USE subrot_lr
+   USE charge
+   USE us
+   USE wave_high
+   USE choleski
+   USE broyden
+   USE subrot
+   USE ebs
+   USE mlrf_main
+   USE subrot_cluster
+   USE kpoints_change
+   USE hamil_high
+   USE meta
+   ! solvation__
+   USE solvation
+   ! emlr
+   USE aedens
+   USE david
+
+
+   REAL(q) :: CSHIFT
+   REAL(q) :: STEP_LENGTH           ! finite differences for second derivative of potential
+                                       ! too small values cause convergence problems (noise upon calculation of POT_DER)
+                                       ! larger ones (1E-2) smooth the energy surface but increase frequencies
+   REAL(q) :: STEP_BASE                                    
+   REAL(q) :: MAGRHO0                  ! groundstate absolute magnetization, used for adaptive adjustment of STEP_LENGTH
+
+
+   ! control
+   LOGICAL :: LFERMI
+   REAL(q) :: EPRO
+   LOGICAL :: LKSHIFT
+   LOGICAL :: LNOIMAG
+   LOGICAL :: LADAPT
+   LOGICAL :: LSOFT
+
+   INTEGER :: NLS
+   REAL(q) :: LSBREAK
+   REAL(q) :: LSDEPER
+   INTEGER :: NCH
+   LOGICAL :: LCHUPD(4)
+   REAL(q) :: CHBREAK
+   REAL(q) :: RCHBREAK ! convergence criterion based on relative error.
+   INTEGER :: UNIT_EMLR_INPUT =314
+   INTEGER :: UNIT_EMLR_OUTPUT=315
+   INTEGER :: UNIT_EMLR_CHI   =316
+   INTEGER :: UNIT_EMLR_RMS   =317
+   INTEGER :: IONODE,NODE_ME
+
+   RGRID,ALLOCATABLE   :: SV1_KPQ_IND(:,:) 
+   RGRID,ALLOCATABLE   :: SV1_KPQ_IND0(:,:)       
+   OVERLAP,ALLOCATABLE :: CDIJ1_KPQ_IND(:,:,:,:)  
+
+   INTERFACE
+   SUBROUTINE AUGCHG_G(WDES, GRID_SOFT,GRIDC_, &
+      LATT_CUR,P,T_INFO,SYMM, LOVERL, SOFT_TO_C,&
+      LMDIM,CRHODE, CHTOT_,CHDEN,QVEC)
+      USE prec
+      USE base
+      USE charge
+      USE pseudo
+      USE poscar
+      USE mpimy
+      USE mgrid
+      USE lattice
+      USE wave
+      USE asa
+      USE paw
+      USE constant
+      USE us
+   
+      IMPLICIT COMPLEX(q) (C)
+      IMPLICIT REAL(q) (A-B,D-H,O-Z)
+   
+      TYPE (type_info)   T_INFO
+      TYPE (potcar)      P(T_INFO%NTYP)
+      TYPE (grid_3d),TARGET :: GRID_SOFT,GRIDC_
+      TYPE (grid_3d),POINTER :: GRIDC
+      TYPE (transit)     SOFT_TO_C
+      TYPE (latt)        LATT_CUR
+      TYPE (wavedes)     WDES
+      TYPE (symmetry)    SYMM
+      LOGICAL   LOVERL
+      INTEGER LMDIM
+      OVERLAP   CRHODE(LMDIM,LMDIM,WDES%NIONS,WDES%NCDIJ)
+      RGRID,TARGET  :: CHTOT_(DIMREAL(GRIDC_%MPLWV),WDES%NCDIJ)
+      COMPLEX(q) CHDEN(GRID_SOFT%MPLWV,WDES%NCDIJ)
+      REAL(q), OPTIONAL :: QVEC(3)
+    END SUBROUTINE
+
+  END INTERFACE
+
+CONTAINS
+
+   SUBROUTINE EMLR_MAIN( &
+         HAMILTONIAN,P,WDES,NONLR_S,NONL_S,W0,LATT_CUR,LATT_INI, &
+         T_INFO,DYN,INFO,IO,MIX,KPOINTS,SYMM,GRID,GRID_SOFT, &
+         GRIDC,GRIDB,GRIDUS,C_TO_US,B_TO_C,SOFT_TO_C, &
+         CHTOT,DENCOR,CSTRF,CDIJ,CQIJ,CRHODE, &
+         N_MIX_PAW,RHOLM,SV,LMDIM,IRDMAX,NEDOS,EFERMI)
+
+   IMPLICIT NONE
+!=======================================================================
+!  input/output variables
+!=======================================================================
+   TYPE (ham_handle)  HAMILTONIAN
+   TYPE (type_info)   T_INFO        ! poscar description
+   TYPE (potcar)      P(T_INFO%NTYP)! pseudo potential
+   TYPE (wavedes)     WDES
+   TYPE (nonlr_struct) NONLR_S      ! non local projection operators in real space
+   TYPE (nonl_struct) NONL_S        ! non local projection operators in recip space
+   TYPE (wavespin)    W0            ! unperturbed wavefunctions
+   TYPE (latt)        LATT_CUR      ! lattice
+   TYPE (latt)        LATT_INI
+   TYPE (dynamics)    DYN
+   TYPE (info_struct) INFO
+   TYPE (in_struct)   IO
+   TYPE (mixing)      MIX
+   TYPE (kpoints_struct) KPOINTS
+   TYPE (symmetry)    SYMM
+   TYPE (grid_3d)     GRID       ! grid for wavefunctions
+   TYPE (grid_3d)     GRID_SOFT  ! grid for soft chargedensity
+   TYPE (grid_3d)     GRIDC      ! grid for potentials/charge
+   TYPE (grid_3d)     GRIDUS     ! temporary grid in us.F
+   TYPE (grid_3d)     GRIDB      ! Broyden grid
+   TYPE (transit)     B_TO_C     ! index table between GRIDB and GRIDC
+   TYPE (transit)     C_TO_US    ! index table between GRIDC and GRIDUS
+   TYPE (transit)     SOFT_TO_C  ! index table between GRID_SOFT and GRIDC
+
+   INTEGER LMDIM,IRDMAX,NEDOS
+   REAL(q) EFERMI
+
+   COMPLEX(q)  CHTOT(GRIDC%MPLWV,WDES%NCDIJ) ! charge-density in real / reciprocal space
+                                             ! \tilde n + \hat n
+                                             ! \tilde n : soft pseudo-charge-density
+                                             ! \hat n :  compensation charges
+   RGRID       DENCOR(GRIDC%RL%NP)           ! partial core
+                                             ! \tilde n_c : partial electronic core density
+   COMPLEX(q)  CSTRF(GRIDC%MPLWV,T_INFO%NTYP)
+   !  augmentation related quantities
+   OVERLAP  CDIJ(LMDIM,LMDIM,WDES%NIONS,WDES%NCDIJ), & ! nonlocal potential
+            CQIJ(LMDIM,LMDIM,WDES%NIONS,WDES%NCDIJ), &
+            CRHODE(LMDIM,LMDIM,WDES%NIONS,WDES%NCDIJ)  ! one center occupancies
+   !  paw sphere charge density
+   OVERLAP :: CRHODE1(LMDIM,LMDIM,WDES%NIONS,WDES%NCDIJ)
+   INTEGER N_MIX_PAW
+   REAL(q) RHOLM(N_MIX_PAW,WDES%NCDIJ)
+   !  charge-density and potential on soft grid
+   RGRID       SV(DIMREAL(GRID%MPLWV),WDES%NCDIJ)
+!=======================================================================
+!  local variables
+!=======================================================================
+   TYPE (eigenf_cluster_pointer),POINTER :: DEG_CLUSTER(:,:)
+   ! INTEGER :: IONODE,NODE_ME
+   REAL(q) :: DESUM,DESUM2                     ! change of energy
+   ! REAL(q) :: RMS_KPQ(INFO%NELM)             ! magnitude of residual vector
+   ! REAL(q) :: RMS_KMQ(INFO%NELM)             ! magnitude of residual vector
+   ! REAL(q) :: RMST,RMSC,RMSP,WEIGHT          ! mixer
+   INTEGER :: ICOUEV                           ! number of H | phi> evaluations
+   ! INTEGER :: IERRBR
+   ! INTEGER :: IERROR
+   ! INTEGER :: N                              ! main loop counter (electronic step)
+   !  density of states
+   ! REAL(q) :: EENTROPY,EFERMI1
+   ! REAL(q)    DOS(NEDOS,WDES%ISPIN),DOSI(NEDOS,WDES%ISPIN)
+   ! local l-projected wavefunction characters (not really used here)
+   ! REAL(q)    PAR(1,1,1,1,WDES%NCDIJ),DOSPAR(1,1,1,WDES%NCDIJ)
+   ! derivative of density
+   ! COMPLEX(q) :: CHDEN1_KPQ(GRID_SOFT%MPLWV,WDES%NCDIJ)     ! 1st order change of pseudo charge
+   ! COMPLEX(q) :: CHTOT1_KPQ(GRIDC%MPLWV,WDES%NCDIJ)         ! derivative change of total charge
+   ! OVERLAP :: CRHODE1_KPQ(LMDIM,LMDIM,WDES%NIONS,WDES%NCDIJ)! derivative of onsite occupancies
+   ! decompose the density matrix into hermitian part and antihermitian part
+   ! COMPLEX(q) :: CHDEN1_H(GRID_SOFT%MPLWV,WDES%NCDIJ)
+   ! COMPLEX(q) :: CHDEN1_AH(GRID_SOFT%MPLWV,WDES%NCDIJ)
+   ! COMPLEX(q) :: CHTOT1_H(GRIDC%MPLWV,WDES%NCDIJ)
+   ! COMPLEX(q) :: CHTOT1_AH(GRIDC%MPLWV,WDES%NCDIJ)
+   ! OVERLAP :: CRHODE1_H(LMDIM,LMDIM,WDES%NIONS,WDES%NCDIJ)
+   ! OVERLAP :: CRHODE1_AH(LMDIM,LMDIM,WDES%NIONS,WDES%NCDIJ)
+   ! REAL(q) :: RHOLM1_H(N_MIX_PAW,WDES%NCDIJ)
+   ! REAL(q) :: RHOLM1_AH(N_MIX_PAW,WDES%NCDIJ)
+   ! REAL(q) :: RHOLM1(N_MIX_PAW*2,WDES%NCDIJ)
+   ! store last step data
+   ! COMPLEX(q) :: CHTOTL_H(GRIDC%MPLWV,WDES%NCDIJ)
+   ! COMPLEX(q) :: CHTOTL_AH(GRIDC%MPLWV,WDES%NCDIJ)
+   ! REAL(q) :: RHOLML(N_MIX_PAW*2,WDES%NCDIJ)
+   ! derivative of Hamiltonian
+   ! RGRID   :: SV1_KPQ(DIMREAL(GRID%MPLWV),WDES%NCDIJ)       ! derivative of soft potential
+   ! RGRID   :: SV1_KMQ(DIMREAL(GRID%MPLWV),WDES%NCDIJ)       ! derivative of soft potential
+   RGRID   :: SV_EXT(DIMREAL(GRID%MPLWV),WDES%NCDIJ)
+   ! OVERLAP :: CDIJ1_KPQ(LMDIM,LMDIM,WDES%NIONS,WDES%NCDIJ)  ! derivative of non local strength
+   ! OVERLAP :: CDIJ1_KMQ(LMDIM,LMDIM,WDES%NIONS,WDES%NCDIJ)  ! derivative of non local strength
+   OVERLAP :: CDIJ_EXT(LMDIM,LMDIM,WDES%NIONS,WDES%NCDIJ)
+   ! wave function
+   TYPE (wavespin)     :: W0_KPQ            ! W0_k+q
+   TYPE (wavespin)     :: W0_KMQ            ! W0_k-q
+   ! TYPE (wavespin)     :: WXI               ! stores H(1) - epsilon S(1) | phi_0>
+   TYPE (wavespin)     :: W1_KPQ            ! W1_k+q
+   TYPE (wavespin)     :: W1_KMQ            ! W1_k-q
+   ! linear response using symmetry
+   TYPE (skpoints_trans)   :: KPOINTS_TRANS
+   INTEGER                 :: NKORIG
+   ! spin susceptibility
+   COMPLEX(q) :: CHI(GRIDC%MPLWV,4)     ! spin susceptibility
+   COMPLEX(q) :: CHI_G(GRIDC%MPLWV,4)     ! spin susceptibility
+   ! COMPLEX(q) :: CHI_IM(GRIDC%MPLWV,4)  ! spin susceptibility
+   ! COMPLEX(q) :: CHIG(4)                ! (0,x,y,z)
+   INTEGER    :: IGVEC
+   INTEGER   , ALLOCATABLE :: GVEC_OUTPUT(:,:)
+   COMPLEX(q), ALLOCATABLE :: CHIG_OUTPUT(:,:)
+   COMPLEX(q), ALLOCATABLE :: CHIGPM_OUTPUT(:,:) ! (0,+,-,z)
+   ! frequence
+   INTEGER :: NOMEGA
+   REAL(q) :: OMEGAMIN
+   REAL(q) :: OMEGAMAX
+   LOGICAL :: LOMEGALIST
+   REAL(q), ALLOCATABLE :: OMEGALIST(:)
+
+   INTEGER :: IOMEGA
+   REAL(q) :: DOMEGA
+   REAL(q) :: OMEGA
+   ! LOGICAL :: LOMEGA0
+   ! LOGICAL :: LSUBTRACT
+   ! q-vector
+   INTEGER :: NQVEC,NQPATH,NPATH,NPATH2
+   INTEGER :: IQVEC,IQPATH,IPATH
+   REAL(q), ALLOCATABLE :: QVECLIST(:,:)
+   REAL(q), ALLOCATABLE :: QVECPATH(:,:)
+   REAL(q) :: QVEC(3)
+   REAL(q) :: QVEC_CART(3)
+   LOGICAL :: LQVEC0
+   INTEGER :: GVEC(3)               ! G
+   REAL(q) :: GVEC_CART(3)
+   INTEGER :: GVEC_READ(3) ! temporary put here in order to give CHI OUTPUT
+   INTEGER    :: NGVEC_OUTPUT
+   INTEGER   , ALLOCATABLE :: GVEC_OUTPUT_READ(:,:)
+   REAL(q) :: QPG_CART(3)           ! q+G
+   REAL(q), ALLOCATABLE :: KORIG(:,:)
+   REAL(q), ALLOCATABLE :: KPQ(:,:)
+   REAL(q), ALLOCATABLE :: KMQ(:,:)
+   ! strength of external field
+   REAL(q) :: REAL_FIELD(4)
+   REAL(q) :: IMAG_FIELD(4)
+   COMPLEX(q) :: FIELD(4) 
+   REAL(q) :: B_DFPT(3)
+             ! electronic and magnetic field in unit eV
+   
+   LOGICAL :: LBROT
+   
+   INTEGER :: ISP,NI,NK,NT 
+   REAL(q) :: POSION(3),SIGMA_X
+   ! input and output
+   INTEGER :: STAT
+   
+   LOGICAL :: LFOUND
+   CHARACTER(LEN=80) :: INLINE
+   INTEGER :: IU6K                  ! OUTCAR k-points
+   ! control
+   
+   
+   REAL(q) :: ETA                   ! complex shift i*\eta
+                                    ! improves stability in particular
+                                    ! if degenerated eigenvalue pairs have not been resolved
+   
+   
+   
+   ! mixing
+   INTEGER :: IMIX                  ! type of mixing
+   REAL(q) :: AMIX                  ! mixing parameter A
+   REAL(q) :: BMIX                  ! mixing parameter B
+   REAL(q) :: AMIX_MAG              ! mixing parameter A for magnetization
+   REAL(q) :: BMIX_MAG              ! mixing parameter B for magnetization
+   REAL(q) :: AMIN                  ! minimal mixing parameter A
+   REAL(q) :: WC
+   INTEGER :: MAXMIX
+   INTEGER :: MREMOVE
+   ! variables for W0_k+q and W0_k-q
+   REAL(q) :: EDIFF                 ! break condition
+   REAL(q) :: RMS                   ! change
+   REAL(q) :: TOTEN,TOTENL          ! energy
+   INTEGER :: NSIM
+   REAL(q) :: X,EXHF
+   INTEGER :: I,J,IALGO_SAVE,ITYPE
+   COMPLEX(q)  CV_EXT(GRIDC%MPLWV,WDES%NCDIJ),GAUSS_FIELD(GRIDC%MPLWV)
+
+   NAMELIST /EMLR_PARA/ REAL_FIELD,IMAG_FIELD,GVEC_READ
+   NAMELIST /EMLR_PARA/ ETA,EPRO,STEP_LENGTH,LFERMI
+   NAMELIST /EMLR_PARA/ OMEGAMIN,OMEGAMAX,NOMEGA,LOMEGALIST
+   NAMELIST /EMLR_PARA/ LBROT,LKSHIFT,LNOIMAG,LADAPT,LSOFT
+   NAMELIST /EMLR_PARA/ NCH,LCHUPD,CHBREAK,RCHBREAK
+   NAMELIST /EMLR_PARA/ NLS,LSBREAK,LSDEPER
+   NAMELIST /EMLR_PARA/ IMIX,AMIX,BMIX,AMIX_MAG,BMIX_MAG,AMIN,WC,MAXMIX,MREMOVE,ITYPE
+
+#ifdef realmode
+   IF (IO%IU0>=0) WRITE(*,*)'DFPT does not support realmode, please remove -DNGXhalf or -DNGZhalf pre-compiler flag!'
+   STOP
+#endif
+
+   IF (.NOT. WDES%LNONCOLLINEAR) THEN
+      IF (IO%IU0>=0) WRITE(*,*)'DFPT REQUIRES NONCOLLINEAR CALCULATIONS!'
+      STOP
+   ENDIF
+
+   IONODE=0
+   NODE_ME=0
+#ifdef MPI
+   IONODE  = WDES%COMM%IONODE
+   NODE_ME = WDES%COMM%NODE_ME
+#endif
+
+   IF (IO%NWRITE>=3) THEN
+      IU6K  = IO%IU6
+   ELSE
+      IU6K  = -1
+   ENDIF
+
+   ! initialise
+   REAL_FIELD  =(/0,1,0,0/)   ! sigma_x
+   IMAG_FIELD  =(/0,0,-1,0/)  ! -i sigma_y
+   GVEC_READ   =(/0,0,0/)
+   ETA         =0.02_q
+   STEP_LENGTH =1E-3_q
+   MAGRHO0     =1._q
+
+   LFERMI      =.FALSE.
+   EPRO        = 0._q
+   LNOIMAG     =.FALSE.
+   LADAPT      =.FALSE.
+   LSOFT       =.FALSE.
+
+   NOMEGA      =1
+   OMEGAMIN    =0.0_q
+   OMEGAMAX    =0.0_q
+   LOMEGALIST  =.FALSE.
+
+   LBROT       =.TRUE.
+   LKSHIFT     =.TRUE.
+   LCHUPD(:)   =.TRUE.
+   NCH         =60
+   CHBREAK     =1E-2_q
+   RCHBREAK    =1E-10_q
+
+   NLS     =6
+   LSBREAK =INFO%EBREAK/10
+   LSDEPER =INFO%DEPER
+   IMIX=MIX%IMIX
+   AMIX=MIX%AMIX
+   BMIX=MIX%BMIX
+   AMIX_MAG=MIX%AMIX_MAG
+   BMIX_MAG=MIX%BMIX_MAG
+   AMIN=MIX%AMIN
+   WC = MIX%WC
+   MAXMIX = MIX%MAXMIX
+   MREMOVE=16
+
+   IALGO_SAVE=INFO%IALGO
+   INFO%IALGO=8
+   ITYPE=2
+
+   OPEN(UNIT=UNIT_EMLR_INPUT,FILE='EMLR_INPUT',FORM='FORMATTED',STATUS='UNKNOWN')
+   READ(UNIT_EMLR_INPUT,NML=EMLR_PARA, IOSTAT=STAT)
+   IF (STAT/=0) THEN
+      IF (IO%IU0>=0) WRITE(*,*) 'ERROR IN READING IN EMLR_PARA NAMELIST'
+      STOP
+   ENDIF
+   IF (NOMEGA<1) THEN
+      IF (IO%IU0>=0) WRITE(*,*) 'NOMEGA SHOULD BE POSITIVE INTEGER',NOMEGA
+      STOP
+   ENDIF
+
+   ! read in frequence
+   ALLOCATE(OMEGALIST(NOMEGA))
+   IF (LOMEGALIST) THEN
+      REWIND(UNIT_EMLR_INPUT)
+      LFOUND=.FALSE.
+      DO
+         READ(UNIT_EMLR_INPUT,*,END=122)INLINE
+         IF (TRIM(ADJUSTL(INLINE))=='OMEGALIST') THEN
+            LFOUND= .TRUE.
+            EXIT
+         ENDIF
+      ENDDO
+122    CONTINUE
+      IF (.NOT.LFOUND) THEN
+         IF (IO%IU0>=0) WRITE(*,*) 'ERROR IN FOUNDING OMEGALIST'
+         STOP
+      ENDIF
+
+      DO IOMEGA=1,NOMEGA
+         READ(UNIT_EMLR_INPUT,*,IOSTAT=STAT)OMEGALIST(IOMEGA)
+         IF (STAT/=0) THEN
+            IF (IO%IU0>=0) WRITE(*,*) 'ERROR IN READING OMEGALIST : ',IOMEGA
+            STOP
+         ENDIF
+      ENDDO
+   ELSE
+      IF (NOMEGA>1) THEN
+         DOMEGA=(OMEGAMAX-OMEGAMIN)/(NOMEGA-1)
+      ELSE
+         DOMEGA=0.0_q
+      ENDIF
+      DO IOMEGA=1,NOMEGA
+         OMEGALIST(IOMEGA)=(IOMEGA-1)*DOMEGA+OMEGAMIN
+      ENDDO
+   ENDIF
+
+   ! read in qvec
+   REWIND(UNIT_EMLR_INPUT)
+   LFOUND=.FALSE.
+   DO
+      READ(UNIT_EMLR_INPUT,*,END=123)INLINE
+      IF (TRIM(ADJUSTL(INLINE))=='QVECLIST') THEN
+         LFOUND= .TRUE.
+         EXIT
+      ENDIF
+   ENDDO
+123    CONTINUE
+   IF (.NOT.LFOUND) THEN
+      IF (IO%IU0>=0) WRITE(*,*) 'ERROR IN FOUNDING QVECLIST'
+      STOP
+   ENDIF
+
+   READ(UNIT_EMLR_INPUT,*,IOSTAT=STAT)NQPATH,NPATH
+   IF (STAT/=0) THEN
+      IF (IO%IU0>=0) WRITE(*,*) 'ERROR IN READING NQPATH AND NPATH'
+      STOP
+   ENDIF
+   IF (NQPATH<1) THEN
+      IF (IO%IU0>=0) WRITE(*,*) 'REQUIRE NQPATH >= 1 '
+      STOP
+   ENDIF
+   IF (NPATH<1) THEN
+      IF (IO%IU0>=0) WRITE(*,*) 'REQUIRE NPATH >= 1 '
+      STOP
+   ENDIF
+
+   IF (NQPATH==1) THEN
+      NPATH2=NPATH
+   ELSE
+      NPATH2=2*NPATH
+   ENDIF
+   ALLOCATE(QVECPATH(3,NPATH2))
+   DO IPATH=1,NPATH2
+      READ(UNIT_EMLR_INPUT,*,IOSTAT=STAT)QVECPATH(:,IPATH)
+      IF (STAT/=0) THEN
+         IF (IO%IU0>=0) WRITE(*,*) 'ERROR IN READING QVECLIST : ',IPATH
+         STOP
+      ENDIF
+   ENDDO
+
+   NQVEC=NQPATH*NPATH
+   ALLOCATE(QVECLIST(3,NQVEC))
+   IF (NQPATH==1) THEN
+      QVECLIST=QVECPATH
+   ELSE
+      IQVEC=0
+      DO IPATH=1,NPATH
+         DO IQPATH=1,NQPATH
+            IQVEC=IQVEC+1
+            QVECLIST(:,IQVEC)=(QVECPATH(:,IPATH*2)-QVECPATH(:,IPATH*2-1)) &
+                        & /(NQPATH-1)*(IQPATH-1)+QVECPATH(:,IPATH*2-1)
+         ENDDO
+      ENDDO
+   ENDIF
+
+   ! read in Gvec
+   REWIND(UNIT_EMLR_INPUT)
+   LFOUND=.FALSE.
+   DO
+      READ(UNIT_EMLR_INPUT,*,END=124)INLINE
+      IF (TRIM(ADJUSTL(INLINE))=='GVECLIST') THEN
+         LFOUND= .TRUE.
+         EXIT
+      ENDIF
+   ENDDO
+124    CONTINUE
+
+   IF (LFOUND) THEN
+      READ(UNIT_EMLR_INPUT,*,IOSTAT=STAT)NGVEC_OUTPUT
+      IF (STAT/=0) THEN
+         IF (IO%IU0>=0) WRITE(*,*) 'ERROR IN READING NGVEC_OUTPUT'
+         STOP
+      ENDIF
+      IF (NGVEC_OUTPUT<1) THEN
+         IF (IO%IU0>=0) WRITE(*,*) 'REQUIRE NGVEC_OUTPUT >= 1 '
+         STOP
+      ENDIF
+   ELSE
+      NGVEC_OUTPUT=1
+   ENDIF
+
+   ALLOCATE(GVEC_OUTPUT(3,NGVEC_OUTPUT))
+   ALLOCATE(GVEC_OUTPUT_READ(3,NGVEC_OUTPUT))
+   ALLOCATE(CHIG_OUTPUT(4,NGVEC_OUTPUT))
+   ALLOCATE(CHIGPM_OUTPUT(4,NGVEC_OUTPUT))
+   IF (.NOT. ALLOCATED(SV1_KPQ_IND)) ALLOCATE(SV1_KPQ_IND(DIMREAL(GRID%MPLWV),WDES%NCDIJ))
+   IF (.NOT. ALLOCATED(SV1_KPQ_IND0)) ALLOCATE(SV1_KPQ_IND0(DIMREAL(GRID%MPLWV),WDES%NCDIJ))
+   IF (.NOT. ALLOCATED(CDIJ1_KPQ_IND)) ALLOCATE(CDIJ1_KPQ_IND(LMDIM,LMDIM,WDES%NIONS,WDES%NCDIJ))
+
+   IF (LFOUND) THEN
+      DO IGVEC=1,NGVEC_OUTPUT
+         READ(UNIT_EMLR_INPUT,*,IOSTAT=STAT)GVEC_OUTPUT_READ(:,IGVEC)
+         IF (STAT/=0) THEN
+            IF (IO%IU0>=0) WRITE(*,*) 'ERROR IN READING GVECLIST : ',IGVEC
+            STOP
+         ENDIF
+      ENDDO
+   ELSE
+      GVEC_OUTPUT_READ(:,1)=GVEC_READ
+   ENDIF
+
+   CLOSE(UNIT_EMLR_INPUT)
+
+   MIX%IMIX=IMIX
+   MIX%AMIX=AMIX
+   MIX%BMIX=BMIX
+   MIX%AMIX_MAG=AMIX_MAG
+   MIX%BMIX_MAG=BMIX_MAG
+   MIX%AMIN=AMIN
+   MIX%WC = WC
+   MIX%MAXMIX = MAXMIX
+   MIX%MREMOVE=MREMOVE
+
+   ! 2*CSHIFT is used in subroutine EDDIAG_LR and LINEAR_RESPONSE_DIIS
+   CSHIFT=ETA/2.0_q
+   STEP_BASE=STEP_LENGTH
+   IF (IO%IU0>=0) THEN
+      OPEN(UNIT=UNIT_EMLR_OUTPUT,FILE='EMLR_OUTPUT',STATUS='UNKNOWN')
+      OPEN(UNIT=UNIT_EMLR_CHI,FILE='EMLR_CHI',STATUS='UNKNOWN')
+      OPEN(UNIT=UNIT_EMLR_RMS,FILE='EMLR_RMS',STATUS='UNKNOWN')
+      WRITE(UNIT_EMLR_OUTPUT,'("real_field (eV) :",4(x,F7.4))') REAL_FIELD
+      WRITE(UNIT_EMLR_OUTPUT,'("imag_field (eV) :",4(x,F7.4))') IMAG_FIELD
+      WRITE(UNIT_EMLR_OUTPUT,'("NQVEC               : ",I3)') NQVEC
+      DO IQVEC=1,NQVEC
+         WRITE(UNIT_EMLR_OUTPUT,'("QVEC                :",3(x,F7.4))') QVECLIST(:,IQVEC)
+      ENDDO
+      WRITE(UNIT_EMLR_OUTPUT,'("GVEC_INPUT          :",3(x,I3))') GVEC_READ
+      WRITE(UNIT_EMLR_OUTPUT,'("NGVEC_OUTPUT        : ",I3)') NGVEC_OUTPUT
+      DO IGVEC=1,NGVEC_OUTPUT
+         WRITE(UNIT_EMLR_OUTPUT,'("GVEC_OUTPUT         :",3(x,I3))') GVEC_OUTPUT_READ(:,IGVEC)
+      ENDDO
+      WRITE(UNIT_EMLR_OUTPUT,'("NOMEGA              : ",I3)') NOMEGA
+      WRITE(UNIT_EMLR_OUTPUT,'("ETA (eV)            : ",F7.4)') ETA
+      WRITE(UNIT_EMLR_OUTPUT,'("STEP_LENGTH         : ",E11.4)') STEP_LENGTH
+      WRITE(UNIT_EMLR_OUTPUT,'("LFermi              : ",L3)') LFERMI
+      WRITE(UNIT_EMLR_OUTPUT,'("EPRO (eV)            : ",F7.4)') EPRO
+      WRITE(UNIT_EMLR_OUTPUT,'("LBROT               : ",L3)') LBROT
+      WRITE(UNIT_EMLR_OUTPUT,'("LKSHIFT             : ",L3)') LKSHIFT
+      WRITE(UNIT_EMLR_OUTPUT,'("LNOIMAG             : ",L3)') LNOIMAG
+      WRITE(UNIT_EMLR_OUTPUT,'("LADAPT             : ",L3)') LADAPT
+      WRITE(UNIT_EMLR_OUTPUT,'("LSOFT             : ",L3)') LSOFT
+      WRITE(UNIT_EMLR_OUTPUT,'("NCHARGE             : ",I3)') NCH
+      WRITE(UNIT_EMLR_OUTPUT,'("update channels     : ",4L3)') LCHUPD
+      WRITE(UNIT_EMLR_OUTPUT,'("CHBREAK             : ",E11.4)') CHBREAK
+      WRITE(UNIT_EMLR_OUTPUT,'("NLS             : ",I3)') NLS
+      WRITE(UNIT_EMLR_OUTPUT,'("LSBREAK         : ",E11.4)') LSBREAK
+      WRITE(UNIT_EMLR_OUTPUT,'("LSDEPER         : ",E11.4)') LSDEPER
+      WRITE(UNIT_EMLR_OUTPUT,'("IMIX                : ",I3)') MIX%IMIX
+      WRITE(UNIT_EMLR_OUTPUT,'("AMIX                : ",F7.4)') MIX%AMIX
+      WRITE(UNIT_EMLR_OUTPUT,'("BMIX                : ",F7.4)') MIX%BMIX
+      WRITE(UNIT_EMLR_OUTPUT,'("AMIX_MAG            : ",F7.4)') MIX%AMIX_MAG
+      WRITE(UNIT_EMLR_OUTPUT,'("BMIX_MAG            : ",F7.4)') MIX%BMIX_MAG
+      WRITE(UNIT_EMLR_OUTPUT,'("AMIN                : ",F7.4)') MIX%AMIN
+      WRITE(UNIT_EMLR_OUTPUT,'("WC                : ",F6.0)')   MIX%WC
+      WRITE(UNIT_EMLR_OUTPUT,'("MAXMIX                : ",I3)')   MIX%MAXMIX
+      WRITE(UNIT_EMLR_OUTPUT,'("MREMOVE                : ",I3)')   MIX%MREMOVE
+      WRITE(UNIT_EMLR_OUTPUT,'("ITYPE                : ",I3)')   ITYPE
+      ! WRITE(UNIT_EMLR_OUTPUT,'("INIMIX                : ",I3)')   MIX%INIMIX
+      ! WRITE(UNIT_EMLR_OUTPUT,'("MIXPRE                : ",I4)')   MIX%MIXPRE
+      ! WRITE(UNIT_EMLR_OUTPUT,'("LRESET                : ",L3)')   MIX%LRESET
+      ! WRITE(UNIT_EMLR_OUTPUT,'("HARD_RESET                : ",L3)')   MIX%HARD_RESET
+   ENDIF
+
+   FIELD=REAL_FIELD+(0._q,1._q)*IMAG_FIELD
+   IF (LBROT) THEN
+      B_DFPT=REAL_FIELD(2:4)+IMAG_FIELD(2:4)*100
+   ELSE
+      B_DFPT=0.0_q
+   ENDIF
+   EPRO = EPRO+EFERMI
+   NKORIG=WDES%NKPTS
+   NULLIFY(DEG_CLUSTER)
+
+momentum: DO IQVEC=1,NQVEC
+      QVEC=QVECLIST(:,IQVEC)
+      CALL NEAREST_LATTICE_POINT(QVEC,GVEC,LATT_CUR)
+      GVEC=GVEC+GVEC_READ
+      GVEC_OUTPUT=GVEC_OUTPUT_READ
+      ! DO ISP=1,3
+      !    GVEC(ISP) = GVEC_READ(ISP)+QVEC(ISP)-(MOD(QVEC(ISP)-0.5_q,1.0_q)+0.5_q)
+      !    QVEC(ISP) = QVEC(ISP)+GVEC_READ(ISP)-GVEC(ISP)
+      ! ENDDO
+      ! Notice that 2*pi is omitted which should be retrieved in the subroutine
+      QVEC_CART(1)=(QVEC(1)*LATT_CUR%B(1,1)+QVEC(2)*LATT_CUR%B(1,2)+QVEC(3)*LATT_CUR%B(1,3))
+      QVEC_CART(2)=(QVEC(1)*LATT_CUR%B(2,1)+QVEC(2)*LATT_CUR%B(2,2)+QVEC(3)*LATT_CUR%B(2,3))
+      QVEC_CART(3)=(QVEC(1)*LATT_CUR%B(3,1)+QVEC(2)*LATT_CUR%B(3,2)+QVEC(3)*LATT_CUR%B(3,3))
+      IF (SUM(QVEC_CART**2) < 1E-10_q) THEN
+         LQVEC0=.TRUE.
+         QVEC=0
+         QVEC_CART=0
+      ELSE
+         LQVEC0=.FALSE.
+      ENDIF
+
+      GVEC_CART(1)=(GVEC(1)*LATT_CUR%B(1,1)+GVEC(2)*LATT_CUR%B(1,2)+GVEC(3)*LATT_CUR%B(1,3))
+      GVEC_CART(2)=(GVEC(1)*LATT_CUR%B(2,1)+GVEC(2)*LATT_CUR%B(2,2)+GVEC(3)*LATT_CUR%B(2,3))
+      GVEC_CART(3)=(GVEC(1)*LATT_CUR%B(3,1)+GVEC(2)*LATT_CUR%B(3,2)+GVEC(3)*LATT_CUR%B(3,3))
+      QPG_CART=QVEC_CART+GVEC_CART
+
+      IF (SYMM%ISYM>0) THEN
+         DO I=1,T_INFO%NIONS
+            DYN%VEL(:,I)=QPG_CART
+         ENDDO
+         CALL KARDIR(T_INFO%NIONS,DYN%VEL,LATT_CUR%B)
+
+         CALL INISYM(LATT_CUR%A,T_INFO%POSION,DYN%VEL,T_INFO%LSFOR, &
+              T_INFO%LSDYN,T_INFO%NTYP,T_INFO%NITYP,T_INFO%NIONS, &
+              SYMM%PTRANS,SYMM%NROT,SYMM%NPTRANS,SYMM%ROTMAP,SYMM%TAU,SYMM%TAUROT,SYMM%WRKROT, &
+              SYMM%INDROT,T_INFO%ATOMOM,WDES%SAXIS,SYMM%MAGROT,WDES%NCDIJ,IO%IU6,B_DFPT)
+#ifdef oldsym
+         IF (IO%IU0>=0) WRITE(*,*) 'SUBROUTINE INISYM FOR OLDSYM HAS NOT BEEN MODIFIED'
+         STOP
+         CALL RE_READ_KPOINTS(KPOINTS,LATT_CUR, &
+              SYMM%ISYM>=0.AND..NOT.WDES%LSORBIT.AND..NOT.WDES%LSPIRAL, &
+             T_INFO%NIONS,SYMM%ROTMAP,SYMM%MAGROT,SYMM%ISYM,IU6K,IO%IU0)
+#else
+         CALL RE_READ_KPOINTS(KPOINTS,LATT_CUR, &
+              SYMM%ISYM>=0.AND..NOT.WDES%LNONCOLLINEAR, &
+              T_INFO%NIONS,SYMM%ROTMAP,SYMM%MAGROT,SYMM%ISYM,IU6K,IO%IU0)
+#endif
+         CALL KPAR_SYNC_ALL(WDES,W0)
+         CALL RE_GEN_LAYOUT(GRID,WDES,KPOINTS,LATT_CUR,LATT_INI,IO%IU6,IO%IU0)
+         CALL REALLOCATE_WAVE(W0,GRID,WDES,NONL_S,T_INFO,P,LATT_CUR,KPOINTS_TRANS)
+
+         ! Loewdin perturbation theory to improve states at added k-points
+         CALL EDDIAG(HAMILTONIAN,GRID,LATT_CUR,NONLR_S,NONL_S,W0,WDES,SYMM, &
+         &    LMDIM,CDIJ,CQIJ,4,SV,T_INFO,P,IO%IU0,DESUM, NKSTART=NKORIG+1)
+         CALL KPAR_SYNC_ALL(WDES,W0)
+      ENDIF
+      CALL FIND_DEG_CLUSTERS(WDES,W0,DEG_CLUSTER)
+
+      ! local potential e^(iG.r) from external field in reciprocal space
+      SV_EXT=0
+      IF (ITYPE==1) THEN
+         CALL SET_RHOG(GRID_SOFT,SV_EXT(:,1), (1.0_q,0.0_q), GVEC)
+         ! transform SV_EXT to real space
+         CALL FFT3D(SV_EXT(:,1),GRID_SOFT,1)
+         !  final result is only correct for first in-band-group
+         ! (i.e. proc with nodeid 1 in COMM_INTER)
+         !  copy to other in-band-groups using COMM_INTER
+         ! (see SET_RL_GRID() in mgrid.F, and M_divide() in mpi.F)
+         CALLMPI( M_bcast_z(WDES%COMM_INTER, SV_EXT(:,1), GRID%RL%NP))
+         ! non-local contribution from external field
+         CALL SET_CDIJ_EXT(WDES, P, T_INFO, INFO%LOVERL, LMDIM, CDIJ_EXT(:,:,:,1), QPG_CART, GVEC)
+         DO ISP=2,WDES%NCDIJ
+            ! for SV1, use the version of density, so a factor of 2 should be add
+            SV_EXT(:,ISP)=SV_EXT(:,1)*FIELD(ISP)
+            CDIJ_EXT(:,:,:,ISP)=CDIJ_EXT(:,:,:,1)*FIELD(ISP)
+         ENDDO
+         SV_EXT(:,1)=SV_EXT(:,1)*FIELD(1)
+         CDIJ_EXT(:,:,:,1)=CDIJ_EXT(:,:,:,1)*FIELD(1)
+      ELSE
+         DO NI = 1,T_INFO%NIONS
+            IF (NORM2(T_INFO%ATOMOM(1+(NI-1)*3:NI*3))>0.01) EXIT 
+         ENDDO
+         NT = T_INFO%ITYP(NI)
+         POSION=T_INFO%POSION(:,NI)
+         SIGMA_X = P(NT)%RDEP/1.6
+         GAUSS_FIELD=0
+         IF (ITYPE==2) THEN
+            CALL GAUSS_CV(GRIDC,GAUSS_FIELD,LATT_CUR,POSION,SIGMA_X,QVEC)
+            DO ISP=1,WDES%NCDIJ
+                  CV_EXT(:,ISP)=GAUSS_FIELD(:)*FIELD(ISP)
+            ENDDO
+         ELSE IF (ITYPE==3) THEN
+            IF (IO%IU0>=0) THEN
+                  WRITE(UNIT_EMLR_OUTPUT,*) "build external potential from user-provided external potential"
+            ENDIF
+            io_begin
+            OPEN(UNIT=99,FILE='CV_EXT',STATUS='UNKNOWN')
+            io_end
+            DO ISP=1,WDES%NCDIJ
+                  CALL INRL_CMPLX(GRIDC,99,.TRUE.,CV_EXT(:,ISP))
+                  CALL FFT_RC_SCALE(CV_EXT(1,ISP),CV_EXT(1,ISP),GRIDC)
+            ENDDO
+            io_begin
+            CLOSE(99)
+            io_end
+         ENDIF 
+         DO ISP=1,WDES%NCDIJ
+            CALL CP_GRID(GRIDC,GRID_SOFT,SOFT_TO_C,CV_EXT(1,ISP),SV_EXT(1,ISP))
+            CALL SETUNB(SV_EXT(1,ISP),GRID_SOFT)
+            CALL FFT3D(SV_EXT(1,ISP),GRID_SOFT, 1)
+#ifdef realmode
+        CALLMPI( M_bcast_d(WDES%COMM_INTER, SV_EXT(1,ISP), GRID%RL%NP))
+#else
+        CALLMPI( M_bcast_z(WDES%COMM_INTER, SV_EXT(1,ISP), GRID%RL%NP))
+#endif
+         CALL CV_TO_CDIJ(WDES, P, T_INFO, INFO%LOVERL, LMDIM, CDIJ_EXT(:,:,:,ISP),QVEC,GRIDC,CV_EXT(:,ISP),LATT_CUR)
+        ENDDO
+      ENDIF
+      ALLOCATE(KORIG(3,WDES%NKPTS),KPQ(3,WDES%NKPTS),KMQ(3,WDES%NKPTS))
+      KORIG=WDES%VKPT(1:3,1:WDES%NKPTS)
+      DO NK=1,WDES%NKPTS
+         KPQ(:,NK)=KORIG(:,NK)+QVEC
+         KMQ(:,NK)=KORIG(:,NK)-QVEC
+      ENDDO
+!=======================================================================
+! calculate W0_k+q and W0_k-q for sub-space rotation
+!=======================================================================
+      EDIFF = 1E-13
+      NSIM=WDES%NSIM*2
+#ifdef MPI
+      NSIM=((WDES%NSIM*2+WDES%COMM_INTER%NCPU-1)/WDES%COMM_INTER%NCPU)*WDES%COMM_INTER%NCPU
+#endif
+
+      X=INFO%EBREAK
+      ! for some non obvious reasons
+      INFO%EBREAK=0.25*EDIFF
+!=======================================================================
+! k+q
+!=======================================================================
+      ! For LKSHIFT = TRUE, irreducible k-points will change if symmetry is switched on
+      IF (LKSHIFT .AND. SYMM%ISYM /= -1) THEN
+         IF (IO%IU0>=0) WRITE(*,*) 'For LKSHIFT = .TRUE., ISYM should be set to -1'
+         STOP
+      ENDIF
+
+      WDES%VKPT(1:3,1:WDES%NKPTS)=KPQ
+      ! kinetic energy |k+q+G|^2
+      CALL SET_DATAKE(WDES, LATT_CUR%B)
+      ! non-local projector |p_k+q>
+      IF (.NOT. INFO%LREAL) THEN
+         CALL SPHER(GRID,NONL_S,P,WDES,LATT_CUR, 1)
+      ENDIF
+
+      IF (IO%IU0>=0) THEN
+         WRITE (IO%IU0,*) 'Wavefunctions W0_k+q for DFPT'
+      ENDIF
+
+      CALL ALLOCW(WDES,W0_KPQ)
+      CALL EMLR_COPYW(W0,W0_KPQ)
+      CALL PROALL(GRID,LATT_CUR,NONLR_S,NONL_S,W0_KPQ)
+      CALL ORTHCH(WDES, W0_KPQ, WDES%LOVERL, LMDIM, CQIJ)
+
+      TOTENL=0
+      DO I=1,15 !INFO%NELM
+         CALL EDDAV(HAMILTONIAN,P, GRID,INFO,LATT_CUR,NONLR_S,NONL_S,W0_KPQ,WDES, NSIM, &
+              LMDIM,CDIJ,CQIJ, RMS,DESUM,ICOUEV, SV, EXHF, IO%IU6,IO%IU0, .FALSE., .TRUE., .FALSE.)
+
+         TOTEN=BANDSTRUCTURE_ENERGY(WDES,W0_KPQ)
+
+         IF (IO%IU0>=0) THEN
+            WRITE(IO%IU0,1000) I, TOTEN, TOTEN-TOTENL, DESUM, ICOUEV, RMS
+         ENDIF
+1000   FORMAT('DAV: ',I3,'   ',E20.12,'   ',E12.5,'   ',E12.5,I6,'  ',E10.3)
+         IF(ABS(DESUM)<EDIFF.AND.ABS(TOTEN-TOTENL)<EDIFF) EXIT
+         TOTENL=TOTEN
+      ENDDO
+      CALL KPAR_SYNC_ALL(WDES,W0_KPQ)
+
+      ! For LKSHIFT = .TRUE., fermi weight of W0_kpq need to be calculated
+      IF (LKSHIFT) THEN
+         CALL EMLR_DEN(IO%IU0, WDES, W0_KPQ, KPOINTS, EFERMI, KPOINTS%SIGMA, NEDOS, 0, 0)
+      ENDIF
+
+      IF (LQVEC0) CALL EMLR_COPYW(W0,W0_KPQ)
+!=======================================================================
+! k-q
+!=======================================================================
+      IF (.NOT. LKSHIFT) THEN
+         WDES%VKPT(1:3,1:WDES%NKPTS)=KMQ
+         ! kinetic energy |k-q+G|^2
+         CALL SET_DATAKE(WDES, LATT_CUR%B)
+         ! non-local projector |p_k-q>
+         IF (.NOT. INFO%LREAL) THEN
+            CALL SPHER(GRID,NONL_S,P,WDES,LATT_CUR, 1)
+         ENDIF
+
+         IF (IO%IU0>=0) THEN
+            WRITE (IO%IU0,*) 'Wavefunctions W0_k-q for DFPT'
+         ENDIF
+
+         CALL ALLOCW(WDES,W0_KMQ)
+         CALL EMLR_COPYW(W0,W0_KMQ)
+         CALL PROALL(GRID,LATT_CUR,NONLR_S,NONL_S,W0_KMQ)
+         CALL ORTHCH(WDES, W0_KMQ, WDES%LOVERL, LMDIM, CQIJ)
+
+         TOTENL=0
+         DO I=1,15
+            CALL EDDAV(HAMILTONIAN,P, GRID,INFO,LATT_CUR,NONLR_S,NONL_S,W0_KMQ,WDES, NSIM, &
+                 LMDIM,CDIJ,CQIJ, RMS,DESUM,ICOUEV, SV, EXHF, IO%IU6,IO%IU0, .FALSE., .TRUE., .FALSE.)
+
+            TOTEN=BANDSTRUCTURE_ENERGY(WDES,W0_KMQ)
+
+            IF (IO%IU0>=0) THEN
+               WRITE(IO%IU0,1000) I, TOTEN, TOTEN-TOTENL, DESUM, ICOUEV, RMS
+            ENDIF
+            IF(ABS(DESUM)<EDIFF.AND.ABS(TOTEN-TOTENL)<EDIFF) EXIT
+            TOTENL=TOTEN
+         ENDDO
+         CALL KPAR_SYNC_ALL(WDES,W0_KMQ)
+
+         IF (LQVEC0) CALL EMLR_COPYW(W0,W0_KMQ)
+      ENDIF
+      INFO%EBREAK=X    ! restore the break condition
+      WDES%VKPT(1:3,1:WDES%NKPTS)=KORIG
+      IF (IO%IU0>=0) THEN
+         WRITE(UNIT_EMLR_CHI,'("QVEC                :",3(x,F7.4))') QVEC
+         IF (ITYPE==1) THEN
+            WRITE(UNIT_EMLR_CHI,'("GVEC_INPUT          :",3(x,I3))') GVEC
+            DO IGVEC=1,NGVEC_OUTPUT
+               WRITE(UNIT_EMLR_CHI,'("GVEC_OUTPUT         :",3(x,I3))') GVEC_OUTPUT(:,IGVEC)
+            ENDDO
+         ENDIF
+         WRITE(UNIT_EMLR_CHI,141)
+      ENDIF
+141 FORMAT(' Omega      n                     m+                    m-                    mz')
+frequence: DO IOMEGA=1,NOMEGA
+      SV1_KPQ_IND=0
+      CDIJ1_KPQ_IND=0
+      OMEGA=OMEGALIST(IOMEGA)
+      CALL ALLOCW(WDES,W1_KPQ)
+      CALL ALLOCW(WDES,W1_KMQ)
+      CALL EMLR_KERNEL( &
+            HAMILTONIAN,P,WDES,NONLR_S,NONL_S,W0,LATT_CUR,LATT_INI, &
+            T_INFO,DYN,INFO,IO,MIX,KPOINTS,SYMM,GRID,GRID_SOFT, &
+            GRIDC,GRIDB,GRIDUS,C_TO_US,B_TO_C,SOFT_TO_C, &
+            CHTOT,DENCOR,CSTRF,CDIJ,CQIJ,CRHODE, &
+            N_MIX_PAW,RHOLM,SV,LMDIM,IRDMAX,NEDOS,EFERMI,DEG_CLUSTER,&
+            OMEGA,QVEC,W0_KPQ,W0_KMQ,W1_KPQ,W1_KMQ,SV_EXT,CDIJ_EXT,CHI,CHI_G,CRHODE1,GVEC)
+
+      IF (ITYPE==1) THEN
+         DO IGVEC=1,NGVEC_OUTPUT
+            DO ISP=1,WDES%NCDIJ
+               CALL GET_RHOG(GRIDC,CHI(1,ISP),CHIG_OUTPUT(ISP,IGVEC),GVEC_OUTPUT(:,IGVEC))
+            ENDDO
+            CHIGPM_OUTPUT(1,IGVEC)=CHIG_OUTPUT(1,IGVEC)
+            CHIGPM_OUTPUT(2,IGVEC)=CHIG_OUTPUT(2,IGVEC)+(0._q,1._q)*CHIG_OUTPUT(3,IGVEC)
+            CHIGPM_OUTPUT(3,IGVEC)=CHIG_OUTPUT(2,IGVEC)-(0._q,1._q)*CHIG_OUTPUT(3,IGVEC)
+            CHIGPM_OUTPUT(4,IGVEC)=CHIG_OUTPUT(4,IGVEC)
+         ENDDO
+         IF (IO%IU0>=0) THEN
+            DO IGVEC=1,NGVEC_OUTPUT
+               WRITE(UNIT_EMLR_CHI,'(E10.3,4(x,E10.3,x,E10.3))') OMEGA,CHIGPM_OUTPUT(:,IGVEC)
+            ENDDO
+         ENDIF
+      ELSE IF (ITYPE==2) THEN
+         DO ISP = 1,WDES%NCDIJ
+            CHIG_OUTPUT(ISP,1) = SUM(CONJG(GAUSS_FIELD(1:GRIDC%RC%NP))*CHI_G(1:GRIDC%RC%NP,ISP))
+         ENDDO
+         CALLMPI( M_sum_z(GRIDC%COMM,CHIG_OUTPUT,4))
+         CHIGPM_OUTPUT(1,1)=CHIG_OUTPUT(1,1)
+         CHIGPM_OUTPUT(2,1)=CHIG_OUTPUT(2,1)+(0._q,1._q)*CHIG_OUTPUT(3,1)
+         CHIGPM_OUTPUT(3,1)=CHIG_OUTPUT(2,1)-(0._q,1._q)*CHIG_OUTPUT(3,1)
+         CHIGPM_OUTPUT(4,1)=CHIG_OUTPUT(4,1)
+         IF (IO%IU0>=0) THEN
+            WRITE(UNIT_EMLR_CHI,'(E10.3,4(x,E10.3,x,E10.3))') OMEGA,CHIGPM_OUTPUT(:,1)
+         ENDIF
+      ELSE IF (ITYPE==3) THEN
+         DO ISP = 1,WDES%NCDIJ
+            CHIG_OUTPUT(ISP,1) = SUM(CONJG(CV_EXT(1:GRIDC%RC%NP,ISP))*CHI_G(1:GRIDC%RC%NP,ISP))
+         ENDDO
+         CALLMPI( M_sum_z(GRIDC%COMM,CHIG_OUTPUT,4))
+         CHIGPM_OUTPUT(1,1)=CHIG_OUTPUT(1,1)
+         CHIGPM_OUTPUT(2,1)=CHIG_OUTPUT(2,1)+CHIG_OUTPUT(3,1)
+         CHIGPM_OUTPUT(3,1)=CHIG_OUTPUT(2,1)-CHIG_OUTPUT(3,1)
+         CHIGPM_OUTPUT(4,1)=CHIG_OUTPUT(4,1)
+         IF (IO%IU0>=0) THEN
+            WRITE(UNIT_EMLR_CHI,'(E10.3,4(x,E10.3,x,E10.3))') OMEGA,CHIGPM_OUTPUT(:,1)
+         ENDIF
+
+      ENDIF 
+
+!       IF (LOMEGA0 .AND. LQVEC0 .AND. LFERMI) THEN
+!          CALL SUBROT_DEG_ALL(WDES, W0, .TRUE., .TRUE., DEG_CLUSTER )
+!          ! Now W0 is rotated, copy to W0_KPQ and W0_KMQ again
+!          CALL EMLR_COPYW(W0,W0_KPQ)
+!          IF (.NOT. LKSHIFT) CALL EMLR_COPYW(W0,W0_KMQ)
+!       ENDIF
+! !=======================================================================
+! ! check for nonself-consistent calculation
+! !=======================================================================
+!       !CALL PROJ_W0(GRID,INFO,LATT_CUR,NONLR_S,NONL_S,W0,W1_KPQ,WDES, &
+!       !            LMDIM,CQIJ, SV)
+!       CALL DEALLOCW(WXI)
+      CALL DEALLOCW(W1_KPQ)
+      CALL DEALLOCW(W1_KMQ)
+
+   ENDDO frequence
+
+   CALL DEALLOCW(W0_KPQ)
+   IF (.NOT. LKSHIFT) CALL DEALLOCW(W0_KMQ)
+
+   WDES%VKPT(1:3,1:WDES%NKPTS)=KORIG
+   ! kinetic energy |k+G|^2
+   CALL SET_DATAKE(WDES, LATT_CUR%B)
+   ! non-local projector |p_k>
+   IF (.NOT. INFO%LREAL) THEN
+      CALL SPHER(GRID,NONL_S,P,WDES,LATT_CUR, 1)
+   ENDIF
+   DEALLOCATE(KORIG,KPQ,KMQ)
+   DEALLOCATE(SV1_KPQ_IND,SV1_KPQ_IND0,CDIJ1_KPQ_IND)
+
+   IF (SYMM%ISYM>0) CALL DEALLOCATE_KPOINTS_TRANS(KPOINTS_TRANS)
+   ENDDO momentum
+
+   CALL FREE_DEG_CLUSTERS(WDES,DEG_CLUSTER)
+
+   ! restore original symmetry
+   IF (SYMM%ISYM>0) THEN
+      DYN%VEL=0
+      CALL INISYM(LATT_CUR%A,T_INFO%POSION,DYN%VEL,T_INFO%LSFOR, &
+           T_INFO%LSDYN,T_INFO%NTYP,T_INFO%NITYP,T_INFO%NIONS, &
+           SYMM%PTRANS,SYMM%NROT,SYMM%NPTRANS,SYMM%ROTMAP,SYMM%TAU,SYMM%TAUROT,SYMM%WRKROT, &
+           SYMM%INDROT,T_INFO%ATOMOM,WDES%SAXIS,SYMM%MAGROT,WDES%NCDIJ,IO%IU6)
+#ifdef oldsym
+      CALL RE_READ_KPOINTS(KPOINTS,LATT_CUR, &
+           SYMM%ISYM>=0.AND..NOT.WDES%LSORBIT.AND..NOT.WDES%LSPIRAL, &
+           T_INFO%NIONS,SYMM%ROTMAP,SYMM%MAGROT,SYMM%ISYM,IU6K,IO%IU0)
+#else
+      CALL RE_READ_KPOINTS(KPOINTS,LATT_CUR, &
+           SYMM%ISYM>=0.AND..NOT.WDES%LNONCOLLINEAR, &
+           T_INFO%NIONS,SYMM%ROTMAP,SYMM%MAGROT,SYMM%ISYM,IU6K,IO%IU0)
+#endif
+      CALL RE_GEN_LAYOUT(GRID,WDES,KPOINTS,LATT_CUR,LATT_INI,IO%IU6,IO%IU0)
+      CALL REALLOCATE_WAVE(W0,GRID,WDES,NONL_S,T_INFO,P,LATT_CUR)
+   ENDIF
+
+   INFO%IALGO=IALGO_SAVE
+   CLOSE(UNIT_EMLR_OUTPUT)
+
+   END SUBROUTINE EMLR_MAIN
+
+   SUBROUTINE EMLR_KERNEL( &
+      HAMILTONIAN,P,WDES,NONLR_S,NONL_S,W0,LATT_CUR,LATT_INI, &
+      T_INFO,DYN,INFO,IO,MIX,KPOINTS,SYMM,GRID,GRID_SOFT, &
+      GRIDC,GRIDB,GRIDUS,C_TO_US,B_TO_C,SOFT_TO_C, &
+      CHTOT,DENCOR,CSTRF,CDIJ,CQIJ,CRHODE, &
+      N_MIX_PAW,RHOLM,SV,LMDIM,IRDMAX,NEDOS,EFERMI,DEG_CLUSTER,&
+      OMEGA,QVEC,W0_KPQ,W0_KMQ,W1_KPQ,W1_KMQ,SV_EXT,CDIJ_EXT,CHI,CHI_G,CRHODE1,GVEC)
+
+      IMPLICIT NONE
+      !=======================================================================
+      !  input/output variables
+      !=======================================================================
+      TYPE (ham_handle)  HAMILTONIAN
+      TYPE (type_info)   T_INFO        ! poscar description
+      TYPE (potcar)      P(T_INFO%NTYP)! pseudo potential
+      TYPE (wavedes)     WDES
+      TYPE (nonlr_struct) NONLR_S      ! non local projection operators in real space
+      TYPE (nonl_struct) NONL_S        ! non local projection operators in recip space
+      TYPE (wavespin)    W0            ! unperturbed wavefunctions
+      TYPE (latt)        LATT_CUR      ! lattice
+      TYPE (latt)        LATT_INI
+      TYPE (dynamics)    DYN
+      TYPE (info_struct) INFO
+      TYPE (in_struct)   IO
+      TYPE (mixing)      MIX
+      TYPE (kpoints_struct) KPOINTS
+      TYPE (symmetry)    SYMM
+      TYPE (grid_3d)     GRID       ! grid for wavefunctions
+      TYPE (grid_3d)     GRID_SOFT  ! grid for soft chargedensity
+      TYPE (grid_3d)     GRIDC      ! grid for potentials/charge
+      TYPE (grid_3d)     GRIDUS     ! temporary grid in us.F
+      TYPE (grid_3d)     GRIDB      ! Broyden grid
+      TYPE (transit)     B_TO_C     ! index table between GRIDB and GRIDC
+      TYPE (transit)     C_TO_US    ! index table between GRIDC and GRIDUS
+      TYPE (transit)     SOFT_TO_C  ! index table between GRID_SOFT and GRIDC
+
+      INTEGER LMDIM,IRDMAX,NEDOS
+      REAL(q) EFERMI
+
+      COMPLEX(q)  CHTOT(GRIDC%MPLWV,WDES%NCDIJ) ! charge-density in real / reciprocal space
+                                                ! \tilde n + \hat n
+                                                ! \tilde n : soft pseudo-charge-density
+                                                ! \hat n :  compensation charges
+      RGRID       DENCOR(GRIDC%RL%NP)           ! partial core
+                                                ! \tilde n_c : partial electronic core density
+      COMPLEX(q)  CSTRF(GRIDC%MPLWV,T_INFO%NTYP)
+      !  augmentation related quantities
+      OVERLAP  CDIJ(LMDIM,LMDIM,WDES%NIONS,WDES%NCDIJ), &
+               CQIJ(LMDIM,LMDIM,WDES%NIONS,WDES%NCDIJ), &
+               CRHODE(LMDIM,LMDIM,WDES%NIONS,WDES%NCDIJ)  ! one center occupancies
+      !  paw sphere charge density
+      INTEGER N_MIX_PAW
+      REAL(q) RHOLM(N_MIX_PAW,WDES%NCDIJ)
+      !  charge-density and potential on soft grid
+      RGRID       SV(DIMREAL(GRID%MPLWV),WDES%NCDIJ)
+      TYPE (eigenf_cluster_pointer),POINTER :: DEG_CLUSTER(:,:)
+      ! !=======================================================================
+      ! ! physical variables
+      ! !=======================================================================
+      REAL(q) :: OMEGA
+      REAL(q) :: QVEC(3)
+      TYPE (wavespin)     :: W0_KPQ            ! W0_k+q
+      TYPE (wavespin)     :: W0_KMQ            ! W0_k-q
+      TYPE (wavespin)     :: W1_KPQ            ! first order change of wavefunction
+      TYPE (wavespin)     :: W1_KMQ            ! first order change of wavefunction
+      RGRID   :: SV_EXT(DIMREAL(GRID%MPLWV),WDES%NCDIJ)
+      OVERLAP :: CDIJ_EXT(LMDIM,LMDIM,WDES%NIONS,WDES%NCDIJ)
+      COMPLEX(q) :: CHI(GRIDC%MPLWV,4)     ! spin susceptibility accurate in real space
+      COMPLEX(q) :: CHI_G(GRIDC%MPLWV,4)   ! spin susceptibility accurate in reciprocal space
+      OVERLAP :: CRHODE1(LMDIM,LMDIM,WDES%NIONS,WDES%NCDIJ)
+      INTEGER :: GVEC(3)               ! G , currently to monitor convergence of CHI and keep compatibility
+      ! !=======================================================================
+      ! !  local variables
+      ! !=======================================================================
+      REAL(q), ALLOCATABLE :: KPQ(:,:)
+      REAL(q), ALLOCATABLE :: KMQ(:,:)
+      REAL(q), ALLOCATABLE :: KORIG(:,:)
+      TYPE (wavespin)     :: WXI               ! stores H(1) - epsilon S(1) | phi_0>
+      ! ! decompose the density matrix into hermitian part and antihermitian part
+      COMPLEX(q) :: CHDEN1_H(GRID_SOFT%MPLWV,WDES%NCDIJ)
+      COMPLEX(q) :: CHDEN1_AH(GRID_SOFT%MPLWV,WDES%NCDIJ)
+      COMPLEX(q) :: CHTOT1_H(GRIDC%MPLWV,WDES%NCDIJ)
+      COMPLEX(q) :: CHTOT1_AH(GRIDC%MPLWV,WDES%NCDIJ)
+      OVERLAP :: CRHODE1_H(LMDIM,LMDIM,WDES%NIONS,WDES%NCDIJ)
+      OVERLAP :: CRHODE1_AH(LMDIM,LMDIM,WDES%NIONS,WDES%NCDIJ)
+      REAL(q) :: RHOLM1_H(N_MIX_PAW,WDES%NCDIJ)
+      REAL(q) :: RHOLM1_AH(N_MIX_PAW,WDES%NCDIJ)
+      REAL(q) :: RHOLM1(N_MIX_PAW*2,WDES%NCDIJ)
+      ! ! store last step data
+      COMPLEX(q) :: CHTOTL_H(GRIDC%MPLWV,WDES%NCDIJ)
+      COMPLEX(q) :: CHTOTL_AH(GRIDC%MPLWV,WDES%NCDIJ)
+
+      COMPLEX(q) :: CHTOT1_H_COPY(GRIDC%MPLWV,WDES%NCDIJ)
+      COMPLEX(q) :: CHTOT1_AH_COPY(GRIDC%MPLWV,WDES%NCDIJ)
+      REAL(q) :: RHOLM1_COPY(N_MIX_PAW*2,WDES%NCDIJ)
+
+      REAL(q) :: RHOLML(N_MIX_PAW*2,WDES%NCDIJ)
+
+      REAL(q) :: RMS,RMS_LAST
+      REAL(q) :: RMS_KPQ(NCH)            ! magnitude of residual vector
+      REAL(q) :: RMS_KMQ(NCH)           ! magnitude of residual vector
+      REAL(q) :: RMS_KPQ_FINAL(NCH)            ! magnitude of residual vector
+      REAL(q) :: RMS_KMQ_FINAL(NCH)           ! magnitude of residual vector
+
+      ! INTEGER :: IONODE,NODE_ME
+      REAL(q) :: DESUM,DESUM2                     ! change of energy
+
+      REAL(q) :: RMST,RMSC,RMSP,WEIGHT,RMST_LAST          ! mixer
+      INTEGER :: ICOUEV                    ! number of H | phi> evaluations
+      INTEGER :: IERRBR
+      INTEGER :: IERROR
+      INTEGER :: N                         ! main loop counter (electronic step)
+      ! !  density of states
+      REAL(q) :: EENTROPY,EFERMI1
+      REAL(q)    DOS(NEDOS,WDES%ISPIN),DOSI(NEDOS,WDES%ISPIN)
+      ! ! local l-projected wavefunction characters (not really used here)
+      REAL(q)    PAR(1,1,1,1,WDES%NCDIJ),DOSPAR(1,1,1,WDES%NCDIJ)
+
+      ! ! derivative of Hamiltonian
+      RGRID   :: SV1_KPQ(DIMREAL(GRID%MPLWV),WDES%NCDIJ)       ! derivative of soft potential
+      RGRID   :: SV1_KMQ(DIMREAL(GRID%MPLWV),WDES%NCDIJ)       ! derivative of soft potential
+
+      OVERLAP :: CDIJ1_KPQ(LMDIM,LMDIM,WDES%NIONS,WDES%NCDIJ)  ! derivative of non local strength
+      OVERLAP :: CDIJ1_KMQ(LMDIM,LMDIM,WDES%NIONS,WDES%NCDIJ)  ! derivative of non local strength
+
+      COMPLEX(q) :: CHI_IM(GRIDC%MPLWV,4)  ! spin susceptibility
+      COMPLEX(q) :: CHIG(4),CSUM1,CSUM2                ! (0,x,y,z)
+      REAL(q) :: CHI0,TOL0,CHB0,CHI00
+      LOGICAL :: LOMEGA0
+      LOGICAL :: LQVEC0
+      LOGICAL :: LSUBTRACT,LRESET,LRESET_KPQ,LRESET_KMQ
+      REAL(q) :: QVEC_CART(3)
+      INTEGER :: ISP,NI,NK,I,J,NIP,IMIX
+      character(10) FILENAME
+      ! ! wave function
+
+      ! ! linear response using symmetry
+      ! TYPE (skpoints_trans)   :: KPOINTS_TRANS
+      ! INTEGER                 :: NKORIG
+      ! ! spin susceptibility
+      ! 
+
+      ! INTEGER    :: IGVEC
+      ! INTEGER   , ALLOCATABLE :: GVEC_OUTPUT(:,:)
+      ! COMPLEX(q), ALLOCATABLE :: CHIG_OUTPUT(:,:)
+      ! COMPLEX(q), ALLOCATABLE :: CHIGPM_OUTPUT(:,:) ! (0,+,-,z)
+      ! ! frequence
+      ! INTEGER :: NOMEGA
+      ! REAL(q) :: OMEGAMIN
+      ! REAL(q) :: OMEGAMAX
+      ! LOGICAL :: LOMEGALIST
+      ! REAL(q), ALLOCATABLE :: OMEGALIST(:)
+
+      ! INTEGER :: IOMEGA
+      ! REAL(q) :: DOMEGA
+
+
+
+      ! ! q-vector
+      ! INTEGER :: NQVEC,NQPATH,NPATH,NPATH2
+      ! INTEGER :: IQVEC,IQPATH,IPATH
+      ! REAL(q), ALLOCATABLE :: QVECLIST(:,:)
+      ! REAL(q), ALLOCATABLE :: QVECPATH(:,:)
+
+      ! INTEGER :: GVEC_READ(3)
+
+
+
+      ! REAL(q) :: GVEC_CART(3)
+      ! INTEGER    :: NGVEC_OUTPUT
+      ! INTEGER   , ALLOCATABLE :: GVEC_OUTPUT_READ(:,:)
+      ! REAL(q) :: QPG_CART(3)           ! q+G
+      ! 
+
+      ! ! strength of external field
+      ! REAL(q) :: REAL_FIELD(4)
+      ! REAL(q) :: IMAG_FIELD(4)
+      !             ! electronic and magnetic field in unit eV
+
+      ! LOGICAL :: LBROT
+
+
+      ! ! input and output
+      ! INTEGER :: STAT
+
+      ! LOGICAL :: LFOUND
+      ! CHARACTER(LEN=80) :: INLINE
+      ! INTEGER :: IU6K                  ! OUTCAR k-points
+      ! ! control
+
+
+      ! REAL(q) :: ETA                   ! complex shift i*\eta
+      !                                     ! improves stability in particular
+      !                                     ! if degenerated eigenvalue pairs have not been resolved
+
+
+
+      ! ! mixing
+      ! INTEGER :: IMIX                  ! type of mixing
+      ! REAL(q) :: AMIX                  ! mixing parameter A
+      ! REAL(q) :: BMIX                  ! mixing parameter B
+      ! REAL(q) :: AMIX_MAG              ! mixing parameter A for magnetization
+      ! REAL(q) :: BMIX_MAG              ! mixing parameter B for magnetization
+      ! REAL(q) :: AMIN                  ! minimal mixing parameter A
+      ! ! variables for W0_k+q and W0_k-q
+      ! REAL(q) :: EDIFF                 ! break condition
+      ! REAL(q) :: RMS                   ! change
+      ! REAL(q) :: TOTEN,TOTENL          ! energy
+      ! INTEGER :: NSIM
+      ! REAL(q) :: X,EXHF
+      ! INTEGER :: I,IALGO_SAVE
+
+      !=======================================================================
+      !  start working
+      !=======================================================================
+
+      IF (ABS(OMEGA) < 1E-5_q) THEN
+         LOMEGA0=.TRUE.
+         OMEGA=0
+      ELSE
+         LOMEGA0=.FALSE.
+      ENDIF
+
+      IF (IO%IU0>=0) THEN
+         WRITE(UNIT_EMLR_OUTPUT,'("QVEC                :",3(x,F7.4))') QVEC
+         WRITE(UNIT_EMLR_OUTPUT,'("GVEC_INPUT          :",3(x,I3))') GVEC
+         WRITE(UNIT_EMLR_OUTPUT,'("Omega          (eV) : ",F7.4)') OMEGA
+         WRITE(UNIT_EMLR_OUTPUT,140)
+      ENDIF
+      
+      140 FORMAT('Step  n                     mx                    my', &
+         '                    mz                    rms                   rms(final)              rms(c)')
+
+
+      ! Notice that 2*pi is omitted which should be retrieved in the subroutine
+      QVEC_CART(1)=(QVEC(1)*LATT_CUR%B(1,1)+QVEC(2)*LATT_CUR%B(1,2)+QVEC(3)*LATT_CUR%B(1,3))
+      QVEC_CART(2)=(QVEC(1)*LATT_CUR%B(2,1)+QVEC(2)*LATT_CUR%B(2,2)+QVEC(3)*LATT_CUR%B(2,3))
+      QVEC_CART(3)=(QVEC(1)*LATT_CUR%B(3,1)+QVEC(2)*LATT_CUR%B(3,2)+QVEC(3)*LATT_CUR%B(3,3))
+      IF (SUM(QVEC_CART**2) < 1E-10_q) THEN
+         LQVEC0=.TRUE.
+         QVEC=0
+         QVEC_CART=0
+      ELSE
+         LQVEC0=.FALSE.
+      ENDIF
+
+      ALLOCATE(KORIG(3,WDES%NKPTS),KPQ(3,WDES%NKPTS),KMQ(3,WDES%NKPTS))
+      KORIG=WDES%VKPT(1:3,1:WDES%NKPTS)
+      DO NK=1,WDES%NKPTS
+      KPQ(:,NK)=KORIG(:,NK)+QVEC
+      KMQ(:,NK)=KORIG(:,NK)-QVEC
+      ENDDO
+
+      !=======================================================================
+      !  allocate and initialise
+      !=======================================================================
+      CALL REINIT_DEG_CLUSTERS(WDES,DEG_CLUSTER)
+
+      CALL ALLOCW(WDES,WXI)
+      ! CALL ALLOCW(WDES,W1_KPQ)
+      ! CALL ALLOCW(WDES,W1_KMQ)
+
+      ! charge density
+      CHTOT1_H  =0
+      CRHODE1_H =0
+      RHOLM1_H  =0
+      CHTOT1_AH =0
+      CRHODE1_AH=0
+      RHOLM1_AH =0
+      RHOLM1    =0
+      !=======================================================================
+      !  main selfconsistent loop for linear response
+      !=======================================================================
+      ! to make timing more sensefull syncronize now
+      CALLMPI( MPI_barrier( WDES%COMM%MPI_COMM, IERROR ))
+      CALL START_TIMING("LOOP")
+
+      DWRITE0 'electron entered'
+
+      INFO%LMIX=.FALSE.
+      MIX%LRESET=.TRUE.
+
+      LSUBTRACT=.FALSE.
+      IF (LQVEC0) LSUBTRACT=.TRUE.
+
+      ! write(FILENAME,'("CDIJ_",I0.4)') WDES%COMM%NODE_ME
+      ! OPEN(UNIT=1099,FILE='logdir/'//TRIM(FILENAME),STATUS='UNKNOWN')
+      CHI0=10._q
+      RMST = 1E14
+      MIX%HARD_RESET=.TRUE.
+      IMIX=MIX%IMIX
+      electron: DO N=1,NCH
+      IF(LADAPT) STEP_LENGTH = MAGRHO0/CHI0*STEP_BASE
+      CALL START_TIMING("G")
+      !=======================================================================
+      !  input : CHTOT1 in reciprocal space and (n,m) representation
+      !          CRHODE1 and RHOLM1 in (n,m) representation
+      !  output:
+      !  first derivative of potential (SV1) in real space and spinor representation
+      !  first derivatives of non local strenght (CDIJ1) in spinor representation
+      !=======================================================================
+      IF (N==1) THEN 
+         SV1_KPQ=SV1_KPQ_IND
+         CDIJ1_KPQ=CDIJ1_KPQ_IND
+      ELSE
+      ! hermitian part
+      CALL EMLR_POT_DER4X(WDES,GRID,GRIDC,GRIDUS,GRID_SOFT,C_TO_US,SOFT_TO_C, &
+            INFO,T_INFO,P,LATT_CUR,CSTRF,CHTOT,CHTOT1_H,CHTOT1_AH,DENCOR,SV1_KPQ,LMDIM, &
+            CDIJ1_KPQ,CRHODE,CRHODE1_H,CQIJ,N_MIX_PAW,RHOLM,RHOLM1_H,IRDMAX,STEP_LENGTH,QVEC_CART)
+      ! IF(WDES%NIONS>0) THEN
+      ! WRITE(1099,*) "LMDIM",LMDIM
+      ! DO NI=1,T_INFO%NIONS
+      !    NIP=NI_LOCAL(NI, WDES%COMM_INB)
+      !    IF (NIP==0) CYCLE 
+      !    WRITE(1099,*) "CDIJ1_KPQ N:",N   
+      !    WRITE(1099,*) "ION #",NI
+      !    DO ISP = 1,WDES%NCDIJ
+      !       WRITE(1099,*) "ISP #",ISP
+      !       DO I=1,LMDIM
+      !          WRITE(1099,'(99(F16.8,F12.8))') (CDIJ1_KPQ(I,J,NIP,ISP) ,J=1,LMDIM)
+      !          ENDDO
+      !    ENDDO
+      ! ENDDO
+      ! ENDIF
+      ! antihermitian part
+      CALL EMLR_POT_DER4X(WDES,GRID,GRIDC,GRIDUS,GRID_SOFT,C_TO_US,SOFT_TO_C, &
+            INFO,T_INFO,P,LATT_CUR,CSTRF,CHTOT,CHTOT1_AH,-CHTOT1_H,DENCOR,SV1_KMQ,LMDIM, &
+            CDIJ1_KMQ,CRHODE,CRHODE1_AH,CQIJ,N_MIX_PAW,RHOLM,RHOLM1_AH,IRDMAX,STEP_LENGTH,QVEC_CART)
+      ! IF(WDES%NIONS>0) THEN
+      !    WRITE(1099,*) "LMDIM",LMDIM
+      !    DO NI=1,T_INFO%NIONS
+      !       NIP=NI_LOCAL(NI, WDES%COMM_INB)
+      !       IF (NIP==0) CYCLE
+      !       WRITE(1099,*) "CDIJ1_KMQ N:",N   
+      !       WRITE(1099,*) "ION #",NI
+      !       DO ISP = 1,WDES%NCDIJ
+      !          WRITE(1099,*) "ISP #",ISP
+      !          DO I=1,LMDIM
+      !             WRITE(1099,'(99(F16.8,F12.8))') (CDIJ1_KMQ(I,J,NIP,ISP) ,J=1,LMDIM)
+      !             ENDDO
+      !       ENDDO
+      !    ENDDO
+      !    ENDIF
+      ! derivative of soft potential and non local strenght for positive omega and q
+      SV1_KPQ=SV1_KPQ+(0._q,1._q)*SV1_KMQ
+      CDIJ1_KPQ=CDIJ1_KPQ+(0._q,1._q)*CDIJ1_KMQ
+      ! IF(WDES%NIONS>0) THEN
+      !    WRITE(1099,*) "LMDIM",LMDIM
+      !    DO NI=1,T_INFO%NIONS
+      !       NIP=NI_LOCAL(NI, WDES%COMM_INB)
+      !       IF (NIP==0) CYCLE 
+      !       WRITE(1099,*) "CDIJ1_KPQ +i*CDIJ1_KMQ N:",N   
+      !       WRITE(1099,*) "ION #",NI
+      !       DO ISP = 1,WDES%NCDIJ
+      !          WRITE(1099,*) "ISP #",ISP
+      !          DO I=1,LMDIM
+      !             WRITE(1099,'(99(F16.8,F12.8))') (CDIJ1_KPQ(I,J,NIP,ISP) ,J=1,LMDIM)
+      !             ENDDO
+      !       ENDDO
+      !    ENDDO
+      ! ENDIF
+      ! SV1_KPQ in real space with 2x2 density matrix in order [00,01,10,11]
+      ! storage convention to (total,magnetization)
+      CALL RL_FLIP(SV1_KPQ,GRID,WDES%NCDIJ,.FALSE.)
+      CALL CDIJ_FLIP(WDES,LMDIM,CDIJ1_KPQ,INFO%LOVERL,.FALSE.)
+      ENDIF
+      SV1_KPQ(:,1)=0
+      SV1_KPQ(:,4)=0
+      CDIJ1_KPQ(:,:,:,1)=0
+      CDIJ1_KPQ(:,:,:,4)=0
+      ! add external field
+      !  DO ISP=1,WDES%NCDIJ
+      !     ! for SV1, use the version of density, so a factor of 2 should be add
+      !     SV1_KPQ(:,ISP)=SV1_KPQ(:,ISP)-SV_EXT*FIELD(ISP)*2._q
+      !     CDIJ1_KPQ(:,:,:,ISP)=CDIJ1_KPQ(:,:,:,ISP)-CDIJ_EXT*FIELD(ISP)
+      !  ENDDO
+      ! SV1_KPQ=0
+      IF (N==2) SV1_KPQ_IND0=SV1_KPQ
+      SV1_KPQ=SV1_KPQ-SV_EXT*2._q
+      ! CDIJ1_KPQ=0
+      ! CDIJ1_KPQ=-CDIJ_EXT
+      CDIJ1_KPQ = CDIJ1_KPQ-CDIJ_EXT
+      ! For negative omega and q
+      SV1_KMQ=CONJG(SV1_KPQ)
+      DO ISP=1,WDES%NCDIJ
+         DO NI=1,WDES%NIONS
+            CDIJ1_KMQ(:,:,NI,ISP)=CONJG(TRANSPOSE(CDIJ1_KPQ(:,:,NI,ISP)))
+         ENDDO
+      ENDDO
+
+      ! back to spinor representation
+      CALL RL_FLIP(SV1_KPQ,GRID,WDES%NCDIJ,.TRUE.)
+      CALL RL_FLIP(SV1_KMQ,GRID,WDES%NCDIJ,.TRUE.)
+      CALL CDIJ_FLIP(WDES,LMDIM,CDIJ1_KPQ,INFO%LOVERL,.TRUE.)
+      CALL CDIJ_FLIP(WDES,LMDIM,CDIJ1_KMQ,INFO%LOVERL,.TRUE.)
+      CALL STOP_TIMING("G",IO%IU6,"POT+DIJ")
+
+      !=======================================================================
+      !  calculate |xi>
+      !  (1) For omega =0 and q =0 : |xi> = H(1) - e(1) S(0) | phi(0)>
+      !  (2) For omega =0 and q/=0 : |xi> = H(1) - e'(1) S(0) | phi(0)>
+      !  (3) For omega/=0          : |xi> = H(1) | phi(0)>
+      !  where H(1) are the first order change of the Hamiltonian
+      !  e(1) is the first order change of the eigenenergy
+      !  e(1) is evaluated as well and stored in WXI%CELTOT
+      !  e'(1) is the SVD value between degenerated pair in k and k+q state
+      !  input : SV1_KPQ in real space and spinor representation
+      !          CDIJ1_KPQ in spinor representation
+      !
+      !  In principal, calculate e(1) or e'(1) will not change the result, but
+      !  improve the accuracy.
+      !=======================================================================
+      !=======================================================================
+      !  calculate the first order change of the wavefunction
+      !    H(0) - epsilon S(0) | phi_1> = - |xi>
+      !  Performing Loewdin perturbation theory in the sub space spanned
+      !  by the calculated orbitals will improve the accuracy (I think)
+      !  However, only for omega =0 and q =0, Loewdin theory is done.
+      !  (1) For q/=0, k+q eigen state is needed
+      !  (2) For omega/=0, omega need to be inserted in to EDDIAG_LR
+      !=======================================================================
+      ! resolve degeneragy problem
+      IF (LOMEGA0 .AND. LQVEC0 .AND. N==1 .AND. LFERMI) THEN
+         DO ISP=1,RESOLVE_DEG_NTIMES
+            CALL EMLR_HAMIL(GRID,INFO,LATT_CUR,NONLR_S,NONL_S, W0, WXI, WDES, &
+                  LMDIM,CDIJ1_KPQ, CQIJ, SV1_KPQ, RMS, ICOUEV, LSUBTRACT)
+            CALL MRG_CEL(WDES,WXI)
+            WXI%CELTOT=REAL(WXI%CELTOT,q)
+            CALL EDDIAG_LR(W1_KPQ,W0,WXI,LMDIM,CQIJ,INFO%LOVERL,.FALSE.,CSHIFT,IO%IU0,DEG_CLUSTER,.TRUE.,OMEGA,LNOIMAG=LNOIMAG)
+         ENDDO
+         W1_KPQ%CW   =0
+         W1_KPQ%CPROJ=0
+
+         ! Now W0 is rotated, copy to W0_KPQ and W0_KMQ again
+         CALL EMLR_COPYW(W0,W0_KPQ)
+         IF (.NOT. LKSHIFT) CALL EMLR_COPYW(W0,W0_KMQ)
+      ENDIF
+      !=======================================================================
+      ! +q and +omega part
+      !=======================================================================
+      ! k+q
+      WDES%VKPT(1:3,1:WDES%NKPTS)=KPQ
+      ! kinetic energy |k+q+G|^2
+      CALL SET_DATAKE(WDES, LATT_CUR%B)
+      ! non-local projector |p_k+q>
+      IF (.NOT. INFO%LREAL) THEN
+         CALL SPHER(GRID,NONL_S,P,WDES,LATT_CUR, 1)
+      ENDIF
+
+      CALL EMLR_HAMIL(GRID,INFO,LATT_CUR,NONLR_S,NONL_S, W0, WXI, WDES, &
+            LMDIM,CDIJ1_KPQ, CQIJ, SV1_KPQ, RMS, ICOUEV, LSUBTRACT)
+      CALL EMLR_PROJECT(GRID,LATT_CUR,NONLR_S,NONL_S,W0_KPQ,WXI,INFO%LREAL,LMDIM,CQIJ,EPRO)
+      CALL MRG_CEL(WDES,WXI)
+
+      ! Passing e_nk in W1_KPQ
+      W1_KPQ%CELTOT=W0%CELTOT
+      WRITE(UNIT_EMLR_RMS,'(I5,"   RMS_KPQ")',ADVANCE='NO') N
+      IF (N==1) LRESET_KPQ=.TRUE.
+      DO I = 1,MAX(60,NLS),10
+         IF (N/=1 .AND. I>NLS) EXIT 
+         RMS_LAST = RMS_KPQ_FINAL(N)
+         CALL STOP_TIMING("G",IO%IU6,"before LRDIAG")
+         CALL EDDIAG_LR(W1_KPQ,W0_KPQ,WXI,LMDIM,CQIJ,INFO%LOVERL,.FALSE.,CSHIFT,IO%IU0,DEG_CLUSTER,OMEGA=OMEGA,EPRO=EPRO,LCLEAN=.TRUE.)
+         CALL STOP_TIMING("G",IO%IU6,"after LRDIAG")
+         IF (LNOIMAG) THEN
+            CALL LINEAR_RESPONSE_DIIS(GRID,INFO,LATT_CUR,NONLR_S,NONL_S,W1_KPQ,WXI,W0,WDES, &
+               LMDIM,CDIJ,CQIJ,RMS_KPQ(N),DESUM,ICOUEV,SV,0._q,IO%IU6,IO%IU0,LRESET_KPQ,IERROR, &
+               OMEGA,10,LSBREAK,LSDEPER,RMS_KPQ_FINAL(N))
+         ELSE 
+            CALL LINEAR_RESPONSE_DIIS(GRID,INFO,LATT_CUR,NONLR_S,NONL_S,W1_KPQ,WXI,W0,WDES, &
+               LMDIM,CDIJ,CQIJ,RMS_KPQ(N),DESUM,ICOUEV,SV,CSHIFT,IO%IU6,IO%IU0,LRESET_KPQ,IERROR, &
+               OMEGA,10,LSBREAK,LSDEPER,RMS_KPQ_FINAL(N))
+         ENDIF 
+         LRESET_KPQ=.FALSE.
+         WRITE(UNIT_EMLR_RMS,'(x,E10.3)',ADVANCE='NO') RMS_KPQ_FINAL(N)
+         IF (I==1) RMS=RMS_KPQ(N)
+         IF (IERROR>0 .and. IO%IU0>=0) WRITE(IO%IU0,*) 'WARNING: LINEAR_RESPONSE_DIIS matrix is zero and required accuracy may not reached for some bands',N,IERROR
+         IF(RMS_KPQ_FINAL(N)<SQRT(ABS(LSBREAK))*2) EXIT
+         IF(I>1 .AND. ABS((RMS_LAST-RMS_KPQ_FINAL(N))/RMS_KPQ_FINAL(N))<0.05_q ) EXIT
+      ENDDO
+      RMS_KPQ(N)=RMS
+      IF (N>1) THEN
+         IF(ABS((RMS_LAST-RMS_KPQ_FINAL(N))/RMS_KPQ_FINAL(N))<0.05_q ) THEN
+            IF (RMS_KPQ_FINAL(N)>CHI0/CHI00*CHB0) LRESET_KPQ=.TRUE. 
+            IF (RMS_KPQ_FINAL(N)>20*CHI0/CHI00*CHB0) MIX%LRESET=.TRUE.
+         ENDIF
+      ENDIF
+         
+      
+      CALL EMLR_HAMIL(GRID,INFO,LATT_CUR,NONLR_S,NONL_S, W0, WXI, WDES, &
+      LMDIM,CDIJ1_KPQ, CQIJ, SV1_KPQ, RMS, ICOUEV, LSUBTRACT)
+
+      W1_KPQ%CELTOT=W0%CELTOT
+      W1_KPQ%FERTOT=W0%FERTOT
+      CALL EDDIAG_LR(W1_KPQ,W0_KPQ,WXI,LMDIM,CQIJ,INFO%LOVERL,.FALSE.,CSHIFT,IO%IU0,DEG_CLUSTER,OMEGA=OMEGA,EPRO=EPRO,LNOIMAG=LNOIMAG)
+
+      ! WRITE(UNIT_EMLR_OUTPUT,'(5(x,E10.3))') RMS_KPQ(N),RMS_KMQ(N),RMS_KPQ_FINAL(N),RMS_KMQ_FINAL(N)
+      ! CYCLE
+      !         CALL PROJ_matrix(GRID,INFO,LATT_CUR,NONLR_S,NONL_S,W0,W1_KPQ,WXI,WDES,LMDIM,CQIJ,OMEGA,CSHIFT,N)
+      !=======================================================================
+      ! -q and -omega part
+      !=======================================================================
+      IF (LKSHIFT) THEN
+         ! k-q is shifted to k
+         WDES%VKPT(1:3,1:WDES%NKPTS)=KORIG
+         ! kinetic energy |k+G|^2
+         CALL SET_DATAKE(WDES, LATT_CUR%B)
+         ! non-local projector |p_k>
+         IF (.NOT. INFO%LREAL) THEN
+            CALL SPHER(GRID,NONL_S,P,WDES,LATT_CUR, 1)
+         ENDIF
+
+         CALL EMLR_HAMIL(GRID,INFO,LATT_CUR,NONLR_S,NONL_S, W0_KPQ, WXI, WDES, &
+               LMDIM,CDIJ1_KMQ, CQIJ, SV1_KMQ, RMS, ICOUEV, LSUBTRACT)
+         CALL EMLR_PROJECT(GRID,LATT_CUR,NONLR_S,NONL_S,W0,WXI,INFO%LREAL,LMDIM,CQIJ,EPRO)
+         CALL MRG_CEL(WDES,WXI)
+
+         ! Passing e_nk in W1_KMQ
+         W1_KMQ%CELTOT=W0_KPQ%CELTOT
+         WRITE(UNIT_EMLR_RMS,'("   RMS_KMQ")',ADVANCE='NO')
+         IF (N==1) LRESET_KMQ=.TRUE.
+         DO I = 1,MAX(60,NLS),10
+            IF (N/=1 .AND. I>NLS) EXIT 
+            RMS_LAST = RMS_KMQ_FINAL(N)
+            CALL EDDIAG_LR(W1_KMQ,W0,WXI,LMDIM,CQIJ,INFO%LOVERL,.FALSE.,CSHIFT,IO%IU0,DEG_CLUSTER,OMEGA=-OMEGA,EPRO=EPRO,LCLEAN=.TRUE.)
+            IF (LNOIMAG) THEN
+               CALL LINEAR_RESPONSE_DIIS(GRID,INFO,LATT_CUR,NONLR_S,NONL_S,W1_KMQ,WXI,W0_KPQ,WDES, &
+                  LMDIM,CDIJ,CQIJ,RMS_KMQ(N),DESUM2,ICOUEV,SV,0._q,IO%IU6,IO%IU0,LRESET_KMQ,IERROR, &
+                  -OMEGA,10,LSBREAK,LSDEPER,RMS_KMQ_FINAL(N))
+            ELSE 
+               CALL LINEAR_RESPONSE_DIIS(GRID,INFO,LATT_CUR,NONLR_S,NONL_S,W1_KMQ,WXI,W0_KPQ,WDES, &
+                  LMDIM,CDIJ,CQIJ,RMS_KMQ(N),DESUM2,ICOUEV,SV,CSHIFT,IO%IU6,IO%IU0,LRESET_KMQ,IERROR, &
+                  -OMEGA,10,LSBREAK,LSDEPER,RMS_KMQ_FINAL(N))
+            ENDIF
+            LRESET_KMQ=.FALSE.
+            WRITE(UNIT_EMLR_RMS,'(x,E10.3)',ADVANCE='NO') RMS_KMQ_FINAL(N)
+            IF (I==1) RMS=RMS_KMQ(N)
+            IF (IERROR>0 .and. IO%IU0>=0) WRITE(IO%IU0,*) 'WARNING: LINEAR_RESPONSE_DIIS matrix is zero and required accuracy may not reached for some bands',N,IERROR
+            IF(RMS_KMQ_FINAL(N)<SQRT(ABS(LSBREAK))*2) EXIT
+            IF(I>1 .AND. ABS((RMS_LAST-RMS_KMQ_FINAL(N))/RMS_KMQ_FINAL(N))<0.05_q ) EXIT
+         ENDDO 
+         RMS_KMQ(N)=RMS
+         IF (N>1) THEN
+            IF( ABS((RMS_LAST-RMS_KMQ_FINAL(N))/RMS_KMQ_FINAL(N))<0.05_q ) THEN
+               IF (RMS_KMQ_FINAL(N)>CHI0/CHI00*CHB0) LRESET_KMQ=.TRUE.
+               IF (RMS_KMQ_FINAL(N)>20*CHI0/CHI00*CHB0) MIX%LRESET=.TRUE.
+            ENDIF
+         ENDIF
+
+         CALL EMLR_HAMIL(GRID,INFO,LATT_CUR,NONLR_S,NONL_S, W0_KPQ, WXI, WDES, &
+               LMDIM,CDIJ1_KMQ, CQIJ, SV1_KMQ, RMS, ICOUEV, LSUBTRACT)
+
+         W1_KMQ%CELTOT=W0_KPQ%CELTOT
+         W1_KMQ%FERTOT=W0_KPQ%FERTOT
+         CALL EDDIAG_LR(W1_KMQ,W0,WXI,LMDIM,CQIJ,INFO%LOVERL,.FALSE.,CSHIFT,IO%IU0,DEG_CLUSTER,OMEGA=-OMEGA,EPRO=EPRO,LNOIMAG=LNOIMAG)
+      ELSE
+         ! k-q
+         WDES%VKPT(1:3,1:WDES%NKPTS)=KMQ
+         ! kinetic energy |k-q+G|^2
+         CALL SET_DATAKE(WDES, LATT_CUR%B)
+         ! non-local projector |p_k-q>
+         IF (.NOT. INFO%LREAL) THEN
+            CALL SPHER(GRID,NONL_S,P,WDES,LATT_CUR, 1)
+         ENDIF
+
+         CALL EMLR_HAMIL(GRID,INFO,LATT_CUR,NONLR_S,NONL_S, W0, WXI, WDES, &
+               LMDIM,CDIJ1_KMQ, CQIJ, SV1_KMQ, RMS, ICOUEV, LSUBTRACT)
+         CALL EMLR_PROJECT(GRID,LATT_CUR,NONLR_S,NONL_S,W0_KMQ,WXI,INFO%LREAL,LMDIM,CQIJ,EPRO)
+         CALL MRG_CEL(WDES,WXI)
+
+         ! Passing e_nk in W1_KMQ
+         W1_KMQ%CELTOT=W0%CELTOT
+         IF (N==1) LRESET_KMQ=.TRUE.
+         DO I = 1,MAX(60,NLS),10
+            IF (N/=1 .AND. I>NLS) EXIT 
+            RMS_LAST = RMS_KMQ_FINAL(N)
+            CALL EDDIAG_LR(W1_KMQ,W0_KMQ,WXI,LMDIM,CQIJ,INFO%LOVERL,.FALSE.,CSHIFT,IO%IU0,DEG_CLUSTER,OMEGA=-OMEGA,EPRO=EPRO,LCLEAN=.TRUE.)
+            IF (LNOIMAG) THEN
+               CALL LINEAR_RESPONSE_DIIS(GRID,INFO,LATT_CUR,NONLR_S,NONL_S,W1_KMQ,WXI,W0,WDES, &
+                  LMDIM,CDIJ,CQIJ,RMS_KMQ(N),DESUM2,ICOUEV,SV,0._q,IO%IU6,IO%IU0,LRESET_KMQ,IERROR, &
+                  -OMEGA,10,LSBREAK,LSDEPER,RMS_KMQ_FINAL(N))
+            ELSE 
+               CALL LINEAR_RESPONSE_DIIS(GRID,INFO,LATT_CUR,NONLR_S,NONL_S,W1_KMQ,WXI,W0,WDES, &
+                  LMDIM,CDIJ,CQIJ,RMS_KMQ(N),DESUM2,ICOUEV,SV,CSHIFT,IO%IU6,IO%IU0,LRESET_KMQ,IERROR, &
+                  -OMEGA,10,LSBREAK,LSDEPER,RMS_KMQ_FINAL(N))
+            ENDIF
+            LRESET_KMQ=.FALSE.
+            IF (I==1) RMS=RMS_KMQ(N)
+            IF (IERROR>0 .and. IO%IU0>=0) WRITE(IO%IU0,*) 'WARNING: LINEAR_RESPONSE_DIIS matrix is zero and required accuracy may not reached for some bands',N,IERROR
+            IF(RMS_KMQ_FINAL(N)<SQRT(ABS(LSBREAK))*2) EXIT
+            IF(I>1 .AND. ABS((RMS_LAST-RMS_KMQ_FINAL(N))/RMS_KMQ_FINAL(N))<0.05_q ) EXIT
+         ENDDO 
+         RMS_KMQ(N)=RMS
+         IF (N>1) THEN
+            IF( ABS((RMS_LAST-RMS_KMQ_FINAL(N))/RMS_KMQ_FINAL(N))<0.05_q ) THEN
+               IF (RMS_KMQ_FINAL(N)>CHI0/CHI00*CHB0) LRESET_KMQ=.TRUE.
+               IF (RMS_KMQ_FINAL(N)>20*CHI0/CHI00*CHB0) MIX%LRESET=.TRUE.
+            ENDIF
+         ENDIF
+
+         CALL EMLR_HAMIL(GRID,INFO,LATT_CUR,NONLR_S,NONL_S, W0, WXI, WDES, &
+               LMDIM,CDIJ1_KMQ, CQIJ, SV1_KMQ, RMS, ICOUEV, LSUBTRACT)
+
+         W1_KMQ%CELTOT=W0%CELTOT
+         W1_KMQ%FERTOT=W0%FERTOT
+         CALL EDDIAG_LR(W1_KMQ,W0_KMQ,WXI,LMDIM,CQIJ,INFO%LOVERL,.FALSE.,CSHIFT,IO%IU0,DEG_CLUSTER,OMEGA=-OMEGA,EPRO=EPRO,LNOIMAG=LNOIMAG)
+
+         !CALL PROJ_matrix(GRID,INFO,LATT_CUR,NONLR_S,NONL_S,W0,W1_KMQ,WXI,WDES,LMDIM,CQIJ,-OMEGA,CSHIFT,N)
+
+         !IF (IO%IU0>=0) THEN
+         !   WRITE(IO%IU0,'("RMM: ",I3,3x,E12.5,x,I8,2(2x,E10.3))',ADVANCE='NO') N, DESUM, ICOUEV, RMS_KPQ(N), RMS_KMQ(N)
+         !ENDIF
+      ENDIF
+      WRITE(UNIT_EMLR_RMS,*) 
+      CALL STOP_TIMING("G",IO%IU6,"LRDIAG")
+      IF (N==1) CHB0=MAX(RMS_KPQ_FINAL(N)*2,RMS_KMQ_FINAL(N)*2,5E-6)
+      !=======================================================================
+      ! calculate first derivative of one electron occupancies
+      !=======================================================================
+      IF (LOMEGA0 .AND. LQVEC0 .AND. LFERMI) THEN
+         ! occupancies (FERWE) use finite differences
+         ! this could be done analytically for some methods
+         ! but not for all, so what the hell, precision is good enough
+         W1_KPQ%CELTOT=W0%CELTOT+REAL(WXI%CELTOT)*(STEP_LENGTH/2)
+         CALL DENSTA( IO%IU0, IO%IU6, WDES, W1_KPQ, KPOINTS, INFO%NELECT, &
+               INFO%NUP_DOWN, EENTROPY, EFERMI1, KPOINTS%SIGMA, .FALSE., &
+               NEDOS, 0, 0, DOS, DOSI, PAR, DOSPAR)
+         WXI%FERTOT=W1_KPQ%FERTOT
+
+         W1_KPQ%CELTOT=W0%CELTOT-REAL(WXI%CELTOT)*(STEP_LENGTH/2)
+         CALL DENSTA( IO%IU0, IO%IU6, WDES, W1_KPQ, KPOINTS, INFO%NELECT, &
+            INFO%NUP_DOWN, EENTROPY, EFERMI1, KPOINTS%SIGMA, .FALSE., &
+            NEDOS, 0, 0, DOS, DOSI, PAR, DOSPAR)
+         ! finished, store the derivative in W1_KPQ
+         W1_KPQ%FERTOT=(WXI%FERTOT-W1_KPQ%FERTOT)/STEP_LENGTH
+
+         W1_KMQ%CELTOT=W0%CELTOT+AIMAG(WXI%CELTOT)*(STEP_LENGTH/2)
+         CALL DENSTA( IO%IU0, IO%IU6, WDES, W1_KMQ, KPOINTS, INFO%NELECT, &
+               INFO%NUP_DOWN, EENTROPY, EFERMI1, KPOINTS%SIGMA, .FALSE., &
+               NEDOS, 0, 0, DOS, DOSI, PAR, DOSPAR)
+         WXI%FERTOT=W1_KMQ%FERTOT
+
+         W1_KMQ%CELTOT=W0%CELTOT-AIMAG(WXI%CELTOT)*(STEP_LENGTH/2)
+         CALL DENSTA( IO%IU0, IO%IU6, WDES, W1_KMQ, KPOINTS, INFO%NELECT, &
+            INFO%NUP_DOWN, EENTROPY, EFERMI1, KPOINTS%SIGMA, .FALSE., &
+            NEDOS, 0, 0, DOS, DOSI, PAR, DOSPAR)
+         ! finished, store the derivative in W1_KMQ
+         W1_KMQ%FERTOT=(WXI%FERTOT-W1_KMQ%FERTOT)/STEP_LENGTH
+      ELSE
+         W1_KPQ%FERTOT=0
+         W1_KMQ%FERTOT=0
+      ENDIF
+      !=======================================================================
+      ! calculate first derivative of charge density
+      !=======================================================================
+      ! store CHTOTL for later use in the mixer
+      CHTOTL_H=CHTOT1_H
+      CHTOTL_AH=CHTOT1_AH
+      RHOLML=RHOLM1
+
+      ! determine first order change of one center occupancy matrix
+      IF (LKSHIFT) THEN
+         CALL DEPSUM1(W0,W1_KPQ,WDES,LMDIM,CRHODE1_H,INFO%LOVERL,W1_KMQ,W0_KPQ)
+      ELSE
+         CALL DEPSUM1(W0,W1_KPQ,WDES,LMDIM,CRHODE1_H,INFO%LOVERL,W1_KMQ)
+      ENDIF
+      ! change storage convention to (total, magnetization)
+      CALL US_FLIP(WDES, LMDIM, CRHODE1_H, INFO%LOVERL, .FALSE.)
+      ! decompose into hermitian part and anti-hermitian part
+      DO ISP=1,WDES%NCDIJ
+         DO NI=1,WDES%NIONS
+            CRHODE1_AH(:,:,NI,ISP)=-(0._q,1._q)*(CRHODE1_H(:,:,NI,ISP)-CONJG(TRANSPOSE(CRHODE1_H(:,:,NI,ISP))))/2.0_q
+            CRHODE1_H(:,:,NI,ISP)=(CRHODE1_H(:,:,NI,ISP)+CONJG(TRANSPOSE(CRHODE1_H(:,:,NI,ISP))))/2.0_q
+         ENDDO
+      ENDDO
+
+      ! set the one center occupancy matrix passed through mixer (RHOLM1_KPQ)
+      CALL SET_RHO_PAW(WDES, P, T_INFO, INFO%LOVERL, WDES%NCDIJ, LMDIM, &
+            CRHODE1_H, RHOLM1_H)
+      CALL SET_RHO_PAW(WDES, P, T_INFO, INFO%LOVERL, WDES%NCDIJ, LMDIM, &
+            CRHODE1_AH, RHOLM1_AH)
+      RHOLM1(1:N_MIX_PAW,:)=RHOLM1_H
+      RHOLM1(N_MIX_PAW+1:N_MIX_PAW*2,:)=RHOLM1_AH
+
+      ! avoid double counting, set soft pseudo charge to 0
+      CHDEN1_H=0
+      CHDEN1_AH=0
+      ! add first order change of one center occupancy matrix times
+      ! augmentation charge distribution rho(1)_ij Q_ij(r) cos(-q.(r-Ri))
+      CHTOT1_H=0
+      CHTOT1_AH=0
+      CALL DEPLE_ADD(WDES,GRID_SOFT,GRIDC,GRIDUS,C_TO_US, &
+               LATT_CUR,P,T_INFO,SYMM, INFO%LOVERL, SOFT_TO_C,&
+               LMDIM, CRHODE1_H, CHTOT1_H, CHDEN1_H, IRDMAX, QVEC_CART, .TRUE.)
+      CALL DEPLE_ADD(WDES,GRID_SOFT,GRIDC,GRIDUS,C_TO_US, &
+               LATT_CUR,P,T_INFO,SYMM, INFO%LOVERL, SOFT_TO_C,&
+               LMDIM, CRHODE1_AH, CHTOT1_AH, CHDEN1_AH, IRDMAX, QVEC_CART, .TRUE.)
+      ! susceptibility
+      ! add (n_ae - n_ps) term
+      ! CALL AUGCHG(WDES,GRID_SOFT,GRIDC,GRIDUS,C_TO_US, &
+      !       &     LATT_CUR,P,T_INFO,SYMM, INFO%LOVERL, SOFT_TO_C,&
+      !       &     LMDIM,CRHODE1_H,CHI,CHDEN1_H, IRDMAX,.TRUE.,.FALSE., QVEC_CART, .TRUE.)
+      ! CALL AUGCHG(WDES,GRID_SOFT,GRIDC,GRIDUS,C_TO_US, &
+      !       &     LATT_CUR,P,T_INFO,SYMM, INFO%LOVERL, SOFT_TO_C,&
+      !       &     LMDIM,CRHODE1_AH,CHI_IM,CHDEN1_AH, IRDMAX,.TRUE.,.FALSE., QVEC_CART, .TRUE.)
+      ! CHI=CHI+(0._q,1._q)*CHI_IM
+
+      ! soft pseudo charge in reciprocal space
+      IF (LKSHIFT) THEN
+         CALL SOFT_CHARGE1(GRID,GRID_SOFT,W0,W1_KPQ,WDES,CHDEN1_H,W1_KMQ,W0_KPQ)
+      ELSE
+         CALL SOFT_CHARGE1(GRID,GRID_SOFT,W0,W1_KPQ,WDES,CHDEN1_H,W1_KMQ)
+      ENDIF
+      ! change storage convention to (total, magnetization)
+      CALL RC_FLIP(CHDEN1_H, GRID_SOFT, WDES%NCDIJ, .FALSE.)
+
+      ! transform the charge density to real space
+      DO ISP=1,WDES%NCDIJ
+         CALL FFT3D(CHDEN1_H(1,ISP),GRID_SOFT,1)
+      ENDDO
+      ! decompose into hermitian part and anti-hermitian part
+      CHDEN1_AH=AIMAG(CHDEN1_H)
+      CHDEN1_H=REAL(CHDEN1_H)
+      ! transform the charge density to reciprocal space
+      ! This subroutine is designed to support transforming a real space chargedensity to
+      ! reciprocal space applying the real to complex FFT transformation
+      ! But we do not need this. It also support complex to complex FFT transformation
+#ifdef realmode
+      IF (IO%IU0>=0) WRITE(*,*) 'DFPT does not support realmode, please remove -DNGXhalf or -DNGZhalf pre-compiler flag'
+      STOP
+#endif
+      DO ISP=1,WDES%NCDIJ
+         CALL FFT_RC_SCALE(CHDEN1_H(1,ISP),CHDEN1_H(1,ISP),GRID_SOFT)
+         CALL FFT_RC_SCALE(CHDEN1_AH(1,ISP),CHDEN1_AH(1,ISP),GRID_SOFT)
+      ENDDO 
+
+      ! symmetrisation of soft pseudo charge
+      IF (SYMM%ISYM ==2) THEN
+         CALL RHOSYM(CHDEN1_H(1,1),GRID_SOFT,SYMM%PTRANS,T_INFO%NIOND,SYMM%MAGROT,1)
+         CALL RHOSYM(CHDEN1_AH(1,1),GRID_SOFT,SYMM%PTRANS,T_INFO%NIOND,SYMM%MAGROT,1)
+         IF (.NOT.WDES%LSPIRAL) THEN
+            CALL SYMFIELD(CHDEN1_H(1,2),GRID_SOFT,SYMM%PTRANS,T_INFO%NIOND,SYMM%MAGROT,WDES%SAXIS,LATT_CUR)
+            CALL SYMFIELD(CHDEN1_AH(1,2),GRID_SOFT,SYMM%PTRANS,T_INFO%NIOND,SYMM%MAGROT,WDES%SAXIS,LATT_CUR)
+         ENDIF
+      ENDIF
+
+      ! add first order change of one center occupancy matrix times
+      ! augmentation charge distribution rho(1)_ij Q_ij(r) sin(-q.(r-Ri))
+      CRHODE1_AH=-CRHODE1_AH
+      CALL DEPLE_ADD(WDES,GRID_SOFT,GRIDC,GRIDUS,C_TO_US, &
+               LATT_CUR,P,T_INFO,SYMM, INFO%LOVERL, SOFT_TO_C,&
+               LMDIM, CRHODE1_AH, CHTOT1_H, CHDEN1_H, IRDMAX, QVEC_CART, .FALSE.)
+      CALL DEPLE_ADD(WDES,GRID_SOFT,GRIDC,GRIDUS,C_TO_US, &
+               LATT_CUR,P,T_INFO,SYMM, INFO%LOVERL, SOFT_TO_C,&
+               LMDIM, CRHODE1_H, CHTOT1_AH, CHDEN1_AH, IRDMAX, QVEC_CART, .FALSE.)
+      CRHODE1_AH=-CRHODE1_AH
+
+      ! susceptibility
+      ! add (n_ae - n_ps) term
+      CALL AUGCHG(WDES,GRID_SOFT,GRIDC,GRIDUS,C_TO_US, &
+            &     LATT_CUR,P,T_INFO,SYMM, INFO%LOVERL, SOFT_TO_C,&
+            &     LMDIM,CRHODE1_H,CHI,CHDEN1_H, IRDMAX,.TRUE.,.FALSE., QVEC_CART)
+      CALL AUGCHG(WDES,GRID_SOFT,GRIDC,GRIDUS,C_TO_US, &
+            &     LATT_CUR,P,T_INFO,SYMM, INFO%LOVERL, SOFT_TO_C,&
+            &     LMDIM,CRHODE1_AH,CHI_IM,CHDEN1_AH, IRDMAX,.TRUE.,.FALSE., QVEC_CART)
+      CHI=CHI+(0._q,1._q)*CHI_IM
+
+      ! symmetrise total pseudo charge density CHTOT if required 
+      IF (SYMM%ISYM ==1) THEN
+         CALL RHOSYM(CHTOT1_H(1,1),GRIDC,SYMM%PTRANS,T_INFO%NIOND,SYMM%MAGROT,1)
+         CALL RHOSYM(CHTOT1_AH(1,1),GRIDC,SYMM%PTRANS,T_INFO%NIOND,SYMM%MAGROT,1)
+         CALL RHOSYM(CHI(1,1),GRIDC,SYMM%PTRANS,T_INFO%NIOND,SYMM%MAGROT,1)
+         IF (.NOT.WDES%LSPIRAL) THEN
+            CALL SYMFIELD(CHTOT1_H(1,2),GRIDC,SYMM%PTRANS,T_INFO%NIOND,SYMM%MAGROT,WDES%SAXIS,LATT_CUR)
+            CALL SYMFIELD(CHTOT1_AH(1,2),GRIDC,SYMM%PTRANS,T_INFO%NIOND,SYMM%MAGROT,WDES%SAXIS,LATT_CUR)
+            CALL SYMFIELD(CHI(1,2),GRIDC,SYMM%PTRANS,T_INFO%NIOND,SYMM%MAGROT,WDES%SAXIS,LATT_CUR)
+         ENDIF
+      ENDIF
+
+      DO ISP=1,WDES%NCDIJ
+         CALL GET_RHOG(GRIDC,CHI(1,ISP),CHIG(ISP),GVEC)
+      ENDDO
+
+      IF (IO%IU0>=0) THEN
+         WRITE(UNIT_EMLR_OUTPUT,'(I4,4(x,E10.3,x,E10.3))',ADVANCE='NO') N,CHIG
+      ENDIF
+
+      DO ISP=2,WDES%NCDIJ
+         CALL FFT3D(CHI(1,ISP),GRIDC,1)
+      ENDDO
+      CHI0= SUM(NORM2(ABS(CHI(1:GRIDC%RL%NP,2:4)),DIM=2))/GRIDC%NPLWV
+      CALLMPI( M_sum_d(GRIDC%COMM,CHI0,1))
+      IF (N==1) CHI00=CHI0
+      ! after this, the data in CHI is garbage, so I don't bother to FFT it back.
+      ! I will recalculate CHI at the end of subroutine anyway.
+
+      ! not update selected channel
+      DO ISP=1,WDES%NCDIJ
+         IF (.NOT.LCHUPD(ISP)) THEN
+            CHTOT1_H(:,ISP)      =0
+            CRHODE1_H(:,:,:,ISP) =0
+            CHTOT1_AH(:,ISP)     =0
+            CRHODE1_AH(:,:,:,ISP)=0
+            RHOLM1(:,ISP)        =0
+            RHOLM1_H(:,ISP)      =0
+            RHOLM1_AH(:,ISP)     =0
+         ENDIF
+      ENDDO
+      !=======================================================================
+      ! mix charge density
+      !=======================================================================
+      IF (LCHUPD(1) .OR. LCHUPD(2) .OR.LCHUPD(3) .OR. LCHUPD(4)) THEN
+         IF (MIX%IMIX/=0) THEN
+            CALL START_TIMING("G")
+            INFO%LMIX=.TRUE.
+            ! for q=0, nq(G=0)=0
+            IF (LQVEC0) THEN
+               CALL SET_RHO0(GRIDC, CHTOT1_H, 0.0_q)
+               CALL SET_RHO0(GRIDC, CHTOT1_AH, 0.0_q)
+            ENDIF
+            IF (MIX%IMIX>=4) THEN
+               RMST_LAST=RMST
+               !  broyden mixing ... :
+               ! IF (LNOIMAG) THEN
+                  CALL EMLR_BRMIX(GRIDB,GRIDC,IO,MIX,B_TO_C, &
+                     (4*GRIDC%MPLWV),CHTOT1_H,CHTOTL_H,CHTOT1_AH,CHTOTL_AH,WDES%NCDIJ,LATT_CUR%B, &
+                     LATT_CUR%OMEGA, N_MIX_PAW*2, RHOLM1, RHOLML, &
+                     RMST,RMSC,RMSP,WEIGHT,.TRUE.,IERRBR,LQVEC0,LSOFT)
+               MIX%LRESET=.FALSE.
+            ELSE
+               !  simple mixing ... :
+               RMST=0
+               RHOLM1_H=0
+               RHOLM1_AH=0
+               CALL MIX_SIMPLE(GRIDC,MIX,WDES%NCDIJ, CHTOT1_H,CHTOTL_H, &
+                     N_MIX_PAW, RHOLM1_H, RHOLM1_AH, LATT_CUR%B, LATT_CUR%OMEGA, RMST)
+               CALL MIX_SIMPLE(GRIDC,MIX,WDES%NCDIJ, CHTOT1_AH,CHTOTL_AH, &
+                     N_MIX_PAW*2, RHOLM1, RHOLML, LATT_CUR%B, LATT_CUR%OMEGA, RMST)
+            ENDIF
+
+            ! not update selected channel
+            DO ISP=1,WDES%NCDIJ
+               IF (.NOT.LCHUPD(ISP)) THEN
+                  CHTOT1_H(:,ISP)      =0
+                  CHTOT1_AH(:,ISP)     =0
+                  RHOLM1(:,ISP)        =0
+               ENDIF
+            ENDDO
+
+            IF (N==1) TOL0=ABS(RMST)
+            
+            RHOLM1_H=RHOLM1(1:N_MIX_PAW,:)
+            RHOLM1_AH=RHOLM1(N_MIX_PAW+1:N_MIX_PAW*2,:)
+
+            CALL STOP_TIMING("G",IO%IU6,"MIXING")
+            DWRITE0 "mixing is ok"
+
+            IF (IO%IU0>=0) THEN
+               WRITE(UNIT_EMLR_OUTPUT,'(5(x,E10.3))') RMS_KPQ(N),RMS_KMQ(N),RMS_KPQ_FINAL(N),RMS_KMQ_FINAL(N),RMST
+            ENDIF
+         ELSE
+            IF (IO%IU0>=0) THEN
+               WRITE(UNIT_EMLR_OUTPUT,'(2(x,E10.3))') RMS_KPQ(N),RMS_KMQ(N)
+            ENDIF
+         ENDIF
+      ELSE
+         IF (IO%IU0>=0) THEN
+            WRITE(UNIT_EMLR_OUTPUT,'(2(x,E10.3))') RMS_KPQ(N),RMS_KMQ(N)
+         ENDIF
+      ENDIF
+      !=======================================================================
+      ! total time used for this step
+      !=======================================================================
+      CALL SEPERATOR_TIMING(IO%IU6)
+      CALL STOP_TIMING("LOOP",IO%IU6,XMLTAG='total')
+      !======================== end of loop ENDLSC ===========================
+      ! end of the selfconsistent calculation loop
+      ! and write commands
+      !=======================================================================
+      INFO%LABORT=.FALSE.
+
+      IF (LCHUPD(1) .OR. LCHUPD(2) .OR.LCHUPD(3) .OR. LCHUPD(4)) THEN
+            IF(ABS(RMST)<CHBREAK) INFO%LABORT=.TRUE.
+            ! IF(ABS(RMST)<TOL0*RCHBREAK) INFO%LABORT=.TRUE.
+      ELSE
+         IF(ABS(RMS_KPQ(N))<CHBREAK .AND. ABS(RMS_KMQ(N))<CHBREAK) INFO%LABORT=.TRUE.
+      ENDIF
+      ! rms stable for three steps, ok stop, no way to improve
+      !IF(N>RESOLVE_DEG_NTIMES+3) THEN
+      !   IF (ABS((RMS_KPQ(N)-RMS_KPQ(N-1))/RMS_KPQ(N))<1E-1 .AND. ABS((RMS_KPQ(N)-RMS_KPQ(N-2))/RMS_KPQ(N))<1E-1) INFO%LABORT=.TRUE.
+      !ENDIF
+
+      !-----do not stop before minimum number of iterations is reached
+      IF (N < ABS(INFO%NELMIN)) INFO%LABORT=.FALSE.
+
+      io_begin
+      ! mixing related output
+      IF ( INFO%LMIX .AND. MIX%IMIX==4 ) THEN
+         WRITE(IO%IU6,2441) RMST,RMSC,RMSP,WEIGHT
+         IF (MIX%NEIG > 0) THEN
+            WRITE(IO%IU6,2442) MIX%AMEAN,MIX%EIGENVAL(1:MIX%NEIG)
+         ENDIF
+      ENDIF
+
+      2441 FORMAT(/ &
+      &       ' Broyden mixing:'/ &
+      &       '  rms(total) =',E12.5,'    rms(broyden)=',E12.5,/ &
+      &       '  rms(prec ) =',E12.5/ &
+      &       '  weight for this iteration ',F10.2)
+
+      2442 FORMAT(/' eigenvalues of (default mixing * dielectric matrix)' / &
+         '  average eigenvalue GAMMA= ',F8.4,/ (10F8.4))
+
+      io_end
+
+      IF (INFO%LABORT) THEN
+         IF (IO%IU6>=0) WRITE(IO%IU6,131)
+      131       FORMAT (5X, //, &
+      &  '------------------------ aborting loop because EDIFF', &
+      &  ' is reached ----------------------------------------'//)
+         EXIT electron
+      ENDIF
+      INFO%LSOFT=.FALSE.
+      ENDDO electron
+      MIX%IMIX=IMIX
+      W1_KPQ%FERTOT=W0%FERTOT
+      W1_KMQ%FERTOT=W0_KPQ%FERTOT
+      CALL RL_FLIP(SV1_KPQ,GRID,WDES%NCDIJ,.FALSE.)
+      CALL CDIJ_FLIP(WDES,LMDIM,CDIJ1_KPQ,INFO%LOVERL,.FALSE.)
+      SV1_KPQ_IND=SV1_KPQ+SV_EXT*2._q
+      CDIJ1_KPQ_IND = CDIJ1_KPQ+CDIJ_EXT
+      
+      ! CALL EDDIAG_LR(W1_KPQ,W0_KPQ,WXI,LMDIM,CQIJ,INFO%LOVERL,.FALSE.,CSHIFT,IO%IU0,DEG_CLUSTER,OMEGA=OMEGA,EPRO=EFERMI-0.5,LCLEAN=.TRUE.)
+      ! CALL EDDIAG_LR(W1_KMQ,W0,WXI,LMDIM,CQIJ,INFO%LOVERL,.FALSE.,CSHIFT,IO%IU0,DEG_CLUSTER,OMEGA=-OMEGA,EPRO=EFERMI-0.5,LCLEAN=.TRUE.)
+
+      ! CLOSE(1099)
+      ! calculate spin susceptibility in reciprocal space
+      CHDEN1_H = CHDEN1_H+(0._q,1._q)*CHDEN1_AH
+      CHDEN1_AH=0
+      ! susceptibility
+      ! add (n_ae - n_ps) term
+
+      CHI_G=0
+      CALL AUGCHG_G(WDES, GRID_SOFT,GRIDC, &
+                  LATT_CUR,P,T_INFO,SYMM, INFO%LOVERL, SOFT_TO_C,&
+                  LMDIM,CRHODE1_AH,CHI_IM,CHDEN1_AH,QVEC)
+      CHI_G = (0._q,1._q)*CHI_IM
+      CALL AUGCHG_G(WDES, GRID_SOFT,GRIDC, &
+                  LATT_CUR,P,T_INFO,SYMM, INFO%LOVERL, SOFT_TO_C,&
+                  LMDIM,CRHODE1_H,CHI_IM,CHDEN1_H,QVEC)
+      CHI_G=CHI_G+CHI_IM
+
+      CHI=0
+      CALL AUGCHG(WDES,GRID_SOFT,GRIDC,GRIDUS,C_TO_US, &
+            &     LATT_CUR,P,T_INFO,SYMM, INFO%LOVERL, SOFT_TO_C,&
+            &     LMDIM,CRHODE1_AH,CHI_IM,CHDEN1_AH, IRDMAX,.TRUE.,.FALSE., QVEC_CART)
+      CHI = (0._q,1._q)*CHI_IM
+      CALL AUGCHG(WDES,GRID_SOFT,GRIDC,GRIDUS,C_TO_US, &
+            &     LATT_CUR,P,T_INFO,SYMM, INFO%LOVERL, SOFT_TO_C,&
+            &     LMDIM,CRHODE1_H,CHI_IM,CHDEN1_H, IRDMAX,.TRUE.,.FALSE., QVEC_CART)
+      
+      CHI=CHI+CHI_IM
+
+      
+      CSUM1=0
+      DO ISP =2,WDES%NCDIJ
+         CALL FFT_RC_SCALE(SV_EXT(1,ISP),SV1_KMQ(1,ISP),GRID_SOFT)
+         CSUM1 = CSUM1+SUM(CONJG(SV1_KMQ(1:GRID_SOFT%RC%NP,ISP))*CHDEN1_H(1:GRID_SOFT%RC%NP,ISP))
+      ENDDO
+      CALLMPI( M_sum_z(GRID_SOFT%COMM,CSUM1,1))
+      CRHODE1_H = CRHODE1_H+(0._q,1._q)*CRHODE1_AH
+      CSUM2=0
+      DO ISP=2,WDES%NCDIJ
+         DO NI=1,WDES%NIONS
+            CSUM2 = CSUM2+SUM(CONJG(CDIJ_EXT(:,:,NI,ISP))*CRHODE1_H(:,:,NI,ISP))
+         ENDDO
+      ENDDO
+      CALLMPI( M_sum_z(WDES%COMM_INB,CSUM2,1))
+      IF (IO%IU0>=0) THEN
+         WRITE(UNIT_EMLR_OUTPUT,'("external energy from non-local calculation: ",F12.3,"+",F12.3,"i   ")') CSUM1+CSUM2
+      ENDIF
+
+      CRHODE1=CRHODE1_H
+
+
+      !  IF (.NOT. INFO%LABORT) N=N-1
+      !  DO IGVEC=1,NGVEC_OUTPUT
+      !     DO ISP=1,WDES%NCDIJ
+      !        CALL GET_RHOG(GRIDC,CHI(1,ISP),CHIG_OUTPUT(ISP,IGVEC),GVEC_OUTPUT(:,IGVEC))
+      !     ENDDO
+      !     CHIGPM_OUTPUT(1,IGVEC)=CHIG_OUTPUT(1,IGVEC)
+      !     CHIGPM_OUTPUT(2,IGVEC)=CHIG_OUTPUT(2,IGVEC)+(0._q,1._q)*CHIG_OUTPUT(3,IGVEC)
+      !     CHIGPM_OUTPUT(3,IGVEC)=CHIG_OUTPUT(2,IGVEC)-(0._q,1._q)*CHIG_OUTPUT(3,IGVEC)
+      !     CHIGPM_OUTPUT(4,IGVEC)=CHIG_OUTPUT(4,IGVEC)
+      !  ENDDO
+      !  IF (IO%IU0>=0) THEN
+      !     DO IGVEC=1,NGVEC_OUTPUT
+      !        WRITE(UNIT_EMLR_CHI,'(I4,4(x,E10.3,x,E10.3))') N,CHIGPM_OUTPUT(:,IGVEC)
+      !     ENDDO
+      !  ENDIF
+
+      IF (LOMEGA0 .AND. LQVEC0 .AND. LFERMI) THEN
+      CALL SUBROT_DEG_ALL(WDES, W0, .TRUE., .TRUE., DEG_CLUSTER )
+      ! Now W0 is rotated, copy to W0_KPQ and W0_KMQ again
+      CALL EMLR_COPYW(W0,W0_KPQ)
+      IF (.NOT. LKSHIFT) CALL EMLR_COPYW(W0,W0_KMQ)
+      ENDIF
+      !=======================================================================
+      ! check for nonself-consistent calculation
+      !=======================================================================
+      !CALL PROJ_W0(GRID,INFO,LATT_CUR,NONLR_S,NONL_S,W0,W1_KPQ,WDES, &
+      !            LMDIM,CQIJ, SV)
+      CALL DEALLOCW(WXI)
+      !  CALL DEALLOCW(W1_KPQ)
+      !  CALL DEALLOCW(W1_KMQ)
+      DEALLOCATE(KORIG,KPQ,KMQ)
+END SUBROUTINE EMLR_KERNEL
+
+END MODULE emlr
+
+SUBROUTINE NEAREST_LATTICE_POINT(QVEC,GVEC,LATT_CUR)
+   USE prec
+   USE lattice
+   implicit none
+   TYPE (latt)        LATT_CUR
+   REAL(q) :: QVEC(3)
+   INTEGER :: GVEC(3)
+   ! local variable
+   REAL(q) :: LENGTH
+   INTEGER :: I,J,K
+   INTEGER :: IMAX,JMAX,KMAX
+   REAL(q) :: RES0,RES
+   INTEGER :: GVEC0(3)
+
+   DO I = 1,3
+      GVEC0(I) = NINT(QVEC(I)-(MOD(QVEC(I)-0.5_q,1.0_q)+0.5_q))
+   ENDDO
+   QVEC = QVEC-GVEC0
+
+   LENGTH = NORM2(MATMUL(LATT_CUR%B,QVEC))
+   IMAX = ceiling(LENGTH*LATT_CUR%ANORM(1)*3)
+   JMAX = ceiling(LENGTH*LATT_CUR%ANORM(2)*3)
+   KMAX = ceiling(LENGTH*LATT_CUR%ANORM(3)*3)
+   RES0=1e4
+
+   DO I = -IMAX,IMAX
+      DO J = -JMAX,JMAX
+         DO K = -KMAX,KMAX
+            RES = NORM2(MATMUL(LATT_CUR%B,QVEC-[I,J,K]))
+            IF (RES+1E-10 <RES0) THEN 
+               GVEC=[I,J,K]
+               RES0=RES
+            ENDIF
+         ENDDO
+      ENDDO
+   ENDDO
+   QVEC = QVEC-GVEC 
+   GVEC = GVEC+GVEC0
+END SUBROUTINE
+
+
+!=======================================================================
+! This subroutine is used to check <W0|W1>
+! only work without parallelisation
+!=======================================================================
+SUBROUTINE PROJ_matrix(GRID,INFO,LATT_CUR,NONLR_S,NONL_S,W0,W1,WXI,WDES, &
+   LMDIM,CQIJ,OMEGA,CSHIFT,N)
+   USE prec
+   USE wave
+   USE wave_high
+   USE base
+   USE lattice
+   USE mpimy
+   USE mgrid
+   USE nonl_high
+   USE hamil
+   USE constant
+   USE wave_mpi
+   IMPLICIT NONE
+
+   TYPE (grid_3d)     GRID
+   TYPE (info_struct) INFO
+   TYPE (latt)        LATT_CUR
+   TYPE (nonlr_struct) NONLR_S
+   TYPE (nonl_struct) NONL_S
+   TYPE (wavespin)    W0
+   TYPE (wavespin)    W1
+   TYPE (wavespin)    WXI
+   TYPE (wavedes)     WDES
+   INTEGER N
+   REAL(q) :: OMEGA
+   REAL(q) :: CSHIFT
+
+   INTEGER LMDIM
+   OVERLAP CQIJ(LMDIM,LMDIM,WDES%NIONS,WDES%NCDIJ)
+   ! local work arrays and structures
+   TYPE (wavedes1) WDES1            ! descriptor for one k-point
+   TYPE (wavefun1) W1_TMP           ! current wavefunction
+   TYPE (wavefun1) W0_TMP
+   INTEGER :: ISP, NK, NGVECTOR, ISPINOR, M, MM
+   INTEGER :: NB1,NB0
+   COMPLEX(q) :: FNORM1,FNORM2,FNORM3,FNORM4,FNORM_NONL
+   ! new file
+   LOGICAL,SAVE :: LNEWFILE=.TRUE.
+
+   ! output
+   IF (LNEWFILE) THEN
+   OPEN(UNIT=100,FILE='PROJ_matrix',STATUS='REPLACE')
+   LNEWFILE=.FALSE.
+   ELSE
+   OPEN(UNIT=100,FILE='PROJ_matrix',STATUS='OLD',POSITION='APPEND')
+   ENDIF
+   WRITE(100,*)'omega :',OMEGA,'step :',N
+   WRITE(100,*)'NK,NB0,NB1,<W0|W0>,<W0|WXI>,<W0|W1>*(omega+ieta+En1-En0),<W1|W1>'
+   !=======================================================================
+   spin:    DO ISP=1,WDES%ISPIN
+   kpoints: DO NK=1,WDES%NKPTS
+   CALL SETWDES(WDES,WDES1,NK)
+   NGVECTOR=WDES1%NGVECTOR
+   !=======================================================================
+   IF (INFO%LREAL) THEN
+   CALL PHASER(GRID,LATT_CUR,NONLR_S,NK,WDES)
+   ELSE
+   CALL PHASE(WDES,NONL_S,NK)
+   ENDIF
+   !=======================================================================
+   nband1:DO NB1=1,WDES%NBANDS
+   nband0:DO NB0=1,WDES%NBANDS
+      CALL SETWAV(W0,W0_TMP,WDES1,NB0,ISP)
+   ! <W0|W0>
+      CALL SETWAV(W0,W1_TMP,WDES1,NB1,ISP)
+      FNORM1=0
+      FNORM_NONL=0
+      CALL ECCP_NL_ALL(WDES1,W1_TMP,W0_TMP,CQIJ,CQIJ,0.0_q,FNORM_NONL)
+      DO ISPINOR=0,WDES%NRSPINORS-1
+      DO M=1,NGVECTOR
+         MM=M+ISPINOR*NGVECTOR
+         FNORM1 =FNORM1+W1_TMP%CW(MM)*CONJG(W0_TMP%CW(MM))
+      ENDDO
+      ENDDO
+      CALLMPI( M_sum_z(WDES%COMM_INB, FNORM1, 1))
+      FNORM1=FNORM1+FNORM_NONL
+
+   ! <W0|WXI>
+      CALL SETWAV(WXI,W1_TMP,WDES1,NB1,ISP)
+      FNORM2=0
+      DO ISPINOR=0,WDES%NRSPINORS-1
+      DO M=1,NGVECTOR
+         MM=M+ISPINOR*NGVECTOR
+         FNORM2 =FNORM2+W1_TMP%CW(MM)*CONJG(W0_TMP%CW(MM))
+      ENDDO
+      ENDDO
+      CALLMPI( M_sum_z(WDES%COMM_INB, FNORM2, 1))
+
+   ! <W0|W1>
+      CALL SETWAV(W1,W1_TMP,WDES1,NB1,ISP)
+      FNORM3=0
+      FNORM_NONL=0
+      CALL ECCP_NL_ALL(WDES1,W1_TMP,W0_TMP,CQIJ,CQIJ,0.0_q,FNORM_NONL)
+      DO ISPINOR=0,WDES%NRSPINORS-1
+      DO M=1,NGVECTOR
+         MM=M+ISPINOR*NGVECTOR
+         FNORM3 =FNORM3+W1_TMP%CW(MM)*CONJG(W0_TMP%CW(MM))
+      ENDDO
+      ENDDO
+      CALLMPI( M_sum_z(WDES%COMM_INB, FNORM3, 1))
+      FNORM3=FNORM3+FNORM_NONL
+      FNORM3=FNORM3*(OMEGA+CMPLX(0.0_q,2.0_q*CSHIFT,q)+W0%CELEN(NB1,NK,ISP)-W0%CELEN(NB0,NK,ISP))
+
+   ! <W1|W1>
+      FNORM4=0
+      FNORM_NONL=0
+      CALL ECCP_NL_ALL(WDES1,W1_TMP,W1_TMP,CQIJ,CQIJ,0.0_q,FNORM_NONL)
+      DO ISPINOR=0,WDES%NRSPINORS-1
+      DO M=1,NGVECTOR
+         MM=M+ISPINOR*NGVECTOR
+         FNORM4 =FNORM4+W1_TMP%CW(MM)*CONJG(W1_TMP%CW(MM))
+      ENDDO
+      ENDDO
+      CALLMPI( M_sum_z(WDES%COMM_INB, FNORM4, 1))
+      FNORM4=FNORM4+FNORM_NONL
+
+      WRITE(100,'(3(I2,x),4(x,E11.4,x,E11.4))')NK,NB0,NB1,FNORM1,FNORM2,FNORM3,FNORM4
+   ENDDO nband0
+   ENDDO nband1
+   !=======================================================================
+   ENDDO kpoints
+   ENDDO spin
+   !=======================================================================
+   CLOSE(100)
+END SUBROUTINE PROJ_matrix
+
+SUBROUTINE GET_RHOG(GRID, CHTOT, RHOG, GVEC)
+   USE prec
+   USE mgrid
+   IMPLICIT NONE
+
+   TYPE (grid_3d) GRID
+   COMPLEX(q) CHTOT(GRID%RC%NROW,GRID%RC%NCOL)
+   COMPlEX(q) RHOG
+   INTEGER GVEC(3)
+   ! local
+   INTEGER :: NC
+   INTEGER :: N1,N2,N3
+   INTEGER :: L1,L2,L3
+
+   RHOG=0
+   DO N1=1,GRID%RC%NROW
+   L1=GRID%LPCTX(N1)
+   DO NC=1,GRID%RC%NCOL
+      N2=GRID%RC%I2(NC)
+      N3=GRID%RC%I3(NC)
+      L2=GRID%LPCTY(N2)
+      L3=GRID%LPCTZ(N3)
+      IF (L1==GVEC(1) .AND. L2==GVEC(2) .AND. L3==GVEC(3)) THEN
+         RHOG=CHTOT(N1,NC)
+      ENDIF
+   ENDDO
+   ENDDO
+   CALLMPI( M_sum_z( GRID%COMM, RHOG, 1))
+END SUBROUTINE GET_RHOG
+
+SUBROUTINE SET_RHOG(GRID, CHTOT, RHOG, GVEC)
+   USE prec
+   USE mgrid
+   IMPLICIT NONE
+
+   TYPE (grid_3d) GRID
+   COMPLEX(q) CHTOT(GRID%RC%NROW,GRID%RC%NCOL)
+   COMPlEX(q) RHOG
+   INTEGER GVEC(3)
+   ! local
+   INTEGER :: NC
+   INTEGER :: N1,N2,N3
+   INTEGER :: L1,L2,L3
+   
+   DO NC=1,GRID%RC%NCOL
+   DO N1=1,GRID%RC%NROW
+      L1=GRID%LPCTX(N1)
+      N2=GRID%RC%I2(NC)
+      N3=GRID%RC%I3(NC)
+      L2=GRID%LPCTY(N2)
+      L3=GRID%LPCTZ(N3)
+      IF (L1==GVEC(1) .AND. L2==GVEC(2) .AND. L3==GVEC(3)) THEN
+         CHTOT(N1,NC)=RHOG
+      ENDIF
+   ENDDO
+   ENDDO
+END SUBROUTINE SET_RHOG
+
+!=======================================================================
+! Non-local contribution to CDIJ from external field
+!=======================================================================
+SUBROUTINE SET_CDIJ_EXT(WDES, P, T_INFO, LOVERL, LMDIM, CDIJ, QPG_CART, GVEC)
+   USE poscar
+   USE pseudo
+   USE wave
+   USE radial
+   USE us
+   USE paw
+   USE constant
+   USE asa
+   IMPLICIT NONE
+
+   TYPE (type_info) T_INFO
+   TYPE (potcar),TARGET:: P(T_INFO%NTYP)
+   TYPE (wavedes) WDES
+   INTEGER LMDIM
+   OVERLAP CDIJ(LMDIM,LMDIM,WDES%NIONS)
+   LOGICAL LOVERL
+   REAL(q) QPG_CART(3)
+   INTEGER :: GVEC(3)               ! G
+   REAL(q) :: POSION(3)             ! Ri
+   COMPLEX(q) :: CREXP              ! e^(iG.Ri)
+   ! local variables
+   TYPE (potcar),POINTER:: PP
+   INTEGER NT,LYMAX,NI,NDIM,LMMAX,NIP,LYCAL
+   INTEGER K,L,M,LM
+   INTEGER, EXTERNAL :: MAXL_AUG,MAXL1
+   REAL(q) QNORM,QX(1),QY(1),QZ(1)
+   REAL(q),ALLOCATABLE :: YLM(:,:)
+   REAL(q) :: QR,WEIGHT,SPHBESSEL
+   !REAL(q),ALLOCATABLE :: SPHBESSEL(:)
+   REAL(q),ALLOCATABLE :: POTD(:,:)
+   REAL(q),ALLOCATABLE :: DDLM(:)
+   OVERLAP,ALLOCATABLE :: CTMP(:,:)
+   COMPLEX(q),ALLOCATABLE :: POTC(:,:)
+   ! needed to distribute over COMM_KINTER
+   INTEGER IDONE
+   LOGICAL LSKIP
+
+   !=======================================================================
+   ! quick return and allocation of work space
+   !=======================================================================
+   IF (.NOT.LOVERL .OR. MIMIC_US) THEN
+   RETURN
+   ENDIF
+
+   LYMAX =MAXL_AUG(T_INFO%NTYP,P)
+
+   NDIM=0
+   DO NT=1,T_INFO%NTYP
+   IF (ASSOCIATED(P(NT)%QPAW)) THEN
+      NDIM=MAX(NDIM, P(NT)%R%NMAX)
+   ENDIF
+   ENDDO
+
+   IF (NDIM == 0) THEN
+   RETURN
+   ENDIF
+
+   ALLOCATE(DDLM(LMDIM*LMDIM))
+   ALLOCATE(CTMP(LMDIM,LMDIM))
+   LMMAX=(LYMAX+1)**2
+
+   ALLOCATE(POTD(NDIM, LMMAX))
+   ALLOCATE(POTC(NDIM, LMMAX))
+   ALLOCATE(YLM(1,LMMAX))
+   !ALLOCATE(SPHBESSEL(0:LYMAX))
+
+   QNORM=SQRT(SUM(QPG_CART**2))
+   IF (QNORM < 1E-5_q ) THEN
+   QX(1)=0
+   QY(1)=0
+   QZ(1)=0
+   QNORM=0
+   ELSE
+   QX(1)=QPG_CART(1)/QNORM
+   QY(1)=QPG_CART(2)/QNORM
+   QZ(1)=QPG_CART(3)/QNORM
+   ENDIF
+   CALL SETYLM(LYMAX,1,YLM,QX,QY,QZ)
+   QNORM=QNORM*TPI
+   !=======================================================================
+   ! cycle all ions
+   !=======================================================================
+   IDONE=0
+   CDIJ=0
+
+   ion: DO NI=1,T_INFO%NIONS
+   NIP=NI_LOCAL(NI, WDES%COMM_INB) ! local storage index
+   NT=T_INFO%ITYP(NI)
+
+   LSKIP=.FALSE.
+#ifdef MPI
+   ! DO_LOCAL represents a distribution of the work on the
+   ! one-center terms over the procs in COMM_INB and COMM_INTER (=COMM_KIN).
+   ! The following allows an additional round-robin distribution over COMM_KINTER as well.
+   IF (DO_LOCAL(NI)) THEN
+      IDONE=IDONE+1; LSKIP=(MOD(IDONE,WDES%COMM_KINTER%NCPU)+1/=WDES%COMM_KINTER%NODE_ME)
+   ENDIF
+#endif
+   ! if this element is not treated locally CYCLE
+   IF (.NOT. DO_LOCAL(NI).OR.LSKIP) CYCLE ion
+
+   PP=> PP_POINTER(P, NI, NT)
+
+   LYMAX =MAXL1(PP)*2
+   !-----------------------------------------------------------------------
+   ! e^(iq.r) = 4 \pi \sum_{lm} i^l j_l(qr) conjg[Y_lm(\hat q)] * Y_lm(\hat r)
+   ! POT_lm   = 4 \pi i^l j_l(qr) Y_lm(\hat q)
+   ! Y_lm is choosed to be real
+   ! multiply potentials by simpson weights
+   !-----------------------------------------------------------------------
+   DO K=1,PP%R%NMAX
+      QR=QNORM*PP%R%R(K)
+      WEIGHT=PP%R%SI(K)
+      !CALL SPHJ(LYMAX,QR,LYCAL,SPHBESSEL)
+      !IF (LYCAL<LYMAX) THEN
+      !   WRITE(*,*) 'Highest order of jn(x) computed less than required'
+      !   STOP
+      !ENDIF
+      DO L=0,LYMAX
+         CALL SBESSEL(QR,SPHBESSEL,L)
+         DO M=0,2*L
+            LM=L*L+M+1
+            POTC(K,LM)=2*TPI*(0.0_q,1.0_q)**L*SPHBESSEL*YLM(1,LM)*WEIGHT
+         ENDDO
+      ENDDO
+   ENDDO
+   ! debug
+   !OPEN(UNIT=31415,FILE='DIJ_EXT',STATUS='UNKNOWN')
+   !WRITE(31415,'("|q|         : ", E15.8)')QNORM
+   !WRITE(31415,'("Max order of spherical bessel function LMAX : ", I5)')LYMAX
+   !WRITE(31415,'("Number of r : ", I5)')PP%R%NMAX
+   !WRITE(31415,'("Logarithmic grid : R(i) = RSTART * exp [H (i-1)]")')
+   !WRITE(31415,'("RSTART      : ", E15.8)')PP%R%RSTART
+   !WRITE(31415,'("H           : ", E15.8)')PP%R%H
+   !WRITE(31415,*)'              R,        weight,     phi_nl(r), j_L(qr) with L=0,1,...,LMAX'
+   !DO K=1,PP%R%NMAX
+   !   WRITE(31415,'(3E15.8)',ADVANCE='NO') PP%R%R(K),PP%R%SI(K),PP%WAE(K,1)
+   !   QR=QNORM*PP%R%R(K)
+   !   DO L=0,LYMAX
+   !      CALL SBESSEL(QR,SPHBESSEL,L)
+   !      POT(K,L+1)=PP%WAE(K,1)*PP%WAE(K,1)*SPHBESSEL
+   !      IF (L==LYMAX) THEN
+   !         WRITE(31415,'(E15.8)') SPHBESSEL
+   !      ELSE
+   !         WRITE(31415,'(E15.8)',ADVANCE='NO') SPHBESSEL
+   !      ENDIF
+   !   ENDDO
+   !ENDDO
+   !WRITE(31415,*)'\int dr phi_nl(r) * phi_nl(r) * j_L(qr), L=0,1,...,LMAX'
+   !DO L=0,LYMAX
+   !   CALL SIMPI(PP%R,POT(:,L+1),SPHBESSEL)
+   !   IF (L==LYMAX) THEN
+   !      WRITE(31415,'(E15.8)') SPHBESSEL
+   !   ELSE
+   !      WRITE(31415,'(E15.8)',ADVANCE='NO') SPHBESSEL
+   !   ENDIF
+   !ENDDO
+   !STOP
+   ! end debug
+   !-----------------------------------------------------------------------
+   ! D(ll',LM)= D(ll',LM)+ A *\int dr phi_l'(r) pot_lm(r) phi_l(r) dr
+   ! phi(r) = \sum_lmn Y_lm(r) w_ln(r) / r
+   !-----------------------------------------------------------------------
+   POTD=REAL(POTC)
+   DDLM=0
+   CALL RAD_PROJ(POTD, PP%R, 1._q, DDLM, PP%LMAX, PP%LPS, PP%WAE )
+   CALL RAD_PROJ(POTD, PP%R,-1._q, DDLM, PP%LMAX, PP%LPS, PP%WPS )
+   !-----------------------------------------------------------------------
+   ! transform them using Clebsch Gordan coefficients and add to CDIJ
+   ! D(lm,l'm') =  sum C(LM,ll',mm') D(ll',LM)
+   ! where C(LM,ll',mm') = \int Y_LM Y_lm Y_l'm' d Omega
+   !-----------------------------------------------------------------------
+   CTMP=0
+   CALL TRANS_DLM(CTMP, DDLM, PP)
+   CDIJ(:,:,NIP)=CDIJ(:,:,NIP)+CTMP
+
+   ! imaginary part
+   POTD=AIMAG(POTC)
+   DDLM=0
+   CALL RAD_PROJ(POTD, PP%R, 1._q, DDLM, PP%LMAX, PP%LPS, PP%WAE )
+   CALL RAD_PROJ(POTD, PP%R,-1._q, DDLM, PP%LMAX, PP%LPS, PP%WPS )
+   CTMP=0
+   CALL TRANS_DLM(CTMP, DDLM, PP)
+   CDIJ(:,:,NIP)=CDIJ(:,:,NIP)+(0._q,1._q)*CTMP
+
+   ! multiply with e^(iG.Ri)
+   POSION=T_INFO%POSION(:,NI)
+   CREXP=EXP(CITPI*(GVEC(1)*POSION(1)+GVEC(2)*POSION(2)+GVEC(3)*POSION(3)))
+   CDIJ(:,:,NIP)=CDIJ(:,:,NIP)*CREXP
+
+   ENDDO ion
+   !=======================================================================
+   ! now distribute the DIJ to all nodes which hold DIJ (using global sum)
+   !=======================================================================
+#ifdef realmode
+   CALLMPI( M_sum_d(WDES%COMM_INTER, CDIJ, LMDIM*LMDIM*WDES%NIONS))
+   CALLMPI( M_sum_d(WDES%COMM_KINTER,CDIJ, LMDIM*LMDIM*WDES%NIONS))
+#else
+   CALLMPI( M_sum_d(WDES%COMM_INTER, CDIJ, LMDIM*LMDIM*WDES%NIONS*2))
+   CALLMPI( M_sum_d(WDES%COMM_KINTER,CDIJ, LMDIM*LMDIM*WDES%NIONS*2))
+#endif
+
+#ifdef debug
+   DO K=1,WDES%COMM%NCPU
+   IF (WDES%COMM%NODE_ME == K) THEN
+   DO NI=1,WDES%NIONS
+      CALL DUMP_DLLMM( "CDIJ",CDIJ(:,:,NI), PP)
+   ENDDO
+   WRITE(*,*)
+   ENDIF
+   CALL MPI_barrier( WDES%COMM%MPI_COMM, k )
+   ENDDO
+#endif
+
+   DEALLOCATE(POTD, POTC, CTMP, DDLM)
+
+END SUBROUTINE SET_CDIJ_EXT
+
+SUBROUTINE EMLR_DEN(IU0, WDES, W, KPOINTS, EFERMI, SIGMA, NEDOS, LDIMP, NIOND)
+   USE prec
+   USE wave
+   USE mkpoints
+   USE density_of_states
+
+   IMPLICIT NONE
+   TYPE (wavedes)        WDES
+   TYPE (wavespin)       W
+   TYPE (kpoints_struct) KPOINTS
+   REAL(q) :: EFERMI,SIGMA
+   INTEGER :: NEDOS,LDIMP,NIOND
+   ! local variables
+   INTEGER :: ISP,K,N,IU0
+   REAL(q) :: EPS,SIGMA_,DFUN,SFUN,X1
+   REAL(q) :: SUMWEI,SUME
+   REAL(q) DOS(NEDOS,WDES%ISPIN),DOSI(NEDOS,WDES%ISPIN)
+   REAL(q) PAR(WDES%NB_TOT,WDES%NKPTS,LDIMP,NIOND,WDES%ISPIN)
+   REAL(q) DOSPAR(NEDOS,LDIMP,NIOND,WDES%ISPIN)
+
+   IF (KPOINTS%ISMEAR==-4) THEN
+   CALL BZINTS(-2,W%FERTOT,W%CELTOT,WDES%WTKPT,WDES%NB_TOT,WDES%NB_TOT,WDES%NKPTS, &
+   &           KPOINTS%IDTET(0,1),KPOINTS%NTET,WDES%ISPIN,WDES%RSPIN,KPOINTS%VOLWGT, &
+   &           KPOINTS%EMIN,KPOINTS%EMAX,DOS,DOSI,NEDOS,EFERMI,SUMWEI, &
+   &           SUME,100,PAR,DOSPAR,WDES%NKPTS,LDIMP,NIOND,NIOND,0)
+   ELSE IF (KPOINTS%ISMEAR==-5) THEN
+   CALL BZINTS(2,W%FERTOT,W%CELTOT,WDES%WTKPT,WDES%NB_TOT,WDES%NB_TOT,WDES%NKPTS, &
+   &           KPOINTS%IDTET(0,1),KPOINTS%NTET,WDES%ISPIN,WDES%RSPIN,KPOINTS%VOLWGT, &
+   &           KPOINTS%EMIN,KPOINTS%EMAX,DOS,DOSI,NEDOS,EFERMI,SUMWEI, &
+   &           SUME,100,PAR,DOSPAR,WDES%NKPTS,LDIMP,NIOND,NIOND,0)
+   ELSE
+   SIGMA_=ABS(SIGMA)
+   IF (SIGMA_==0) THEN
+      IF (IU0>=0) WRITE(IU0,*)'SIGMA = 0, BE CAREFUL !!!'
+      RETURN
+   ENDIF
+
+   DO ISP=1,WDES%ISPIN
+      DO K=1,WDES%NKPTS
+#ifdef MPI
+         IF (MOD(K-1,WDES%COMM_KINTER%NCPU).NE.WDES%COMM_KINTER%NODE_ME-1) CYCLE
+#endif
+         DO N=1,WDES%NBANDS
+            EPS=W%CELEN(N,K,ISP)
+            X1=(EFERMI-EPS)/SIGMA_
+            CALL DELSTP(KPOINTS%ISMEAR,X1,DFUN,SFUN)
+            W%FERWE(N,K,ISP)=SFUN
+         ENDDO
+      ENDDO
+   ENDDO
+   CALL MRG_FERWE(WDES,W)
+   ENDIF
+
+END SUBROUTINE EMLR_DEN
+
+SUBROUTINE EMLR_COPYW(W0,W1)
+   USE wave
+   IMPLICIT NONE
+   TYPE (wavespin) W0,W1
+
+   W1%CW    =W0%CW
+   W1%CPROJ =W0%CPROJ
+   W1%CELTOT=W0%CELTOT
+   W1%FERTOT=W0%FERTOT
+   W1%AUXTOT=W0%AUXTOT
+   W1%OVER_BAND=W0%OVER_BAND
+
+END SUBROUTINE EMLR_COPYW
+
+!************************ SUBROUTINE AUGCHG  ***************************
+!
+! While subroutine AUGCHG calculate all-electron densities accurate 
+! in the real space. The subroutine AUGCHG_G below calculate all-electron 
+! densities accurate in reciprocal space.
+! 
+! This routine is needed if we want to calculate the overlap between an 
+! oscillated density and a smooth external field (has a wavevector cut-off). 
+! Such calculation is better carried out in reciprocal space. 
+!
+! It calculates contribution of 1/Omgea*\int dr n(r) e^(-i(q+G).r) from 
+! augmentation spheres
+!***********************************************************************
+SUBROUTINE AUGCHG_G(WDES, GRID_SOFT,GRIDC_, &
+   LATT_CUR,P,T_INFO,SYMM, LOVERL, SOFT_TO_C,&
+   LMDIM,CRHODE, CHTOT_,CHDEN,QVEC)
+   USE prec
+   USE base
+   USE charge
+   USE pseudo
+   USE poscar
+   USE mpimy
+   USE mgrid
+   USE lattice
+   USE wave
+   USE asa
+   USE paw
+   USE constant
+   USE us
+
+   ! IMPLICIT COMPLEX(q) (C)
+   ! IMPLICIT REAL(q) (A-B,D-H,O-Z)
+
+   IMPLICIT NONE
+   TYPE (type_info)   T_INFO
+   TYPE (potcar),TARGET::      P(T_INFO%NTYP)
+   TYPE (grid_3d),TARGET :: GRID_SOFT,GRIDC_
+   TYPE (grid_3d),POINTER :: GRIDC
+   TYPE (transit)     SOFT_TO_C
+   TYPE (latt)        LATT_CUR
+   TYPE (wavedes)     WDES
+   TYPE (symmetry)    SYMM
+   LOGICAL   LOVERL
+   INTEGER LMDIM
+   OVERLAP   CRHODE(LMDIM,LMDIM,WDES%NIONS,WDES%NCDIJ)
+   RGRID,TARGET  :: CHTOT_(DIMREAL(GRIDC_%MPLWV),WDES%NCDIJ)
+   COMPLEX(q) CHDEN(GRID_SOFT%MPLWV,WDES%NCDIJ)
+   REAL(q), OPTIONAL :: QVEC(3)
+
+
+   INTEGER   ISP      ! allocation required for augmentation
+   RGRID,POINTER :: CHTOT(:)
+   LOGICAL L_SYM
+   TYPE (potcar),POINTER:: PP
+   REAL(q) PNORM,PX(1),PY(1),PZ(1)
+   REAL(q),ALLOCATABLE :: YLM(:,:)
+   REAL(q) :: PR,WEIGHT,SPHBESSEL
+   
+   INTEGER :: GVEC(3),N1,N2,N3,NC
+   REAL(q) :: PVEC(3)
+   REAL(q),ALLOCATABLE :: POTD(:,:)
+   COMPLEX(q),ALLOCATABLE :: POTC(:,:)
+   REAL(q),ALLOCATABLE :: DDLM(:)
+   OVERLAP,ALLOCATABLE :: CWORK(:,:)
+   REAL(q) PVEC_CART(3)             ! G
+   REAL(q) :: POSION(3)             ! Ri
+   COMPLEX(q) :: CREXP              ! e^(iG.Ri)
+   INTEGER :: NI,NT,NIP,LYMAX,NDIM,LMMAX
+   INTEGER :: I1,I2,I3
+   INTEGER :: K,L,M,LM
+   INTEGER,EXTERNAL :: MAXL1,MAXL_AUG
+   OVERLAP CDIJ(LMDIM,LMDIM,T_INFO%NIONS)
+   !-MM- end of addition
+#ifdef MPI
+   ! in the MPI version CRHODE holds the contribution to the augmentation
+   ! occupation only for ions and bands which are local
+   ! CTMP holds all elements (merged)
+   ! to achive good load balancing CTMP is first merged, and then each node
+   ! calculates augmentation charges for his columns
+   OVERLAP,ALLOCATABLE :: CTMP(:,:,:,:)
+   ALLOCATE(CTMP(LMDIM,LMDIM,T_INFO%NIONS,WDES%NCDIJ))
+#else
+#define CTMP CRHODE
+#endif
+
+   !=======================================================================
+   ! if no overlap copy CHDEN to CHTOT and that s it
+   !=======================================================================
+   overl: IF (.NOT.LOVERL) THEN
+      DO ISP=1,WDES%NCDIJ
+         CALL RC_ADD(CHDEN(1,ISP),1.0_q,CHDEN(1,ISP),0.0_q,CHTOT_(1,ISP),GRID_SOFT)
+      ENDDO
+   ELSE overl
+      LYMAX =MAXL_AUG(T_INFO%NTYP,P)
+   ! find the maximum L for augmentation charge (usually just 2 l)
+      NDIM=0
+      DO NT=1,T_INFO%NTYP
+         IF (ASSOCIATED(P(NT)%QPAW)) THEN
+            NDIM=MAX(NDIM, P(NT)%R%NMAX)
+         ENDIF
+      ENDDO
+
+      IF (NDIM == 0) THEN
+         RETURN
+      ENDIF
+      LMMAX=(LYMAX+1)**2
+      ALLOCATE(DDLM(LMDIM*LMDIM))
+      ALLOCATE(CWORK(LMDIM,LMDIM))
+      ALLOCATE(POTD(NDIM, LMMAX))
+      ALLOCATE(POTC(NDIM, LMMAX))
+      ALLOCATE(YLM(1,LMMAX))
+#ifdef MPI
+   !=======================================================================
+   ! merge CRHODE from all nodes
+   ! for simplicity I do this with M_sum_d but there are of course better
+   ! ways to do this
+   !=======================================================================
+   CTMP=0
+   DO ISP=1,WDES%NCDIJ
+      DO NI=1,T_INFO%NIONS
+         NIP=NI_LOCAL(NI, WDES%COMM_INB)
+         IF (NIP/=0) THEN
+            CTMP(:,:,NI,ISP)=CRHODE(:,:,NIP,ISP)
+         ENDIF
+      ENDDO
+   ENDDO
+#ifdef realmode
+   CALLMPI( M_sum_d(WDES%COMM_INB,CTMP,LMDIM*LMDIM*T_INFO%NIONS*WDES%NCDIJ))
+#else
+   CALLMPI( M_sum_d(WDES%COMM_INB,CTMP,LMDIM*LMDIM*T_INFO%NIONS*WDES%NCDIJ*2))
+#endif
+#endif
+   !-----------------------------------------------------------------------
+   ! do  symmetrization of the CRHODE
+   ! (in MPI version this is the only position where I can do that
+   !  without additional communication)
+   !-----------------------------------------------------------------------
+   ! if PAW is selected, do symmetrization in any case
+   L_SYM=.FALSE.
+   DO NT=1,T_INFO%NTYP
+      IF ( ASSOCIATED(P(NT)%QPAW) ) L_SYM=.TRUE.
+   ENDDO
+   ! no symmetry used, well switch it off
+   IF (SYMM%ISYM<=0) L_SYM=.FALSE.
+   ! CHDEN is symmetrized and not CHTOT, in that case do symmetrization in any case
+   IF (SYMM%ISYM==2) L_SYM=.TRUE.
+   ! now do the symmetrization
+   IF (L_SYM) THEN
+      IF (WDES%LNONCOLLINEAR) THEN
+#ifdef MPI
+         CALL AUGSYM_(P,LMDIM,T_INFO%NIONS,T_INFO%NIOND,T_INFO%NTYP,T_INFO%NITYP, &
+            CTMP(1,1,1,1), SYMM%ROTMAP(1,1,1), SYMM%MAGROT(1,1), LATT_CUR%A, LATT_CUR%B, 1)
+   ! Marsman insert symmetrization here
+   ! Symmetrize the vectors (DX,DY,DZ)
+         IF (.NOT.WDES%LSPIRAL) &
+      &   CALL AUGSYM_NONCOL_(P,LMDIM,T_INFO%NIONS,T_INFO%NIOND,T_INFO%NTYP,T_INFO%NITYP, &
+            CTMP(1,1,1,2), SYMM%ROTMAP(1,1,1), SYMM%MAGROT(1,1), WDES%SAXIS, LATT_CUR%A, LATT_CUR%B)
+   ! store result back to original storage position
+         DO NI=1,T_INFO%NIONS
+            NIP=NI_LOCAL(NI, WDES%COMM_INB)
+            IF (NIP/=0) THEN
+               CRHODE(:,:,NIP,:)=CTMP(:,:,NI,:)
+            ENDIF
+         ENDDO
+#else
+         CALL AUGSYM_(P,LMDIM,T_INFO%NIONS,T_INFO%NIOND,T_INFO%NTYP,T_INFO%NITYP(1), &
+            CRHODE(1,1,1,1), SYMM%ROTMAP(1,1,1), SYMM%MAGROT(1,1), LATT_CUR%A, LATT_CUR%B, 1)
+   ! Marsman insert symmetrization here
+   ! Symmetrize the vectors (DX,DY,DZ)
+         IF (.NOT.WDES%LSPIRAL) &
+      &   CALL AUGSYM_NONCOL_(P,LMDIM,T_INFO%NIONS,T_INFO%NIOND,T_INFO%NTYP,T_INFO%NITYP, &
+            CTMP(1,1,1,2), SYMM%ROTMAP(1,1,1), SYMM%MAGROT(1,1), WDES%SAXIS, LATT_CUR%A, LATT_CUR%B)
+#endif
+      ELSE
+      DO ISP=1,WDES%NCDIJ
+#ifdef MPI
+         CALL AUGSYM_(P,LMDIM,T_INFO%NIONS,T_INFO%NIOND,T_INFO%NTYP,T_INFO%NITYP, &
+            CTMP(1,1,1,ISP), SYMM%ROTMAP(1,1,1), SYMM%MAGROT(1,1), LATT_CUR%A, LATT_CUR%B, ISP)
+      ! store result back to original storage position
+         DO NI=1,T_INFO%NIONS
+            NIP=NI_LOCAL(NI, WDES%COMM_INB)
+            IF (NIP/=0) THEN
+               CRHODE(:,:,NIP,ISP)=CTMP(:,:,NI,ISP)
+            ENDIF
+         ENDDO
+#else
+         CALL AUGSYM_(P,LMDIM,T_INFO%NIONS,T_INFO%NIOND,T_INFO%NTYP,T_INFO%NITYP(1), &
+            CRHODE(1,1,1,ISP), SYMM%ROTMAP(1,1,1), SYMM%MAGROT(1,1), LATT_CUR%A, LATT_CUR%B, ISP)
+#endif
+      ENDDO
+      ENDIF
+   ENDIF
+   !=======================================================================
+   ! now the actual work starts
+   !=======================================================================
+   spin:DO ISP=1,WDES%NCDIJ
+   CHTOT => CHTOT_(:,ISP)
+   GRIDC => GRIDC_
+   !=======================================================================
+   ! loop over all ions
+   !=======================================================================
+   CHTOT=0
+   DO NC=1,GRIDC%RC%NCOL
+   DO N1=1,GRIDC%RC%NROW
+      GVEC(1)=GRIDC%LPCTX(N1)
+      N2=GRIDC%RC%I2(NC)
+      N3=GRIDC%RC%I3(NC)
+      GVEC(2)=GRIDC%LPCTY(N2)
+      GVEC(3)=GRIDC%LPCTZ(N3)
+
+      
+      ! we have to add in balanced boundary contribution to avoid 
+      ! e.g. both NGX/2 and -NGX/2 component will contribute to all-electron density
+      ! both are identified as NGX/2 in the folded zone of discrete Fourier transform.
+      ! If we only count in the NGX/2 component, the density will be complex and possess
+      ! artificial kinks in the real space. -> not useful
+      ! DO I1=1,2
+      !    IF(I1==2) THEN
+      !       IF (ABS(GVEC(1))==GRIDC%NGX/2) THEN
+      !          GVEC(1)=-GVEC(1)
+      !       ELSE 
+      !          EXIT
+      !       ENDIF
+      !    ENDIF
+      ! DO I2=1,2
+      !    IF(I2==2) THEN
+      !       IF (ABS(GVEC(2))==GRIDC%NGY/2) THEN
+      !          GVEC(2)=-GVEC(2)
+      !       ELSE 
+      !          EXIT
+      !       ENDIF
+      !    ENDIF
+      ! DO I3=1,2
+      !    IF(I3==2) THEN
+      !       IF (ABS(GVEC(3))==GRIDC%NGZ/2) THEN
+      !          GVEC(3)=-GVEC(3)
+      !       ELSE 
+      !          EXIT
+      !       ENDIF
+      !    ENDIF
+         
+         IF (PRESENT(QVEC)) THEN
+            PVEC = -GVEC-QVEC
+         ELSE 
+            PVEC = -GVEC
+         ENDIF
+         PVEC_CART = MATMUL(LATT_CUR%B,PVEC)
+         PNORM=SQRT(SUM(PVEC_CART**2))
+         IF (PNORM < 1E-5_q ) THEN
+            PX(1)=0
+            PY(1)=0
+            PZ(1)=0
+            PNORM=0
+         ELSE
+            PX(1)=PVEC_CART(1)/PNORM
+            PY(1)=PVEC_CART(2)/PNORM
+            PZ(1)=PVEC_CART(3)/PNORM
+         ENDIF
+         PNORM=PNORM*TPI
+
+         CDIJ=0
+         ion: DO NI=1,T_INFO%NIONS
+            NT=T_INFO%ITYP(NI)
+#ifdef MPI
+            IF (MOD(NI-1,WDES%COMM_KINTER%NCPU)+1/=WDES%COMM_KINTER%NODE_ME) THEN
+               CYCLE ion
+            ENDIF
+#endif
+            PP=> P(NT)
+
+            LYMAX =MAXL1(PP)*2
+            !-----------------------------------------------------------------------
+            ! e^(iq.r) = 4 \pi \sum_{lm} i^l j_l(qr) conjg[Y_lm(\hat q)] * Y_lm(\hat r)
+            ! POT_lm   = 4 \pi i^l j_l(qr) Y_lm(\hat q)
+            ! Y_lm is choosed to be real
+            ! multiply potentials by simpson weights
+            !-----------------------------------------------------------------------
+            POTC=0
+
+            CALL SETYLM(LYMAX,1,YLM,PX,PY,PZ)
+            DO K=1,PP%R%NMAX
+               PR=PNORM*PP%R%R(K)
+               WEIGHT=PP%R%SI(K)
+               DO L=0,LYMAX
+                     CALL SBESSEL(PR,SPHBESSEL,L)
+                     DO M=0,2*L
+                        LM=L*L+M+1
+                        POTC(K,LM)=2*TPI*(0.0_q,1.0_q)**L*SPHBESSEL*YLM(1,LM)*WEIGHT
+                     ENDDO
+               ENDDO
+            ENDDO
+            !-----------------------------------------------------------------------
+            ! D(ll',LM)= D(ll',LM)+ A *\int dr phi_l'(r) pot_lm(r) phi_l(r) dr
+            ! phi(r) = \sum_lmn Y_lm(r) w_ln(r) / r
+            !-----------------------------------------------------------------------
+            POTD=REAL(POTC)
+            DDLM=0
+            CALL RAD_PROJ(POTD, PP%R, 1._q, DDLM, PP%LMAX, PP%LPS, PP%WAE )
+            CALL RAD_PROJ(POTD, PP%R,-1._q, DDLM, PP%LMAX, PP%LPS, PP%WPS )
+            !-----------------------------------------------------------------------
+            ! transform them using Clebsch Gordan coefficients and add to CDIJ
+            ! D(lm,l'm') =  sum C(LM,ll',mm') D(ll',LM)
+            ! where C(LM,ll',mm') = \int Y_LM Y_lm Y_l'm' d Omega
+            !-----------------------------------------------------------------------
+            CWORK=0
+            CALL TRANS_DLM(CWORK, DDLM, PP)
+            CDIJ(:,:,NI)=CDIJ(:,:,NI)+CWORK
+         
+            ! imaginary part
+            POTD=AIMAG(POTC)
+            DDLM=0
+            CALL RAD_PROJ(POTD, PP%R, 1._q, DDLM, PP%LMAX, PP%LPS, PP%WAE )
+            CALL RAD_PROJ(POTD, PP%R,-1._q, DDLM, PP%LMAX, PP%LPS, PP%WPS )
+            CWORK=0
+            CALL TRANS_DLM(CWORK, DDLM, PP)
+            CDIJ(:,:,NI)=CDIJ(:,:,NI)+(0._q,1._q)*CWORK
+         
+            ! multiply with e^(iG.Ri)
+            POSION=T_INFO%POSION(:,NI)
+            CREXP=EXP(-CITPI*(GVEC(1)*POSION(1)+GVEC(2)*POSION(2)+GVEC(3)*POSION(3)))
+            CDIJ(:,:,NI)=CDIJ(:,:,NI)*CREXP
+         ENDDO ion
+         ! CHTOT(N1,NC)=CHTOT(N1,NC)+SUM(CDIJ*CTMP(:,:,:,ISP))
+         CHTOT(N1+(NC-1)*GRIDC%RC%NROW)=CHTOT(N1+(NC-1)*GRIDC%RC%NROW)+SUM(CDIJ*CTMP(:,:,:,ISP))
+      ! ENDDO
+      ! ENDDO
+      ! ENDDO
+   ENDDO
+   ENDDO
+
+! !=======================================================================
+! ! now distribute the DIJ to all nodes which hold DIJ (using global sum)
+! !=======================================================================
+#ifdef realmode
+   CALLMPI( M_sum_d(WDES%COMM_KINTER,CHTOT_(1,ISP), DIMREAL(GRIDC_%MPLWV)))
+#else
+   CALLMPI( M_sum_d(WDES%COMM_KINTER,CHTOT_(1,ISP), DIMREAL(GRIDC_%MPLWV)*2))
+#endif 
+
+! #define debug
+#ifdef debug
+   RHO_AUG =RHO0(GRIDC_, CHTOT_(1,ISP))
+   RHO_SOFT=RHO0(GRID_SOFT , CHDEN)
+   WRITE(*,*) "augmentation electrons", RHO_AUG
+   WRITE(*,*) "soft         electrons", RHO_SOFT
+#endif
+
+   CALL ADD_GRID(GRIDC_,GRID_SOFT,SOFT_TO_C,CHDEN(1,ISP),CHTOT_(1,ISP))
+
+   CALL SETUNB(CHTOT_(1,ISP),GRIDC_)
+#ifdef debug
+   RHO_AUG =RHO0(GRIDC_, CHTOT_(1,ISP))
+   WRITE(*,*) "total        electrons", RHO_AUG
+#endif
+   ENDDO spin
+
+   DEALLOCATE(DDLM)
+   DEALLOCATE(CWORK)
+   DEALLOCATE(POTD)
+   DEALLOCATE(POTC)
+   DEALLOCATE(YLM)
+   ENDIF overl
+#ifdef MPI
+   DEALLOCATE(CTMP)
+#else
+#undef CTMP
+#endif
+
+   RETURN
+END SUBROUTINE AUGCHG_G
diff -urN file_ini/emlr_hamiltonian.F file_modify/emlr_hamiltonian.F
--- file_ini/emlr_hamiltonian.F	1970-01-01 08:00:00.000000000 +0800
+++ file_modify/emlr_hamiltonian.F	2024-07-13 10:37:23.000000000 +0800
@@ -0,0 +1,546 @@
+#include "symbol.inc"
+
+!************************ SUBROUTINE EMLR_HAMIL *************************
+!
+! this subroutine evaluates the "first order perturbation"
+!    |xi>  = H(1) - e(1) S(0) | phi>
+! H(1) and epsilon(1) are the first order change of the
+! Hamiltonian and eigenenergies, respectively
+! more specifically:
+!    |xi>  = V(1) + sum_ij | p_i> D(1)_ij <p_j | phi >
+!                 - sum_ij | p_i> e(1) Q(0)_ij <p_j | phi >
+!                 - e(1) |phi>
+! for details see also HAMILMU_LR
+! e(1) is returned in WXI%CELEN
+! whereas WXI%CW is set to <G | xi>
+!
+! The following term set to 0
+! < d/dR p_j | phi > is returned in WXI%CPROJ
+! and the term
+!         <phi|(sum_ij | d/dR p_i> Q(0)_ij  <p_j |
+!              +sum_ij | p_i> Q(0)_ij < d/dR p_j |) |phi>
+! (change of norm) for each wavefunction
+! this term is returned in WXI%FERWE (somewhat unclean)
+!***********************************************************************
+
+   SUBROUTINE EMLR_HAMIL(GRID,INFO,LATT_CUR,NONLR_S,NONL_S,W0, WXI, WDES, &
+         LMDIM,CDIJ1, CQIJ, SV1, RMS, ICOUEV, LSUBTRACT)
+   USE prec
+   USE wave
+   USE wave_high
+   USE base
+   USE lattice
+   USE mpimy
+   USE mgrid
+   USE nonl_high
+   USE hamil
+   USE constant
+   USE wave_mpi
+   IMPLICIT NONE
+
+   TYPE (grid_3d)     GRID
+   TYPE (info_struct) INFO
+   TYPE (latt)        LATT_CUR
+   TYPE (nonlr_struct) NONLR_S
+   TYPE (nonl_struct) NONL_S
+   TYPE (wavespin)    W0, WXI
+   TYPE (wavedes)     WDES
+
+   RGRID   SV1(DIMREAL(GRID%MPLWV),WDES%NCDIJ) ! local potential
+   INTEGER LMDIM
+   OVERLAP CDIJ1(LMDIM,LMDIM,WDES%NIONS,WDES%NCDIJ)
+   OVERLAP CQIJ(LMDIM,LMDIM,WDES%NIONS,WDES%NCDIJ)
+   REAL(q) RMS        ! magnitude of the residual vector
+   INTEGER ICOUEV     ! number of H | phi> evaluations
+   LOGICAL LSUBTRACT  ! subtract - sum_ij | p_i> e(1) Q(0)_ij <p_j | phi > - e(1) |phi>
+! local work arrays and structures
+   TYPE (wavedes1)  WDES1           ! descriptor for one k-point
+   TYPE (wavefun1)  W0_1(WDES%NSIM) ! current wavefunction
+   COMPLEX(q),ALLOCATABLE:: CF(:,:)
+   INTEGER :: NSIM                  ! number of bands treated simultaneously
+   INTEGER :: NODE_ME, IONODE
+   INTEGER :: NP, ISP, NK, NPL, NGVECTOR, NB_DONE, N, IDUMP, ISPINOR, LD, M, MM
+   REAL(q) :: FNORM, ORTH
+   INTEGER :: NB(WDES%NSIM)         ! contains a list of bands currently optimized
+   LOGICAL :: LDO(WDES%NSIM)        ! band finished
+   LOGICAL :: LSTOP
+
+   NODE_ME=0
+   IONODE =0
+#ifdef MPI
+   NODE_ME=WDES%COMM%NODE_ME
+   IONODE =WDES%COMM%IONODE
+#endif
+!=======================================================================
+!  INITIALISATION:
+! maximum  number of bands treated simultaneously
+!=======================================================================
+   RMS   =0
+   ICOUEV=0
+   NSIM=WDES%NSIM
+
+   ALLOCATE(CF(WDES%NRPLWV,NSIM))
+   LD=WDES%NRPLWV
+
+   DO NP=1,NSIM
+      ALLOCATE(W0_1(NP)%CR(GRID%MPLWV*WDES%NRSPINORS))
+   ENDDO
+
+   WXI%CW=0
+!=======================================================================
+   spin:    DO ISP=1,WDES%ISPIN
+      kpoints: DO NK=1,WDES%NKPTS
+#ifdef MPI
+         IF (MOD(NK-1,WDES%COMM_KINTER%NCPU).NE.WDES%COMM_KINTER%NODE_ME-1) CYCLE
+#endif
+         CALL SETWDES(WDES,WDES1,NK)
+
+         NPL=WDES1%NPL
+         NGVECTOR=WDES1%NGVECTOR
+
+         IF (INFO%LREAL) THEN
+           CALL PHASER(GRID,LATT_CUR,NONLR_S,NK,WDES)
+         ELSE
+           CALL PHASE(WDES,NONL_S,NK)
+         ENDIF
+!=======================================================================
+         NB_DONE=0                 ! index of the bands allready optimised
+         bands: DO
+            NB=0                   ! empty the list of bands, which are optimized currently
+!
+!  check the NB list, whether there is any empty slot
+!  fill in a not yet optimized wavefunction into the slot
+!
+            newband: DO NP=1,NSIM
+               IF (NB_DONE < WDES%NBANDS ) THEN
+                  NB_DONE=NB_DONE+1
+                  N     =NB_DONE
+                  NB(NP)=NB_DONE
+                  ICOUEV=ICOUEV+1
+
+                  CALL SETWAV(W0,W0_1(NP),WDES1,N,ISP)  ! fill band N into W0_1(NP)
+
+                  IDUMP=0
+#ifdef MPI
+                  IF (NODE_ME /= IONODE) IDUMP=0
+#endif
+                  !fft to real space
+                  DO ISPINOR=0,WDES%NRSPINORS-1
+                     CALL FFTWAV(NGVECTOR, WDES%NINDPW(1,NK),W0_1(NP)%CR(1+ISPINOR*GRID%MPLWV),W0_1(NP)%CW(1+ISPINOR*NGVECTOR),GRID)
+                  ENDDO
+               ENDIF
+            ENDDO newband
+!=======================================================================
+! if the NB list is now empty end the bands DO loop
+!=======================================================================
+            LSTOP=.TRUE.
+            LDO  =.FALSE.
+            DO NP=1,NSIM
+               IF ( NB(NP) /= 0 ) THEN
+                  LSTOP  =.FALSE.
+                  LDO(NP)=.TRUE.     ! band not finished yet
+               ENDIF
+            ENDDO
+            IF (LSTOP) EXIT bands
+!=======================================================================
+! determine gradient and store it
+!=======================================================================
+            !  store H | psi > temporarily
+            !  to have uniform stride for result array
+            CALL EMLR_HAMILTMU(WDES1,W0_1,NONLR_S,NONL_S, &
+                    & GRID,INFO%LREAL,LMDIM,CDIJ1(1,1,1,ISP),CQIJ(1,1,1,ISP),&
+                    & SV1(1,ISP),CF(1,1),LD,NSIM,LDO,LSUBTRACT)
+
+            i2: DO NP=1,NSIM
+               N=NB(NP); IF (.NOT. LDO(NP)) CYCLE i2
+
+               ORTH =0
+               FNORM=0
+               DO ISPINOR=0,WDES%NRSPINORS-1
+               DO M=1,NGVECTOR
+                  MM=M+ISPINOR*NGVECTOR
+                  IF (LSUBTRACT) THEN
+                     CF(MM,NP)=CF(MM,NP)-W0_1(NP)%CELEN*W0_1(NP)%CW(MM)
+                  ENDIF
+                  IF (WDES%LSPIRAL.AND.WDES%DATAKE(M,ISPINOR+1,NK)>INFO%ENINI) CF(MM,NP)=0
+                  FNORM =FNORM+CF(MM,NP)*CONJG(CF(MM,NP))
+                  ORTH  =ORTH +CF(MM,NP)*CONJG(W0_1(NP)%CW(MM))
+                  WXI%CW(MM,N,NK,ISP)=CF(MM,NP)
+               ENDDO
+               WXI%CPROJ(:,N,NK,ISP)=0
+               WXI%CELEN(N,NK,ISP)=W0_1(NP)%CELEN
+               ENDDO
+               CALLMPI( M_sum_s(WDES%COMM_INB, 2, FNORM, ORTH, 0._q, 0._q))
+
+               IF (ABS(ORTH)>1E-4.AND.LSUBTRACT) THEN
+                  WRITE(0,*)'HAMIL_LR internal error: the vector H(1)-e(1) S(1) |phi(0)> is not orthogonal to |phi(0)>',NK,N,ORTH
+                  STOP
+               ENDIF
+
+               IF (IDUMP==2) WRITE(*,'(I3,E11.4,"R ",E11.4,"E ",E11.4,"O ",E14.7)') N,SQRT(ABS(FNORM)),REAL(W0_1(NP)%CELEN,q),ORTH,REAL(WXI%CELEN(N,NK,ISP))
+               RMS=RMS+WDES%RSPIN*WDES%WTKPT(NK)*W0%FERWE(N,NK,ISP)*SQRT(ABS(FNORM))/WDES%NB_TOT
+
+!=======================================================================
+! move onto the next block of bands
+!=======================================================================
+            ENDDO i2
+!=======================================================================
+         ENDDO bands
+      ENDDO kpoints
+   ENDDO spin
+!=======================================================================
+
+   CALLMPI( M_sum_d(WDES%COMM_INTER, RMS, 1))
+   CALLMPI( M_sum_d(WDES%COMM_KINTER, RMS, 1))
+
+   CALLMPI( M_sum_i(WDES%COMM_INTER, ICOUEV ,1))
+   CALLMPI( M_sum_i(WDES%COMM_KINTER, ICOUEV ,1))
+
+   DO NP=1,NSIM
+      DEALLOCATE(W0_1(NP)%CR)
+   ENDDO
+   DEALLOCATE(CF)
+
+   RETURN
+   END SUBROUTINE EMLR_HAMIL
+
+!************************* SUBROUTINE EMLR_HAMILTMU *******************
+!
+! this subroutine calculates the first order change of H
+! acting onto a set of wavefuntions
+! the  wavefunction must be given in reciprocal space C and real
+! space CR
+! CH contains the result
+!      |xi>  = V(1) | phi > + | p_i> D(1)_ij <p_j | phi >
+!                 - sum_ij | p_i> e(1) Q_ij <p_j | phi >
+!
+! V(1) is the first order change of the local potential  (SV1)
+! D(1) is the first order change of the PAW strenght     (CDIJ1)
+! e(1) is the first order change of the eigen energy
+!
+! e(1) is evaluated during the calculation of |xi>:
+! e(1) = <phi| V(1) | phi > + <phi | p_i> D(1)_ij <p_j | phi >
+!
+! NOTE: the calling routine has to subtract e(1) |phi> to get the
+! correct vector xi
+!
+!***********************************************************************
+
+   SUBROUTINE EMLR_HAMILTMU( WDES1,W0_1,NONLR_S,NONL_S,&
+         GRID,LREAL,LMDIM,CDIJ1,CQIJ,SV1,CH,LD,NSIM,LDO,LSUBTRACT)
+   USE prec
+   USE mpimy
+   USE mgrid
+   USE wave
+   USE nonl_high
+   USE lattice
+   USE hamil
+   IMPLICIT NONE
+
+   INTEGER NSIM,NP,LD
+   INTEGER LMDIM, NGVECTOR, ISPINOR, ISPINOR_, MM, MM_
+   TYPE (grid_3d)     GRID
+   TYPE (nonlr_struct) NONLR_S
+   TYPE (nonl_struct) NONL_S
+   TYPE (wavefun1)    W0_1(NSIM)
+   TYPE (wavedes1)    WDES1
+   RGRID      SV1(DIMREAL(GRID%MPLWV),WDES1%NRSPINORS*WDES1%NRSPINORS) ! local potential
+   OVERLAP    CDIJ1(LMDIM,LMDIM,WDES1%NIONS,WDES1%NRSPINORS*WDES1%NRSPINORS), &
+              CQIJ(LMDIM,LMDIM,WDES1%NIONS,WDES1%NRSPINORS*WDES1%NRSPINORS)
+   COMPLEX(q) CH(LD,NSIM)
+   LOGICAL LREAL
+   LOGICAL LDO(NSIM)
+   LOGICAL LSUBTRACT
+! local variables
+   REAL(q) RINPLW; INTEGER M
+   COMPLEX(q),ALLOCATABLE :: CWORK1(:,:)
+   COMPLEX(q) :: CE
+   COMPLEX(q) :: EVALUE1(NSIM)
+
+   EVALUE1=0
+   ALLOCATE(CWORK1(GRID%MPLWV*WDES1%NRSPINORS,NSIM))
+   RINPLW=1._q/GRID%NPLWV
+   NGVECTOR=WDES1%NGVECTOR
+!=======================================================================
+! calculate the local contribution (result in CWORK1)
+!=======================================================================
+   DO NP=1,NSIM
+     IF ( LDO(NP) ) THEN
+     CE=0
+     CWORK1(:,NP)  = 0
+     DO ISPINOR =0,WDES1%NRSPINORS-1
+     DO ISPINOR_=0,WDES1%NRSPINORS-1
+        DO M=1,GRID%RL%NP
+           MM =M+ISPINOR *GRID%MPLWV
+           MM_=M+ISPINOR_*GRID%MPLWV
+           CWORK1(MM,NP)=  CWORK1(MM,NP)+(SV1(M,1+ISPINOR_+2*ISPINOR) *W0_1(NP)%CR(MM_)*RINPLW)
+           CE=CE + CONJG(W0_1(NP)%CR(MM)) *(SV1(M,1+ISPINOR_+2*ISPINOR) *W0_1(NP)%CR(MM_)*RINPLW)
+        ENDDO
+     ENDDO
+     ENDDO
+     CALLMPI( M_sum_z(WDES1%COMM_INB, CE, 1))
+     W0_1(NP)%CELEN=CE
+     ENDIF
+   ENDDO
+!=======================================================================
+! non-local contribution in real-space
+!=======================================================================
+   IF (LREAL) THEN
+      ! non local contributions to e(1)
+      DO NP=1,NSIM
+         IF ( LDO(NP) ) THEN
+            CALL ECCP_NL_ALL(WDES1,W0_1(NP),W0_1(NP),CDIJ1,CQIJ,0.0_q,CE)
+            W0_1(NP)%CELEN=W0_1(NP)%CELEN+CE
+
+            IF (LSUBTRACT) THEN
+               EVALUE1(NP)=W0_1(NP)%CELEN
+            ELSE
+               EVALUE1(NP)=0
+            ENDIF
+         ENDIF
+      ENDDO
+
+      ! contribution | p_i > d D_ij / d R - e(1) Q_ij < p_j |
+      CALL RACCMU_C(NONLR_S,WDES1,W0_1, LMDIM,CDIJ1,CQIJ,EVALUE1,CWORK1,GRID%MPLWV*WDES1%NRSPINORS, NSIM, LDO)
+
+      DO NP=1,NSIM
+         IF ( LDO(NP) ) THEN
+         DO ISPINOR=0,WDES1%NRSPINORS-1
+            CALL FFTEXT(NGVECTOR,WDES1%NINDPW(1),CWORK1(1+ISPINOR*WDES1%GRID%MPLWV,NP),CH(1+ISPINOR*NGVECTOR,NP),GRID,.FALSE.)
+         ENDDO
+         ENDIF
+      ENDDO
+!=======================================================================
+! calculate the non local contribution in reciprocal space
+!=======================================================================
+   ELSE
+      DO NP=1,NSIM
+      IF ( LDO(NP) ) THEN
+         DO ISPINOR=0,WDES1%NRSPINORS-1
+            DO M=1,NGVECTOR
+               MM=M+ISPINOR*NGVECTOR
+               CH(MM,NP)=0
+            ENDDO
+         ENDDO
+
+         ! non local contributions to e(1)
+         CALL ECCP_NL_ALL(WDES1,W0_1(NP),W0_1(NP),CDIJ1,CQIJ,0.0_q,CE)
+         W0_1(NP)%CELEN=W0_1(NP)%CELEN+CE
+
+         IF (LSUBTRACT) THEN
+            EVALUE1(NP)=W0_1(NP)%CELEN
+         ELSE
+            EVALUE1(NP)=0
+         ENDIF
+
+         ! contribution | p_i > d D_ij / d R - e(1) Q_ij < p_j |
+         CALL VNLACC_ADD_C(NONL_S,W0_1(NP), CDIJ1, CQIJ, 1, EVALUE1(NP),CH(:,NP))
+
+         DO ISPINOR=0,WDES1%NRSPINORS-1
+            CALL FFTEXT(NGVECTOR,WDES1%NINDPW(1),CWORK1(1+ISPINOR*WDES1%GRID%MPLWV,NP),CH(1+ISPINOR*NGVECTOR,NP),GRID,.TRUE.)
+         ENDDO
+     ENDIF
+     ENDDO
+   ENDIF
+
+   DEALLOCATE(CWORK1)
+   RETURN
+   END SUBROUTINE EMLR_HAMILTMU
+   
+!************************ SUBROUTINE EMLR_PROJECT *************************
+! this subroutine removes the contribution of calculated orbitals
+! whose energies lower than EPRO from |xi>  = H(1) - e(1) S(0) | phi>
+!
+! |xi> ->|xi> - sum_j S(0) |phi(0)_j> <phi(0)_j| xi_i> when e(0)_j < EPRO
+!
+!***********************************************************************
+
+   SUBROUTINE EMLR_PROJECT(GRID,LATT_CUR,NONLR_S,NONL_S,W0,WXI,LREAL,LMDIM,CQIJ,EPRO)
+      USE prec
+      USE constant
+      USE mgrid
+      USE lattice
+      USE nonl_high
+      USE wave_high
+      USE dfast
+
+      IMPLICIT NONE
+
+      TYPE (grid_3d)     GRID
+      TYPE (latt)        LATT_CUR
+      TYPE (nonlr_struct) NONLR_S
+      TYPE (nonl_struct) NONL_S
+      TYPE (wavespin)    W0
+      TYPE (wavespin)    WXI
+      LOGICAL LREAL
+      INTEGER LMDIM
+      OVERLAP CQIJ(LMDIM,LMDIM,W0%WDES%NIONS,W0%WDES%NCDIJ)
+      REAL(q) EPRO
+! local variables
+      INTEGER ISP, NK, NBAND, NSTRIP
+      INTEGER NPOS, NSTRIP_ACT
+      INTEGER NB_TOT_WXI, NB_TOT_W0
+      INTEGER N1, ISPINOR
+
+      TYPE (wavedes1)    WDES1_WXI      ! descriptor for one k-point
+      TYPE (wavedes1)    WDES1_W0       ! descriptor for one k-point for W0
+      TYPE (wavefuna)    WAXI           ! array to store wavefunction
+      TYPE (wavefuna)    S_W0           ! S |W0>
+      TYPE (wavefun1)    W0_1
+      OVERLAP CDIJ_TMP(LMDIM,LMDIM,W0%WDES%NIONS,W0%WDES%NCDIJ)
+      GDEF,ALLOCATABLE,TARGET::  CHAM(:,:)
+! redistributed plane wave coefficients
+      INTEGER NCPU
+
+      PROFILING_START('EMLR_PROJECT')
+
+#ifdef MPI
+      NCPU   =W0%WDES%COMM_INTER%NCPU ! number of procs involved in band dis.
+#else
+      NCPU=1
+#endif
+!-----------------------------------------------------------------------
+! determine whether redistribution is required
+!-----------------------------------------------------------------------
+      NB_TOT_WXI=WXI%WDES%NB_TOT
+      NB_TOT_W0 =W0%WDES%NB_TOT
+
+      ! set NSTRIP between [1 and 32]
+      NSTRIP=NSTRIP_STANDARD_GLOBAL
+
+      CALL SETWDES(W0%WDES,WDES1_W0,0)
+      CALL NEWWAVA(S_W0, WDES1_W0, W0%WDES%NBANDS)
+
+      CDIJ_TMP=0._q
+      ALLOCATE(CHAM(NB_TOT_W0,NB_TOT_WXI))
+      ALLOCATE(W0_1%CR(GRID%MPLWV*W0%WDES%NRSPINORS))
+!=======================================================================
+      spin:  DO ISP=1,W0%WDES%ISPIN
+      kpoint: DO NK=1,W0%WDES%NKPTS
+#ifdef MPI
+      IF (MOD(NK-1,W0%WDES%COMM_KINTER%NCPU).NE.W0%WDES%COMM_KINTER%NODE_ME-1) CYCLE
+#endif
+!=======================================================================
+      CALL SETWDES(WXI%WDES ,WDES1_WXI,NK)
+      CALL SETWDES(W0%WDES,WDES1_W0,NK)
+      WAXI=ELEMENTS(WXI, WDES1_WXI, ISP)
+      CALL WA_COPY(ELEMENTS(W0, WDES1_W0, ISP), S_W0)
+!=======================================================================
+! S |w0> =  |w0> + |p_i> q_ij <p_j|w0>
+!=======================================================================
+!=======================================================================
+! non-local contribution in real-space
+!=======================================================================
+      IF (LREAL) THEN
+         CALL PHASER(GRID,LATT_CUR,NONLR_S,NK,W0%WDES)
+
+         DO NBAND=1,W0%WDES%NBANDS
+            CALL SETWAV(W0,W0_1,WDES1_W0,NBAND,ISP)
+            !fft to real space
+            W0_1%CR=0.0_q
+            ! contribution | p_i > - e(1) Q_ij < p_j |
+            CALL RACC(NONLR_S,W0_1,CDIJ_TMP,CQIJ,1,-1._q,W0_1%CR)
+
+            DO ISPINOR=0,WDES1_W0%NRSPINORS-1
+               CALL FFTEXT(WDES1_W0%NGVECTOR,WDES1_W0%NINDPW(1),W0_1%CR(1+ISPINOR*GRID%MPLWV),S_W0%CW(1+ISPINOR*WDES1_W0%NGVECTOR,NBAND),GRID,.TRUE.)
+            ENDDO
+         ENDDO
+!=======================================================================
+! calculate the non local contribution in reciprocal space
+!=======================================================================
+      ELSE
+         CALL PHASE(W0%WDES,NONL_S,NK)
+
+         DO NBAND=1,W0%WDES%NBANDS
+            CALL SETWAV(W0,W0_1,WDES1_W0,NBAND,ISP)
+            ! contribution | p_i > - e(1) Q_ij < p_j |
+            CALL VNLACC_ADD(NONL_S,W0_1,CDIJ_TMP,CQIJ,1,-1._q,S_W0%CW(:,NBAND))
+         ENDDO
+      ENDIF
+!=======================================================================
+!  calculate Hamiltonian CHAM
+!  CHAM(j,i) =   <phi(0)_j| xi_i>
+!=======================================================================
+    ! redistribute the projected wavefunctions
+    ! wavefunctions are still required at this point
+      IF (W0%WDES%DO_REDIS) THEN
+        CALL REDIS_PW  (WDES1_W0, W0%WDES%NBANDS, S_W0%CW(1,1))
+        CALL REDIS_PW  (WDES1_W0, W0%WDES%NBANDS, W0%CW   (1,1,NK,ISP))
+        CALL REDIS_PROJ(WDES1_W0, W0%WDES%NBANDS, W0%CPROJ(1,1,NK,ISP))
+        CALL REDIS_PW  (WDES1_WXI, WXI%WDES%NBANDS, WXI%CW   (1,1,NK,ISP))
+        CALL REDIS_PROJ(WDES1_WXI, WXI%WDES%NBANDS, WXI%CPROJ(1,1,NK,ISP))
+      ENDIF
+
+      CHAM=0
+! first calculate CHAM(j,i) =  <phi(0)_j| xi_i>
+      DO NPOS=1,NB_TOT_WXI,NSTRIP
+         NSTRIP_ACT=MIN(NB_TOT_WXI+1-NPOS, NSTRIP)
+
+         CALL ORTH2( &
+              W0%CW(1,1,NK,ISP),WAXI%CW_RED(1,NPOS),W0%CPROJ(1,1,NK,ISP), &
+              WAXI%CPROJ_RED(1,NPOS),NB_TOT_W0, &
+              NPOS,NSTRIP_ACT,WDES1_WXI%NPL_RED,0,WDES1_WXI%NRPLWV_RED,WDES1_WXI%NPROD_RED,CHAM(1,1))
+      ENDDO
+      CALLMPI( M_sum_g(W0%WDES%COMM_KIN,CHAM(1,1),NB_TOT_W0*NB_TOT_WXI))
+!#ifdef debug
+!      IF (IU0>=0) CALL DUMP_HAM( "<phi(0)_j| xi_i>",W0%WDES, CHAM)
+!#endif
+1     FORMAT(1I2,3X,20F9.5)
+2     FORMAT(1I2,3X,20E9.1)
+!=======================================================================
+! now add COVL to CHAM
+!=======================================================================
+      CHAM=-CHAM
+      DO N1=1,NB_TOT_W0
+         IF (REAL(W0%CELTOT(N1,NK,ISP)) > EPRO) CHAM(N1,:)=0
+      ENDDO
+!=======================================================================
+! rotate wavefunctions
+!=======================================================================
+      IF (WDES1_WXI%NPL_RED/=0) &
+      CALL GGEMM('N', 'N', m_ WDES1_WXI%NPL_RED, NB_TOT_WXI, NB_TOT_W0, one, &
+     &               S_W0%CW(1,1), m_ WDES1_WXI%NRPLWV_RED, CHAM(1,1), &
+     &               NB_TOT_W0, one, WXI%CW(1,1,NK,ISP) , m_ WDES1_WXI%NRPLWV_RED)
+
+      DWRITE "lincom ok"
+
+      IF (W0%WDES%DO_REDIS) THEN
+         CALL REDIS_PW  (WDES1_W0, W0%WDES%NBANDS, S_W0%CW(1,1))
+         CALL REDIS_PW  (WDES1_W0, W0%WDES%NBANDS, W0%CW   (1,1,NK,ISP))
+         CALL REDIS_PROJ(WDES1_W0, W0%WDES%NBANDS, W0%CPROJ(1,1,NK,ISP))
+         CALL REDIS_PW  (WDES1_WXI, WXI%WDES%NBANDS, WXI%CW   (1,1,NK,ISP))
+         CALL REDIS_PROJ(WDES1_WXI, WXI%WDES%NBANDS, WXI%CPROJ(1,1,NK,ISP))
+         DWRITE "redis ok"
+      ENDIF
+!=======================================================================
+      ENDDO kpoint
+      ENDDO spin
+!=======================================================================
+      CALL DELWAVA(S_W0)
+      DEALLOCATE(CHAM)
+      DEALLOCATE(W0_1%CR)
+
+      PROFILING_STOP('EMLR_PROJECT')
+
+      RETURN
+      END SUBROUTINE EMLR_PROJECT
+
+!***********************************************************************
+!
+! function that yields .TRUE. if a state is fully occupied
+! this is a little bit ambiguous  the threshold is presently set
+! to something 0.99 electrons
+!
+!***********************************************************************
+
+  FUNCTION FILLED(F)
+    USE prec
+    IMPLICIT NONE
+    LOGICAL FILLED
+    REAL(q) :: F
+    IF (ABS(F-1)<0.1) THEN
+       FILLED=.TRUE.
+    ELSE
+       FILLED=.FALSE.
+    ENDIF
+  END FUNCTION FILLED
\ No newline at end of file
diff -urN file_ini/emlr_potential.F file_modify/emlr_potential.F
--- file_ini/emlr_potential.F	1970-01-01 08:00:00.000000000 +0800
+++ file_modify/emlr_potential.F	2024-07-13 10:37:23.000000000 +0800
@@ -0,0 +1,405 @@
+#include "symbol.inc"
+
+!=======================================================================
+!  calculate first derivative of potential
+!  and derivatives of non local strenght parameters
+!  this presently done using finite differences
+!  the results are stored in
+!   SV1
+!   CDIJ1
+!
+!  second derivative
+!  grid point
+!            -2    -1      1      2
+!                  -1/2    1/2
+!            1/12 -8/12    8/12  -1/12
+!=======================================================================
+   SUBROUTINE EMLR_POT_DER4(WDES,GRID,GRIDC,GRIDUS,GRID_SOFT,C_TO_US,SOFT_TO_C,&
+         INFO,T_INFO,P,LATT_CUR,CSTRF,CHTOT,CHTOT1,CHTOT1_GGAcorr,DENCOR,SV1,LMDIM,&
+         CDIJ1,CRHODE,CRHODE1,CQIJ,N_MIX_PAW,RHOLM,RHOLM1,IRDMAX,STEP_LENGTH,QVEC_CART)
+   USE base
+   USE wave
+   USE mgrid
+   USE poscar
+   USE pseudo
+   USE lattice
+   USE pawm
+   USE us
+   USE pot
+
+   TYPE (wavedes)     WDES
+   TYPE (grid_3d)     GRID       ! grid for wavefunctions
+   TYPE (grid_3d)     GRIDC      ! grid for potentials/charge
+   TYPE (grid_3d)     GRIDUS     ! temporary grid in us.F
+   TYPE (grid_3d)     GRID_SOFT  ! grid for soft chargedensity
+   TYPE (transit)     C_TO_US    ! index table between GRIDC and GRIDUS
+   TYPE (transit)     SOFT_TO_C  ! index table between GRID_SOFT and GRIDC
+   TYPE (info_struct) INFO
+   TYPE (type_info)   T_INFO
+   TYPE (potcar)      P(T_INFO%NTYP)
+   TYPE (latt)        LATT_CUR
+   COMPLEX(q)  CSTRF(GRIDC%MPLWV,T_INFO%NTYP)! original structure factor
+   COMPLEX(q)  CHTOT(GRIDC%MPLWV,WDES%NCDIJ) ! charge-density
+   COMPLEX(q)  CHTOT1(GRIDC%MPLWV,WDES%NCDIJ)! derivative of charge density
+   COMPLEX(q)  CHTOT1_GGAcorr(GRIDC%MPLWV,WDES%NCDIJ)! for GGA
+   RGRID       DENCOR(GRIDC%RL%NP)           ! partial core
+   RGRID       SV1(DIMREAL(GRID%MPLWV),WDES%NCDIJ) ! derivative of potential on GRID
+   INTEGER LMDIM
+   OVERLAP  CDIJ1(LMDIM,LMDIM,WDES%NIONS,WDES%NCDIJ)   ! derivative of strength parameters
+   OVERLAP  CRHODE(LMDIM,LMDIM,WDES%NIONS,WDES%NCDIJ)  ! one center occupancies
+   OVERLAP  CRHODE1(LMDIM,LMDIM,WDES%NIONS,WDES%NCDIJ) ! derivative of one center occupancies
+   OVERLAP  CQIJ(LMDIM,LMDIM,WDES%NIONS,WDES%NCDIJ)
+   INTEGER N_MIX_PAW
+   REAL(q)  RHOLM(N_MIX_PAW,WDES%NCDIJ)      ! one centre occupancies passed through mixer
+   REAL(q)  RHOLM1(N_MIX_PAW,WDES%NCDIJ)     ! derivative of one centre occupancies
+   INTEGER IRDMAX
+   REAL(q) STEP_LENGTH                             ! step size used for finite differences
+   REAL(q) :: QVEC_CART(3)                        ! q
+! local
+   COMPLEX(q)  CHTOT_(GRIDC%MPLWV,WDES%NCDIJ)            ! work array charge density
+   COMPLEX(q)  CHTOT1_(GRIDC%MPLWV,WDES%NCDIJ)            ! work array charge density
+   OVERLAP     CRHODE_(LMDIM,LMDIM,WDES%NIONS,WDES%NCDIJ)! work array
+   REAL(q)     RHOLM_(N_MIX_PAW,WDES%NCDIJ)              ! work array
+   COMPLEX(q)  CVTOT1(GRIDC%MPLWV,WDES%NCDIJ)            ! derivative of potential on GRIDC (real space)
+   RGRID       SV2(DIMREAL(GRID%MPLWV),WDES%NCDIJ)       ! work array
+   OVERLAP     CDIJ2(LMDIM,LMDIM,WDES%NIONS,WDES%NCDIJ)  ! work array
+   OVERLAP     CDIJ3(LMDIM,LMDIM,WDES%NIONS,WDES%NCDIJ)  ! work array
+   TYPE (energy) E1,E2,E3,E4                             ! energy arrays
+   INTEGER :: IRDMAA
+   REAL(q) :: XCSIF(3,3)
+   REAL(q) :: WEIGHT
+   INTEGER :: ISP,I,J,NI
+   REAL(q) DISPL(3,T_INFO%NIONS)             ! displacement vector
+   REAL(q) :: DTMP1(LMDIM,LMDIM,WDES%NIONS,WDES%NCDIJ),DTMP2(LMDIM,LMDIM,WDES%NIONS,WDES%NCDIJ)
+
+   DISPL=0
+   SV1=0
+   CVTOT1=0
+   CDIJ1=0
+! positive displacement
+   CHTOT_=CHTOT+CHTOT1*(STEP_LENGTH/2) ! \tilde n + \hat n
+                                 ! DENCOR: \tilde n_c
+   CHTOT1_=CHTOT1_GGAcorr*(STEP_LENGTH/2)
+! \tilde v_eff
+   CALL POTLOK(GRID,GRIDC,GRID_SOFT,WDES%COMM_INTER, WDES, &
+        INFO,P,T_INFO,E1,LATT_CUR, &
+        CHTOT_,CSTRF,CVTOT1,DENCOR,SV1, SOFT_TO_C,XCSIF,CHTOT1_,QVEC_CART)
+! \hat D_ij
+! Although CHTOT1 is decomposed into real part and image part,
+! only v^1_xc in LDA is real, while the contribution from Hartree and GGA
+! will make v^1_eff complex.
+! Real( v_eff*exp^(i q.(r-R)) )
+   CALL SETDIJ_(WDES,GRIDC,GRIDUS,C_TO_US,LATT_CUR,P,T_INFO,INFO%LOVERL, &
+        LMDIM,CDIJ1,CQIJ,CVTOT1,.TRUE.,IRDMAA,IRDMAX, DISPL, QVEC_CART, .TRUE.)
+! Image( v_eff*exp^(i q.(r-R)) )
+   CALL SETDIJ_(WDES,GRIDC,GRIDUS,C_TO_US,LATT_CUR,P,T_INFO,INFO%LOVERL, &
+        LMDIM,CDIJ3,CQIJ,CVTOT1,.TRUE.,IRDMAA,IRDMAX, DISPL, QVEC_CART, .FALSE.)
+   CDIJ1=CDIJ1+(0._q,1._q)*CDIJ3
+!    CDIJ1=0
+   CRHODE_=CRHODE+CRHODE1*(STEP_LENGTH/2)
+   RHOLM_=RHOLM+RHOLM1*(STEP_LENGTH/2)
+   CALL SET_DD_PAW(WDES, P , T_INFO, INFO%LOVERL, &
+        WDES%NCDIJ, LMDIM, CDIJ1(1,1,1,1), RHOLM_ , CRHODE_(1,1,1,1), &
+        E1,  LMETA=.FALSE., LASPH=INFO%LASPH, LCOREL= .FALSE.  )
+
+! negative displacement
+   CHTOT_=CHTOT-CHTOT1*(STEP_LENGTH/2)
+   CHTOT1_=-CHTOT1_GGAcorr*(STEP_LENGTH/2)
+   CALL POTLOK(GRID,GRIDC,GRID_SOFT, WDES%COMM_INTER, WDES, &
+        INFO,P,T_INFO,E2,LATT_CUR, &
+        CHTOT_,CSTRF,CVTOT1,DENCOR,SV2, SOFT_TO_C,XCSIF,CHTOT1_,QVEC_CART)
+   CALL SETDIJ_(WDES,GRIDC,GRIDUS,C_TO_US,LATT_CUR,P,T_INFO,INFO%LOVERL, &
+        LMDIM,CDIJ2,CQIJ,CVTOT1,.TRUE.,IRDMAA,IRDMAX, DISPL, QVEC_CART, .TRUE.)
+   CALL SETDIJ_(WDES,GRIDC,GRIDUS,C_TO_US,LATT_CUR,P,T_INFO,INFO%LOVERL, &
+        LMDIM,CDIJ3,CQIJ,CVTOT1,.TRUE.,IRDMAA,IRDMAX, DISPL, QVEC_CART, .FALSE.)
+   CDIJ2=CDIJ2+(0._q,1._q)*CDIJ3
+!    CDIJ2=0
+   CRHODE_=CRHODE-CRHODE1*(STEP_LENGTH/2)
+   RHOLM_=RHOLM-RHOLM1*(STEP_LENGTH/2)
+   CALL SET_DD_PAW(WDES, P , T_INFO, INFO%LOVERL, &
+        WDES%NCDIJ, LMDIM, CDIJ2(1,1,1,1), RHOLM_ , CRHODE_(1,1,1,1), &
+        E2,  LMETA=.FALSE., LASPH=INFO%LASPH, LCOREL= .FALSE.  )
+
+! derivative of potential SV1   =(SV1   -SV2  )*(1/STEP_LENGTH)
+   WEIGHT=16._q/12._q/STEP_LENGTH
+   DO ISP=1,WDES%NCDIJ
+      CALL RL_ADD(SV1(1,ISP)   ,WEIGHT,SV2(1,ISP)   ,-WEIGHT,SV1(1,ISP)   ,GRID)
+   ENDDO
+   CDIJ1=(CDIJ1-CDIJ2)*WEIGHT
+
+! positive displacement (doubled)
+   CHTOT_=CHTOT+CHTOT1*STEP_LENGTH
+   CHTOT1_=CHTOT1_GGAcorr*STEP_LENGTH
+   CALL POTLOK(GRID,GRIDC,GRID_SOFT, WDES%COMM_INTER, WDES, &
+        INFO,P,T_INFO,E3,LATT_CUR, &
+        CHTOT_,CSTRF,CVTOT1,DENCOR,SV2, SOFT_TO_C,XCSIF,CHTOT1_,QVEC_CART)
+   CALL SETDIJ_(WDES,GRIDC,GRIDUS,C_TO_US,LATT_CUR,P,T_INFO,INFO%LOVERL, &
+        LMDIM,CDIJ2,CQIJ,CVTOT1,.TRUE.,IRDMAA,IRDMAX, DISPL, QVEC_CART, .TRUE.)
+   CALL SETDIJ_(WDES,GRIDC,GRIDUS,C_TO_US,LATT_CUR,P,T_INFO,INFO%LOVERL, &
+        LMDIM,CDIJ3,CQIJ,CVTOT1,.TRUE.,IRDMAA,IRDMAX, DISPL, QVEC_CART, .FALSE.)
+   CDIJ2=CDIJ2+(0._q,1._q)*CDIJ3
+!    CDIJ2=0
+   CRHODE_=CRHODE+CRHODE1*STEP_LENGTH
+   RHOLM_=RHOLM+RHOLM1*STEP_LENGTH
+   CALL SET_DD_PAW(WDES, P , T_INFO, INFO%LOVERL, &
+        WDES%NCDIJ, LMDIM, CDIJ2(1,1,1,1), RHOLM_ , CRHODE_(1,1,1,1), &
+        E3,  LMETA=.FALSE., LASPH=INFO%LASPH, LCOREL= .FALSE.  )
+
+   WEIGHT=-2._q/12._q/STEP_LENGTH
+   DO ISP=1,WDES%NCDIJ
+      CALL RL_ADD(SV1(1,ISP)   ,1.0_q,SV2(1,ISP)   ,WEIGHT,SV1(1,ISP)   ,GRID)
+   ENDDO
+   CDIJ1=CDIJ1+WEIGHT*CDIJ2
+
+! negative displacement (doubled)
+   CHTOT_=CHTOT-CHTOT1*STEP_LENGTH
+   CHTOT1_=-CHTOT1_GGAcorr*STEP_LENGTH
+   CALL POTLOK(GRID,GRIDC,GRID_SOFT, WDES%COMM_INTER, WDES, &
+        INFO,P,T_INFO,E4,LATT_CUR, &
+        CHTOT_,CSTRF,CVTOT1,DENCOR,SV2, SOFT_TO_C,XCSIF,CHTOT1_,QVEC_CART)
+   CALL SETDIJ_(WDES,GRIDC,GRIDUS,C_TO_US,LATT_CUR,P,T_INFO,INFO%LOVERL, &
+        LMDIM,CDIJ2,CQIJ,CVTOT1,.TRUE.,IRDMAA,IRDMAX, DISPL, QVEC_CART, .TRUE.)
+   CALL SETDIJ_(WDES,GRIDC,GRIDUS,C_TO_US,LATT_CUR,P,T_INFO,INFO%LOVERL, &
+        LMDIM,CDIJ3,CQIJ,CVTOT1,.TRUE.,IRDMAA,IRDMAX, DISPL, QVEC_CART, .FALSE.)
+   CDIJ2=CDIJ2+(0._q,1._q)*CDIJ3
+!    CDIJ2=0
+   CRHODE_=CRHODE-CRHODE1*STEP_LENGTH
+   RHOLM_=RHOLM-RHOLM1*STEP_LENGTH
+   CALL SET_DD_PAW(WDES, P , T_INFO, INFO%LOVERL, &
+        WDES%NCDIJ, LMDIM, CDIJ2(1,1,1,1), RHOLM_ , CRHODE_(1,1,1,1), &
+        E4,  LMETA=.FALSE., LASPH=INFO%LASPH, LCOREL= .FALSE.  )
+
+   WEIGHT=2._q/12._q/STEP_LENGTH
+   DO ISP=1,WDES%NCDIJ
+      CALL RL_ADD(SV1(1,ISP)   ,1.0_q,SV2(1,ISP)   ,WEIGHT,SV1(1,ISP)   ,GRID)
+   ENDDO
+   CDIJ1=CDIJ1+WEIGHT*CDIJ2
+   
+! !-------------------------------------------------------------------------
+! ! round the results in DFPT calculation.
+! #ifdef realmode
+!    DTMP1 = REAL(CDIJ1,KIND=q)
+!    DTMP2 = 0
+! #else
+!    DTMP1 = REAL(CDIJ1,KIND=q)
+!    DTMP2 = AIMAG(CDIJ1)
+! #endif
+!    DO ISP=1,WDES%NCDIJ
+!    DO NI = 1,WDES%NIONS
+!    DO J = 1,LMDIM
+!    DO I = 1,LMDIM
+!       IF (DTMP1(I,J,NI,ISP)<1E-12/STEP_LENGTH) DTMP1(I,J,NI,ISP)=0
+!       IF (DTMP2(I,J,NI,ISP)<1E-12/STEP_LENGTH) DTMP2(I,J,NI,ISP)=0
+!    ENDDO
+!    ENDDO
+!    ENDDO
+!    ENDDO
+!    CDIJ1 = DTMP1+(0._q,1._q)*DTMP2
+! !-------------------------------------------------------------------------
+   
+   END SUBROUTINE EMLR_POT_DER4
+
+!=======================================================================
+!  calculate first derivative of potential
+!  and derivatives of non local strenght parameters
+!  this presently done using finite differences
+!  the results are stored in
+!   SV1
+!   CDIJ1
+!
+!  second derivative
+!  grid point
+!            -2    -1      1      2
+!                  -1/2    1/2
+!            1/12 -8/12    8/12  -1/12
+!=======================================================================
+   SUBROUTINE EMLR_POT_DER4X(WDES,GRID,GRIDC,GRIDUS,GRID_SOFT,C_TO_US,SOFT_TO_C,&
+          INFO,T_INFO,P,LATT_CUR,CSTRF,CHTOT,CHTOT1,CHTOT1_GGAcorr,DENCOR,SV1,LMDIM,&
+          CDIJ1,CRHODE,CRHODE1,CQIJ,N_MIX_PAW,RHOLM,RHOLM1,IRDMAX,STEP_LENGTH,QVEC_CART)
+     USE base
+     USE wave
+     USE mgrid
+     USE poscar
+     USE pseudo
+     USE lattice
+     USE pawm
+     USE us
+     USE pot
+     implicit none
+     TYPE (wavedes)     WDES
+     TYPE (grid_3d)     GRID       ! grid for wavefunctions
+     TYPE (grid_3d)     GRIDC      ! grid for potentials/charge
+     TYPE (grid_3d)     GRIDUS     ! temporary grid in us.F
+     TYPE (grid_3d)     GRID_SOFT  ! grid for soft chargedensity
+     TYPE (transit)     C_TO_US    ! index table between GRIDC and GRIDUS
+     TYPE (transit)     SOFT_TO_C  ! index table between GRID_SOFT and GRIDC
+     TYPE (info_struct) INFO
+     TYPE (type_info)   T_INFO
+     TYPE (potcar)      P(T_INFO%NTYP)
+     TYPE (latt)        LATT_CUR
+     COMPLEX(q)  CSTRF(GRIDC%MPLWV,T_INFO%NTYP)! original structure factor
+     COMPLEX(q)  CHTOT(GRIDC%MPLWV,WDES%NCDIJ) ! charge-density
+     COMPLEX(q)  CHTOT1(GRIDC%MPLWV,WDES%NCDIJ)! derivative of charge density
+     COMPLEX(q)  CHTOT1_GGAcorr(GRIDC%MPLWV,WDES%NCDIJ)! for GGA
+     RGRID       DENCOR(GRIDC%RL%NP)           ! partial core
+     RGRID       SV1(DIMREAL(GRID%MPLWV),WDES%NCDIJ) ! derivative of potential on GRID
+     INTEGER LMDIM
+     OVERLAP  CDIJ1(LMDIM,LMDIM,WDES%NIONS,WDES%NCDIJ)   ! derivative of strength parameters
+     OVERLAP  CRHODE(LMDIM,LMDIM,WDES%NIONS,WDES%NCDIJ)  ! one center occupancies
+     OVERLAP  CRHODE1(LMDIM,LMDIM,WDES%NIONS,WDES%NCDIJ) ! derivative of one center occupancies
+     OVERLAP  CQIJ(LMDIM,LMDIM,WDES%NIONS,WDES%NCDIJ)
+     INTEGER N_MIX_PAW
+     REAL(q)  RHOLM(N_MIX_PAW,WDES%NCDIJ)      ! one centre occupancies passed through mixer
+     REAL(q)  RHOLM1(N_MIX_PAW,WDES%NCDIJ)     ! derivative of one centre occupancies
+     INTEGER IRDMAX
+     REAL(q) STEP_LENGTH                             ! step size used for finite differences
+     REAL(q) :: QVEC_CART(3)                        ! q
+     ! local
+     COMPLEX(q)  CHTOT_(GRIDC%MPLWV,WDES%NCDIJ)            ! work array charge density
+     COMPLEX(q)  CHTOT1_(GRIDC%MPLWV,WDES%NCDIJ)            ! work array charge density
+     OVERLAP     CRHODE_(LMDIM,LMDIM,WDES%NIONS,WDES%NCDIJ)! work array
+     REAL(q)     RHOLM_(N_MIX_PAW,WDES%NCDIJ)              ! work array
+     COMPLEX(q)  CVTOT1(GRIDC%MPLWV,WDES%NCDIJ)            ! derivative of potential on GRIDC (real space)
+     COMPLEX(q)  CVTOT2(GRIDC%MPLWV,WDES%NCDIJ)            ! derivative of potential on GRIDC (real space)
+     RGRID       SV2(DIMREAL(GRID%MPLWV),WDES%NCDIJ)       ! work array
+     OVERLAP     CDIJ2(LMDIM,LMDIM,WDES%NIONS,WDES%NCDIJ)  ! work array
+     OVERLAP     CDIJ3(LMDIM,LMDIM,WDES%NIONS,WDES%NCDIJ)  ! work array
+     OVERLAP     CDIJ2_(LMDIM,LMDIM,WDES%NIONS,WDES%NCDIJ)  ! work array
+     OVERLAP     CDIJ3_(LMDIM,LMDIM,WDES%NIONS,WDES%NCDIJ)  ! work array
+     TYPE (energy) E1,E2,E3,E4                             ! energy arrays
+     INTEGER :: IRDMAA
+     REAL(q) :: XCSIF(3,3),SCAL
+     REAL(q) :: WEIGHT,SUM1,SUM2,SUM3,SUM4
+     INTEGER :: ISP,I,J,K,NI
+     REAL(q) DISPL(3,T_INFO%NIONS)             ! displacement vector
+     REAL(q) :: DTMP1,DTMP2,truncate_sig_fig
+     ! REAL(q),dimension(4) :: STEP = (/1.0_q,0.5_q,-0.5_q,-1.0_q/)
+     ! REAL(q),dimension(4) :: WARRAY = (/-2._q/12._q,16._q/12._q,-16._q/12._q,2._q/12._q/)
+     REAL(q),dimension(6) :: STEP = (/1.0_q,2._q/3._q,1._q/3._q,-1._q/3._q,-2._q/3._q,-1.0_q/)
+     REAL(q),dimension(6) :: WARRAY = (/0.05_q,-0.45_q,2.25_q,-2.25_q,0.45_q,-0.05_q/)
+     COMPLEX(q) CSUM
+
+     DISPL=0
+     ! starting point
+      CHTOT_=CHTOT ! \tilde n + \hat n
+      CHTOT1_=0
+      ! \tilde v_eff
+      SV2=0
+      CVTOT2=0
+      CALL POTLOK(GRID,GRIDC,GRID_SOFT,WDES%COMM_INTER, WDES, &
+      INFO,P,T_INFO,E1,LATT_CUR, &
+      CHTOT_,CSTRF,CVTOT2,DENCOR,SV2, SOFT_TO_C,XCSIF,CHTOT1_,QVEC_CART)
+      
+      CDIJ2_=0
+      CDIJ3_=0
+      CALL SETDIJ_(WDES,GRIDC,GRIDUS,C_TO_US,LATT_CUR,P,T_INFO,INFO%LOVERL, &
+      LMDIM,CDIJ2_,CQIJ,CVTOT2,.TRUE.,IRDMAA,IRDMAX, DISPL, QVEC_CART, .TRUE.)
+      CALL SETDIJ_(WDES,GRIDC,GRIDUS,C_TO_US,LATT_CUR,P,T_INFO,INFO%LOVERL, &
+      LMDIM,CDIJ3_,CQIJ,CVTOT2,.TRUE.,IRDMAA,IRDMAX, DISPL, QVEC_CART, .FALSE.)
+      CDIJ2_=CDIJ2_+(0._q,1._q)*CDIJ3_
+
+      CDIJ3_=0
+      CRHODE_=CRHODE
+      RHOLM_=RHOLM
+      CALL SET_DD_PAW(WDES, P , T_INFO, INFO%LOVERL, &
+      WDES%NCDIJ, LMDIM, CDIJ3_(1,1,1,1), RHOLM_ , CRHODE_(1,1,1,1), &
+      E1,  LMETA=.FALSE., LASPH=INFO%LASPH, LCOREL= .FALSE.  )
+
+      SUM1 = SUM(ABS(CDIJ2_)**2)
+      SUM2 = SUM(ABS(CDIJ3_)**2)
+      CALLMPI( M_sum_d(WDES%COMM,SUM1,1))
+      CALLMPI( M_sum_d(WDES%COMM,SUM2,1))
+      SUM1=SQRT(SUM1)
+      SUM2=SQRT(SUM2)
+
+     SV1=0
+     CVTOT1=0
+     CDIJ1=0
+     DO I = 1,SIZE(STEP)
+          CHTOT_=CHTOT+CHTOT1*(STEP_LENGTH*STEP(I)) ! \tilde n + \hat n
+          CHTOT1_=CHTOT1_GGAcorr*(STEP_LENGTH*STEP(I))
+          ! \tilde v_eff
+          SV2=0
+          CVTOT2=0
+          CALL POTLOK(GRID,GRIDC,GRID_SOFT,WDES%COMM_INTER, WDES, &
+          INFO,P,T_INFO,E1,LATT_CUR, &
+          CHTOT_,CSTRF,CVTOT2,DENCOR,SV2, SOFT_TO_C,XCSIF,CHTOT1_,QVEC_CART)
+          
+          CDIJ2=0
+          ! \hat D_ij
+          ! Although CHTOT1 is decomposed into real part and image part,
+          ! only v^1_xc in LDA is real, while the contribution from Hartree and GGA
+          ! will make v^1_eff complex.
+          ! Real( v_eff*exp^(i q.(r-R)) )
+          CALL SETDIJ_(WDES,GRIDC,GRIDUS,C_TO_US,LATT_CUR,P,T_INFO,INFO%LOVERL, &
+          LMDIM,CDIJ2,CQIJ,CVTOT2,.TRUE.,IRDMAA,IRDMAX, DISPL, QVEC_CART, .TRUE.)
+          ! ! ! Image( v_eff*exp^(i q.(r-R)) )
+          CALL SETDIJ_(WDES,GRIDC,GRIDUS,C_TO_US,LATT_CUR,P,T_INFO,INFO%LOVERL, &
+          LMDIM,CDIJ3,CQIJ,CVTOT2,.TRUE.,IRDMAA,IRDMAX, DISPL, QVEC_CART, .FALSE.)
+          CDIJ2=CDIJ2+(0._q,1._q)*CDIJ3
+          IF (I==1) THEN 
+            SUM3 = SUM(ABS(CDIJ2-CDIJ2_)**2)
+            CALLMPI( M_sum_d(WDES%COMM,SUM3,1))
+            SUM3=SQRT(SUM3)
+            ! \tilde D Trial step
+            CDIJ3=0
+            CRHODE_=CRHODE+CRHODE1*(STEP_LENGTH*STEP(I))
+            RHOLM_=RHOLM+RHOLM1*(STEP_LENGTH*STEP(I))
+            CALL SET_DD_PAW(WDES, P , T_INFO, INFO%LOVERL, &
+            WDES%NCDIJ, LMDIM, CDIJ3(1,1,1,1), RHOLM_ , CRHODE_(1,1,1,1), &
+            E1,  LMETA=.FALSE., LASPH=INFO%LASPH, LCOREL= .FALSE.  )
+
+            SUM4 = SUM(ABS(CDIJ3-CDIJ3_)**2)
+            CALLMPI( M_sum_d(WDES%COMM,SUM4,1))
+            SUM4=SQRT(SUM4)
+            SCAL = MIN(MAX((SUM3/SUM1),1E-12_q)/MAX((SUM4/SUM2),1E-12_q),1._q)
+            ! WRITE(*,*)SUM1,SUM2,SUM3,SUM4,SCAL
+         ENDIF
+          ! \tilde D Trial step
+          CDIJ3=0
+          CRHODE_=CRHODE+CRHODE1*(SCAL*STEP_LENGTH*STEP(I))
+          RHOLM_=RHOLM+RHOLM1*(SCAL*STEP_LENGTH*STEP(I))
+          CALL SET_DD_PAW(WDES, P , T_INFO, INFO%LOVERL, &
+          WDES%NCDIJ, LMDIM, CDIJ3(1,1,1,1), RHOLM_ , CRHODE_(1,1,1,1), &
+          E1,  LMETA=.FALSE., LASPH=INFO%LASPH, LCOREL= .FALSE.  )
+          !------------------------------------------------------------------
+          CDIJ2=CDIJ2-CDIJ2_
+          CDIJ3=(CDIJ3-CDIJ3_)/SCAL
+          WEIGHT=WARRAY(I)/STEP_LENGTH
+          DO ISP=1,WDES%NCDIJ
+               CALL RL_ADD(SV1(1,ISP),1.0_q,     SV2(1,ISP),WEIGHT,     SV1(1,ISP)   ,GRID)
+               CALL RL_ADD(CVTOT1(1,ISP),1.0_q,  CVTOT2(1,ISP),WEIGHT,  CVTOT1(1,ISP)   ,GRIDC)
+          ENDDO
+          CDIJ1=CDIJ1+(CDIJ2+CDIJ3)*WEIGHT
+     ENDDO
+     !------------------------------------------------------------------
+     ! \hat D_ij
+     ! Although CHTOT1 is decomposed into real part and image part,
+     ! only v^1_xc in LDA is real, while the contribution from Hartree and GGA
+     ! will make v^1_eff complex.
+     ! Real( v_eff*exp^(i q.(r-R)) )
+     ! CALL SETDIJ_(WDES,GRIDC,GRIDUS,C_TO_US,LATT_CUR,P,T_INFO,INFO%LOVERL, &
+     ! LMDIM,CDIJ2,CQIJ,CVTOT1,.TRUE.,IRDMAA,IRDMAX, DISPL, QVEC_CART, .TRUE.)
+     ! ! ! Image( v_eff*exp^(i q.(r-R)) )
+     ! CALL SETDIJ_(WDES,GRIDC,GRIDUS,C_TO_US,LATT_CUR,P,T_INFO,INFO%LOVERL, &
+     ! LMDIM,CDIJ3,CQIJ,CVTOT1,.TRUE.,IRDMAA,IRDMAX, DISPL, QVEC_CART, .FALSE.)
+     ! CDIJ1=CDIJ1+CDIJ2+(0._q,1._q)*CDIJ3
+
+     ! CVTOT2=0 ! compensate for diagonal terms.
+     ! CALL SETDIJ_(WDES,GRIDC,GRIDUS,C_TO_US,LATT_CUR,P,T_INFO,INFO%LOVERL, &
+     ! LMDIM,CDIJ2,CQIJ,CVTOT2,.TRUE.,IRDMAA,IRDMAX, DISPL, QVEC_CART, .TRUE.)
+     ! ! ! Image( v_eff*exp^(i q.(r-R)) )
+     ! CALL SETDIJ_(WDES,GRIDC,GRIDUS,C_TO_US,LATT_CUR,P,T_INFO,INFO%LOVERL, &
+     ! LMDIM,CDIJ3,CQIJ,CVTOT2,.TRUE.,IRDMAA,IRDMAX, DISPL, QVEC_CART, .FALSE.)
+     ! CDIJ1=CDIJ1-CDIJ2-(0._q,1._q)*CDIJ3
+END SUBROUTINE EMLR_POT_DER4X
+function truncate_sig_fig(x, n)
+      use prec
+   implicit none
+   REAL(q), intent(in) :: x
+   integer, intent(in) :: n
+   REAL(q) :: factor,truncate_sig_fig
+   
+   factor = 10._q ** (n - aint(log10(abs(x)+1E-3_q) + 1))
+   truncate_sig_fig = aint(x * factor) / factor
+end function truncate_sig_fig
diff -urN file_ini/force.F file_modify/force.F
--- file_ini/force.F	2024-07-13 10:37:12.000000000 +0800
+++ file_modify/force.F	2024-07-13 10:37:23.000000000 +0800
@@ -1125,6 +1125,7 @@
 ! solvation__
     USE solvation
 ! solvation__
+    USE aedens
     IMPLICIT NONE
 !=======================================================================
 !  structures
diff -urN file_ini/linear_response.F file_modify/linear_response.F
--- file_ini/linear_response.F	2024-07-13 10:37:12.000000000 +0800
+++ file_modify/linear_response.F	2024-07-13 10:37:23.000000000 +0800
@@ -1,2292 +1,2320 @@
-#include "symbol.inc"
-
-MODULE mlr_main
-  USE prec
-  USE vaspxml
-  USE lr_helper
-  IMPLICIT NONE
-
-  REAL(q),ALLOCATABLE,PRIVATE :: POSION_LAST(:,:)
-  REAL(q),ALLOCATABLE,PRIVATE :: BORN_CHARGES_SAVE(:,:,:)
-  REAL(q),ALLOCATABLE,PRIVATE :: DIPOLE_TIME(:,:)
-CONTAINS
-
-!*********************************************************************
-!
-! calculate second derivatives using linear response theory
-!
-! implemented by gK
-! the main scheduler is based on the finite difference kernel of 
-! Orest Dubay (at least the skeleton is essentially identical)
-! it steps through all ions (at least those that are allowed to move)
-! and calls the main linear response kerner to calculate the
-! linear response of the wavefunction and the second derivatives
-! with respect to the ionic positions
-!
-!*********************************************************************
-
-  SUBROUTINE LR_SKELETON( &
-          KINEDEN,HAMILTONIAN,P,WDES,NONLR_S,NONL_S,W,LATT_CUR,LATT_INI, &
-          T_INFO,DYN,INFO,IO,MIX,KPOINTS,SYMM,GRID,GRID_SOFT, &
-          GRIDC,GRIDB,GRIDUS,C_TO_US,B_TO_C,SOFT_TO_C,E, &
-          CHTOT,CHTOTL,DENCOR,CVTOT,CSTRF, &
-          CDIJ,CQIJ,CRHODE,N_MIX_PAW,RHOLM,RHOLM_LAST, &
-          CHDEN,SV,DOS,DOSI,CHAM, &
-          IBRION,LMDIM,IRDMAX,NEDOS, &
-          TOTENIN,EFERMI,FORCE,LFAST)
-
-    USE ini
-    USE base
-    USE lattice
-    USE finite_differences
-    USE charge
-    USE pseudo
-    USE lattice
-    
-    USE nonl_high
-    USE msymmetry
-    USE mpimy
-    USE mgrid
-    USE mkpoints
-    USE constant
-    USE poscar
-    USE wave
-    USE pot
-    USE subrot
-    USE pawm
-    USE rmm_diis
-    USE choleski
-    USE david
-    USE wave_high
-    USE mlrf_main
-    USE lri_main
-    USE subrot_cluster
-    USE kpoints_change
-    USE full_kpoints
-    USE hamil_high
-    USE pead
-    USE fock
-    USE morbitalmag
-    USE meta
-    USE wannier_interpolation
-    USE crpa, ONLY : LCRPAPLOT
-    USE rpa_force, ONLY : STORE_RPA_SECOND_DERIV
-! solvation__
-    USE solvation
-! solvation__
-#ifdef PROFILING
-    USE profiling
-#endif
-    IMPLICIT NONE
-!=======================================================================
-!  structures
-!=======================================================================
-    TYPE (tau_handle)  KINEDEN
-    TYPE (ham_handle)  HAMILTONIAN
-    TYPE (type_info)   T_INFO
-    TYPE (potcar)      P(T_INFO%NTYP)
-    TYPE (wavedes)     WDES
-    TYPE (nonlr_struct) NONLR_S
-    TYPE (nonl_struct) NONL_S
-    TYPE (wavespin)    W          ! wavefunction
-    TYPE (latt)        LATT_CUR
-    TYPE (dynamics)    DYN
-    TYPE (info_struct) INFO
-    TYPE (in_struct)   IO
-    TYPE (mixing)      MIX
-    TYPE (kpoints_struct) KPOINTS
-    TYPE (symmetry)    SYMM
-    TYPE (grid_3d)     GRID       ! grid for wavefunctions
-    TYPE (grid_3d)     GRID_SOFT  ! grid for soft chargedensity
-    TYPE (grid_3d)     GRIDC      ! grid for potentials/charge
-    TYPE (grid_3d)     GRIDUS     ! temporary grid in us.F
-    TYPE (grid_3d)     GRIDB      ! Broyden grid
-    TYPE (transit)     B_TO_C     ! index table between GRIDB and GRIDC
-    TYPE (transit)     C_TO_US    ! index table between GRIDC and GRIDUS
-    TYPE (transit)     SOFT_TO_C  ! index table between GRID_SOFT and GRIDC
-    TYPE (energy)      E
-    TYPE (latt)        LATT_INI
-
-    INTEGER IBRION
-    INTEGER LMDIM,IRDMAX,IRDMAA,NEDOS
-    REAL(q) TOTENIN,EFERMI
-
-    COMPLEX(q)  CHTOT(GRIDC%MPLWV,WDES%NCDIJ) ! charge-density in real / reciprocal space
-    COMPLEX(q)  CHTOTL(GRIDC%MPLWV,WDES%NCDIJ)! old charge-density
-    RGRID       DENCOR(GRIDC%RL%NP)           ! partial core
-    COMPLEX(q)  CVTOT(GRIDC%MPLWV,WDES%NCDIJ) ! local potential
-    COMPLEX(q)  CSTRF(GRIDC%MPLWV,T_INFO%NTYP)
-
-!  augmentation related quantities
-    OVERLAP  CDIJ(LMDIM,LMDIM,WDES%NIONS,WDES%NCDIJ), &
-             CQIJ(LMDIM,LMDIM,WDES%NIONS,WDES%NCDIJ), &
-             CRHODE(LMDIM,LMDIM,WDES%NIONS,WDES%NCDIJ)
-!  paw sphere charge density
-    INTEGER N_MIX_PAW
-    REAL(q)  RHOLM(N_MIX_PAW,WDES%NCDIJ),RHOLM_LAST(N_MIX_PAW,WDES%NCDIJ)
-!  charge-density and potential on soft grid
-    COMPLEX(q)  CHDEN(GRID_SOFT%MPLWV,WDES%NCDIJ)
-    RGRID       SV(DIMREAL(GRID%MPLWV),WDES%NCDIJ)
-!  density of states
-    REAL(q)    DOS(NEDOS,WDES%ISPIN),DOSI(NEDOS,WDES%ISPIN)
-!  Hamiltonian
-    GDEF       CHAM(WDES%NB_TOT,WDES%NB_TOT,WDES%NKPTS,WDES%ISPIN)
-    REAL(q)   XCSIF(3,3)
-    REAL(q) :: FORCE(3,T_INFO%NIONS)   ! forces in cartesian coordinates
-    LOGICAL, OPTIONAL :: LFAST
-
-! local variables related to finite difference code
-
-    TYPE (eigenf_cluster_pointer),POINTER :: DEG_CLUSTER(:,:)
-    INTEGER :: NIONS
-    INTEGER :: IU6                ! OUTCAR file
-    INTEGER :: IU6K               ! OUTCAR k-points
-    INTEGER :: IU0                ! stdout
-
-    TYPE (type_info)   T_INFO_0
-    INTEGER :: IUDYNMAT           ! DYNMAT file
-    REAL(q) :: X
-    REAL(q),ALLOCATABLE      :: INITIAL_FORCE(:,:)
-    REAL(q),ALLOCATABLE      :: DISPL_FORCES(:,:,:)
-    REAL(q),ALLOCATABLE      :: INT_STRAIN(:,:,:), PIEZO(:,:,:)
-    REAL(q),ALLOCATABLE      :: BORN_CHARGES(:,:,:), BORN_CHARGES2(:,:,:)
-    REAL(q),ALLOCATABLE      :: SECOND_DERIV(:,:)
-    INTEGER                  :: DOF
-    INTEGER                  :: PROCESSED_DISPL
-    INTEGER                  :: I,J,K,M,N, IDIR, IDISPL_ON_ION
-    REAL(q),ALLOCATABLE      :: WORK(:,:)
-    REAL(q),ALLOCATABLE      :: EIGENVECTORS(:,:)
-    REAL(q),ALLOCATABLE      :: EIGENVALUES(:)
-    INTEGER                  :: IERROR
-    REAL(q) :: EPSILON(3,3),  ELASTIC(3,3,3,3),  ELASTICP(6,3,3)
-! variables for the reevaluation of energy
-    REAL(q) DESUM, RMS       ! change
-    REAL(q) TOTEN, TOTEN_    ! energy
-    REAL(q) EDIFF            ! break condition
-    INTEGER ICOUEV
-    INTEGER NSIM
-! linear response using symmetry
-    INTEGER                  :: NKORIG
-    REAL(q),ALLOCATABLE      :: D(:,:,:)
-    INTEGER,ALLOCATABLE      :: ND(:), IDIRD(:,:)
-    REAL(q)                  :: WORKD(3,3,T_INFO%NIONS)
-    INTEGER                  :: IWORK(T_INFO%NIONS)
-    CHARACTER(3)             :: IDIR_TEXT(3)=(/"x","y","z"/)
-    LOGICAL                  :: LDO(T_INFO%NIONS)
-    REAL(q)                  :: WDMAT(3,T_INFO%NIONS,3,T_INFO%NIONS),DMAT(3,3,T_INFO%NIONS,T_INFO%NIONS)
-    REAL(q)                  :: ST(3,3,3,T_INFO%NIONS), AST(3,3,3,T_INFO%NIONS)
-    REAL(q)                  :: FACT, TMP(3,3)
-! variables to store G [H,r] phi
-    COMPLEX(qs), ALLOCATABLE :: RPHI(:,:,:,:,:)
-    GDEFS, ALLOCATABLE ::  RPHI_CPROJ(:,:,:,:,:)
-    TYPE (skpoints_trans)   :: KPOINTS_TRANS
-
-! symmetry related quantities (common block)
-    INTEGER  ISYMOP,NROT,IGRPOP,NROTK,INVMAP,NPCELL
-    REAL(q)  GTRANS,AP
-    COMMON /SYMM/   ISYMOP(3,3,48),NROT,IGRPOP(3,3,48),NROTK, &
-         GTRANS(3,48),INVMAP(48),AP(3,3),NPCELL
-
-    ! NULLIFY to make sure a later "IF(ASSOCIATED())" works correctly.
-    NULLIFY(KPOINTS_TRANS%CPHASE)
-
-#if defined(VASP2WANNIER90) && ! defined(gammareal)
-    IF (LWANNIERINTERPOL.OR.LCRPAPLOT) THEN
-       CALL WANNIER_INTERPOLATE(HAMILTONIAN,KPOINTS,GRID,LATT_CUR,LATT_INI,&
-            T_INFO,NONLR_S,NONL_S,W,LMDIM,P,SV,CQIJ,CDIJ,SYMM,INFO,IO)
-       ! at this point the wave functions are messed up, so let's call it a day ...
-#ifdef PROFILING
-       ! started in INIT_PROFILING
-       PROFILING_STOP('total_time')
-       IF (IO%IU0>=0) THEN
-          CALL PRINT_FULL_PROFILE(IO%IU6,PFLAT=.FALSE.)
-       ENDIF
-#endif
-       CALL DUMP_ALLOCATE(IO%IU6)
-       CALL DUMP_FINAL_TIMING(IO%IU6)
-       CALL STOP_XML
-       CALLMPI_C(M_exit())
-    ENDIF
-#endif
-
-    IF (KINTER<0) THEN
-       IF (LHFCALC) THEN
-          CALL INTERPOLATE_BAND_STR(HAMILTONIAN, KPOINTS, GRID, LATT_CUR, LATT_INI, & 
-            T_INFO, NONLR_S, NONL_S, W, NEDOS, DOS, DOSI, INFO%NELECT, INFO%NUP_DOWN,  &
-            LMDIM, P, SV, CQIJ, CDIJ, SYMM, IO%IU0, IO%IU6)
-       ELSE
-          CALL INTERPOLATE_BANDSTR_GRDSHFT(HAMILTONIAN, E, KPOINTS, GRID, LATT_CUR, LATT_INI, & 
-            T_INFO, NONLR_S, NONL_S, W, NEDOS, &
-            LMDIM, P, SV, CQIJ, CDIJ, SYMM, INFO, IO, GRIDC, GRIDUS, C_TO_US, IRDMAX)
-       ENDIF
-       RETURN
-    ENDIF
-
-    IF (LHFCALC .AND. AEXX/=0 ) THEN
-       CALL VTUTOR('E','LHFLINEARRESPONSE',0.0_q,1,0,1,(0.0_q,0.0_q),1,.TRUE.,1, &
-            IO%IU6,3)
-       CALL VTUTOR('S','LHFLINEARRESPONSE',0.0_q,1,0,1,(0.0_q,0.0_q),1,.TRUE.,1, &
-            IO%IU0,3)
-    ENDIF
-
-    IF (LDO_METAGGA()) THEN
-       CALL VTUTOR('E','METAGGARESPONSE',0.0_q,1,0,1,(0.0_q,0.0_q),1,.TRUE.,1, &
-            IO%IU6,3)
-       CALL VTUTOR('S','METAGGARESPONSE',0.0_q,1,0,1,(0.0_q,0.0_q),1,.TRUE.,1, &
-            IO%IU0,3)
-    ENDIF
-
-    IF (INFO%LREAL) THEN
-       CALL VTUTOR('W','LINEARRESPONSE LREAL',0.0_q,1,0,1,(0.0_q,0.0_q),1,.TRUE.,1, &
-            IO%IU6,3)
-       CALL VTUTOR('W','LINEARRESPONSE LREAL',0.0_q,1,0,1,(0.0_q,0.0_q),1,.TRUE.,1, &
-            IO%IU0,3)
-    ENDIF
-
-    NIONS = T_INFO%NIONS
-    IU6   = IO%IU6
-    IU0   = IO%IU0
-
-    IF (IO%NWRITE>=3) THEN
-       IU6K  = IO%IU6
-    ELSE
-       IU6K  = -1
-    ENDIF
-
-    IF (IBRION>0) THEN
-       IF (IBRION==8) THEN
-          ALLOCATE(D(3,3,T_INFO%NIONS), ND(T_INFO%NIONS),IDIRD(3,T_INFO%NIONS))
-
-          CALL FREDOM(SYMM%ROTMAP,ISYMOP,INVMAP,NROTK,NPCELL,D,ND,1,T_INFO%NTYP,T_INFO%NIONS, &
-             T_INFO%NITYP,WORKD,IWORK, & 
-             LATT_CUR%A(1,1),LATT_CUR%A(1,2),LATT_CUR%A(1,3), &
-             LATT_CUR%B(1,1),LATT_CUR%B(1,2),LATT_CUR%B(1,3),IDIRD,.FALSE.)
-          DOF=SUM(ND)
-
-          IF (IU6>=0) THEN
-             WRITE(IU6,*)
-             WRITE(IU6,'(A,I5,A)') ' Found ',DOF,' degrees of freedom:'
-             WRITE(IU6,*)' ----------------------------------------------'
-             WRITE(IU6,*)
-             DO J=1,NIONS
-                IF (ND(J).GT.0) THEN
-                   WRITE(IU6,'(A,I5,A,3A2)') '     directions for atom ',J,':  ',IDIR_TEXT(IDIRD(ND(J),J))
-                ENDIF
-             ENDDO
-          ENDIF
-       ELSE IF (IBRION==7) THEN
-          CALL COUNT_DOF(NIONS, T_INFO%LSFOR, T_INFO%LSDYN, DOF)
-       ELSE
-          DOF=0
-       ENDIF
-    ELSE
-       DOF=0
-    ENDIF
-
-    T_INFO_0=T_INFO
-    NULLIFY(T_INFO_0%POSION)
-    ALLOCATE(T_INFO_0%POSION(3,NIONS))
-    ALLOCATE(INITIAL_FORCE(3,NIONS))
-    ALLOCATE(DISPL_FORCES(DOF,3,NIONS),BORN_CHARGES(3,3,NIONS),BORN_CHARGES2(3,3,NIONS), & 
-      PIEZO(3,3,3),INT_STRAIN(DOF,3,3))
-
-    DISPL_FORCES=0
-    BORN_CHARGES=0 ; BORN_CHARGES2=0
-    PIEZO=0
-    INT_STRAIN=0
-
-    T_INFO_0%POSION             = T_INFO%POSION
-    INITIAL_FORCE               = FORCE
-    NKORIG                      = WDES%NKPTS
-!=======================================================================
-! reset the potential and recalculate the ground state wavefunctions
-! with very high precision for this setup
-!=======================================================================
-    IF (IU0>=0) THEN
-       WRITE (IU0,*) 'Linear response reoptimize wavefunctions to high precision'
-       WRITE ( 17,*) 'Linear response reoptimize wavefunctions'
-    ENDIF
-
-    IF (IU6>=0) THEN
-       WRITE (IU6,*) 'Linear response reoptimize wavefunctions'
-    ENDIF
-
-    IF (INFO%LREAL) THEN
-       CALL RSPHER(GRID,NONLR_S,LATT_CUR)
-    ENDIF
-
-    CALL POTLOK(GRID,GRIDC,GRID_SOFT, WDES%COMM_INTER, WDES,  &
-         INFO,P,T_INFO,E,LATT_CUR, &
-         CHTOT,CSTRF,CVTOT,DENCOR,SV, SOFT_TO_C,XCSIF)
-
-!   CALL VECTORPOT(GRID, GRIDC, GRID_SOFT, SOFT_TO_C,  WDES%COMM_INTER, & 
-!        LATT_CUR, T_INFO%POSION, HAMILTONIAN%AVEC, HAMILTONIAN%AVTOT)
-                  
-    CALL SETDIJ(WDES,GRIDC,GRIDUS,C_TO_US,LATT_CUR,P,T_INFO,INFO%LOVERL, &
-         LMDIM,CDIJ,CQIJ,CVTOT,IRDMAA,IRDMAX)
-
-    CALL SETDIJ_AVEC(WDES,GRIDC,GRIDUS,C_TO_US,LATT_CUR,P,T_INFO,INFO%LOVERL, &
-         LMDIM,CDIJ,HAMILTONIAN%AVTOT, NONLR_S, NONL_S, IRDMAX)
-    
-    CALL SET_DD_MAGATOM(WDES, T_INFO, P, LMDIM, CDIJ) 
-    CALL SET_DD_PAW(WDES, P , T_INFO, INFO%LOVERL, &
-         WDES%NCDIJ, LMDIM, CDIJ(1,1,1,1),  RHOLM, CRHODE(1,1,1,1), &
-         E,  LMETA=.FALSE., LASPH=INFO%LASPH, LCOREL= .FALSE.  )
-    !
-    ! only if the tolerance is very tight for the occupied states
-    ! it is possible to attain a tight tolerance for the perturbed states
-    ! with the present DIIS algorithm
-
-    EDIFF = 1E-10
-    NSIM=WDES%NSIM*2
-#ifdef MPI
-    NSIM=((WDES%NSIM*2+WDES%COMM_INTER%NCPU-1)/WDES%COMM_INTER%NCPU)*WDES%COMM_INTER%NCPU
-#endif
-
-    X=INFO%EBREAK
-
-    ! for some non obvious reasons 
-    IF (.NOT. LMAGBLOCH) THEN 
-       INFO%EBREAK=0.25*EDIFF
-    ELSE
-       IF (IU0>=0) WRITE(IU0,*) 'WARNING: EBREAK remains at default, EDDAV has a problem for too tight convergence criteria'
-       INFO%EBREAK=EDIFF
-    ENDIF
-
-    TOTEN=TOTENIN
-    DO I=1,3
-       CALL EDDAV(HAMILTONIAN,P, GRID,INFO,LATT_CUR,NONLR_S,NONL_S,W,WDES, NSIM, &
-            LMDIM,CDIJ,CQIJ, RMS,DESUM,ICOUEV, SV, E%EXHF, IO%IU6,IO%IU0, .FALSE., .TRUE., .FALSE.)
-
-       E%EBANDSTR=BANDSTRUCTURE_ENERGY(WDES, W)
-       TOTEN_=E%EBANDSTR+E%DENC+E%XCENC+E%TEWEN+E%PSCENC+E%EENTROPY+E%PAWPS+E%PAWAE+INFO%EALLAT+E%EXHF+Ediel_sol
-
-       IF (IO%IU0>=0) THEN
-          WRITE(IO%IU0,1000) I, TOTEN_, TOTEN_-TOTEN, DESUM, ICOUEV, RMS
-          WRITE(17,1000)     I, TOTEN_, TOTEN_-TOTEN, DESUM, ICOUEV, RMS
-       ENDIF
-1000   FORMAT('DAV: ',I3,'   ',E20.12,'   ',E12.5,'   ',E12.5,I6,'  ',E10.3)
-       IF(ABS(DESUM)<EDIFF.AND.ABS(TOTEN_-TOTEN)<EDIFF) EXIT
-
-       TOTEN=TOTEN_
-    ENDDO
-    CALL KPAR_SYNC_ALL(WDES,W)
-
-    INFO%EBREAK=X    ! restore the break condition
-
-    IF (IO%IU0>=0 .AND. IO%LOPEN) CALL WFORCE(17)
-
-!=======================================================================
-! determine G [H, r] |phi> = d/ dk | phi(k)>
-!=======================================================================
-    NULLIFY(DEG_CLUSTER)
-    CALL FIND_DEG_CLUSTERS(WDES, W, DEG_CLUSTER)
-
-    IF (LEPSILON .OR. KINTER/=0 .OR. LMAGBLOCH ) THEN
-
-    CALL SET_NABIJ_AUG(P,T_INFO%NTYP)
-    ALLOCATE(RPHI(WDES%NRPLWV,WDES%NBANDS,WDES%NKPTS,WDES%ISPIN,3), &
-             RPHI_CPROJ(WDES%NPROD,WDES%NBANDS,WDES%NKPTS,WDES%ISPIN,3))
-
-    IF (LUSEPEAD()) THEN
-       IF (LMAGBLOCH) THEN
-          LPEAD_RETURN_Q_CPROJ=.FALSE.
-       ENDIF
-       RPHI=0
-       RPHI_CPROJ=0
-       CALL PEAD_DPSI_DK_ALL(W,KPOINTS,P,CQIJ,LATT_CUR,T_INFO,RPHI,RPHI_CPROJ)
-       LPEAD_RETURN_Q_CPROJ=.TRUE.
-    ELSE 
-       RPHI=0
-       RPHI_CPROJ=0
-
-       DO IDIR=1,3
-          IF (IU0>=0) THEN
-             WRITE (IU0,*)'Linear response G [H, r] |phi>, progress :'
-             WRITE (IU0,'(A,I3)') &
-                  '  Direction: ',IDIR
-             WRITE (17,*)'Linear response G [H, r] |phi>, progress :'
-             WRITE (17,'(A,I3)') &
-                  '  Direction: ',IDIR
-          END IF
-
-          IF (IU6>=0) THEN
-             WRITE (IU6,*)'Linear response G [H, r] |phi>, progress :'
-             WRITE (IU6,'(A,I3)') &
-                  '  Direction: ',IDIR
-          ENDIF
-
-          CALL LRF_RPHI( &
-             P,WDES,NONLR_S,NONL_S,W,LATT_CUR, &
-             T_INFO,INFO,IO,GRID,GRIDC,GRIDUS,C_TO_US,IRDMAX, &
-             CDIJ,CQIJ,SV,LMDIM,DEG_CLUSTER, IDIR, RPHI(:,:,:,:,IDIR), RPHI_CPROJ(:,:,:,:,IDIR), & 
-             .TRUE.) !KINTER==0)
-
-          IF (IO%LOPEN) CALL WFORCE(IO%IU6)
-       ENDDO
-    ENDIF
-
-    IF (KINTER>0) THEN
-!       CALL INTERPOLATE_BAND_STR(HAMILTONIAN, KPOINTS, GRID, LATT_CUR, LATT_INI, & 
-!            T_INFO, NONLR_S, NONL_S, W, NEDOS, DOS, DOSI, INFO%NELECT, INFO%NUP_DOWN, &
-!            LMDIM, P, SV, CQIJ, CDIJ, SYMM, IO%IU0, IO%IU6, RPHI)
-       CALL INTERPOLATE_BANDSTR_GRDSHFT( HAMILTONIAN, E, KPOINTS, GRID, LATT_CUR, LATT_INI, & 
-            T_INFO, NONLR_S, NONL_S, W, NEDOS, &
-            LMDIM, P, SV, CQIJ, CDIJ, SYMM, INFO, IO, GRIDC, GRIDUS, C_TO_US, IRDMAX, RPHI)
-
-       ! well this deallocates most of the quantities we have used, but not all
-       DEALLOCATE(RPHI, RPHI_CPROJ)
-       RETURN
-    ENDIF
-
-    IF (LMAGBLOCH) THEN
-
-       CALL BLOCH_CURRENT( W, GRID_SOFT, GRIDC, GRIDUS, C_TO_US, SOFT_TO_C, P, LATT_CUR, & 
-          HAMILTONIAN%AVEC, HAMILTONIAN%AVTOT, CHTOT, NONLR_S, NONL_S, & 
-          RPHI, RPHI_CPROJ, CDIJ, CQIJ, SV, EFERMI, &
-          T_INFO, LMDIM, CRHODE, IRDMAX, IO%IU6, IO%IU0)
-
-       ! well this deallocates most of the quantities we have used, but not all
-       DEALLOCATE(RPHI, RPHI_CPROJ)
-       RETURN
-    ENDIF
-!=======================================================================
-! response to external excluding local field effects
-! i.e. in the independent particle approximation
-!=======================================================================
-    IF (.NOT. PRESENT (LFAST)) THEN
-    DO IDIR=1,3
-
-       IF (IU0>=0) THEN
-          WRITE (IU0,*)'Linear response to external field (no local field effect), progress :'
-          WRITE (IU0,'(A,I3)') &
-               '  Direction: ',IDIR
-          WRITE (17,*)'Linear response to external field (no local field effect), progress :'
-          WRITE (17,'(A,I3)') &
-               '  Direction: ',IDIR
-       END IF
-     
-       IF (IU6>=0) THEN
-          WRITE (IU6,*)'Linear response to external field (no local field effect), progress :'
-          WRITE (IU6,'(A,I3)') &
-               '  Direction: ',IDIR
-       ENDIF
-
-       IF (SYMM%ISYM>0) THEN
-          DYN%VEL=0
-          DYN%VEL(IDIR,:)=1.0
-          CALL KARDIR(T_INFO%NIONS,DYN%VEL,LATT_CUR%B)
-          CALL INISYM(LATT_CUR%A,T_INFO%POSION,DYN%VEL,T_INFO%LSFOR, &
-               T_INFO%LSDYN,T_INFO%NTYP,T_INFO%NITYP,T_INFO%NIONS, &
-               SYMM%PTRANS,SYMM%NROT,SYMM%NPTRANS,SYMM%ROTMAP,SYMM%TAU,SYMM%TAUROT,SYMM%WRKROT, &
-               SYMM%INDROT,T_INFO%ATOMOM,WDES%SAXIS,SYMM%MAGROT,WDES%NCDIJ,IO%IU6)
-       ENDIF
-
-       CALL LRF_MAIN( &
-          KINEDEN,HAMILTONIAN,P,WDES,NONLR_S,NONL_S,W,RPHI,RPHI_CPROJ, &
-          LATT_CUR, &
-          T_INFO,DYN,INFO,IO,MIX,KPOINTS,SYMM,GRID,GRID_SOFT, &
-          GRIDC,GRIDB,GRIDUS,C_TO_US,B_TO_C,SOFT_TO_C,E, &
-          CHTOT,CHTOTL,DENCOR,CVTOT,CSTRF, &
-          CDIJ,CQIJ,CRHODE,N_MIX_PAW,RHOLM,RHOLM_LAST, &
-          CHDEN,SV,DOS,DOSI, &
-          LMDIM,IRDMAX,NEDOS, &
-          TOTEN,EFERMI, DEG_CLUSTER, KPOINTS_TRANS, EPSILON(IDIR,:), BORN_CHARGES(IDIR,:,:), PIEZO(IDIR,:,:),  & 
-          IDIR, .FALSE.)
-
-          IF (IO%LOPEN) CALL WFORCE(IO%IU6)
-    ENDDO
-    ! reinitialise symmetry
-    IF (SYMM%ISYM>0) THEN
-       DYN%VEL=0
-       CALL INISYM(LATT_CUR%A,T_INFO%POSION,DYN%VEL,T_INFO%LSFOR, &
-            T_INFO%LSDYN,T_INFO%NTYP,T_INFO%NITYP,T_INFO%NIONS, &
-            SYMM%PTRANS,SYMM%NROT,SYMM%NPTRANS,SYMM%ROTMAP,SYMM%TAU,SYMM%TAUROT,SYMM%WRKROT, &
-            SYMM%INDROT,T_INFO%ATOMOM,WDES%SAXIS,SYMM%MAGROT,WDES%NCDIJ,IO%IU6)
-    ENDIF
-
-    IF (SYMM%ISYM>0) CALL TSYM(EPSILON,ISYMOP,NROTK,LATT_CUR%A)
-    IF (IO%IU6>=0) THEN
-       WRITE(IO%IU6,1110) '(INDEPENDENT PARTICLE, excluding Hartree and local field effects)',EPSILON
-       WRITE(IO%IU6,130)
-       CALL XML_TENSOR("epsilon_rpa",EPSILON)
-    ENDIF
-    ENDIF
-!=======================================================================
-! response to external field including local field effects
-! if do_kpoints_chage is not set the k-point set remains unchanged
-! and symmetrization of the final tensor is performed
-! results are not exact but errors are sometimes small (not recommended)
-!=======================================================================
-#define do_kpoints_change
-#ifndef do_kpoints_change
-    DO IDIR=1,3
-
-       IF (IU0>=0) THEN
-          WRITE (IU0,*)'Linear response to external field, progress :'
-          WRITE (IU0,'(A,I3)') &
-               '  Direction: ',IDIR
-          WRITE (17,*)'Linear response to external field, progress :'
-          WRITE (17,'(A,I3)') &
-               '  Direction: ',IDIR
-       END IF
-     
-       IF (IU6>=0) THEN
-          WRITE (IU6,*)'Linear response to external field, progress :'
-          WRITE (IU6,'(A,I3)') &
-               '  Direction: ',IDIR
-       ENDIF
-
-       IF (SYMM%ISYM>0) THEN
-          DYN%VEL=0
-          DYN%VEL(IDIR,:)=1.0
-          CALL KARDIR(T_INFO%NIONS,DYN%VEL,LATT_CUR%B)
-          CALL INISYM(LATT_CUR%A,T_INFO%POSION,DYN%VEL,T_INFO%LSFOR, &
-               T_INFO%LSDYN,T_INFO%NTYP,T_INFO%NITYP,T_INFO%NIONS, &
-               SYMM%PTRANS,SYMM%NROT,SYMM%NPTRANS,SYMM%ROTMAP,SYMM%TAU,SYMM%TAUROT,SYMM%WRKROT, &
-               SYMM%INDROT,T_INFO%ATOMOM,WDES%SAXIS,SYMM%MAGROT,WDES%NCDIJ,IO%IU6)
-       ENDIF
-
-       CALL LRF_MAIN( &
-          KINEDEN,HAMILTONIAN,P,WDES,NONLR_S,NONL_S,W,RPHI,RPHI_CPROJ, &
-          LATT_CUR, &
-          T_INFO,DYN,INFO,IO,MIX,KPOINTS,SYMM,GRID,GRID_SOFT, &
-          GRIDC,GRIDB,GRIDUS,C_TO_US,B_TO_C,SOFT_TO_C,E, &
-          CHTOT,CHTOTL,DENCOR,CVTOT,CSTRF, &
-          CDIJ,CQIJ,CRHODE,N_MIX_PAW,RHOLM,RHOLM_LAST, &
-          CHDEN,SV,DOS,DOSI, &
-          LMDIM,IRDMAX,NEDOS, &
-          TOTEN,EFERMI, DEG_CLUSTER, KPOINTS_TRANS, EPSILON(IDIR,:), BORN_CHARGES(IDIR,:,:), PIEZO(IDIR,:,:),  & 
-          IDIR, .TRUE.)
-
-          IF (IO%LOPEN) CALL WFORCE(IO%IU6)
-    ENDDO
-    ! reinitialise symmetry
-    IF (SYMM%ISYM>0) THEN
-       DYN%VEL=0
-       CALL INISYM(LATT_CUR%A,T_INFO%POSION,DYN%VEL,T_INFO%LSFOR, &
-            T_INFO%LSDYN,T_INFO%NTYP,T_INFO%NITYP,T_INFO%NIONS, &
-            SYMM%PTRANS,SYMM%NROT,SYMM%NPTRANS,SYMM%ROTMAP,SYMM%TAU,SYMM%TAUROT,SYMM%WRKROT, &
-            SYMM%INDROT,T_INFO%ATOMOM,WDES%SAXIS,SYMM%MAGROT,WDES%NCDIJ,IO%IU6)
-    ENDIF
-
-    IF (SYMM%ISYM>0) CALL TSYM(EPSILON,ISYMOP,NROTK,LATT_CUR%A)
-    IF (IO%IU6>=0) THEN
-       IF (LRPA) THEN
-          WRITE(IO%IU6,1100) '(including local field effects in RPA (Hartree))',EPSILON
-       ELSE
-          WRITE(IO%IU6,1100) '(including local field effects in DFT)',EPSILON
-       ENDIF
-       WRITE(IO%IU6,130)
-       CALL XML_TENSOR("epsilon",EPSILON)
-    ENDIF
-
-!=======================================================================
-! response to external field including local field effects
-! this version changes the k-point set on the fly
-! and symmetrizes the polarisation vector
-!=======================================================================
-#else
-    DO IDIR=1,3
-       IF (IU0>=0) THEN
-          WRITE (IU0,*)'Linear response to external field, progress :'
-          WRITE (IU0,'(A,I3)') &
-               '  Direction: ',IDIR
-          WRITE (17,*)'Linear response to external field, progress :'
-          WRITE (17,'(A,I3)') &
-               '  Direction: ',IDIR
-       END IF
-     
-       IF (IU6>=0) THEN
-          WRITE (IU6,*)'Linear response to external field, progress :'
-          WRITE (IU6,'(A,I3)') &
-               '  Direction: ',IDIR
-       ENDIF
-       !
-       ! reinitialise symmetry part for field in direction IDIR
-       ! presently this is done by supplying a velocity field to the ions
-       !
-       IF (SYMM%ISYM>0) THEN
-          DYN%VEL=0
-          DYN%VEL(IDIR,:)=1.0
-          CALL  KARDIR(T_INFO%NIONS,DYN%VEL,LATT_CUR%B)
-          CALL INISYM(LATT_CUR%A,T_INFO%POSION,DYN%VEL,T_INFO%LSFOR, &
-               T_INFO%LSDYN,T_INFO%NTYP,T_INFO%NITYP,T_INFO%NIONS, &
-               SYMM%PTRANS,SYMM%NROT,SYMM%NPTRANS,SYMM%ROTMAP,SYMM%TAU,SYMM%TAUROT,SYMM%WRKROT, &
-               SYMM%INDROT,T_INFO%ATOMOM,WDES%SAXIS,SYMM%MAGROT,WDES%NCDIJ,IO%IU6)
-#ifdef oldsym
-          CALL RE_READ_KPOINTS(KPOINTS,LATT_CUR, &
-               SYMM%ISYM>=0.AND..NOT.WDES%LSORBIT.AND..NOT.WDES%LSPIRAL, &
-               T_INFO%NIONS,SYMM%ROTMAP,SYMM%MAGROT,SYMM%ISYM,IU6K,IO%IU0)
-#else
-          CALL RE_READ_KPOINTS(KPOINTS,LATT_CUR, &
-               SYMM%ISYM>=0.AND..NOT.WDES%LNONCOLLINEAR, &
-               T_INFO%NIONS,SYMM%ROTMAP,SYMM%MAGROT,SYMM%ISYM,IU6K,IO%IU0)
-#endif
-          CALL KPAR_SYNC_ALL(WDES,W)
-          CALL RE_GEN_LAYOUT( GRID, WDES, KPOINTS, LATT_CUR, LATT_INI, IO%IU6, IO%IU0)
-          CALL REALLOCATE_WAVE( W, GRID, WDES, NONL_S, T_INFO, P, LATT_CUR, KPOINTS_TRANS)
-
-          ! Loewdin perturbation theory to improve states at added k-points
-          CALL EDDIAG(HAMILTONIAN,GRID,LATT_CUR,NONLR_S,NONL_S,W,WDES,SYMM, &
-          &    LMDIM,CDIJ,CQIJ,4,SV,T_INFO,P,IO%IU0,DESUM, NKSTART=NKORIG+1)
-          CALL KPAR_SYNC_ALL(WDES,W)
-
-          CALL FIND_DEG_CLUSTERS(WDES, W, DEG_CLUSTER)
-       ENDIF
-
-       CALL LRF_MAIN( &
-          KINEDEN,HAMILTONIAN,P,WDES,NONLR_S,NONL_S,W,RPHI,RPHI_CPROJ, &
-          LATT_CUR, &
-          T_INFO,DYN,INFO,IO,MIX,KPOINTS,SYMM,GRID,GRID_SOFT, &
-          GRIDC,GRIDB,GRIDUS,C_TO_US,B_TO_C,SOFT_TO_C,E, &
-          CHTOT,CHTOTL,DENCOR,CVTOT,CSTRF, &
-          CDIJ,CQIJ,CRHODE,N_MIX_PAW,RHOLM,RHOLM_LAST, &
-          CHDEN,SV,DOS,DOSI, &
-          LMDIM,IRDMAX,NEDOS, &
-          TOTEN,EFERMI, DEG_CLUSTER, KPOINTS_TRANS, EPSILON(IDIR,:), BORN_CHARGES(IDIR,:,:), PIEZO(IDIR,:,:), & 
-          IDIR, .TRUE.)
-       IF (IO%LOPEN) CALL WFORCE(IO%IU6)
-
-       IF (SYMM%ISYM>0) CALL DEALLOCATE_KPOINTS_TRANS(KPOINTS_TRANS)
-    ENDDO
-
-    IF (SYMM%ISYM>0) THEN
-       DYN%VEL=0
-       CALL KARDIR(T_INFO%NIONS,DYN%VEL,LATT_CUR%B)
-       CALL INISYM(LATT_CUR%A,T_INFO%POSION,DYN%VEL,T_INFO%LSFOR, &
-            T_INFO%LSDYN,T_INFO%NTYP,T_INFO%NITYP,T_INFO%NIONS, &
-            SYMM%PTRANS,SYMM%NROT,SYMM%NPTRANS,SYMM%ROTMAP,SYMM%TAU,SYMM%TAUROT,SYMM%WRKROT, &
-            SYMM%INDROT,T_INFO%ATOMOM,WDES%SAXIS,SYMM%MAGROT,WDES%NCDIJ,IO%IU6)
-#ifdef oldsym
-       CALL RE_READ_KPOINTS(KPOINTS,LATT_CUR, &
-            SYMM%ISYM>=0.AND..NOT.WDES%LSORBIT.AND..NOT.WDES%LSPIRAL, &
-            T_INFO%NIONS,SYMM%ROTMAP,SYMM%MAGROT,SYMM%ISYM,IU6K,IO%IU0)
-#else
-       CALL RE_READ_KPOINTS(KPOINTS,LATT_CUR, &
-            SYMM%ISYM>=0.AND..NOT.WDES%LNONCOLLINEAR, &
-            T_INFO%NIONS,SYMM%ROTMAP,SYMM%MAGROT,SYMM%ISYM,IU6K,IO%IU0)
-#endif
-       CALL RE_GEN_LAYOUT( GRID, WDES, KPOINTS, LATT_CUR, LATT_INI, IO%IU6, IO%IU0)
-       CALL REALLOCATE_WAVE( W, GRID, WDES, NONL_S, T_INFO, P, LATT_CUR)
-
-       CALL TSYM(EPSILON,ISYMOP,NROTK,LATT_CUR%A)
-    ENDIF
-
-    IF (IO%IU6>=0) THEN
-       IF (LRPA) THEN
-          WRITE(IO%IU6,1100) '(including local field effects in RPA (Hartree))',EPSILON
-       ELSE
-          WRITE(IO%IU6,1100) '(including local field effects in DFT)',EPSILON
-       ENDIF
-       WRITE(IO%IU6,130)
-       CALL XML_TENSOR("epsilon",EPSILON)
-    ENDIF
-#endif
-1100   FORMAT(// &
-            " MACROSCOPIC STATIC DIELECTRIC TENSOR ",A/, &
-            " ------------------------------------------------------"/, &
-            &       3(6X,3F13.6/), &
-            " ------------------------------------------------------"/)
-
-1110   FORMAT(// &
-            " HEAD OF MICROSCOPIC STATIC DIELECTRIC TENSOR ",A/, &
-            " ------------------------------------------------------"/, &
-            &       3(6X,3F13.6/), &
-            " ------------------------------------------------------"/)
-
-
-    ENDIF
-130 FORMAT (5X, //, &
-     &'----------------------------------------------------', &
-     &'----------------------------------------------------'//)
-!=======================================================================
-! ionic displacements
-!=======================================================================
-
-    IF (IU0>=0 .AND. DOF>0) THEN
-       WRITE (IU0,*) 'Linear response DOF=',DOF
-       WRITE (17,*) 'Linear response DOF=',DOF
-    ENDIF
-
-    IF (IU6>=0 .AND. DOF>0) THEN
-       WRITE (IU6,*) 'Linear response:'
-       WRITE (IU6,*) '  Degrees of freedom DOF   = ',DOF
-    END IF
-
-    DO PROCESSED_DISPL=1,DOF
-
-       IF (IU0>=0) THEN
-          WRITE (IU0,*)'Linear response progress:'
-          WRITE (IU0,'(A,I3,A,I3)') &
-               '  Degree of freedom: ',PROCESSED_DISPL,'/',DOF
-          WRITE (17,*)'Linear response progress:'
-          WRITE (17,'(A,I3,A,I3)') &
-               '  Degree of freedom: ',PROCESSED_DISPL,'/',DOF
-       END IF
-     
-       IF (IU6>=0) THEN
-          WRITE (IU6,*)'Linear response progress:'
-          WRITE (IU6,'(A,I3,A,I3)') &
-               '  Degree of freedom: ',PROCESSED_DISPL,'/',DOF
-       ENDIF
-       T_INFO%POSION=T_INFO_0%POSION
-       IF (IBRION==8) THEN
-          CALL FIND_IJ_ID(.FALSE.,NIONS,PROCESSED_DISPL,ND,J,IDISPL_ON_ION)
-          IDIR=IDIRD(IDISPL_ON_ION,J)
-          IF (ABS(D(IDIR,IDISPL_ON_ION,J)-1.0) >1E-8) THEN
-             CALL VTUTOR('E','LINEARRES POSCAR',0.0_q,1,0,1,(0.0_q,0.0_q),1,.TRUE.,1, &
-                  IO%iu6,3)
-             CALL VTUTOR('S','LINEARRES POSCAR',0.0_q,1,0,1,(0.0_q,0.0_q),1,.TRUE.,1, &
-                  IO%IU0,3)
-          ENDIF
-       ELSE
-          CALL FIND_IJ(NIONS,T_INFO%LSFOR,T_INFO%LSDYN,PROCESSED_DISPL,IDIR,J)
-       ENDIF
-
-       IF (SYMM%ISYM>0) THEN
-          DYN%VEL=0
-          DYN%VEL(IDIR,J)=1.0
-          CALL  KARDIR(1,DYN%VEL(:,J),LATT_CUR%B)
-          CALL INISYM(LATT_CUR%A,T_INFO%POSION,DYN%VEL,T_INFO%LSFOR, &
-               T_INFO%LSDYN,T_INFO%NTYP,T_INFO%NITYP,T_INFO%NIONS, &
-               SYMM%PTRANS,SYMM%NROT,SYMM%NPTRANS,SYMM%ROTMAP,SYMM%TAU,SYMM%TAUROT,SYMM%WRKROT, &
-               SYMM%INDROT,T_INFO%ATOMOM,WDES%SAXIS,SYMM%MAGROT,WDES%NCDIJ,IO%IU6)
-#ifdef oldsym
-          CALL RE_READ_KPOINTS(KPOINTS,LATT_CUR, &
-               SYMM%ISYM>=0.AND..NOT.WDES%LSORBIT.AND..NOT.WDES%LSPIRAL, &
-               T_INFO%NIONS,SYMM%ROTMAP,SYMM%MAGROT,SYMM%ISYM,IU6K,IO%IU0)
-#else
-          CALL RE_READ_KPOINTS(KPOINTS,LATT_CUR, &
-               SYMM%ISYM>=0.AND..NOT.WDES%LNONCOLLINEAR, &
-               T_INFO%NIONS,SYMM%ROTMAP,SYMM%MAGROT,SYMM%ISYM,IU6K,IO%IU0)
-#endif
-          CALL KPAR_SYNC_ALL(WDES,W)
-          CALL RE_GEN_LAYOUT( GRID, WDES, KPOINTS, LATT_CUR, LATT_INI, IO%IU6, IO%IU0)
-          CALL REALLOCATE_WAVE( W, GRID, WDES, NONL_S, T_INFO, P, LATT_CUR, KPOINTS_TRANS)
-
-          ! Loewdin perturbation theory to improve states at added k-points
-          CALL EDDIAG(HAMILTONIAN,GRID,LATT_CUR,NONLR_S,NONL_S,W,WDES,SYMM, &
-          &    LMDIM,CDIJ,CQIJ,4,SV,T_INFO,P,IO%IU0,DESUM, NKSTART=NKORIG+1)
-          CALL KPAR_SYNC_ALL(WDES,W)
-
-          ! or alternatively, but not more accurate 3 steps Davidson
-          ! problem is that this might yield wrong piezoelectric tensors
-!          X=INFO%EBREAK
-!          INFO%EBREAK=0.25*EDIFF
-!          DO I=1,3
-!             CALL EDDAV(HAMILTONIAN,P, GRID,INFO,LATT_CUR,NONLR_S,NONL_S,W,WDES, NSIM, &
-!             LMDIM,CDIJ,CQIJ, RMS,DESUM,ICOUEV, SV, E%EXHF, IO%IU6,IO%IU0, .FALSE., .TRUE., .FALSE.)
-!             
-!             E%EBANDSTR=BANDSTRUCTURE_ENERGY(WDES, W)
-!             TOTEN_=E%EBANDSTR+E%DENC+E%XCENC+E%TEWEN+E%PSCENC+E%EENTROPY+E%PAWPS+E%PAWAE+INFO%EALLAT+E%EXHF
-!
-!             IF (IO%IU0>=0) THEN
-!                WRITE(IO%IU0,1000) I, TOTEN_, TOTEN_-TOTEN, DESUM, ICOUEV, RMS
-!                WRITE(17,1000)     I, TOTEN_, TOTEN_-TOTEN, DESUM, ICOUEV, RMS
-!             ENDIF
-!             IF(ABS(DESUM)<EDIFF.AND.ABS(TOTEN_-TOTEN)<EDIFF) EXIT
-!             TOTEN=TOTEN_
-!          ENDDO
-!          CALL KPAR_SYNC_ALL(WDES,W)
-!          INFO%EBREAK=X         ! restore the break condition
-
-          CALL FIND_DEG_CLUSTERS(WDES, W, DEG_CLUSTER)
-       ENDIF
-
-       CALL LR_MAIN( &
-          KINEDEN,HAMILTONIAN,P,WDES,NONLR_S,NONL_S,W,LATT_CUR, &
-          T_INFO,T_INFO_0,DYN,INFO,IO,MIX,KPOINTS,SYMM,GRID,GRID_SOFT, &
-          GRIDC,GRIDB,GRIDUS,C_TO_US,B_TO_C,SOFT_TO_C,E, &
-          CHTOT,CHTOTL,DENCOR,CVTOT,CSTRF, &
-          CDIJ,CQIJ,CRHODE,N_MIX_PAW,RHOLM,RHOLM_LAST, &
-          CHDEN,SV,DOS,DOSI, &
-          LMDIM,IRDMAX,NEDOS, &
-          TOTEN,EFERMI,DISPL_FORCES(PROCESSED_DISPL,:,:),INT_STRAIN(PROCESSED_DISPL,:,:), & 
-          IDIR, J, BORN_CHARGES2(:,IDIR,J), &
-          DEG_CLUSTER, KPOINTS_TRANS, RPHI, RPHI_CPROJ)
-       IF (IO%LOPEN) CALL WFORCE(IO%IU6)
-
-       IF (SYMM%ISYM>0) CALL DEALLOCATE_KPOINTS_TRANS(KPOINTS_TRANS)
-    ENDDO
-
-    CALL FREE_DEG_CLUSTERS(WDES,DEG_CLUSTER)
-
-    IF (LEPSILON) THEN
-       DEALLOCATE(RPHI, RPHI_CPROJ)
-    ENDIF
-
-    ! restore original symmetry
-    IF (SYMM%ISYM>0) THEN
-       DYN%VEL=0
-       CALL INISYM(LATT_CUR%A,T_INFO%POSION,DYN%VEL,T_INFO%LSFOR, &
-            T_INFO%LSDYN,T_INFO%NTYP,T_INFO%NITYP,T_INFO%NIONS, &
-            SYMM%PTRANS,SYMM%NROT,SYMM%NPTRANS,SYMM%ROTMAP,SYMM%TAU,SYMM%TAUROT,SYMM%WRKROT, &
-            SYMM%INDROT,T_INFO%ATOMOM,WDES%SAXIS,SYMM%MAGROT,WDES%NCDIJ,IO%IU6)
-#ifdef oldsym
-       CALL RE_READ_KPOINTS(KPOINTS,LATT_CUR, &
-            SYMM%ISYM>=0.AND..NOT.WDES%LSORBIT.AND..NOT.WDES%LSPIRAL, &
-            T_INFO%NIONS,SYMM%ROTMAP,SYMM%MAGROT,SYMM%ISYM,IU6K,IO%IU0)
-#else
-       CALL RE_READ_KPOINTS(KPOINTS,LATT_CUR, &
-            SYMM%ISYM>=0.AND..NOT.WDES%LNONCOLLINEAR, &
-            T_INFO%NIONS,SYMM%ROTMAP,SYMM%MAGROT,SYMM%ISYM,IU6K,IO%IU0)
-#endif
-       CALL RE_GEN_LAYOUT( GRID, WDES, KPOINTS, LATT_CUR, LATT_INI, IO%IU6, IO%IU0)
-       CALL REALLOCATE_WAVE( W, GRID, WDES, NONL_S, T_INFO, P, LATT_CUR)
-    ENDIF
-!=======================================================================
-!
-! final processing and output 
-! Born effective charges, piezoelectric tensors, and internal strain
-!
-!=======================================================================
-    IF (IBRION==8) THEN
-       !
-       ! version for case symmetry was used to reduce the number of displacments
-       !
-       CALL PRINT_DYNMAT_ID(.FALSE.,NIONS,DOF,1.0_q,T_INFO%NTYP,T_INFO%NITYP,T_INFO%POMASS,DISPL_FORCES,D,ND,IU6)
-
-       DO PROCESSED_DISPL=1,DOF
-          CALL FIND_IJ_ID(.FALSE.,NIONS,PROCESSED_DISPL,ND,J,IDIR)
-          DO N=1,T_INFO%NIONS
-             DMAT(1:3,IDIR,N,J)=DISPL_FORCES(PROCESSED_DISPL,1:3,N)
-          END DO
-          ST(1:3,1:3,IDIR,J)=INT_STRAIN  (PROCESSED_DISPL,1:3,1:3)
-       END DO
-
-       CALL MKDMAT(SYMM%ROTMAP,ISYMOP,INVMAP,NROTK,NPCELL,D,DMAT,ST,ND,      &
-            1,T_INFO%NTYP,T_INFO%NIONS,T_INFO%NITYP,WORKD,WDMAT,AST,IWORK,SYMM%TAU,SYMM%TAUROT,   &
-            SYMM%WRKROT, &
-            LATT_CUR%A(1,1),LATT_CUR%A(1,2),LATT_CUR%A(1,3), &
-            LATT_CUR%B(1,1),LATT_CUR%B(1,2),LATT_CUR%B(1,3))
-
-       LDO=.TRUE.
-       CALL SYDMAT(DMAT,SYMM%ROTMAP,ISYMOP,NROTK,NPCELL,1,T_INFO%NTYP, &
-            T_INFO%NIONS,T_INFO%NITYP,WDMAT,LATT_CUR%A(1,1),LATT_CUR%A(1,2),LATT_CUR%A(1,3),LDO)
-       CALL STMAT(ST  ,SYMM%ROTMAP,ISYMOP,NROTK,NPCELL,1,T_INFO%NTYP, &
-            T_INFO%NIONS,T_INFO%NITYP,AST  ,LATT_CUR%A(1,1),LATT_CUR%A(1,2),LATT_CUR%A(1,3),LDO)
-
-       ! now reset DOF to NIONS*3
-       ! and copy results from DMAT back to DISPL_FORCES
-
-       CALL COUNT_DOF(NIONS, T_INFO%LSFOR, T_INFO%LSDYN, DOF)
-       DEALLOCATE(DISPL_FORCES)
-       ALLOCATE(DISPL_FORCES(DOF,3,NIONS))
-
-       DO PROCESSED_DISPL=1,DOF
-          CALL FIND_IJ(NIONS,T_INFO%LSFOR,T_INFO%LSDYN,PROCESSED_DISPL,IDIR,J)
-          DO N=1,NIONS
-             DISPL_FORCES(PROCESSED_DISPL,1:3,N)=DMAT(1:3,IDIR,N,J)
-          ENDDO
-       ENDDO
-    ELSE
-       !
-       ! version for case no symmetry was used
-       !
-       CALL PRINT_DYNMAT(NIONS,DOF,1.0_q,T_INFO%NTYP,T_INFO%NITYP,T_INFO%POMASS,DISPL_FORCES,T_INFO%LSDYN,T_INFO%LSFOR,IU6)
-
-       DO PROCESSED_DISPL=1,DOF
-          CALL FIND_IJ(NIONS,T_INFO%LSFOR,T_INFO%LSDYN,PROCESSED_DISPL,IDIR,J)
-          ST(1:3,1:3,IDIR,J)=INT_STRAIN  (PROCESSED_DISPL,1:3,1:3)
-       END DO
-    ENDIF
-
-    IF (IU6>=0) THEN
-       WRITE (IU6,130) 
-       IF (LEPSILON) THEN
-          ! for the sake of having everything at the very end print EPSILON again
-          IF (LRPA) THEN
-             WRITE(IO%IU6,1100) '(including local field effects in RPA (Hartree))',EPSILON
-          ELSE
-             WRITE(IO%IU6,1100) '(including local field effects in DFT)',EPSILON
-          ENDIF
-
-          FACT=EVTOJ*1E20_q/LATT_CUR%OMEGA
-          
-170       FORMAT(/ ' ',A,'  for field in x, y, z        (e  Angst)',/ &
-               10X,'XX', 10X,'YY', 10X,'ZZ',10X,'XY', 10X,'YZ', 10X,'ZX'/ &
-               '  ----------------------------------------------------', &
-               '----------------------------')
-
-180       FORMAT(/ ' ',A,'  for field in x, y, z        (C/m^2)',/ &
-               &        10X,'XX', 10X,'YY', 10X,'ZZ', 10X,'XY', 10X,'YZ', 10X,'ZX'/ &
-               &        '  ----------------------------------------------------', &
-               &        '----------------------------')
-          IF (.NOT.LRPA) THEN
-             WRITE (IU6,170) 'PIEZOELECTRIC TENSOR (including local field effects)'
-             DO I =1,3
-                WRITE (IU6,140) IDIR_TEXT(I),(PIEZO(I,J,J),J=1,3), & 
-                     PIEZO(I,1,2),PIEZO(I,2,3),PIEZO(I,3,1)
-             ENDDO
-             
-             CALL TSYM3(PIEZO,ISYMOP,NROTK,LATT_CUR%A)
-          
-             WRITE (IU6,180) 'PIEZOELECTRIC TENSOR (including local field effects)'
-             DO I =1,3
-                WRITE (IU6,140) IDIR_TEXT(I),(PIEZO(I,J,J)*FACT,J=1,3), & 
-                     PIEZO(I,1,2)*FACT,PIEZO(I,2,3)*FACT,PIEZO(I,3,1)*FACT
-             ENDDO
-140          FORMAT(2X,A1,6F12.5)
-
-             ! remove any drift from BORN charges
-             IF (IO%IU0>0) WRITE(IO%IU0,*) 'Born effective charges drift removed'
-             TMP=0
-             DO N=1,T_INFO%NIONS
-                TMP(:,:)=TMP(:,:)+BORN_CHARGES(:,:,N)/T_INFO%NIONS
-             ENDDO
-             DO N=1,T_INFO%NIONS
-                BORN_CHARGES(:,:,N)=BORN_CHARGES(:,:,N)-TMP(:,:)
-             ENDDO
-             
-          
-             WRITE (IU6,*)
-             WRITE (IU6,'(X,A)') 'BORN EFFECTIVE CHARGES (including local field effects) (in e, cummulative output)'
-             WRITE (IU6,'(X,A)') '---------------------------------------------------------------------------------'
-             
-             DO N=1,T_INFO%NIONS
-                WRITE (IU6,'(" ion ",I4)') N
-                DO IDIR =1,3
-                   WRITE (IU6,'(I5,3F12.5)') IDIR,BORN_CHARGES(IDIR,:,N)
-                ENDDO
-             ENDDO
-
-             CALL XML_BORN_CHARGES(BORN_CHARGES,T_INFO%NIONS)
-            ! now set the Born charges in the global array defined in pead
-             IF (.NOT. LBORN) THEN
-                LBORN=.TRUE.
-                IF (ALLOCATED(BORN_CHARGES_PEAD)) DEALLOCATE(BORN_CHARGES_PEAD)
-                ALLOCATE(BORN_CHARGES_PEAD(3,3,T_INFO%NIOND))
-             ENDIF
-             BORN_CHARGES_PEAD=BORN_CHARGES
-          ENDIF
-       ENDIF
-    ENDIF
-    IF (DOF>0 .AND. IU6>=0) THEN
-       IF (DYN%ISIF>0) THEN
-160       FORMAT(/ ' INTERNAL STRAIN TENSOR FOR ION ',I4,' for displacements in x,y,z  (eV/Angst):',/ &
-               10X,'X', 11X,'Y', 11X,'Z', 10X,'XY', 10X,'YZ', 10X,'ZX'/ &
-               '  ----------------------------------------------------', &
-               '----------------------------')
-          DO N=1,T_INFO%NIONS
-             WRITE(IU6,160) N
-             DO I =1,3
-                WRITE (IU6,140) IDIR_TEXT(I),(ST(J,J,I,N),J=1,3),ST(1,2,I,N),ST(2,3,I,N),ST(3,1,I,N)
-             ENDDO
-          ENDDO
-       END IF
-       WRITE (IU6,130)
-    ENDIF
-
-!=======================================================================
-! apply delta impulse in time DFIELD on ions, by adding 
-! a force term to FORCE
-!=======================================================================
-    IF (.NOT. DFIELD_DONE) THEN
-       DFIELD_DONE=.TRUE.
-       DO N=1,T_INFO%NIONS
-          DO IDIR =1,3 ! loop over cartesian direction of external field
-             FORCE(:,N)=FORCE(:,N)+BORN_CHARGES(IDIR,:,N)*DFIELD(IDIR)/DYN%POTIM
-          ENDDO
-       ENDDO
-       
-       ALLOCATE(POSION_LAST(3,T_INFO%NIONS))
-       ALLOCATE(BORN_CHARGES_SAVE(3,3,T_INFO%NIONS))
-
-       ! store initial postions for later use (required for evolution of dipole moment)
-       POSION_LAST=T_INFO_0%POSION
-    ENDIF
-
-    
-    IF (ALLOCATED(BORN_CHARGES_SAVE) .AND. LEPSILON) THEN
-       BORN_CHARGES_SAVE=BORN_CHARGES
-    ENDIF
-!=======================================================================
-!
-! final processing and output
-! vibrational frequencies etc.
-!
-!=======================================================================
-    IF (DOF>0 .AND. IU6>=0 ) THEN
-
-       ALLOCATE(SECOND_DERIV(DOF,DOF))
-       
-       DO N=1,DOF
-          CALL FIND_IJ(NIONS,T_INFO%LSFOR,T_INFO%LSDYN,N,I,J)       
-          DO M=1,DOF
-             SECOND_DERIV(M,N)=DISPL_FORCES(M,I,J)
-          END DO
-       END DO
-       
-       IF (IU6>=0) THEN
-          WRITE (IU6,*) 
-          WRITE (IU6,*) 'SECOND DERIVATIVES (NOT SYMMETRIZED)'
-          WRITE (IU6,*) '------------------------------------'
-          CALL PRINT_SECOND_DERIV(NIONS,DOF,SECOND_DERIV,T_INFO%LSFOR,T_INFO%LSDYN,IU6)
-       END IF
-
-       ! symmetrize Hessian matrix
-       DO N=1,DOF
-          DO M=N+1,DOF
-             X=0.5_q*(SECOND_DERIV(N,M)+SECOND_DERIV(M,N))
-             SECOND_DERIV(N,M)=X
-             SECOND_DERIV(M,N)=X
-          END DO
-       END DO
-
-       ALLOCATE(WORK(DOF,32),EIGENVECTORS(DOF,DOF),EIGENVALUES(DOF))
-
-       EIGENVECTORS=SECOND_DERIV
-       N=1
-       DO I=1,T_INFO%NTYP
-          DO J=1,T_INFO%NITYP(I)
-             DO K=1,3
-                CALL FIND_DOF_INDEX(NIONS,T_INFO%LSFOR,T_INFO%LSDYN,K,N,M)
-                IF (M>0) EIGENVECTORS(:,M)=EIGENVECTORS(:,M)/SQRT(T_INFO%POMASS(I))
-                IF (M>0) EIGENVECTORS(M,:)=EIGENVECTORS(M,:)/SQRT(T_INFO%POMASS(I))
-             END DO
-             N=N+1
-          END DO
-       END DO
-
-       CALL XML_TAG("dynmat")
-       CALL XML_VECARRAY("hessian")
-       CALL XML_ARRAY_REAL(EIGENVECTORS)
-       CALL XML_CLOSE_TAG
-
-       CALL DSYEV &
-            ('V','U',DOF,EIGENVECTORS,DOF, &
-            EIGENVALUES,WORK,32*DOF, IERROR)
-       IF (IERROR/=0) THEN
-          IF (IU6>=0) THEN
-             WRITE(IU6,*) "Error while diagonalisation DSYEV INFO=",IERROR
-             WRITE(IU6,*) "Some of (or all) eigenvectors and eigenvalues are not correct !"
-          END IF
-       END IF
-
-       CALL XML_VEC_REAL(EIGENVALUES,"eigenvalues",'(ES16.8)')
-       CALL XML_VECARRAY("eigenvectors")
-       CALL XML_ARRAY_REAL(EIGENVECTORS,'(ES16.8)')
-       CALL XML_CLOSE_TAG
-       CALL XML_CLOSE_TAG
-
-       CALL PRINT_EIGENVECTORS(NIONS,DOF,T_INFO_0%POSION,LATT_CUR%A, &
-            EIGENVECTORS,EIGENVALUES,       &
-            T_INFO%LSFOR,T_INFO%LSDYN,IU6)
-
-       N=1
-       DO I=1,T_INFO%NTYP
-          DO J=1,T_INFO%NITYP(I)
-             DO K=1,3
-                CALL FIND_DOF_INDEX(NIONS,T_INFO%LSFOR,T_INFO%LSDYN,K,N,M)
-                IF (M>0) EIGENVECTORS(M,:)=EIGENVECTORS(M,:)/SQRT(T_INFO%POMASS(I))
-             END DO
-             N=N+1
-          END DO
-       END DO
-
-       IF (IU6>=0 .AND. IO%NWRITE>=3) THEN
-          WRITE(IU6,*) "Eigenvectors after division by SQRT(mass)"
-          CALL PRINT_EIGENVECTORS(NIONS,DOF,T_INFO_0%POSION,LATT_CUR%A, &
-               EIGENVECTORS,EIGENVALUES,       &
-               T_INFO%LSFOR,T_INFO%LSDYN,IU6)
-       ENDIF
-       DEALLOCATE(WORK)
-
-       CALL STORE_RPA_SECOND_DERIV(SECOND_DERIV)
-!=======================================================================
-!
-! ionic contribution to dielectric, elastic and piezoelectric tensor
-!
-!=======================================================================
-       IF (DYN%ISIF>0 .OR. LEPSILON) THEN
-          WRITE(IO%IU6,130)
-          ! invert the matrix of the second derivatives
-          SECOND_DERIV=-SECOND_DERIV
-          CALL INV_SECOND_DERIV(SECOND_DERIV, DOF, IU6 )
-
-          ! ionic contribution to macroscopic dielectric tensor
-          IF (LBORN .AND. .NOT. LRPA .AND. IO%IU6>=0 ) THEN
-             CALL EPSILON_ION( T_INFO, DOF, SECOND_DERIV, BORN_CHARGES_PEAD, EPSILON )
-
-             ! induced polariation -> field
-             EPSILON=EPSILON*EDEPS/(LATT_CUR%OMEGA)
-             WRITE(IO%IU6,1100) 'IONIC CONTRIBUTION',EPSILON
-
-             CALL XML_TENSOR("epsilon_ion",EPSILON)
-
-             CALL EPSILON_ION_OMEGA( T_INFO, DOF, EIGENVECTORS, EIGENVALUES, BORN_CHARGES_PEAD, LATT_CUR%OMEGA )
-          ENDIF
-
-          IF (DYN%ISIF>0.AND.IO%IU6>=0) THEN
-100       FORMAT(/ &
-            A / &
-            ' Direction', &
-            4X,'XX', 10X,'YY', 10X,'ZZ', 10X,'XY', 10X,'YZ', 10X,'ZX'/ &
-            ' --------------------------------------------------------------------------------'/ &
-            ' XX     ',6F12.4/ &
-            ' YY     ',6F12.4/ &
-            ' ZZ     ',6F12.4/ &
-            ' XY     ',6F12.4/ &
-            ' YZ     ',6F12.4/ &
-            ' ZX     ',6F12.4/ &
-            ' --------------------------------------------------------------------------------'/)
-             CALL ELASTIC_ION( T_INFO, DOF, SECOND_DERIV, ST, ELASTIC )
-
-             ELASTICP(1,:,:)=ELASTIC(1,1,:,:)
-             ELASTICP(2,:,:)=ELASTIC(2,2,:,:)
-             ELASTICP(3,:,:)=ELASTIC(3,3,:,:)
-             ELASTICP(4,:,:)=ELASTIC(1,2,:,:)
-             ELASTICP(5,:,:)=ELASTIC(2,3,:,:)
-             ELASTICP(6,:,:)=ELASTIC(3,1,:,:)
-
-             FACT=EVTOJ*1E22_q/LATT_CUR%OMEGA
-
-             WRITE(IU6,100) ' ELASTIC MODULI CONTR FROM IONIC RELAXATION (kBar)', ( &
-                  (ELASTICP(J,I,I)*FACT,I=1,3), &
-                   ELASTICP(J,1,2)*FACT,ELASTICP(J,2,3)*FACT,ELASTICP(J,3,1)*FACT,J=1,6)
-          END IF
-
-          ! ionic contribution to piezoelectric tensor
-          IF ( DYN%ISIF>0 .AND. LBORN .AND. .NOT. LRPA .AND.IO%IU6>=0 ) THEN
-
-             CALL PIEZO_ION( T_INFO, DOF, SECOND_DERIV, ST, BORN_CHARGES_PEAD, PIEZO )
-             
-             WRITE (IU6,180) 'PIEZOELECTRIC TENSOR IONIC CONTR'
-             FACT=EVTOJ*1E20_q/LATT_CUR%OMEGA
-             DO I =1,3
-                WRITE (IU6,140) IDIR_TEXT(I),(PIEZO(I,J,J)*FACT,J=1,3), & 
-                     PIEZO(I,1,2)*FACT,PIEZO(I,2,3)*FACT,PIEZO(I,3,1)*FACT
-             ENDDO
-          ENDIF
-       END IF
-       DEALLOCATE(SECOND_DERIV, EIGENVECTORS, EIGENVALUES)
-    END IF
-    IF (IO%IU6>=0) WRITE(IO%IU6,130)
-
-    DEALLOCATE(T_INFO_0%POSION)
-    DEALLOCATE(INITIAL_FORCE)
-    DEALLOCATE(DISPL_FORCES,BORN_CHARGES,BORN_CHARGES2, &
-      PIEZO,INT_STRAIN)
-
-    IF (IBRION==8) THEN
-      DEALLOCATE(D, ND, IDIRD)
-    ENDIF
-
-    IF (IU0>=0 .AND. DOF>0) THEN
-       WRITE (IU0,*) 'Linear response finished'
-       WRITE (17,*) 'Linear response finished'
-    ENDIF
-
-    IF (IO%LOPEN) CALL WFORCE(IO%IU6)
-
-  END SUBROUTINE LR_SKELETON
-
-!************************ SUBROUTINE STORE_DIPOLE_AND_AUTOCORRELATE ****
-!
-! Routine to store the dipole moment as a function of time
-!
-!***********************************************************************
-
-  SUBROUTINE STORE_DIPOLE_AND_AUTOCORRELATE( T_INFO, LATT_CUR, POTIM, NSW, NSTEP, IO)
-    USE constant
-    USE lattice 
-    USE poscar
-    USE base
-    USE mlrf_main
-    IMPLICIT NONE
-    TYPE (type_info)   T_INFO     ! information on positions etc.
-    TYPE (latt)        LATT_CUR   ! lattice parameters
-    REAL(q)            POTIM
-    INTEGER            NSW        ! total number of steps
-    INTEGER            NSTEP      ! current step
-    TYPE (in_struct)   IO
-    REAL(q),PARAMETER :: PLANK=6.626075E-34
-  ! local variables
-    REAL(q) :: DIPOLE(3), TMP(3), OMEGA_MAX, OMEGA, DAMPING, SCALE
-    INTEGER :: N, I, J
-    COMPLEX(q), ALLOCATABLE :: EPSILON(:,:)
-    COMPLEX(q) :: EXPFAC
-    
-    ! first allocate if required
-    IF (.NOT. ALLOCATED(DIPOLE_TIME)) THEN
-       ALLOCATE(DIPOLE_TIME(3, NSW))
-       DIPOLE_TIME=0
-    ENDIF
-
-    ! first calculate current dipole
-    DIPOLE=0
-    
-    SCALE=1.0_q/SQRT(DFIELD(1)**2+DFIELD(2)**2+DFIELD(3)**2)
-    DO N=1,T_INFO%NIONS
-       TMP=T_INFO%POSION(:,N)-POSION_LAST(:,N)
-       TMP(1)=MOD(TMP(1)+4.5_q,1.0_q)-0.5_q
-       TMP(2)=MOD(TMP(2)+4.5_q,1.0_q)-0.5_q
-       TMP(3)=MOD(TMP(3)+4.5_q,1.0_q)-0.5_q
-       ! convert to cartesian coordinates
-       CALL DIRKAR(1, TMP, LATT_CUR%A)
-       ! divide by the absolute magnitude of the external field
-       ! to obtain response
-       DIPOLE(:)=DIPOLE(:)+MATMUL(BORN_CHARGES_SAVE(:,:,N), TMP)*SCALE
-    ENDDO
-    ! store current positions into last position array
-    POSION_LAST=T_INFO%POSION
-
-    IF (NSTEP==1) THEN
-       ! initial dipole is assumed to be zero
-       DIPOLE_TIME(:,NSTEP)=0
-    ELSE
-       ! accumulate the change of the dipole over time
-       DIPOLE_TIME(:,NSTEP)=DIPOLE(:)+DIPOLE_TIME(:,NSTEP-1)
-    ENDIF
-
-    IF (NSTEP==NSW) THEN
-       ALLOCATE(EPSILON(3, NSW))
-       EPSILON=0
-
-       OMEGA_MAX=PI/POTIM
-       DAMPING=4.0_q/(POTIM*NSW)
-
-       IF (IO%IU6>=0) THEN
-          DO I=0,NSW-1
-             WRITE(77,'(4F14.7)') POTIM*I, DIPOLE_TIME(:,I+1)
-          ENDDO
-       ENDIF
-
-       DO I=0,NSW-1
-          OMEGA=OMEGA_MAX/NSW*I
-          ! weight is the derivative of the function above
-          DO J=0,NSW-1
-             EXPFAC=EXP( ((0._q,1._q)*OMEGA-DAMPING )*POTIM*J) !expfac=exponential-factor
-             EPSILON(:,I+1)=EPSILON(:,I+1)-1.0_q*DIPOLE_TIME(:,J+1)*EXPFAC*POTIM
-          ENDDO
-       ENDDO !ENDDO omega_sum
-
-       ! in CALC_WRITE_DF there is another factor HARTREE**2 / AUTOA**2 
-       EPSILON=EPSILON*EDEPS/LATT_CUR%OMEGA
-
-       IF (IO%IU6>=0) THEN
-          DO I=0,NSW-1
-             ! convert from circular frequency to cm (see finite_diff.F)
-             WRITE(78,'(7F14.7)') OMEGA_MAX/NSW*I*1000, -REAL(EPSILON(:,I+1),q)
-          ENDDO
-          WRITE(78,*)
-          DO I=0,NSW-1
-             ! convert from circular frequency to cm (see finite_diff.F)
-             WRITE(78,'(7F14.7)') OMEGA_MAX/NSW*I*1000, -AIMAG(EPSILON(:,I+1))
-          ENDDO
-       ENDIF
-
-       DEALLOCATE(EPSILON)
-
-       
-    ENDIF
-
-  END SUBROUTINE STORE_DIPOLE_AND_AUTOCORRELATE
-
-
-!************************ SUBROUTINE INTERPOLATE_BAND_STR **************
-!
-! this routine interpolates the band structure to a dense k-point
-! grid 
-! the strategy is fairly simply
-! first the first derivative with respect to k is calculated
-!    (presently only the subspace of considered orbitals)
-! next the k-point grid is partly shifted and a diagonalization
-! in the subspace is performed
-! very little data is stored, to keep the routine simple
-! and concise
-! 
-!***********************************************************************
-
-    SUBROUTINE INTERPOLATE_BAND_STR(HAMILTONIAN, KPOINTS, GRID, LATT_CUR, LATT_INI, & 
-       &    T_INFO, NONLR_S, NONL_S, W, NEDOS, DOS, DOSI, NELECT, NUP_DOWN, &
-       &    LMDIM, P, SV, CQIJ, CDIJ, SYMM, IU0, IU6, RPHI)
-      USE prec
-      USE wave_high
-      USE lattice
-      USE poscar
-      USE mpimy
-      USE mgrid
-      USE nonl_high
-      USE base
-      USE pseudo
-      USE kpoints_change
-      USE constant
-      USE choleski
-      USE subrot
-      USE mlrf_main
-      USE hamil_high
-      IMPLICIT NONE
-
-      TYPE (ham_handle)  HAMILTONIAN
-      TYPE (kpoints_struct) KPOINTS
-      TYPE (grid_3d)     GRID
-      TYPE (latt)        LATT_CUR
-      TYPE (latt)        LATT_INI
-      TYPE (type_info)   T_INFO
-      TYPE (nonlr_struct)NONLR_S
-      TYPE (nonl_struct) NONL_S
-      TYPE (potcar)      P(:)
-      TYPE (wavespin), TARGET :: W
-      INTEGER LMDIM
-      OVERLAP         CQIJ (LMDIM,LMDIM,W%WDES%NIONS,W%WDES%NCDIJ)
-      OVERLAP         CDIJ (LMDIM,LMDIM,W%WDES%NIONS,W%WDES%NCDIJ)
-      TYPE (symmetry) SYMM
-      RGRID           SV(DIMREAL(GRID%MPLWV),W%WDES%NCDIJ)
-      INTEGER IU0, IU6
-      COMPLEX(qs), OPTIONAL :: RPHI(:,:,:,:,:)
-      INTEGER    NEDOS
-      REAL(q)    DOS(NEDOS,W%WDES%ISPIN),DOSI(NEDOS,W%WDES%ISPIN), NELECT, NUP_DOWN
-!    local
-      INTEGER NKPTS_ORIG, I, ISP, NK, NPOS, NB
-      INTEGER IKX, IKY, IKZ, IKXP, IKYP, IKZP, IWZ
-      REAL(q) DISPL(3), DISPL_CART(3), DISPL_FOUND(3), DIST, DIST_FOUND, KSTART
-      REAL(q) EFERMI, ENTROPY, PAR(1,1,1,1,W%WDES%NCDIJ),DOSPAR(1,1,1,W%WDES%NCDIJ)
-      REAL(q)    DOS_TMP(NEDOS,W%WDES%ISPIN),DOSI_TMP(NEDOS,W%WDES%ISPIN), EFERMI_TMP
-      INTEGER :: N
-      REAL(q) :: EXHF
-!-----------------------------------------------------------------------
-! double k-points in new structure
-! in the upper part of the wavefunction arrays the wavefunctions 
-! corresponding to the new shifted k-points are stored
-! in the lower part the original wavefunctions are stored
-!-----------------------------------------------------------------------
-
-      IF (KPOINTS%NKPX<1 .OR. KPOINTS%NKPY<1 .OR. KPOINTS%NKPZ<1 )  THEN
-         ! here we need some warning
-         ! the routine works only using regular gamma centered grids
-         WRITE(*,*) ' INTERPOLATE_BAND_STR: requires a regular k-point grid '
-         RETURN
-      ENDIF
-
-      CALL CHECK_FULL_KPOINTS
-
-      ! original number of k-points
-      NKPTS_ORIG=W%WDES%NKPTS
-#ifdef oldsym
-      CALL RE_READ_KPOINTS(KPOINTS,LATT_CUR, &
-           SYMM%ISYM>=0.AND..NOT.W%WDES%LSORBIT.AND..NOT.W%WDES%LSPIRAL, &
-           T_INFO%NIONS,SYMM%ROTMAP,SYMM%MAGROT,SYMM%ISYM, IU6, IU0, W%WDES%VKPT(:,1:NKPTS_ORIG))
-#else
-      CALL RE_READ_KPOINTS(KPOINTS,LATT_CUR, &
-           SYMM%ISYM>=0.AND..NOT.W%WDES%LNONCOLLINEAR, &
-           T_INFO%NIONS,SYMM%ROTMAP,SYMM%MAGROT,SYMM%ISYM, IU6, IU0, W%WDES%VKPT(:,1:NKPTS_ORIG))
-#endif
-      CALL KPAR_SYNC_ALL(W%WDES,W)
-      CALL RE_GEN_LAYOUT( GRID, W%WDES, KPOINTS, LATT_CUR, LATT_INI, IU6, IU0)
-      CALL REALLOCATE_WAVE( W, GRID, W%WDES, NONL_S, T_INFO, P, LATT_CUR)
-
-      CALL XML_TAG("eigenvalues", comment="interpolated")
-!-----------------------------------------------------------------------
-! loop over new super k-point grid
-! a  kind of Wigner Seitz procedure is used to generate the new supergrid
-! this can be bypassed by setting IWZ to 0
-! a few notes are in place here
-! ) only gamma centered grids do not violate the symmetry
-!   and are therefore recommended
-! ) such super grids are created by setting KINTER to an odd value
-! ) otherwise the super grids might spoil the symmetry
-!-----------------------------------------------------------------------
-      IWZ=2
-      KSTART=-REAL(ABS(KINTER),q)/2+0.5_q
-      DOS =0
-      DOSI=0
-      EFERMI=0
-
-      DO IKX=0,ABS(KINTER)-1
-      DO IKY=0,ABS(KINTER)-1
-      DO IKZ=0,ABS(KINTER)-1
-
-         ! search the equivalent k-point with the shortest length
-         DIST_FOUND=1E6
-         DO IKXP=-IWZ,IWZ
-         DO IKYP=-IWZ,IWZ
-         DO IKZP=-IWZ,IWZ
-            DISPL(1)=((IKX+KSTART)/ABS(KINTER)+IKXP)/KPOINTS%NKPX
-            DISPL(2)=((IKY+KSTART)/ABS(KINTER)+IKYP)/KPOINTS%NKPY
-            DISPL(3)=((IKZ+KSTART)/ABS(KINTER)+IKZP)/KPOINTS%NKPZ
-            ! k-point displacement in cartesian coordinates
-            DISPL_CART=DISPL
-            CALL DIRKAR(1, DISPL_CART(1), LATT_CUR%B)
-            DIST=DISPL_CART(1)**2+DISPL_CART(2)**2+DISPL_CART(3)**2
-            IF (DIST<DIST_FOUND) THEN
-               DISPL_FOUND=DISPL
-               DIST_FOUND =DIST
-            ENDIF
-         ENDDO
-         ENDDO
-         ENDDO
-         
-         DISPL=DISPL_FOUND
-         DISPL_CART=DISPL
-         CALL DIRKAR(1, DISPL_CART(1), LATT_CUR%B)
-
-         DO NK=1,NKPTS_ORIG
-            W%WDES%VKPT(:,NKPTS_ORIG+NK)=W%WDES%VKPT(:,NK)+DISPL
-         ENDDO
-
-         IF (PRESENT(RPHI)) THEN
-            DO ISP=1,W%WDES%ISPIN
-               DO NK=1,NKPTS_ORIG
-                  DO N=1,W%WDES%NBANDS
-                     W%CW(:,N,NKPTS_ORIG+NK,ISP)=W%CW(:,N,NK,ISP)+TPI*( &
-                          RPHI(:,N,NK,ISP,1)*(0.0_q,1.0_q)*DISPL_CART(1)+ & 
-                          RPHI(:,N,NK,ISP,2)*(0.0_q,1.0_q)*DISPL_CART(2)+ &
-                          RPHI(:,N,NK,ISP,3)*(0.0_q,1.0_q)*DISPL_CART(3))
-                  ENDDO
-               ENDDO
-            ENDDO
-         ELSE
-            DO ISP=1,W%WDES%ISPIN
-               DO NK=1,NKPTS_ORIG
-                  DO N=1,W%WDES%NBANDS
-                     W%CW(:,N,NKPTS_ORIG+NK,ISP)=W%CW(:,N,NK,ISP)
-                  ENDDO
-               ENDDO
-            ENDDO
-         ENDIF
-         CALL SET_DATAKE(W%WDES, LATT_CUR%B)
-         IF (NONLR_S%LREAL) THEN
-            CALL RSPHER(GRID,NONLR_S,LATT_CUR)
-         ELSE
-            CALL SPHER(GRID,NONL_S,P,W%WDES,LATT_CUR, 1)
-         ENDIF
-         CALL PROALL (GRID,LATT_CUR,NONLR_S,NONL_S,W)
-
-         CALL ORTHCH(W%WDES,W, W%WDES%LOVERL, LMDIM, CQIJ)
-         
-         CALL EDDIAG(HAMILTONIAN,GRID,LATT_CUR,NONLR_S,NONL_S,W,W%WDES,SYMM, &
-              LMDIM,CDIJ,CQIJ,2,SV,T_INFO,P,IU0,EXHF, & 
-              NKSTART=NKPTS_ORIG+1)
-
-         IF (KPOINTS%ISMEAR>=0) THEN
-         ! well this is not elegant, we now simply set the weights for
-         ! lower k-point set to 0, and that for the upper one to the
-         ! proper weight
-         KPOINTS%WTKPT(NKPTS_ORIG+1:NKPTS_ORIG*2)=KPOINTS%WTKPT(1:NKPTS_ORIG)
-         KPOINTS%WTKPT(1:NKPTS_ORIG)=0
-
-         ! sum dos
-         CALL DENSTA( IU0, IU6, W%WDES, W, KPOINTS, NELECT, &
-              NUP_DOWN, ENTROPY, EFERMI_TMP, KPOINTS%SIGMA, .TRUE., &
-              NEDOS, 0, 0, DOS_TMP, DOSI_TMP, PAR, DOSPAR)
-
-         ! restore weights
-         KPOINTS%WTKPT(1:NKPTS_ORIG)=KPOINTS%WTKPT(NKPTS_ORIG+1:NKPTS_ORIG*2)
-         KPOINTS%WTKPT(NKPTS_ORIG+1:NKPTS_ORIG*2)=0
-
-         DOS =DOS +DOS_TMP *(1_q/REAL(KINTER,q)/REAL(KINTER,q)/REAL(KINTER,q))
-         DOSI=DOSI+DOSI_TMP*(1_q/REAL(KINTER,q)/REAL(KINTER,q)/REAL(KINTER,q))
-         EFERMI=EFERMI+EFERMI_TMP*(1_q/REAL(KINTER,q)/REAL(KINTER,q)/REAL(KINTER,q))
-         ENDIF
-
-         IF (IU6>=0) THEN
-            
-            DO ISP=1,W%WDES%ISPIN
-               WRITE(IU6,'(/" k-point displacement            :",3F10.4 )') DISPL
-               WRITE(IU6,'( " k-point displacement (cartesian):",3F10.4 )') DISPL_CART
-               IF (W%WDES%ISPIN==2) WRITE(IU6,'(/A,I1)') ' spin component ',ISP
-               DO N=NKPTS_ORIG+1,W%WDES%NKPTS
-                  WRITE(IU6,2201) N-NKPTS_ORIG, W%WDES%VKPT(1,N),W%WDES%VKPT(2,N),W%WDES%VKPT(3,N), &
-                       &             (I,REAL( W%CELTOT(I,N,ISP) ,KIND=q) ,W%FERTOT(I,N,ISP)*W%WDES%RSPIN,I=1,W%WDES%NB_TOT)
-               ENDDO
-            ENDDO
-2201        FORMAT(/' k-point ',I3,' :',3X,3F10.4/ &
-                 &         '  band No.  band energies     occupation '/ &
-                 &           (3X,I4,3X,F10.4,3X,F10.5))
-
-            
-         ENDIF
-
-         CALL XML_VEC_REAL( DISPL, "displacement" )
-         CALL XML_VEC_REAL( DISPL_CART, "displacement_cart" )
-
-         CALL XML_EIGENVAL_NOHEAD( W%CELTOT(:,NKPTS_ORIG+1:W%WDES%NKPTS,:), W%FERTOT(:,NKPTS_ORIG+1:W%WDES%NKPTS,:), &
-              W%WDES%NB_TOT, W%WDES%NKPTS-NKPTS_ORIG, W%WDES%ISPIN)
-      
-      ENDDO
-      ENDDO
-      ENDDO
-!-----------------------------------------------------------------------
-! restore old data layout
-!-----------------------------------------------------------------------
-      CALL XML_CLOSE_TAG
-#ifdef oldsym
-      CALL RE_READ_KPOINTS(KPOINTS,LATT_CUR, &
-           SYMM%ISYM>=0.AND..NOT.W%WDES%LSORBIT.AND..NOT.W%WDES%LSPIRAL, &
-           T_INFO%NIONS,SYMM%ROTMAP,SYMM%MAGROT,SYMM%ISYM,-1,-1)
-#else
-      CALL RE_READ_KPOINTS(KPOINTS,LATT_CUR, &
-           SYMM%ISYM>=0.AND..NOT.W%WDES%LNONCOLLINEAR, &
-           T_INFO%NIONS,SYMM%ROTMAP,SYMM%MAGROT,SYMM%ISYM,-1,-1)
-#endif
-      CALL RE_GEN_LAYOUT( GRID, W%WDES, KPOINTS, LATT_CUR, LATT_INI, -1, -1)
-      CALL REALLOCATE_WAVE( W, GRID, W%WDES, NONL_S, T_INFO, P, LATT_CUR)
-
-      IF (KPOINTS%ISMEAR>=0) THEN
-      CALL XML_DOS(EFERMI, KPOINTS%EMIN, KPOINTS%EMAX, .FALSE., &
-           DOS, DOSI, DOSPAR, NEDOS, 1, 1, W%WDES%NCDIJ, comment='interpolated')
-      ENDIF
-
-
-    END SUBROUTINE INTERPOLATE_BAND_STR
-
-
-!************** SUBROUTINE INTERPOLATE_BANDSTR_GRDSHFT *****************
-!************************************************************************
-
-    SUBROUTINE INTERPOLATE_BANDSTR_GRDSHFT(HAMILTONIAN, E, KPOINTS, GRID, LATT_CUR, LATT_INI, & 
-       &    T_INFO, NONLR_S, NONL_S, W, NEDOS, &
-       &    LMDIM, P, SV, CQIJ, CDIJ, SYMM, INFO, IO, GRIDC, GRIDUS, C_TO_US, IRDMAX, RPHI)
-      USE prec
-      USE wave_high
-      USE hamil_high
-      USE lattice
-      USE poscar
-      USE mpimy
-      USE mgrid
-      USE nonl_high
-      USE base
-      USE pseudo
-      USE kpoints_change
-      USE constant
-      USE choleski
-      USE subrot
-      USE subrot_cluster
-      USE mlr_optic
-      USE mlrf_main
-      USE ini
-      USE david
-      IMPLICIT NONE
-
-      TYPE (ham_handle)     :: HAMILTONIAN
-      TYPE (energy)         :: E
-      TYPE (kpoints_struct) :: KPOINTS
-      TYPE (grid_3d)        :: GRID
-      TYPE (latt)           :: LATT_CUR
-      TYPE (latt)           :: LATT_INI
-      TYPE (type_info)      :: T_INFO
-      TYPE (nonlr_struct)   :: NONLR_S
-      TYPE (nonl_struct)    :: NONL_S
-      TYPE (potcar)         :: P(:)
-      TYPE (grid_3d)        :: GRIDC 
-      TYPE (grid_3d)        :: GRIDUS
-      TYPE (transit)        :: C_TO_US
-      TYPE (info_struct)    :: INFO
-      TYPE (in_struct)      :: IO
-      TYPE (symmetry)       :: SYMM
-      INTEGER               :: LMDIM, NEDOS
-      TYPE (wavespin), TARGET :: W
-      TYPE (eigenf_cluster_pointer),POINTER :: DEG_CLUSTER(:,:)
-      OVERLAP :: CQIJ (LMDIM,LMDIM,W%WDES%NIONS,W%WDES%NCDIJ)
-      OVERLAP :: CDIJ (LMDIM,LMDIM,W%WDES%NIONS,W%WDES%NCDIJ)
-      RGRID   :: SV(DIMREAL(GRID%MPLWV),W%WDES%NCDIJ)
-      REAL(q) :: DOS(NEDOS,W%WDES%ISPIN),DOSI(NEDOS,W%WDES%ISPIN)
-      COMPLEX(qs), OPTIONAL :: RPHI(:,:,:,:,:)
-      
-      TYPE (kpoints_struct) :: KPOINTS_INTER
-      TYPE (skpoints_full),SAVE,POINTER :: KPOINTS_INTER_FULL
-      TYPE (skpoints_full),SAVE,POINTER :: KPOINTS_FULL_TEMP
-      TYPE (wavedes)  :: WDES_INTER
-      TYPE (wavespin) :: W_INTER
-      TYPE (wavespin) :: WDIFF
-      ! eFL: I DO NOT THINK ALLOCW NEEDS THIS, REMOVE?
-      TYPE (wavefun)  :: WTMP
-
-      LOGICAL :: LDONE, LWARN, LDO_VEL
-      INTEGER :: I, L, K, J, ISP, NK, NPOS, NEDOS_DIEL, KPAR
-      INTEGER :: DISPINDEX, IBZINDEX, IDIR, JDIR, IRDMAX
-      INTEGER :: IK, N, NB, NB2, NSIM, NELM, ICOUEV, IWINDOW
-      REAL(q) :: EXHF, RMS, DESUM1, TOTEN, TOTENINTER, TOTENRDIFF, WO
-      REAL(q) :: TOTENORG, OTHERTERMS, EBANDSTR_INTER, DELTAE, EMAX
-      REAL(q) :: DER(3)
-      INTEGER :: MULTIPL(3)
-      REAL(q) :: EFERMI, ENTROPY, PAR(1,1,1,1,W%WDES%NCDIJ)
-      REAL(q) :: DOSPAR(1,1,1,W%WDES%NCDIJ)
-      REAL(q), ALLOCATABLE :: DISPL(:,:)
-      REAL(q) :: DISPLV(3), DISPLV_CART(3)
-      REAL(q), ALLOCATABLE :: EDER(:,:,:,:)
-      REAL(q), ALLOCATABLE :: EINTERPOL_FULL(:,:,:,:), EINTERPOL(:,:,:,:)
-      REAL(q), ALLOCATABLE :: KINTERPOL(:,:)
-      GDEFS, ALLOCATABLE :: CHAMD(:,:,:,:,:)
-      GDEFS, ALLOCATABLE :: CHAM(:,:,:,:,:)
-      COMPLEX(q), ALLOCATABLE  :: EPSDD(:,:,:)
-      COMPLEX(q), ALLOCATABLE  :: EPSJJ(:,:,:)
-      REAL(q), ALLOCATABLE :: WPLASM(:,:), COND(:,:)
-      REAL(q), ALLOCATABLE :: BIMAG(:,:)
-      COMPLEX(q), ALLOCATABLE :: CW_OLD(:,:,:,:)
-      REAL(q), ALLOCATABLE :: VKPT_OLD(:,:)
-      REAL(q) :: S(3,3)
-
-      INTEGER  ISYMOP,NROT,IGRPOP,NROTK,INVMAP,NPCELL
-      REAL(q)  GTRANS,AP
-      COMMON /SYMM/   ISYMOP(3,3,48),NROT,IGRPOP(3,3,48),NROTK, &
-           GTRANS(3,48),INVMAP(48),AP(3,3),NPCELL
-
-#ifdef MPI
-      IF (W%WDES%COMM_KINTER%NCPU.NE.1) THEN
-         CALL VTUTOR('E','NOKPAR',0.0_q,1,0,1,(0.0_q,0.0_q),1, &
-              .TRUE.,1, IO%IU6,3)
-         CALL VTUTOR('S','NOKPAR',0.0_q,1,0,1,(0.0_q,0.0_q),1, &
-              .TRUE.,1, IO%IU0,3)
-         RETURN
-      ENDIF
-#endif
-
-      IF (KPOINTS%ISMEAR <= -4) THEN
-         CALL VTUTOR('E','GRDSHFT_NOTET',0.0_q,1,0,1,(0.0_q,0.0_q),1, &
-              .TRUE.,1, IO%IU6,3)
-         CALL VTUTOR('S','GRDSHFT_NOTET',0.0_q,1,0,1,(0.0_q,0.0_q),1, &
-              .TRUE.,1, IO%IU0,3)
-         RETURN
-      ENDIF
-
-      LDO_VEL=LVEL.OR.IO%LOPTICS
-
-      TOTENORG = BANDSTRUCTURE_ENERGY(W%WDES,W)+E%DENC+E%XCENC+E%TEWEN+ &
-           E%PSCENC+E%EENTROPY+ E%PAWPS+E%PAWAE+INFO%EALLAT+E%EXHF
-      
-      CALL GENERATE_GRDSHFT_GRD_AND_DISPL(KPOINTS, W%WDES, LATT_CUR, T_INFO, &
-           SYMM, IO, KINTER, KPOINTS_INTER, KPOINTS_INTER_FULL, DISPL)
-      
-      ALLOCATE(EINTERPOL(W%WDES%NB_TOT,KPOINTS_INTER%NKPTS,W%WDES%ISPIN,4), & 
-               KINTERPOL(3,KPOINTS_INTER%NKPTS), VKPT_OLD(3,KPOINTS%NKPTS), &
-               CW_OLD(SIZE(W%CW,1),W%WDES%NBANDS,KPOINTS%NKPTS,W%WDES%ISPIN))
-      
-      EFERMI=0.0
-      DOS =0.0
-      DOSI=0.0
-     
-      IF (IO%LOPTICS) THEN
-         NEDOS_DIEL=MAX(NEDOS,1000)
-         ALLOCATE(EPSDD(NEDOS_DIEL,3,3), EPSJJ(NEDOS_DIEL,3,3), &
-              WPLASM(3,3), COND(3,3), BIMAG(3,3), &
-              CHAMD(W%WDES%NB_TOT, W%WDES%NB_TOT, W%WDES%NKPTS, &
-              W%WDES%ISPIN, 3), &
-              CHAM(W%WDES%NB_TOT, W%WDES%NB_TOT, KPOINTS_INTER%NKPTS, &
-              W%WDES%ISPIN, 3))
-         
-         EPSDD=0
-         EPSJJ=0
-         BIMAG=0
-         
-         ! eFL: NOT SO SURE ABOUT THIS BUCKET THING FOR EACH DIFFERENT
-         !      DISPLACEMENT. I SUSPECT THIS MIGHT CHANGE SLIGHTLY, SAY
-         !      WE HIT A K-POINT THAT MODIFIES THIS RANGE WHILE DISPLACING
-         !      MAYBE DO THIS FOR EACH DISPLACEMENT...BUT THEN WE HAVE THE
-         !      PROBLEM OF A DIFFERENT dENERGY FOR EACH INDEX...HMMM...
-         !      SO HERE WE USE THE BUCKETING FROM THE INPUT GRID
-         EMAX=MAX_ENERGY_UNOCCUPIED(W%WDES,W)*1.2
-         IF (EMAX<=0) THEN
-            CALL VTUTOR('E','NOOCC',0.0_q,1,0,1,(0.0_q,0.0_q),1,.TRUE.,1, &
-                 IO%IU6,3)
-            CALL VTUTOR('S','NOOCC',0.0_q,1,0,1,(0.0_q,0.0_q),1,.TRUE.,1, &
-                 IO%IU0,3)
-            RETURN
-         ENDIF
-         DELTAE=EMAX/(NEDOS_DIEL-1)
-         
-         CALL DENSTA( IO%IU0, IO%IU6, W%WDES, W, KPOINTS, &
-              INFO%NELECT, INFO%NUP_DOWN, ENTROPY, EFERMI, &
-              KPOINTS%SIGMA, .TRUE., NEDOS, 0, 0, &
-              DOS, DOSI, PAR, DOSPAR)
-      ENDIF
-      
-      IF (LDO_VEL) THEN
-         ALLOCATE(EDER(W%WDES%NB_TOT,KPOINTS%NKPTS,W%WDES%ISPIN,3)) 
-         CALL ALLOCW(W%WDES,WDIFF,WTMP,WTMP)
-      ENDIF
-
-      DO ISP=1,W%WDES%ISPIN
-         DO NK=1,KPOINTS%NKPTS
-            IF (ISP==1) THEN
-               VKPT_OLD(:,NK)=W%WDES%VKPT(:,NK)
-            ENDIF
-            DO N=1,W%WDES%NBANDS
-               CW_OLD(:,N,NK,ISP)=W%CW(:,N,NK,ISP)
-            ENDDO
-         ENDDO
-      ENDDO
-
-      
-      EINTERPOL=0.0
-      KINTERPOL=0.0
-      IBZINDEX=1
-      DISPINDEX=1
-
-      WDES_INTER=W%WDES
-      WDES_INTER%NKPTS= KPOINTS_INTER%NKPTS
-      WDES_INTER%VKPT =>KPOINTS_INTER%VKPT
-      WDES_INTER%WTKPT=>KPOINTS_INTER%WTKPT
-
-      CALL ALLOCW_NOPLANEWAVE(WDES_INTER, W_INTER)
-
-      IF (IO%IU0>=0) WRITE(IO%IU0,*) ' '
-      IF (IO%IU0>=0) WRITE(IO%IU0,*) &
-           '------------------------------------------------'// &
-           '--------------'
-      IF (IO%IU0>=0) WRITE(IO%IU0,*) &
-           'Starting gridshift interpolation of the bandstructure'
-      IF (IO%IU0>=0) WRITE(IO%IU0,*) &
-           '  original grid sampling:', KPOINTS%NKPX, &
-           KPOINTS%NKPY, KPOINTS%NKPZ
-      IF (IO%IU0>=0) WRITE(IO%IU0,*) &
-           '  new grid grid sampling:', KPOINTS%NKPX*ABS(KINTER), &
-           KPOINTS%NKPY*ABS(KINTER), KPOINTS%NKPZ*ABS(KINTER)
-      IF (IO%IU0>=0) WRITE(IO%IU0,*) &
-           '------------------------------------------------'// &
-           '--------------'
-            
-      DO IK=1,ABS(KINTER*KINTER*KINTER)
-         IF (IO%IU0>=0) THEN
-            WRITE(IO%IU0,*) 'Displacement', IK
-            WRITE(17,*)     'Displacement', IK
-         ENDIF
-
-         DISPLV=DISPL(:,IK)
-
-         DISPLV_CART=DISPLV
-         CALL DIRKAR(1, DISPLV_CART(1), LATT_CUR%B)
-
-         DO NK=1,KPOINTS%NKPTS
-            W%WDES%VKPT(:,NK)=VKPT_OLD(:,NK)+DISPLV
-         ENDDO
-
-         IF (KINTER>=0) THEN
-            DO ISP=1,W%WDES%ISPIN
-               DO NK=1,KPOINTS%NKPTS
-                  DO NB=1,W%WDES%NBANDS
-                     ! eFL: Here we not use RPHI even if we hit a
-                     ! displaced k-point that exists in the input IBZ
-                     ! The accuracy would most likely be improve by using
-                     ! the orginal CW values at these points.
-                     ! For this we need a mapping table between the
-                     ! KPOINTS_INTER and the grid created by the
-                     ! displacements
-                     W%CW(:,NB,NK,ISP)=CW_OLD(:,NB,NK,ISP)+TPI*( &
-                          RPHI(:,NB,NK,ISP,1)*(0.0_q,1.0_q)*DISPLV_CART(1)+ & 
-                          RPHI(:,NB,NK,ISP,2)*(0.0_q,1.0_q)*DISPLV_CART(2)+ &
-                          RPHI(:,NB,NK,ISP,3)*(0.0_q,1.0_q)*DISPLV_CART(3))
-                  ENDDO
-               ENDDO
-            ENDDO
-         ELSE
-            DO ISP=1,W%WDES%ISPIN
-               DO NK=1,KPOINTS%NKPTS
-                  DO NB=1,W%WDES%NBANDS
-                     W%CW(:,NB,NK,ISP)=CW_OLD(:,NB,NK,ISP)
-                  ENDDO
-               ENDDO
-            ENDDO
-         ENDIF
-         CALL SET_DATAKE(W%WDES, LATT_CUR%B)
-         IF (NONLR_S%LREAL) THEN
-            CALL RSPHER(GRID,NONLR_S,LATT_CUR)
-         ELSE
-            CALL SPHER(GRID,NONL_S,P,W%WDES,LATT_CUR, 1)
-         ENDIF
-         CALL PROALL (GRID,LATT_CUR,NONLR_S,NONL_S,W)
-
-         CALL ORTHCH(W%WDES,W, W%WDES%LOVERL, LMDIM, CQIJ)        
-
-         IF (.NOT. LINTERFAST) THEN
-            NSIM=W%WDES%NSIM*2
-#ifdef MPI
-            NSIM=((W%WDES%NSIM*2+W%WDES%COMM_INTER%NCPU-1)/ &
-                 W%WDES%COMM_INTER%NCPU)*W%WDES%COMM_INTER%NCPU
-#endif
-            DO NELM=1,10
-               CALL EDDAV(HAMILTONIAN,P, GRID,INFO,LATT_CUR,NONLR_S,NONL_S, &
-                    W,W%WDES, NSIM, LMDIM,CDIJ,CQIJ, RMS,DESUM1,ICOUEV, SV, &
-                    E%EXHF, IO%IU6,IO%IU0, .FALSE., .TRUE., .FALSE.)
-               E%EBANDSTR=BANDSTRUCTURE_ENERGY(W%WDES, W)
-
-               IF (IO%IU0>=0) WRITE(17, 200)      &
-                    NELM,E%EBANDSTR,E%EBANDSTR-TOTEN,DESUM1,ICOUEV,RMS
-               IF (IO%IU0>=0) WRITE(IO%IU0, 200)  &
-                    NELM,E%EBANDSTR,E%EBANDSTR-TOTEN,DESUM1,ICOUEV,RMS
-
-               TOTEN=E%EBANDSTR
-           
-200            FORMAT('DAV: ',I3,'   ',E20.12,'   ',E12.5,'   ',E12.5, &
-                    &       I6,'  ',E10.3)
-               
-               IF (ABS(DESUM1) < ABS(INFO%EDIFF) ) EXIT
-            ENDDO
-         ELSE IF (LDO_VEL) THEN
-            CALL EDDIAG(HAMILTONIAN,GRID,LATT_CUR,NONLR_S,NONL_S,W,W%WDES, &
-                 SYMM, LMDIM,CDIJ,CQIJ,3,SV,T_INFO,P,IO%IU0,EXHF)
-         ELSE
-            CALL EDDIAG(HAMILTONIAN,GRID,LATT_CUR,NONLR_S,NONL_S,W,W%WDES, &
-                 SYMM,LMDIM,CDIJ,CQIJ,2,SV,T_INFO,P,IO%IU0,EXHF)
-         ENDIF
-
-         E%EBANDSTR=BANDSTRUCTURE_ENERGY(W%WDES, W)
-
-! eFL: MARTIJN, CAN YOU CHECK IF THESE THINGS ARE OKEY FOR
-!      ISPIN=2? I THINK SO...
-
-         IF (LDO_VEL) THEN
-            WDIFF%CW   =0
-            WDIFF%CPROJ=0
-
-            NULLIFY(DEG_CLUSTER)
-            CALL FIND_DEG_CLUSTERS(W%WDES, W, DEG_CLUSTER)
-
-            IF (LUSEPEAD()) THEN
-               ALLOCATE(KPOINTS_FULL_TEMP)
-               KPOINTS_FULL_TEMP = KPOINTS_FULL
-               KPOINTS_FULL = KPOINTS_INTER_FULL
-            ENDIF
- 
-            IF (IO%LOPTICS) THEN
-               IF (IO%IU0>=0) WRITE(IO%IU0,*) 'Calculating the energy '// &
-                    'derivatives and density matrix the displaced '// &
-                    'fine grid:'
-            ELSE
-               IF (IO%IU0>=0) WRITE(IO%IU0,*) 'Calculating the energy '// &
-                    'derivatives on the displaced fine grid:'
-            ENDIF
-
-            DO IDIR=1,3
-               IF (IO%IU0>=0) WRITE(IO%IU0,'(A,I4)') '  Direction:',IDIR
-
-               IF (LUSEPEAD()) THEN
-                  WDIFF%CW=0
-                  WDIFF%CPROJ=0
-                  WDIFF%CELTOT=0
-                  CALL PEAD_DPSI_DK_IDIR(W,KPOINTS,P,CQIJ,LATT_CUR, &
-                       T_INFO,IDIR,WDIFF)
-               ELSE
-                  CALL FOCK_K_DER_ANALYT(KPOINTS, GRID, LATT_CUR, LATT_INI, &
-                       T_INFO,  NONLR_S, NONL_S, W, WDIFF, LMDIM, P, CQIJ, &
-                       SYMM, IDIR, LDONE, IO%IU0, IO%IU6)
-
-                  CALL LRF_RPHI0( &
-                       P,NONLR_S,NONL_S,W,LATT_CUR, &
-                       T_INFO,INFO,IO,GRID,GRIDC,GRIDUS,C_TO_US,IRDMAX, &
-                       CDIJ,CQIJ,SV,LMDIM,DEG_CLUSTER, IDIR, WDIFF, LDONE)
-               ENDIF
-
-               IF (IO%LOPTICS) THEN
-                  CALL INPROD_W(WDIFF,W,CHAMD(:,:,:,:,IDIR), &
-                       W%WDES%LOVERL,IO%IU0)
-               ENDIF
-               DO ISP=1,W%WDES%ISPIN
-                  DO NK=1,W%WDES%NKPTS
-                     DO NB=1,W%WDES%NB_TOT
-                        EDER(NB,NK,ISP,IDIR)=REAL(WDIFF%CELTOT(NB,NK,ISP),KIND=q)
-                     ENDDO
-                  ENDDO
-               ENDDO
-            ENDDO
-         ENDIF
-
-         IF(LUSEPEAD()) THEN
-            KPOINTS_FULL = KPOINTS_FULL_TEMP            
-         ENDIF
-         
-         DO N=1,KPOINTS%NKPTS
-            NK=KPOINT_IN_FULL_GRID_KINTER(W%WDES%VKPT(:,N),KPOINTS_INTER)
-            IF (NK/=-1) THEN
-               DO IDIR=1,3
-                  KINTERPOL(IDIR,NK)=W%WDES%VKPT(IDIR,N)
-               ENDDO
-               DO ISP=1,W%WDES%ISPIN
-                  DO NB=1,W%WDES%NB_TOT
-                     EINTERPOL(NB,NK,ISP,1)=REAL(W%CELTOT(NB,N,ISP),KIND=q)
-                     W_INTER%CELTOT(NB,NK,ISP)=W%CELTOT(NB,N,ISP)
-                     W_INTER%FERTOT(NB,NK,ISP)=W%FERTOT(NB,N,ISP)
-                     IF (LDO_VEL) THEN
-                        DO IDIR=1,3
-                           IF (IO%LOPTICS) THEN
-                              DO NB2=1,W%WDES%NB_TOT
-                                 CHAM(NB,NB2,NK,ISP,IDIR) = &
-                                      CHAMD(NB,NB2,N,ISP,IDIR)
-                              ENDDO
-                           ENDIF
-                           EINTERPOL(NB,NK,ISP,IDIR+1)=EDER(NB,N,ISP,IDIR)
-                        ENDDO
-                     ENDIF
-                  ENDDO
-               ENDDO
-            ENDIF
-         ENDDO
-         DISPINDEX=DISPINDEX+1
-      ENDDO
-
-      IF (.NOT. LDO_VEL) THEN
-         CALL XML_TAG("eigenvalues", comment="interpolated")
-         CALL XML_TAG("kpoints")
-         CALL XML_KPOINTS_LIST(KINTERPOL, KPOINTS_INTER%WTKPT)
-         CALL XML_CLOSE_TAG("kpoints")
-         CALL XML_EIGENVALUES_EXT(EINTERPOL,1, W%WDES%NB_TOT, &
-              KPOINTS_INTER%NKPTS, W%WDES%ISPIN)
-         CALL XML_CLOSE_TAG("eigenvalues")
-      ENDIF
-
-      IF (IO%LOPTICS) THEN
-         NBANDS_CDER=MIN(LAST_FILLED_OPTICS(W_INTER)*2, W_INTER%WDES%NB_TOT)
-         IF (IO%IU0>=0) WRITE(IO%IU0,*) 'Calculating the imaginary ' // &
-              'part of the dielectric function.'
-         
-         DO IDIR=1,3
-            DO JDIR=1,3
-               CALL EPSILON_IMAG(W_INTER%WDES, W_INTER, CHAM(:,:,:,:,IDIR), &
-                    CHAM(:,:,:,:,JDIR), EINTERPOL(:,:,:,IDIR+1), &
-                    EINTERPOL(:,:,:,JDIR+1), EFERMI, NEDOS_DIEL, &
-                    EPSDD(:,IDIR,JDIR), EPSJJ(:,IDIR,JDIR), DELTAE, &
-                    KPOINTS%ISMEAR, KPOINTS%SIGMA, LATT_CUR%OMEGA, &
-                    WPLASM(IDIR, JDIR), COND(IDIR, JDIR), &
-                    BIMAG(IDIR, JDIR), RTIME, LCSHIFT)
-            ENDDO
-         ENDDO
-         
-         IF (KPOINTS%ISMEAR >= -1) THEN
-            CALLMPI( M_sum_z(W%WDES%COMM, EPSDD, SIZE(EPSDD)))
-            CALLMPI( M_sum_z(W%WDES%COMM, EPSJJ, SIZE(EPSJJ)))
-            CALLMPI( M_sum_d(W%WDES%COMM, BIMAG, SIZE(BIMAG)))
-         ENDIF
-         
-
-         ! eFL: MARTIJN, IS THE ISYMOP AND NROTK OKEY HERE FOR GENERAL CASES?
-         DO I=1,NEDOS_DIEL
-            IF (SYMM%ISYM>0) THEN
-               CALL TSYM_CMPLX(EPSDD(I,:,:),ISYMOP,NROTK,LATT_CUR%A)
-            ENDIF
-            IF (SYMM%ISYM>0) THEN
-               CALL TSYM_CMPLX(EPSJJ(I,:,:),ISYMOP,NROTK,LATT_CUR%A)
-            ENDIF
-         ENDDO
-         
-         IF (SYMM%ISYM>0) CALL TSYM(WPLASM(:,:),ISYMOP,NROTK,LATT_CUR%A)
-         IF (SYMM%ISYM>0) CALL TSYM(BIMAG(:,:),ISYMOP,NROTK,LATT_CUR%A)
-      
-      
-         
-         IWINDOW=0
-         LWARN=.FALSE.
-         IF (IO%IU0>=0) WRITE(IO%IU0,*) 'Calculating the real ' // &
-              'part of the dielectric function.'
-         DO IDIR=1,3
-            DO JDIR=1,3
-               CALL EPSILON_REAL(W%WDES%COMM, NEDOS_DIEL, &
-                    EPSDD(:,IDIR,JDIR), LWARN, DELTAE, LCSHIFT, IWINDOW)
-               IF (JDIR==IDIR) THEN
-                  EPSDD(:,IDIR,IDIR)=EPSDD(:,IDIR,IDIR)+1
-               ENDIF
-               CALL EPSILON_REAL(W%WDES%COMM, NEDOS_DIEL, &
-                    EPSJJ(:,IDIR,JDIR), LWARN, DELTAE, LCSHIFT, IWINDOW)
-            ENDDO
-         ENDDO
-         IF (LWARN) THEN
-            CALL VTUTOR('W','SMALL CSHIFT',0.0_q,1, &
-                 &           0,1,(0.0_q,0.0_q),1,.FALSE.,1,IO%IU6,2)
-            CALL VTUTOR('W','SMALL CSHIFT',0.0_q,1, &
-                 &           0,1,(0.0_q,0.0_q),1,.FALSE.,1,IO%IU0,2)
-         ENDIF
-         
-         DO IDIR=1,3
-            DO JDIR=1,3
-               IF (IDIR==JDIR) CYCLE
-#ifdef timeordered
-               DO I=2,NEDOS_DIEL
-                  EPSDD(I,IDIR,JDIR)=EPSDD(I,IDIR,JDIR)+ &
-                       (0._q,1._q)*BIMAG(IDIR,JDIR)/(DELTAE*(I-1))
-               ENDDO
-               EPSDD(1,IDIR,JDIR)=EPSDD(2,IDIR,JDIR)
-#else
-               DO I=1,NEDOS_DIEL
-                  EPSDD(I,IDIR,JDIR)=EPSDD(I,IDIR,JDIR)+ &
-                       (0._q,1._q)*BIMAG(IDIR,JDIR)/(DELTAE*(I-1)+ &
-                       CMPLX(0,LCSHIFT,q))
-               ENDDO
-#endif
-            ENDDO
-         ENDDO
-         DO IDIR=1,3
-            DO JDIR=1,3
-               DO I=2,NEDOS_DIEL
-                  EPSJJ(I,IDIR,JDIR)=(EPSJJ(I,IDIR,JDIR)- &
-                       EPSJJ(1,IDIR,JDIR))/(DELTAE*(I-1))**2
-               ENDDO
-               IF (JDIR==IDIR) EPSJJ(:,IDIR,IDIR)=EPSJJ(:,IDIR,IDIR)+1
-            ENDDO
-         ENDDO
-         EPSJJ(1,:,:)=EPSJJ(2,:,:)
-         IF (WPLASMAI>0) THEN
-            DO IDIR=1,3
-               DO I=1,NEDOS_DIEL
-                  WO=DELTAE*(I-1)
-                  EPSDD(I,IDIR,IDIR)=EPSDD(I,IDIR,IDIR)+ &
-                       WPLASMON(IDIR,IDIR)/(WO**2+WPLASMAI**2)* &
-                       CMPLX(-1.0_q,WPLASMAI/MAX(WO,DELTAE))
-                  EPSJJ(I,IDIR,IDIR)=EPSJJ(I,IDIR,IDIR)+ &
-                       WPLASMON(IDIR,IDIR)/(WO**2+WPLASMAI**2)* &
-                       CMPLX(-1.0_q,WPLASMAI/MAX(WO,DELTAE))
-               ENDDO
-            ENDDO
-         ENDIF
-         
-         CALL XML_EPSILON_W(DELTAE, REAL(EPSDD,q), AIMAG(EPSDD), NEDOS_DIEL)
-         CALL XML_EPSILON_W(DELTAE, REAL(EPSJJ,q), AIMAG(EPSJJ), NEDOS_DIEL)
-      ENDIF
-      
-      IF (LVEL) THEN
-         ALLOCATE(EINTERPOL_FULL(4,W%WDES%NB_TOT,KPOINTS_INTER_FULL%NKPTS, &
-              W%WDES%ISPIN))
-         DO N=1,KPOINTS_INTER_FULL%NKPTS
-            NK=KPOINTS_INTER_FULL%NEQUIV(N)
-            S=0
-            DO L=1,3
-               DO K=1,3
-                  DO J=1,3
-                     DO I=1,3
-                        S(L,I)=S(L,I)+LATT_CUR%A(L,K)* &
-                             KPOINTS_INTER_FULL%ISYMOP(J,K,N)*LATT_CUR%B(I,J)
-                     ENDDO
-                  ENDDO
-               ENDDO
-            ENDDO
-            DO ISP=1,W%WDES%ISPIN
-               DO NB=1,W%WDES%NB_TOT
-                  EINTERPOL_FULL(1,NB,N,ISP)=EINTERPOL(NB,NK,ISP,1)
-                  DER=0
-                  DO IDIR=1,3
-                     DER(:)=DER(:)+S(:,IDIR)*EINTERPOL(NB,NK,ISP,IDIR+1)
-                  ENDDO
-                  DO IDIR=1,3
-                     EINTERPOL_FULL(IDIR+1,NB,N,ISP)=DER(IDIR)
-                  ENDDO
-               ENDDO
-            ENDDO
-         ENDDO
-         CALL XML_TAG("eigenvelocities", comment="interpolated")
-         CALL XML_TAG("kpoints")
-         CALL XML_KPOINTS_LIST(KPOINTS_INTER_FULL%VKPT, &
-              KPOINTS_INTER_FULL%WTKPT)
-         CALL XML_CLOSE_TAG("kpoints")
-         CALL XML_EIGENVALUES_EXT(EINTERPOL_FULL, 4, W%WDES%NB_TOT, &
-              KPOINTS_INTER_FULL%NKPTS, W%WDES%ISPIN)
-         CALL XML_CLOSE_TAG("eigenvelocities")
-
-         DEALLOCATE(EINTERPOL_FULL,KPOINTS_INTER_FULL)
-      ENDIF
-      
-      CALL DENSTA( IO%IU0, IO%IU6, WDES_INTER, W_INTER, KPOINTS_INTER, &
-           INFO%NELECT, INFO%NUP_DOWN, ENTROPY, EFERMI, KPOINTS_INTER%SIGMA, &
-           .TRUE., NEDOS, 0, 0, DOS, DOSI, PAR, DOSPAR)
-      CALL XML_DOS(EFERMI, KPOINTS%EMIN, KPOINTS%EMAX, .FALSE., &
-           DOS, DOSI, DOSPAR, NEDOS, 1, 1, W%WDES%NCDIJ, &
-           comment='interpolated')
-
-      EBANDSTR_INTER = BANDSTRUCTURE_ENERGY(WDES_INTER, W_INTER)
-      OTHERTERMS = E%DENC+E%XCENC+E%TEWEN+E%PSCENC+E%EENTROPY+ &
-           E%PAWPS+E%PAWAE+INFO%EALLAT+E%EXHF
-      TOTENINTER = EBANDSTR_INTER+OTHERTERMS
-      TOTENRDIFF = (TOTENORG - TOTENINTER)/TOTENORG
-
-      IF (IO%IU0>=0) THEN
-         WRITE(IO%IU0,1000) TOTENINTER, TOTENRDIFF
-         WRITE(17,1000)     TOTENINTER, TOTENRDIFF
-      ENDIF
-1000  FORMAT('Energy from interpolated bandstructure: ',E20.12/ &
-             '                 (relative difference): ',E20.12)
-      
-      DO ISP=1,W%WDES%ISPIN
-         DO NK=1,KPOINTS%NKPTS
-            IF (ISP==1) THEN
-               W%WDES%VKPT(:,NK)=VKPT_OLD(:,NK)
-            ENDIF
-            DO N=1,W%WDES%NBANDS
-               W%CW(:,N,NK,ISP)=CW_OLD(:,N,NK,ISP)
-            ENDDO
-         ENDDO
-      ENDDO
-      CALL SET_DATAKE(W%WDES, LATT_CUR%B)
-      IF (NONLR_S%LREAL) THEN
-         CALL RSPHER(GRID,NONLR_S,LATT_CUR)
-      ELSE
-         CALL SPHER(GRID,NONL_S,P,W%WDES,LATT_CUR, 1)
-      ENDIF
-      CALL PROALL (GRID,LATT_CUR,NONLR_S,NONL_S,W)
-! should not be necessary
-!     CALL ORTHCH(W%WDES,W, W%WDES%LOVERL, LMDIM, CQIJ)        
-
-      IF (LDO_VEL) THEN
-         DEALLOCATE(EDER)
-         CALL DEALLOCW(WDIFF)
-      ENDIF
-      IF (IO%LOPTICS) THEN
-         DEALLOCATE(EPSDD, EPSJJ, &
-         CHAMD, CHAM, WPLASM, COND, BIMAG)
-      ENDIF
-      DEALLOCATE(EINTERPOL, KINTERPOL, CW_OLD, VKPT_OLD)
-      CALL DEALLOCW_NOPLANEWAVE(W_INTER)
-
-      IF (IO%IU0>=0) WRITE(IO%IU0,*) '------------------------------------------------'// &
-           '--------------'
-      
-    END SUBROUTINE INTERPOLATE_BANDSTR_GRDSHFT
-
-
-  SUBROUTINE GENERATE_GRDSHFT_GRD_AND_DISPL(KPOINTS, WDES, LATT_CUR, &
-       T_INFO, SYMM, IO, KINTER, KPOINTS_INTER, KPOINTS_INTER_FULL, DISPL)
-    USE lattice
-    USE base
-    USE wave
-    USE poscar
-    USE mkpoints
-    USE full_kpoints
-    IMPLICIT NONE
-
-    
-    TYPE (kpoints_struct)           KPOINTS
-    TYPE (kpoints_struct)           KPOINTS_INTER
-    TYPE (skpoints_full),POINTER :: KPOINTS_INTER_FULL
-    TYPE (skpoints_full),POINTER :: KPOINTS_FULL_TEMP  
-    TYPE (latt)                     LATT_CUR
-    TYPE (info_struct)              INFO
-    TYPE (in_struct)                IO
-    TYPE (symmetry)                 SYMM
-    TYPE (type_info)                T_INFO
-    ! eFL: CAN WE GET RID OF THIS WDES FROM THIS ROUTINE?
-    TYPE (wavedes)                  WDES
-
-    INTEGER KINTER, ABSKINTER
-    INTEGER, DIMENSION(3) :: MULTIPL
-    INTEGER I, N, NK, IWZ, IK, IKX, IKY, IKZ, IKXP, IKYP, IKZP, NUMDISPL
-    REAL(q) DIST, DIST_FOUND, KSTART
-    REAL(q) DISPLV(3), DISPLV_CART(3)
-    REAL(q), ALLOCATABLE :: DISPL(:,:)
-    LOGICAL LDONE
-    LOGICAL, ALLOCATABLE :: K_FOUND_IN_GRID(:)
-    CHARACTER (LEN=8) :: XMLTAG
-    
-    DISPLV=0.0
-    IF (KPOINT_IN_FULL_GRID_KINTER(DISPLV,KPOINTS)==-1)  THEN
-       CALL VTUTOR('E','GAMMAC',0.0_q,1,0,1,(0.0_q,0.0_q),1, &
-            .TRUE.,1, IO%IU6,3)
-       CALL VTUTOR('S','GAMMAC',0.0_q,1,0,1,(0.0_q,0.0_q),1, &
-            .TRUE.,1, IO%IU0,3)
-       RETURN
-    ENDIF
-    IF ((MOD(KPOINTS%NKPX,2)==0) .OR. (MOD(KPOINTS%NKPY,2)==0) &
-         .OR. (MOD(KPOINTS%NKPZ,2)==0)) THEN
-       CALL VTUTOR('E','NOODDGRID',0.0_q,1,0,1,(0.0_q,0.0_q),1, &
-            .TRUE.,1, IO%IU6,3)
-       CALL VTUTOR('S','NOODDGRID',0.0_q,1,0,1,(0.0_q,0.0_q),1, &
-            .TRUE.,1, IO%IU0,3)
-       RETURN
-    ENDIF
-    IF (MOD(ABS(KINTER),2)==0) THEN
-       CALL VTUTOR('E','GRDSHFT_K',0.0_q,1,0,1,(0.0_q,0.0_q),1, &
-            .TRUE.,1, IO%IU6,3)
-       CALL VTUTOR('S','GRDSHFT_K',0.0_q,1,0,1,(0.0_q,0.0_q),1, &
-            .TRUE.,1, IO%IU0,3)
-       RETURN
-    ENDIF
-
-    ABSKINTER = ABS(KINTER)
-    NUMDISPL = ABSKINTER * ABSKINTER * ABSKINTER
-    KPOINTS_INTER=KPOINTS
-    CALL CHECK_FULL_KPOINTS
-    MULTIPL=ABSKINTER
-#ifdef oldsym
-    CALL RD_KPOINTS(KPOINTS_INTER, LATT_CUR, &
-         SYMM%ISYM>=0.AND..NOT. WDES%LSORBIT.AND..NOT. WDES%LSPIRAL, &
-         SYMM%ISYM<0, -1, -1, MULTIPL = MULTIPL)
-#else
-    CALL RD_KPOINTS(KPOINTS_INTER, LATT_CUR, &
-         SYMM%ISYM>=0.AND..NOT. WDES%LNONCOLLINEAR, SYMM%ISYM<0, &
-         -1, -1, MULTIPL = MULTIPL)
-#endif
-
-    ALLOCATE(KPOINTS_INTER_FULL)
-    CALL IBZKPT_HF(LATT_CUR, KPOINTS_INTER, &
-         KPOINTS_INTER_FULL, T_INFO%NIONS, SYMM%ROTMAP, &
-         SYMM%MAGROT,SYMM%ISYM, IO%IU6, IO%IU0)
-    
-    IWZ=2
-    KSTART=-REAL(ABSKINTER,q)/2+0.5_q
-    IK=0
-    ALLOCATE(DISPL(3,NUMDISPL))
-    DISPL=0.0
-    DO IKX=0,ABSKINTER-1
-       DO IKY=0,ABSKINTER-1
-          DO IKZ=0,ABSKINTER-1
-             IK=IK+1
-             DIST_FOUND=1E6
-             DO IKXP=-IWZ,IWZ
-                DO IKYP=-IWZ,IWZ
-                   DO IKZP=-IWZ,IWZ
-                      DISPLV(1)=((IKX+KSTART)/ABSKINTER+IKXP)/KPOINTS%NKPX
-                      DISPLV(2)=((IKY+KSTART)/ABSKINTER+IKYP)/KPOINTS%NKPY
-                      DISPLV(3)=((IKZ+KSTART)/ABSKINTER+IKZP)/KPOINTS%NKPZ
-                      DISPLV_CART=DISPLV
-                      CALL DIRKAR(1, DISPLV_CART(1), LATT_CUR%B)
-                      DIST=DISPLV_CART(1)**2+ &
-                           DISPLV_CART(2)**2+ &
-                           DISPLV_CART(3)**2
-                      IF (DIST<=DIST_FOUND) THEN
-                         DISPL(:,IK)=DISPLV
-                         DIST_FOUND =DIST
-                      ENDIF
-                   ENDDO
-                ENDDO
-             ENDDO
-          ENDDO
-       ENDDO
-    ENDDO
-
-    ALLOCATE(K_FOUND_IN_GRID(KPOINTS_INTER%NKPTS))
-    K_FOUND_IN_GRID=.FALSE.
-    DO IK=1,NUMDISPL
-       DO N=1,KPOINTS%NKPTS
-          NK=KPOINT_IN_FULL_GRID_KINTER(KPOINTS%VKPT(:,N)+DISPL(:,IK), &
-               KPOINTS_INTER)
-          IF (NK/=-1) K_FOUND_IN_GRID(NK)=.TRUE.
-       ENDDO
-    ENDDO
-
-    LDONE=.FALSE.
-    DO IK=1,NUMDISPL
-       DO N=1,KPOINTS%NKPTS
-          NK=KPOINT_IN_FULL_GRID_KINTER(KPOINTS%VKPT(:,N)+DISPL(:,IK), &
-               KPOINTS_INTER)
-          IF (NK==-1) THEN
-             I=KPOINT_IN_FULL_GRID(KPOINTS%VKPT(:,N)+DISPL(:,IK), &
-                  KPOINTS_INTER_FULL)
-             NK=KPOINTS_INTER_FULL%NEQUIV(I)
-             IF (.NOT. K_FOUND_IN_GRID(NK)) THEN
-                KPOINTS_INTER%VKPT(:,NK)=KPOINTS_INTER_FULL%VKPT(:,I)
-                K_FOUND_IN_GRID(NK)=.TRUE.
-                LDONE=.TRUE.
-             ENDIF
-          ENDIF
-       ENDDO
-    ENDDO
-    
-    DO NK=1, KPOINTS_INTER%NKPTS
-       IF (.NOT. K_FOUND_IN_GRID(NK) ) THEN
-          IF (IO%IU0>=0) WRITE(IO%IU0,'(I6,3F14.7)') NK, &
-               KPOINTS_INTER%VKPT(:,NK)
-          CALL VTUTOR('E','GRDSHFT_NOT_IN_IBZ',0.0_q,1,0,1, &
-               (0.0_q,0.0_q),1, .TRUE.,1, IO%IU6,3)
-          CALL VTUTOR('S','GRDSHFT_NOT_IN_IBZ',0.0_q,1,0,1, &
-               (0.0_q,0.0_q),1, .TRUE.,1, IO%IU0,3)
-          STOP
-       ENDIF
-    ENDDO
-
-    IF (LDONE) THEN
-       CALL IBZKPT_HF(LATT_CUR, KPOINTS_INTER, &
-            KPOINTS_INTER_FULL, T_INFO%NIONS, SYMM%ROTMAP, &
-            SYMM%MAGROT,SYMM%ISYM, IO%IU6, IO%IU0)
-    ENDIF
-    
-  END SUBROUTINE GENERATE_GRDSHFT_GRD_AND_DISPL
-
-    
-END MODULE mlr_main
+#include "symbol.inc"
+
+MODULE mlr_main
+  USE prec
+  USE vaspxml
+  USE lr_helper
+  IMPLICIT NONE
+
+  REAL(q),ALLOCATABLE,PRIVATE :: POSION_LAST(:,:)
+  REAL(q),ALLOCATABLE,PRIVATE :: BORN_CHARGES_SAVE(:,:,:)
+  REAL(q),ALLOCATABLE,PRIVATE :: DIPOLE_TIME(:,:)
+CONTAINS
+
+!*********************************************************************
+!
+! calculate second derivatives using linear response theory
+!
+! implemented by gK
+! the main scheduler is based on the finite difference kernel of 
+! Orest Dubay (at least the skeleton is essentially identical)
+! it steps through all ions (at least those that are allowed to move)
+! and calls the main linear response kerner to calculate the
+! linear response of the wavefunction and the second derivatives
+! with respect to the ionic positions
+!
+!*********************************************************************
+
+  SUBROUTINE LR_SKELETON( &
+          KINEDEN,HAMILTONIAN,P,WDES,NONLR_S,NONL_S,W,LATT_CUR,LATT_INI, &
+          T_INFO,DYN,INFO,IO,MIX,KPOINTS,SYMM,GRID,GRID_SOFT, &
+          GRIDC,GRIDB,GRIDUS,C_TO_US,B_TO_C,SOFT_TO_C,E, &
+          CHTOT,CHTOTL,DENCOR,CVTOT,CSTRF, &
+          CDIJ,CQIJ,CRHODE,N_MIX_PAW,RHOLM,RHOLM_LAST, &
+          CHDEN,SV,DOS,DOSI,CHAM, &
+          IBRION,LMDIM,IRDMAX,NEDOS, &
+          TOTENIN,EFERMI,FORCE,LFAST)
+
+    USE ini
+    USE base
+    USE lattice
+    USE finite_differences
+    USE charge
+    USE pseudo
+    USE lattice
+    
+    USE nonl_high
+    USE msymmetry
+    USE mpimy
+    USE mgrid
+    USE mkpoints
+    USE constant
+    USE poscar
+    USE wave
+    USE pot
+    USE subrot
+    USE pawm
+    USE rmm_diis
+    USE choleski
+    USE david
+    USE wave_high
+    USE mlrf_main
+    USE lri_main
+    USE emlr
+    USE magnon
+    USE subrot_cluster
+    USE kpoints_change
+    USE full_kpoints
+    USE hamil_high
+    USE pead
+    USE fock
+    USE morbitalmag
+    USE meta
+    USE wannier_interpolation
+    USE crpa, ONLY : LCRPAPLOT
+    USE rpa_force, ONLY : STORE_RPA_SECOND_DERIV
+! solvation__
+    USE solvation
+! solvation__
+#ifdef PROFILING
+    USE profiling
+#endif
+    IMPLICIT NONE
+!=======================================================================
+!  structures
+!=======================================================================
+    TYPE (tau_handle)  KINEDEN
+    TYPE (ham_handle)  HAMILTONIAN
+    TYPE (type_info)   T_INFO
+    TYPE (potcar)      P(T_INFO%NTYP)
+    TYPE (wavedes)     WDES
+    TYPE (nonlr_struct) NONLR_S
+    TYPE (nonl_struct) NONL_S
+    TYPE (wavespin)    W          ! wavefunction
+    TYPE (latt)        LATT_CUR
+    TYPE (dynamics)    DYN
+    TYPE (info_struct) INFO
+    TYPE (in_struct)   IO
+    TYPE (mixing)      MIX
+    TYPE (kpoints_struct) KPOINTS
+    TYPE (symmetry)    SYMM
+    TYPE (grid_3d)     GRID       ! grid for wavefunctions
+    TYPE (grid_3d)     GRID_SOFT  ! grid for soft chargedensity
+    TYPE (grid_3d)     GRIDC      ! grid for potentials/charge
+    TYPE (grid_3d)     GRIDUS     ! temporary grid in us.F
+    TYPE (grid_3d)     GRIDB      ! Broyden grid
+    TYPE (transit)     B_TO_C     ! index table between GRIDB and GRIDC
+    TYPE (transit)     C_TO_US    ! index table between GRIDC and GRIDUS
+    TYPE (transit)     SOFT_TO_C  ! index table between GRID_SOFT and GRIDC
+    TYPE (energy)      E
+    TYPE (latt)        LATT_INI
+
+    INTEGER IBRION
+    INTEGER LMDIM,IRDMAX,IRDMAA,NEDOS
+    REAL(q) TOTENIN,EFERMI
+
+    COMPLEX(q)  CHTOT(GRIDC%MPLWV,WDES%NCDIJ) ! charge-density in real / reciprocal space
+    COMPLEX(q)  CHTOTL(GRIDC%MPLWV,WDES%NCDIJ)! old charge-density
+    RGRID       DENCOR(GRIDC%RL%NP)           ! partial core
+    COMPLEX(q)  CVTOT(GRIDC%MPLWV,WDES%NCDIJ) ! local potential
+    COMPLEX(q)  CSTRF(GRIDC%MPLWV,T_INFO%NTYP)
+
+!  augmentation related quantities
+    OVERLAP  CDIJ(LMDIM,LMDIM,WDES%NIONS,WDES%NCDIJ), &
+             CQIJ(LMDIM,LMDIM,WDES%NIONS,WDES%NCDIJ), &
+             CRHODE(LMDIM,LMDIM,WDES%NIONS,WDES%NCDIJ)
+!  paw sphere charge density
+    INTEGER N_MIX_PAW
+    REAL(q)  RHOLM(N_MIX_PAW,WDES%NCDIJ),RHOLM_LAST(N_MIX_PAW,WDES%NCDIJ)
+!  charge-density and potential on soft grid
+    COMPLEX(q)  CHDEN(GRID_SOFT%MPLWV,WDES%NCDIJ)
+    RGRID       SV(DIMREAL(GRID%MPLWV),WDES%NCDIJ)
+!  density of states
+    REAL(q)    DOS(NEDOS,WDES%ISPIN),DOSI(NEDOS,WDES%ISPIN)
+!  Hamiltonian
+    GDEF       CHAM(WDES%NB_TOT,WDES%NB_TOT,WDES%NKPTS,WDES%ISPIN)
+    REAL(q)   XCSIF(3,3)
+    REAL(q) :: FORCE(3,T_INFO%NIONS)   ! forces in cartesian coordinates
+    LOGICAL, OPTIONAL :: LFAST
+
+! local variables related to finite difference code
+
+    TYPE (eigenf_cluster_pointer),POINTER :: DEG_CLUSTER(:,:)
+    INTEGER :: NIONS
+    INTEGER :: IU6                ! OUTCAR file
+    INTEGER :: IU6K               ! OUTCAR k-points
+    INTEGER :: IU0                ! stdout
+
+    TYPE (type_info)   T_INFO_0
+    INTEGER :: IUDYNMAT           ! DYNMAT file
+    REAL(q) :: X
+    REAL(q),ALLOCATABLE      :: INITIAL_FORCE(:,:)
+    REAL(q),ALLOCATABLE      :: DISPL_FORCES(:,:,:)
+    REAL(q),ALLOCATABLE      :: INT_STRAIN(:,:,:), PIEZO(:,:,:)
+    REAL(q),ALLOCATABLE      :: BORN_CHARGES(:,:,:), BORN_CHARGES2(:,:,:)
+    REAL(q),ALLOCATABLE      :: SECOND_DERIV(:,:)
+    INTEGER                  :: DOF
+    INTEGER                  :: PROCESSED_DISPL
+    INTEGER                  :: I,J,K,M,N, IDIR, IDISPL_ON_ION
+    REAL(q),ALLOCATABLE      :: WORK(:,:)
+    REAL(q),ALLOCATABLE      :: EIGENVECTORS(:,:)
+    REAL(q),ALLOCATABLE      :: EIGENVALUES(:)
+    INTEGER                  :: IERROR
+    REAL(q) :: EPSILON(3,3),  ELASTIC(3,3,3,3),  ELASTICP(6,3,3)
+! variables for the reevaluation of energy
+    REAL(q) DESUM, RMS       ! change
+    REAL(q) TOTEN, TOTEN_    ! energy
+    REAL(q) EDIFF            ! break condition
+    INTEGER ICOUEV
+    INTEGER NSIM
+! linear response using symmetry
+    INTEGER                  :: NKORIG
+    REAL(q),ALLOCATABLE      :: D(:,:,:)
+    INTEGER,ALLOCATABLE      :: ND(:), IDIRD(:,:)
+    REAL(q)                  :: WORKD(3,3,T_INFO%NIONS)
+    INTEGER                  :: IWORK(T_INFO%NIONS)
+    CHARACTER(3)             :: IDIR_TEXT(3)=(/"x","y","z"/)
+    LOGICAL                  :: LDO(T_INFO%NIONS)
+    REAL(q)                  :: WDMAT(3,T_INFO%NIONS,3,T_INFO%NIONS),DMAT(3,3,T_INFO%NIONS,T_INFO%NIONS)
+    REAL(q)                  :: ST(3,3,3,T_INFO%NIONS), AST(3,3,3,T_INFO%NIONS)
+    REAL(q)                  :: FACT, TMP(3,3)
+! variables to store G [H,r] phi
+    COMPLEX(qs), ALLOCATABLE :: RPHI(:,:,:,:,:)
+    GDEFS, ALLOCATABLE ::  RPHI_CPROJ(:,:,:,:,:)
+    TYPE (skpoints_trans)   :: KPOINTS_TRANS
+
+! symmetry related quantities (common block)
+    INTEGER  ISYMOP,NROT,IGRPOP,NROTK,INVMAP,NPCELL
+    REAL(q)  GTRANS,AP
+    COMMON /SYMM/   ISYMOP(3,3,48),NROT,IGRPOP(3,3,48),NROTK, &
+         GTRANS(3,48),INVMAP(48),AP(3,3),NPCELL
+
+    ! NULLIFY to make sure a later "IF(ASSOCIATED())" works correctly.
+    NULLIFY(KPOINTS_TRANS%CPHASE)
+
+#if defined(VASP2WANNIER90) && ! defined(gammareal)
+    IF (LWANNIERINTERPOL.OR.LCRPAPLOT) THEN
+       CALL WANNIER_INTERPOLATE(HAMILTONIAN,KPOINTS,GRID,LATT_CUR,LATT_INI,&
+            T_INFO,NONLR_S,NONL_S,W,LMDIM,P,SV,CQIJ,CDIJ,SYMM,INFO,IO)
+       ! at this point the wave functions are messed up, so let's call it a day ...
+#ifdef PROFILING
+       ! started in INIT_PROFILING
+       PROFILING_STOP('total_time')
+       IF (IO%IU0>=0) THEN
+          CALL PRINT_FULL_PROFILE(IO%IU6,PFLAT=.FALSE.)
+       ENDIF
+#endif
+       CALL DUMP_ALLOCATE(IO%IU6)
+       CALL DUMP_FINAL_TIMING(IO%IU6)
+       CALL STOP_XML
+       CALLMPI_C(M_exit())
+    ENDIF
+#endif
+
+    IF (KINTER<0) THEN
+       IF (LHFCALC) THEN
+          CALL INTERPOLATE_BAND_STR(HAMILTONIAN, KPOINTS, GRID, LATT_CUR, LATT_INI, & 
+            T_INFO, NONLR_S, NONL_S, W, NEDOS, DOS, DOSI, INFO%NELECT, INFO%NUP_DOWN,  &
+            LMDIM, P, SV, CQIJ, CDIJ, SYMM, IO%IU0, IO%IU6)
+       ELSE
+          CALL INTERPOLATE_BANDSTR_GRDSHFT(HAMILTONIAN, E, KPOINTS, GRID, LATT_CUR, LATT_INI, & 
+            T_INFO, NONLR_S, NONL_S, W, NEDOS, &
+            LMDIM, P, SV, CQIJ, CDIJ, SYMM, INFO, IO, GRIDC, GRIDUS, C_TO_US, IRDMAX)
+       ENDIF
+       RETURN
+    ENDIF
+
+    IF (LHFCALC .AND. AEXX/=0 ) THEN
+       CALL VTUTOR('E','LHFLINEARRESPONSE',0.0_q,1,0,1,(0.0_q,0.0_q),1,.TRUE.,1, &
+            IO%IU6,3)
+       CALL VTUTOR('S','LHFLINEARRESPONSE',0.0_q,1,0,1,(0.0_q,0.0_q),1,.TRUE.,1, &
+            IO%IU0,3)
+    ENDIF
+
+    IF (LDO_METAGGA()) THEN
+       CALL VTUTOR('E','METAGGARESPONSE',0.0_q,1,0,1,(0.0_q,0.0_q),1,.TRUE.,1, &
+            IO%IU6,3)
+       CALL VTUTOR('S','METAGGARESPONSE',0.0_q,1,0,1,(0.0_q,0.0_q),1,.TRUE.,1, &
+            IO%IU0,3)
+    ENDIF
+
+    IF (INFO%LREAL) THEN
+       CALL VTUTOR('W','LINEARRESPONSE LREAL',0.0_q,1,0,1,(0.0_q,0.0_q),1,.TRUE.,1, &
+            IO%IU6,3)
+       CALL VTUTOR('W','LINEARRESPONSE LREAL',0.0_q,1,0,1,(0.0_q,0.0_q),1,.TRUE.,1, &
+            IO%IU0,3)
+    ENDIF
+
+    NIONS = T_INFO%NIONS
+    IU6   = IO%IU6
+    IU0   = IO%IU0
+
+    IF (IO%NWRITE>=3) THEN
+       IU6K  = IO%IU6
+    ELSE
+       IU6K  = -1
+    ENDIF
+
+    IF (IBRION>0) THEN
+       IF (IBRION==8) THEN
+          ALLOCATE(D(3,3,T_INFO%NIONS), ND(T_INFO%NIONS),IDIRD(3,T_INFO%NIONS))
+
+          CALL FREDOM(SYMM%ROTMAP,ISYMOP,INVMAP,NROTK,NPCELL,D,ND,1,T_INFO%NTYP,T_INFO%NIONS, &
+             T_INFO%NITYP,WORKD,IWORK, & 
+             LATT_CUR%A(1,1),LATT_CUR%A(1,2),LATT_CUR%A(1,3), &
+             LATT_CUR%B(1,1),LATT_CUR%B(1,2),LATT_CUR%B(1,3),IDIRD,.FALSE.)
+          DOF=SUM(ND)
+
+          IF (IU6>=0) THEN
+             WRITE(IU6,*)
+             WRITE(IU6,'(A,I5,A)') ' Found ',DOF,' degrees of freedom:'
+             WRITE(IU6,*)' ----------------------------------------------'
+             WRITE(IU6,*)
+             DO J=1,NIONS
+                IF (ND(J).GT.0) THEN
+                   WRITE(IU6,'(A,I5,A,3A2)') '     directions for atom ',J,':  ',IDIR_TEXT(IDIRD(ND(J),J))
+                ENDIF
+             ENDDO
+          ENDIF
+       ELSE IF (IBRION==7) THEN
+          CALL COUNT_DOF(NIONS, T_INFO%LSFOR, T_INFO%LSDYN, DOF)
+       ELSE
+          DOF=0
+       ENDIF
+    ELSE
+       DOF=0
+    ENDIF
+
+    T_INFO_0=T_INFO
+    NULLIFY(T_INFO_0%POSION)
+    ALLOCATE(T_INFO_0%POSION(3,NIONS))
+    ALLOCATE(INITIAL_FORCE(3,NIONS))
+    ALLOCATE(DISPL_FORCES(DOF,3,NIONS),BORN_CHARGES(3,3,NIONS),BORN_CHARGES2(3,3,NIONS), & 
+      PIEZO(3,3,3),INT_STRAIN(DOF,3,3))
+
+    DISPL_FORCES=0
+    BORN_CHARGES=0 ; BORN_CHARGES2=0
+    PIEZO=0
+    INT_STRAIN=0
+
+    T_INFO_0%POSION             = T_INFO%POSION
+    INITIAL_FORCE               = FORCE
+    NKORIG                      = WDES%NKPTS
+!=======================================================================
+! reset the potential and recalculate the ground state wavefunctions
+! with very high precision for this setup
+!=======================================================================
+    IF (IU0>=0) THEN
+       WRITE (IU0,*) 'Linear response reoptimize wavefunctions to high precision'
+       WRITE ( 17,*) 'Linear response reoptimize wavefunctions'
+    ENDIF
+
+    IF (IU6>=0) THEN
+       WRITE (IU6,*) 'Linear response reoptimize wavefunctions'
+    ENDIF
+
+    IF (INFO%LREAL) THEN
+       CALL RSPHER(GRID,NONLR_S,LATT_CUR)
+    ENDIF
+
+    CALL POTLOK(GRID,GRIDC,GRID_SOFT, WDES%COMM_INTER, WDES,  &
+         INFO,P,T_INFO,E,LATT_CUR, &
+         CHTOT,CSTRF,CVTOT,DENCOR,SV, SOFT_TO_C,XCSIF)
+
+!   CALL VECTORPOT(GRID, GRIDC, GRID_SOFT, SOFT_TO_C,  WDES%COMM_INTER, & 
+!        LATT_CUR, T_INFO%POSION, HAMILTONIAN%AVEC, HAMILTONIAN%AVTOT)
+                  
+    CALL SETDIJ(WDES,GRIDC,GRIDUS,C_TO_US,LATT_CUR,P,T_INFO,INFO%LOVERL, &
+         LMDIM,CDIJ,CQIJ,CVTOT,IRDMAA,IRDMAX)
+
+    CALL SETDIJ_AVEC(WDES,GRIDC,GRIDUS,C_TO_US,LATT_CUR,P,T_INFO,INFO%LOVERL, &
+         LMDIM,CDIJ,HAMILTONIAN%AVTOT, NONLR_S, NONL_S, IRDMAX)
+    
+    CALL SET_DD_MAGATOM(WDES, T_INFO, P, LMDIM, CDIJ) 
+    CALL SET_DD_PAW(WDES, P , T_INFO, INFO%LOVERL, &
+         WDES%NCDIJ, LMDIM, CDIJ(1,1,1,1),  RHOLM, CRHODE(1,1,1,1), &
+         E,  LMETA=.FALSE., LASPH=INFO%LASPH, LCOREL= .FALSE.  )
+    !
+    ! only if the tolerance is very tight for the occupied states
+    ! it is possible to attain a tight tolerance for the perturbed states
+    ! with the present DIIS algorithm
+
+    EDIFF = 1E-13
+    NSIM=WDES%NSIM*2
+#ifdef MPI
+    NSIM=((WDES%NSIM*2+WDES%COMM_INTER%NCPU-1)/WDES%COMM_INTER%NCPU)*WDES%COMM_INTER%NCPU
+#endif
+
+    X=INFO%EBREAK
+
+    ! for some non obvious reasons 
+    IF (.NOT. LMAGBLOCH) THEN 
+       INFO%EBREAK=0.25*EDIFF
+    ELSE
+       IF (IU0>=0) WRITE(IU0,*) 'WARNING: EBREAK remains at default, EDDAV has a problem for too tight convergence criteria'
+       INFO%EBREAK=EDIFF
+    ENDIF
+
+    TOTEN=TOTENIN
+    DO I=1,5
+       CALL EDDAV(HAMILTONIAN,P, GRID,INFO,LATT_CUR,NONLR_S,NONL_S,W,WDES, NSIM, &
+            LMDIM,CDIJ,CQIJ, RMS,DESUM,ICOUEV, SV, E%EXHF, IO%IU6,IO%IU0, .FALSE., .TRUE., .FALSE.)
+
+       E%EBANDSTR=BANDSTRUCTURE_ENERGY(WDES, W)
+       TOTEN_=E%EBANDSTR+E%DENC+E%XCENC+E%TEWEN+E%PSCENC+E%EENTROPY+E%PAWPS+E%PAWAE+INFO%EALLAT+E%EXHF+Ediel_sol
+
+       IF (IO%IU0>=0) THEN
+          WRITE(IO%IU0,1000) I, TOTEN_, TOTEN_-TOTEN, DESUM, ICOUEV, RMS
+          WRITE(17,1000)     I, TOTEN_, TOTEN_-TOTEN, DESUM, ICOUEV, RMS
+       ENDIF
+1000   FORMAT('DAV: ',I3,'   ',E20.12,'   ',E12.5,'   ',E12.5,I6,'  ',E10.3)
+       IF(ABS(DESUM)<EDIFF.AND.ABS(TOTEN_-TOTEN)<EDIFF) EXIT
+
+       TOTEN=TOTEN_
+    ENDDO
+    CALL KPAR_SYNC_ALL(WDES,W)
+
+    INFO%EBREAK=X    ! restore the break condition
+
+    IF (IO%IU0>=0 .AND. IO%LOPEN) CALL WFORCE(17)
+
+!=======================================================================
+! determine G [H, r] |phi> = d/ dk | phi(k)>
+!=======================================================================
+    NULLIFY(DEG_CLUSTER)
+    CALL FIND_DEG_CLUSTERS(WDES, W, DEG_CLUSTER)
+
+    IF (LEPSILON .OR. KINTER/=0 .OR. LMAGBLOCH ) THEN
+
+    CALL SET_NABIJ_AUG(P,T_INFO%NTYP)
+    ALLOCATE(RPHI(WDES%NRPLWV,WDES%NBANDS,WDES%NKPTS,WDES%ISPIN,3), &
+             RPHI_CPROJ(WDES%NPROD,WDES%NBANDS,WDES%NKPTS,WDES%ISPIN,3))
+
+    IF (LUSEPEAD()) THEN
+       IF (LMAGBLOCH) THEN
+          LPEAD_RETURN_Q_CPROJ=.FALSE.
+       ENDIF
+       RPHI=0
+       RPHI_CPROJ=0
+       CALL PEAD_DPSI_DK_ALL(W,KPOINTS,P,CQIJ,LATT_CUR,T_INFO,RPHI,RPHI_CPROJ)
+       LPEAD_RETURN_Q_CPROJ=.TRUE.
+    ELSE 
+       RPHI=0
+       RPHI_CPROJ=0
+
+       DO IDIR=1,3
+          IF (IU0>=0) THEN
+             WRITE (IU0,*)'Linear response G [H, r] |phi>, progress :'
+             WRITE (IU0,'(A,I3)') &
+                  '  Direction: ',IDIR
+             WRITE (17,*)'Linear response G [H, r] |phi>, progress :'
+             WRITE (17,'(A,I3)') &
+                  '  Direction: ',IDIR
+          END IF
+
+          IF (IU6>=0) THEN
+             WRITE (IU6,*)'Linear response G [H, r] |phi>, progress :'
+             WRITE (IU6,'(A,I3)') &
+                  '  Direction: ',IDIR
+          ENDIF
+
+          CALL LRF_RPHI( &
+             P,WDES,NONLR_S,NONL_S,W,LATT_CUR, &
+             T_INFO,INFO,IO,GRID,GRIDC,GRIDUS,C_TO_US,IRDMAX, &
+             CDIJ,CQIJ,SV,LMDIM,DEG_CLUSTER, IDIR, RPHI(:,:,:,:,IDIR), RPHI_CPROJ(:,:,:,:,IDIR), & 
+             .TRUE.) !KINTER==0)
+
+          IF (IO%LOPEN) CALL WFORCE(IO%IU6)
+       ENDDO
+    ENDIF
+
+    IF (KINTER>0) THEN
+!       CALL INTERPOLATE_BAND_STR(HAMILTONIAN, KPOINTS, GRID, LATT_CUR, LATT_INI, & 
+!            T_INFO, NONLR_S, NONL_S, W, NEDOS, DOS, DOSI, INFO%NELECT, INFO%NUP_DOWN, &
+!            LMDIM, P, SV, CQIJ, CDIJ, SYMM, IO%IU0, IO%IU6, RPHI)
+       CALL INTERPOLATE_BANDSTR_GRDSHFT( HAMILTONIAN, E, KPOINTS, GRID, LATT_CUR, LATT_INI, & 
+            T_INFO, NONLR_S, NONL_S, W, NEDOS, &
+            LMDIM, P, SV, CQIJ, CDIJ, SYMM, INFO, IO, GRIDC, GRIDUS, C_TO_US, IRDMAX, RPHI)
+
+       ! well this deallocates most of the quantities we have used, but not all
+       DEALLOCATE(RPHI, RPHI_CPROJ)
+       RETURN
+    ENDIF
+
+    IF (LMAGBLOCH) THEN
+
+       CALL BLOCH_CURRENT( W, GRID_SOFT, GRIDC, GRIDUS, C_TO_US, SOFT_TO_C, P, LATT_CUR, & 
+          HAMILTONIAN%AVEC, HAMILTONIAN%AVTOT, CHTOT, NONLR_S, NONL_S, & 
+          RPHI, RPHI_CPROJ, CDIJ, CQIJ, SV, EFERMI, &
+          T_INFO, LMDIM, CRHODE, IRDMAX, IO%IU6, IO%IU0)
+
+       ! well this deallocates most of the quantities we have used, but not all
+       DEALLOCATE(RPHI, RPHI_CPROJ)
+       RETURN
+    ENDIF
+!=======================================================================
+! response to external excluding local field effects
+! i.e. in the independent particle approximation
+!=======================================================================
+    IF (.NOT. PRESENT (LFAST)) THEN
+    DO IDIR=1,3
+
+       IF (IU0>=0) THEN
+          WRITE (IU0,*)'Linear response to external field (no local field effect), progress :'
+          WRITE (IU0,'(A,I3)') &
+               '  Direction: ',IDIR
+          WRITE (17,*)'Linear response to external field (no local field effect), progress :'
+          WRITE (17,'(A,I3)') &
+               '  Direction: ',IDIR
+       END IF
+     
+       IF (IU6>=0) THEN
+          WRITE (IU6,*)'Linear response to external field (no local field effect), progress :'
+          WRITE (IU6,'(A,I3)') &
+               '  Direction: ',IDIR
+       ENDIF
+
+       IF (SYMM%ISYM>0) THEN
+          DYN%VEL=0
+          DYN%VEL(IDIR,:)=1.0
+          CALL KARDIR(T_INFO%NIONS,DYN%VEL,LATT_CUR%B)
+          CALL INISYM(LATT_CUR%A,T_INFO%POSION,DYN%VEL,T_INFO%LSFOR, &
+               T_INFO%LSDYN,T_INFO%NTYP,T_INFO%NITYP,T_INFO%NIONS, &
+               SYMM%PTRANS,SYMM%NROT,SYMM%NPTRANS,SYMM%ROTMAP,SYMM%TAU,SYMM%TAUROT,SYMM%WRKROT, &
+               SYMM%INDROT,T_INFO%ATOMOM,WDES%SAXIS,SYMM%MAGROT,WDES%NCDIJ,IO%IU6)
+       ENDIF
+
+       CALL LRF_MAIN( &
+          KINEDEN,HAMILTONIAN,P,WDES,NONLR_S,NONL_S,W,RPHI,RPHI_CPROJ, &
+          LATT_CUR, &
+          T_INFO,DYN,INFO,IO,MIX,KPOINTS,SYMM,GRID,GRID_SOFT, &
+          GRIDC,GRIDB,GRIDUS,C_TO_US,B_TO_C,SOFT_TO_C,E, &
+          CHTOT,CHTOTL,DENCOR,CVTOT,CSTRF, &
+          CDIJ,CQIJ,CRHODE,N_MIX_PAW,RHOLM,RHOLM_LAST, &
+          CHDEN,SV,DOS,DOSI, &
+          LMDIM,IRDMAX,NEDOS, &
+          TOTEN,EFERMI, DEG_CLUSTER, KPOINTS_TRANS, EPSILON(IDIR,:), BORN_CHARGES(IDIR,:,:), PIEZO(IDIR,:,:),  & 
+          IDIR, .FALSE.)
+
+          IF (IO%LOPEN) CALL WFORCE(IO%IU6)
+    ENDDO
+    ! reinitialise symmetry
+    IF (SYMM%ISYM>0) THEN
+       DYN%VEL=0
+       CALL INISYM(LATT_CUR%A,T_INFO%POSION,DYN%VEL,T_INFO%LSFOR, &
+            T_INFO%LSDYN,T_INFO%NTYP,T_INFO%NITYP,T_INFO%NIONS, &
+            SYMM%PTRANS,SYMM%NROT,SYMM%NPTRANS,SYMM%ROTMAP,SYMM%TAU,SYMM%TAUROT,SYMM%WRKROT, &
+            SYMM%INDROT,T_INFO%ATOMOM,WDES%SAXIS,SYMM%MAGROT,WDES%NCDIJ,IO%IU6)
+    ENDIF
+
+    IF (SYMM%ISYM>0) CALL TSYM(EPSILON,ISYMOP,NROTK,LATT_CUR%A)
+    IF (IO%IU6>=0) THEN
+       WRITE(IO%IU6,1110) '(INDEPENDENT PARTICLE, excluding Hartree and local field effects)',EPSILON
+       WRITE(IO%IU6,130)
+       CALL XML_TENSOR("epsilon_rpa",EPSILON)
+    ENDIF
+    ENDIF
+!=======================================================================
+! response to external field including local field effects
+! if do_kpoints_chage is not set the k-point set remains unchanged
+! and symmetrization of the final tensor is performed
+! results are not exact but errors are sometimes small (not recommended)
+!=======================================================================
+#define do_kpoints_change
+#ifndef do_kpoints_change
+    DO IDIR=1,3
+
+       IF (IU0>=0) THEN
+          WRITE (IU0,*)'Linear response to external field, progress :'
+          WRITE (IU0,'(A,I3)') &
+               '  Direction: ',IDIR
+          WRITE (17,*)'Linear response to external field, progress :'
+          WRITE (17,'(A,I3)') &
+               '  Direction: ',IDIR
+       END IF
+     
+       IF (IU6>=0) THEN
+          WRITE (IU6,*)'Linear response to external field, progress :'
+          WRITE (IU6,'(A,I3)') &
+               '  Direction: ',IDIR
+       ENDIF
+
+       IF (SYMM%ISYM>0) THEN
+          DYN%VEL=0
+          DYN%VEL(IDIR,:)=1.0
+          CALL KARDIR(T_INFO%NIONS,DYN%VEL,LATT_CUR%B)
+          CALL INISYM(LATT_CUR%A,T_INFO%POSION,DYN%VEL,T_INFO%LSFOR, &
+               T_INFO%LSDYN,T_INFO%NTYP,T_INFO%NITYP,T_INFO%NIONS, &
+               SYMM%PTRANS,SYMM%NROT,SYMM%NPTRANS,SYMM%ROTMAP,SYMM%TAU,SYMM%TAUROT,SYMM%WRKROT, &
+               SYMM%INDROT,T_INFO%ATOMOM,WDES%SAXIS,SYMM%MAGROT,WDES%NCDIJ,IO%IU6)
+       ENDIF
+
+       CALL LRF_MAIN( &
+          KINEDEN,HAMILTONIAN,P,WDES,NONLR_S,NONL_S,W,RPHI,RPHI_CPROJ, &
+          LATT_CUR, &
+          T_INFO,DYN,INFO,IO,MIX,KPOINTS,SYMM,GRID,GRID_SOFT, &
+          GRIDC,GRIDB,GRIDUS,C_TO_US,B_TO_C,SOFT_TO_C,E, &
+          CHTOT,CHTOTL,DENCOR,CVTOT,CSTRF, &
+          CDIJ,CQIJ,CRHODE,N_MIX_PAW,RHOLM,RHOLM_LAST, &
+          CHDEN,SV,DOS,DOSI, &
+          LMDIM,IRDMAX,NEDOS, &
+          TOTEN,EFERMI, DEG_CLUSTER, KPOINTS_TRANS, EPSILON(IDIR,:), BORN_CHARGES(IDIR,:,:), PIEZO(IDIR,:,:),  & 
+          IDIR, .TRUE.)
+
+          IF (IO%LOPEN) CALL WFORCE(IO%IU6)
+    ENDDO
+    ! reinitialise symmetry
+    IF (SYMM%ISYM>0) THEN
+       DYN%VEL=0
+       CALL INISYM(LATT_CUR%A,T_INFO%POSION,DYN%VEL,T_INFO%LSFOR, &
+            T_INFO%LSDYN,T_INFO%NTYP,T_INFO%NITYP,T_INFO%NIONS, &
+            SYMM%PTRANS,SYMM%NROT,SYMM%NPTRANS,SYMM%ROTMAP,SYMM%TAU,SYMM%TAUROT,SYMM%WRKROT, &
+            SYMM%INDROT,T_INFO%ATOMOM,WDES%SAXIS,SYMM%MAGROT,WDES%NCDIJ,IO%IU6)
+    ENDIF
+
+    IF (SYMM%ISYM>0) CALL TSYM(EPSILON,ISYMOP,NROTK,LATT_CUR%A)
+    IF (IO%IU6>=0) THEN
+       IF (LRPA) THEN
+          WRITE(IO%IU6,1100) '(including local field effects in RPA (Hartree))',EPSILON
+       ELSE
+          WRITE(IO%IU6,1100) '(including local field effects in DFT)',EPSILON
+       ENDIF
+       WRITE(IO%IU6,130)
+       CALL XML_TENSOR("epsilon",EPSILON)
+    ENDIF
+
+!=======================================================================
+! response to external field including local field effects
+! this version changes the k-point set on the fly
+! and symmetrizes the polarisation vector
+!=======================================================================
+#else
+    DO IDIR=1,3
+       IF (IU0>=0) THEN
+          WRITE (IU0,*)'Linear response to external field, progress :'
+          WRITE (IU0,'(A,I3)') &
+               '  Direction: ',IDIR
+          WRITE (17,*)'Linear response to external field, progress :'
+          WRITE (17,'(A,I3)') &
+               '  Direction: ',IDIR
+       END IF
+     
+       IF (IU6>=0) THEN
+          WRITE (IU6,*)'Linear response to external field, progress :'
+          WRITE (IU6,'(A,I3)') &
+               '  Direction: ',IDIR
+       ENDIF
+       !
+       ! reinitialise symmetry part for field in direction IDIR
+       ! presently this is done by supplying a velocity field to the ions
+       !
+       IF (SYMM%ISYM>0) THEN
+          DYN%VEL=0
+          DYN%VEL(IDIR,:)=1.0
+          CALL  KARDIR(T_INFO%NIONS,DYN%VEL,LATT_CUR%B)
+          CALL INISYM(LATT_CUR%A,T_INFO%POSION,DYN%VEL,T_INFO%LSFOR, &
+               T_INFO%LSDYN,T_INFO%NTYP,T_INFO%NITYP,T_INFO%NIONS, &
+               SYMM%PTRANS,SYMM%NROT,SYMM%NPTRANS,SYMM%ROTMAP,SYMM%TAU,SYMM%TAUROT,SYMM%WRKROT, &
+               SYMM%INDROT,T_INFO%ATOMOM,WDES%SAXIS,SYMM%MAGROT,WDES%NCDIJ,IO%IU6)
+#ifdef oldsym
+          CALL RE_READ_KPOINTS(KPOINTS,LATT_CUR, &
+               SYMM%ISYM>=0.AND..NOT.WDES%LSORBIT.AND..NOT.WDES%LSPIRAL, &
+               T_INFO%NIONS,SYMM%ROTMAP,SYMM%MAGROT,SYMM%ISYM,IU6K,IO%IU0)
+#else
+          CALL RE_READ_KPOINTS(KPOINTS,LATT_CUR, &
+               SYMM%ISYM>=0.AND..NOT.WDES%LNONCOLLINEAR, &
+               T_INFO%NIONS,SYMM%ROTMAP,SYMM%MAGROT,SYMM%ISYM,IU6K,IO%IU0)
+#endif
+          CALL KPAR_SYNC_ALL(WDES,W)
+          CALL RE_GEN_LAYOUT( GRID, WDES, KPOINTS, LATT_CUR, LATT_INI, IO%IU6, IO%IU0)
+          CALL REALLOCATE_WAVE( W, GRID, WDES, NONL_S, T_INFO, P, LATT_CUR, KPOINTS_TRANS)
+
+          ! Loewdin perturbation theory to improve states at added k-points
+          CALL EDDIAG(HAMILTONIAN,GRID,LATT_CUR,NONLR_S,NONL_S,W,WDES,SYMM, &
+          &    LMDIM,CDIJ,CQIJ,4,SV,T_INFO,P,IO%IU0,DESUM, NKSTART=NKORIG+1)
+          CALL KPAR_SYNC_ALL(WDES,W)
+
+          CALL FIND_DEG_CLUSTERS(WDES, W, DEG_CLUSTER)
+       ENDIF
+
+       CALL LRF_MAIN( &
+          KINEDEN,HAMILTONIAN,P,WDES,NONLR_S,NONL_S,W,RPHI,RPHI_CPROJ, &
+          LATT_CUR, &
+          T_INFO,DYN,INFO,IO,MIX,KPOINTS,SYMM,GRID,GRID_SOFT, &
+          GRIDC,GRIDB,GRIDUS,C_TO_US,B_TO_C,SOFT_TO_C,E, &
+          CHTOT,CHTOTL,DENCOR,CVTOT,CSTRF, &
+          CDIJ,CQIJ,CRHODE,N_MIX_PAW,RHOLM,RHOLM_LAST, &
+          CHDEN,SV,DOS,DOSI, &
+          LMDIM,IRDMAX,NEDOS, &
+          TOTEN,EFERMI, DEG_CLUSTER, KPOINTS_TRANS, EPSILON(IDIR,:), BORN_CHARGES(IDIR,:,:), PIEZO(IDIR,:,:), & 
+          IDIR, .TRUE.)
+       IF (IO%LOPEN) CALL WFORCE(IO%IU6)
+
+       IF (SYMM%ISYM>0) CALL DEALLOCATE_KPOINTS_TRANS(KPOINTS_TRANS)
+    ENDDO
+
+    IF (SYMM%ISYM>0) THEN
+       DYN%VEL=0
+       CALL KARDIR(T_INFO%NIONS,DYN%VEL,LATT_CUR%B)
+       CALL INISYM(LATT_CUR%A,T_INFO%POSION,DYN%VEL,T_INFO%LSFOR, &
+            T_INFO%LSDYN,T_INFO%NTYP,T_INFO%NITYP,T_INFO%NIONS, &
+            SYMM%PTRANS,SYMM%NROT,SYMM%NPTRANS,SYMM%ROTMAP,SYMM%TAU,SYMM%TAUROT,SYMM%WRKROT, &
+            SYMM%INDROT,T_INFO%ATOMOM,WDES%SAXIS,SYMM%MAGROT,WDES%NCDIJ,IO%IU6)
+#ifdef oldsym
+       CALL RE_READ_KPOINTS(KPOINTS,LATT_CUR, &
+            SYMM%ISYM>=0.AND..NOT.WDES%LSORBIT.AND..NOT.WDES%LSPIRAL, &
+            T_INFO%NIONS,SYMM%ROTMAP,SYMM%MAGROT,SYMM%ISYM,IU6K,IO%IU0)
+#else
+       CALL RE_READ_KPOINTS(KPOINTS,LATT_CUR, &
+            SYMM%ISYM>=0.AND..NOT.WDES%LNONCOLLINEAR, &
+            T_INFO%NIONS,SYMM%ROTMAP,SYMM%MAGROT,SYMM%ISYM,IU6K,IO%IU0)
+#endif
+       CALL RE_GEN_LAYOUT( GRID, WDES, KPOINTS, LATT_CUR, LATT_INI, IO%IU6, IO%IU0)
+       CALL REALLOCATE_WAVE( W, GRID, WDES, NONL_S, T_INFO, P, LATT_CUR)
+
+       CALL TSYM(EPSILON,ISYMOP,NROTK,LATT_CUR%A)
+    ENDIF
+
+    IF (IO%IU6>=0) THEN
+       IF (LRPA) THEN
+          WRITE(IO%IU6,1100) '(including local field effects in RPA (Hartree))',EPSILON
+       ELSE
+          WRITE(IO%IU6,1100) '(including local field effects in DFT)',EPSILON
+       ENDIF
+       WRITE(IO%IU6,130)
+       CALL XML_TENSOR("epsilon",EPSILON)
+    ENDIF
+#endif
+1100   FORMAT(// &
+            " MACROSCOPIC STATIC DIELECTRIC TENSOR ",A/, &
+            " ------------------------------------------------------"/, &
+            &       3(6X,3F13.6/), &
+            " ------------------------------------------------------"/)
+
+1110   FORMAT(// &
+            " HEAD OF MICROSCOPIC STATIC DIELECTRIC TENSOR ",A/, &
+            " ------------------------------------------------------"/, &
+            &       3(6X,3F13.6/), &
+            " ------------------------------------------------------"/)
+
+
+    ENDIF
+130 FORMAT (5X, //, &
+     &'----------------------------------------------------', &
+     &'----------------------------------------------------'//)
+!=======================================================================
+! electromagnetic linear response
+!=======================================================================
+    IF (IBRION==9) THEN
+      T_INFO%POSION=T_INFO_0%POSION
+      CALL EMLR_MAIN( &
+        HAMILTONIAN,P,WDES,NONLR_S,NONL_S,W,LATT_CUR,LATT_INI, &
+        T_INFO,DYN,INFO,IO,MIX,KPOINTS,SYMM,GRID,GRID_SOFT, &
+        GRIDC,GRIDB,GRIDUS,C_TO_US,B_TO_C,SOFT_TO_C, &
+        CHTOT,DENCOR,CSTRF,CDIJ,CQIJ,CRHODE, &
+        N_MIX_PAW,RHOLM,SV,LMDIM,IRDMAX,NEDOS,EFERMI)
+      RETURN
+    ENDIF
+!=======================================================================
+! adiabatic magnon calculation
+!=======================================================================
+    IF (IBRION==19) THEN
+      T_INFO%POSION=T_INFO_0%POSION
+      CALL MAGNON_MAIN( &
+         HAMILTONIAN,P,WDES,NONLR_S,NONL_S,W,LATT_CUR,LATT_INI, &
+         T_INFO,DYN,INFO,IO,MIX,KPOINTS,SYMM,GRID,GRID_SOFT, &
+         GRIDC,GRIDB,GRIDUS,C_TO_US,B_TO_C,SOFT_TO_C, &
+         CHTOT,DENCOR,CSTRF,CDIJ,CQIJ,CRHODE, &
+         N_MIX_PAW,RHOLM,CHDEN,SV,LMDIM,IRDMAX,NEDOS,EFERMI)
+      RETURN
+    ENDIF
+!=======================================================================
+! ionic displacements
+!=======================================================================
+
+    IF (IU0>=0 .AND. DOF>0) THEN
+       WRITE (IU0,*) 'Linear response DOF=',DOF
+       WRITE (17,*) 'Linear response DOF=',DOF
+    ENDIF
+
+    IF (IU6>=0 .AND. DOF>0) THEN
+       WRITE (IU6,*) 'Linear response:'
+       WRITE (IU6,*) '  Degrees of freedom DOF   = ',DOF
+    END IF
+
+    DO PROCESSED_DISPL=1,DOF
+
+       IF (IU0>=0) THEN
+          WRITE (IU0,*)'Linear response progress:'
+          WRITE (IU0,'(A,I3,A,I3)') &
+               '  Degree of freedom: ',PROCESSED_DISPL,'/',DOF
+          WRITE (17,*)'Linear response progress:'
+          WRITE (17,'(A,I3,A,I3)') &
+               '  Degree of freedom: ',PROCESSED_DISPL,'/',DOF
+       END IF
+     
+       IF (IU6>=0) THEN
+          WRITE (IU6,*)'Linear response progress:'
+          WRITE (IU6,'(A,I3,A,I3)') &
+               '  Degree of freedom: ',PROCESSED_DISPL,'/',DOF
+       ENDIF
+       T_INFO%POSION=T_INFO_0%POSION
+       IF (IBRION==8) THEN
+          CALL FIND_IJ_ID(.FALSE.,NIONS,PROCESSED_DISPL,ND,J,IDISPL_ON_ION)
+          IDIR=IDIRD(IDISPL_ON_ION,J)
+          IF (ABS(D(IDIR,IDISPL_ON_ION,J)-1.0) >1E-8) THEN
+             CALL VTUTOR('E','LINEARRES POSCAR',0.0_q,1,0,1,(0.0_q,0.0_q),1,.TRUE.,1, &
+                  IO%iu6,3)
+             CALL VTUTOR('S','LINEARRES POSCAR',0.0_q,1,0,1,(0.0_q,0.0_q),1,.TRUE.,1, &
+                  IO%IU0,3)
+          ENDIF
+       ELSE
+          CALL FIND_IJ(NIONS,T_INFO%LSFOR,T_INFO%LSDYN,PROCESSED_DISPL,IDIR,J)
+       ENDIF
+
+       IF (SYMM%ISYM>0) THEN
+          DYN%VEL=0
+          DYN%VEL(IDIR,J)=1.0
+          CALL  KARDIR(1,DYN%VEL(:,J),LATT_CUR%B)
+          CALL INISYM(LATT_CUR%A,T_INFO%POSION,DYN%VEL,T_INFO%LSFOR, &
+               T_INFO%LSDYN,T_INFO%NTYP,T_INFO%NITYP,T_INFO%NIONS, &
+               SYMM%PTRANS,SYMM%NROT,SYMM%NPTRANS,SYMM%ROTMAP,SYMM%TAU,SYMM%TAUROT,SYMM%WRKROT, &
+               SYMM%INDROT,T_INFO%ATOMOM,WDES%SAXIS,SYMM%MAGROT,WDES%NCDIJ,IO%IU6)
+#ifdef oldsym
+          CALL RE_READ_KPOINTS(KPOINTS,LATT_CUR, &
+               SYMM%ISYM>=0.AND..NOT.WDES%LSORBIT.AND..NOT.WDES%LSPIRAL, &
+               T_INFO%NIONS,SYMM%ROTMAP,SYMM%MAGROT,SYMM%ISYM,IU6K,IO%IU0)
+#else
+          CALL RE_READ_KPOINTS(KPOINTS,LATT_CUR, &
+               SYMM%ISYM>=0.AND..NOT.WDES%LNONCOLLINEAR, &
+               T_INFO%NIONS,SYMM%ROTMAP,SYMM%MAGROT,SYMM%ISYM,IU6K,IO%IU0)
+#endif
+          CALL KPAR_SYNC_ALL(WDES,W)
+          CALL RE_GEN_LAYOUT( GRID, WDES, KPOINTS, LATT_CUR, LATT_INI, IO%IU6, IO%IU0)
+          CALL REALLOCATE_WAVE( W, GRID, WDES, NONL_S, T_INFO, P, LATT_CUR, KPOINTS_TRANS)
+
+          ! Loewdin perturbation theory to improve states at added k-points
+          CALL EDDIAG(HAMILTONIAN,GRID,LATT_CUR,NONLR_S,NONL_S,W,WDES,SYMM, &
+          &    LMDIM,CDIJ,CQIJ,4,SV,T_INFO,P,IO%IU0,DESUM, NKSTART=NKORIG+1)
+          CALL KPAR_SYNC_ALL(WDES,W)
+
+          ! or alternatively, but not more accurate 3 steps Davidson
+          ! problem is that this might yield wrong piezoelectric tensors
+!          X=INFO%EBREAK
+!          INFO%EBREAK=0.25*EDIFF
+!          DO I=1,3
+!             CALL EDDAV(HAMILTONIAN,P, GRID,INFO,LATT_CUR,NONLR_S,NONL_S,W,WDES, NSIM, &
+!             LMDIM,CDIJ,CQIJ, RMS,DESUM,ICOUEV, SV, E%EXHF, IO%IU6,IO%IU0, .FALSE., .TRUE., .FALSE.)
+!             
+!             E%EBANDSTR=BANDSTRUCTURE_ENERGY(WDES, W)
+!             TOTEN_=E%EBANDSTR+E%DENC+E%XCENC+E%TEWEN+E%PSCENC+E%EENTROPY+E%PAWPS+E%PAWAE+INFO%EALLAT+E%EXHF
+!
+!             IF (IO%IU0>=0) THEN
+!                WRITE(IO%IU0,1000) I, TOTEN_, TOTEN_-TOTEN, DESUM, ICOUEV, RMS
+!                WRITE(17,1000)     I, TOTEN_, TOTEN_-TOTEN, DESUM, ICOUEV, RMS
+!             ENDIF
+!             IF(ABS(DESUM)<EDIFF.AND.ABS(TOTEN_-TOTEN)<EDIFF) EXIT
+!             TOTEN=TOTEN_
+!          ENDDO
+!          CALL KPAR_SYNC_ALL(WDES,W)
+!          INFO%EBREAK=X         ! restore the break condition
+
+          CALL FIND_DEG_CLUSTERS(WDES, W, DEG_CLUSTER)
+       ENDIF
+
+       CALL LR_MAIN( &
+          KINEDEN,HAMILTONIAN,P,WDES,NONLR_S,NONL_S,W,LATT_CUR, &
+          T_INFO,T_INFO_0,DYN,INFO,IO,MIX,KPOINTS,SYMM,GRID,GRID_SOFT, &
+          GRIDC,GRIDB,GRIDUS,C_TO_US,B_TO_C,SOFT_TO_C,E, &
+          CHTOT,CHTOTL,DENCOR,CVTOT,CSTRF, &
+          CDIJ,CQIJ,CRHODE,N_MIX_PAW,RHOLM,RHOLM_LAST, &
+          CHDEN,SV,DOS,DOSI, &
+          LMDIM,IRDMAX,NEDOS, &
+          TOTEN,EFERMI,DISPL_FORCES(PROCESSED_DISPL,:,:),INT_STRAIN(PROCESSED_DISPL,:,:), & 
+          IDIR, J, BORN_CHARGES2(:,IDIR,J), &
+          DEG_CLUSTER, KPOINTS_TRANS, RPHI, RPHI_CPROJ)
+       IF (IO%LOPEN) CALL WFORCE(IO%IU6)
+
+       IF (SYMM%ISYM>0) CALL DEALLOCATE_KPOINTS_TRANS(KPOINTS_TRANS)
+    ENDDO
+
+    CALL FREE_DEG_CLUSTERS(WDES,DEG_CLUSTER)
+
+    IF (LEPSILON) THEN
+       DEALLOCATE(RPHI, RPHI_CPROJ)
+    ENDIF
+
+    ! restore original symmetry
+    IF (SYMM%ISYM>0) THEN
+       DYN%VEL=0
+       CALL INISYM(LATT_CUR%A,T_INFO%POSION,DYN%VEL,T_INFO%LSFOR, &
+            T_INFO%LSDYN,T_INFO%NTYP,T_INFO%NITYP,T_INFO%NIONS, &
+            SYMM%PTRANS,SYMM%NROT,SYMM%NPTRANS,SYMM%ROTMAP,SYMM%TAU,SYMM%TAUROT,SYMM%WRKROT, &
+            SYMM%INDROT,T_INFO%ATOMOM,WDES%SAXIS,SYMM%MAGROT,WDES%NCDIJ,IO%IU6)
+#ifdef oldsym
+       CALL RE_READ_KPOINTS(KPOINTS,LATT_CUR, &
+            SYMM%ISYM>=0.AND..NOT.WDES%LSORBIT.AND..NOT.WDES%LSPIRAL, &
+            T_INFO%NIONS,SYMM%ROTMAP,SYMM%MAGROT,SYMM%ISYM,IU6K,IO%IU0)
+#else
+       CALL RE_READ_KPOINTS(KPOINTS,LATT_CUR, &
+            SYMM%ISYM>=0.AND..NOT.WDES%LNONCOLLINEAR, &
+            T_INFO%NIONS,SYMM%ROTMAP,SYMM%MAGROT,SYMM%ISYM,IU6K,IO%IU0)
+#endif
+       CALL RE_GEN_LAYOUT( GRID, WDES, KPOINTS, LATT_CUR, LATT_INI, IO%IU6, IO%IU0)
+       CALL REALLOCATE_WAVE( W, GRID, WDES, NONL_S, T_INFO, P, LATT_CUR)
+    ENDIF
+!=======================================================================
+!
+! final processing and output 
+! Born effective charges, piezoelectric tensors, and internal strain
+!
+!=======================================================================
+    IF (IBRION==8) THEN
+       !
+       ! version for case symmetry was used to reduce the number of displacments
+       !
+       CALL PRINT_DYNMAT_ID(.FALSE.,NIONS,DOF,1.0_q,T_INFO%NTYP,T_INFO%NITYP,T_INFO%POMASS,DISPL_FORCES,D,ND,IU6)
+
+       DO PROCESSED_DISPL=1,DOF
+          CALL FIND_IJ_ID(.FALSE.,NIONS,PROCESSED_DISPL,ND,J,IDIR)
+          DO N=1,T_INFO%NIONS
+             DMAT(1:3,IDIR,N,J)=DISPL_FORCES(PROCESSED_DISPL,1:3,N)
+          END DO
+          ST(1:3,1:3,IDIR,J)=INT_STRAIN  (PROCESSED_DISPL,1:3,1:3)
+       END DO
+
+       CALL MKDMAT(SYMM%ROTMAP,ISYMOP,INVMAP,NROTK,NPCELL,D,DMAT,ST,ND,      &
+            1,T_INFO%NTYP,T_INFO%NIONS,T_INFO%NITYP,WORKD,WDMAT,AST,IWORK,SYMM%TAU,SYMM%TAUROT,   &
+            SYMM%WRKROT, &
+            LATT_CUR%A(1,1),LATT_CUR%A(1,2),LATT_CUR%A(1,3), &
+            LATT_CUR%B(1,1),LATT_CUR%B(1,2),LATT_CUR%B(1,3))
+
+       LDO=.TRUE.
+       CALL SYDMAT(DMAT,SYMM%ROTMAP,ISYMOP,NROTK,NPCELL,1,T_INFO%NTYP, &
+            T_INFO%NIONS,T_INFO%NITYP,WDMAT,LATT_CUR%A(1,1),LATT_CUR%A(1,2),LATT_CUR%A(1,3),LDO)
+       CALL STMAT(ST  ,SYMM%ROTMAP,ISYMOP,NROTK,NPCELL,1,T_INFO%NTYP, &
+            T_INFO%NIONS,T_INFO%NITYP,AST  ,LATT_CUR%A(1,1),LATT_CUR%A(1,2),LATT_CUR%A(1,3),LDO)
+
+       ! now reset DOF to NIONS*3
+       ! and copy results from DMAT back to DISPL_FORCES
+
+       CALL COUNT_DOF(NIONS, T_INFO%LSFOR, T_INFO%LSDYN, DOF)
+       DEALLOCATE(DISPL_FORCES)
+       ALLOCATE(DISPL_FORCES(DOF,3,NIONS))
+
+       DO PROCESSED_DISPL=1,DOF
+          CALL FIND_IJ(NIONS,T_INFO%LSFOR,T_INFO%LSDYN,PROCESSED_DISPL,IDIR,J)
+          DO N=1,NIONS
+             DISPL_FORCES(PROCESSED_DISPL,1:3,N)=DMAT(1:3,IDIR,N,J)
+          ENDDO
+       ENDDO
+    ELSE
+       !
+       ! version for case no symmetry was used
+       !
+       CALL PRINT_DYNMAT(NIONS,DOF,1.0_q,T_INFO%NTYP,T_INFO%NITYP,T_INFO%POMASS,DISPL_FORCES,T_INFO%LSDYN,T_INFO%LSFOR,IU6)
+
+       DO PROCESSED_DISPL=1,DOF
+          CALL FIND_IJ(NIONS,T_INFO%LSFOR,T_INFO%LSDYN,PROCESSED_DISPL,IDIR,J)
+          ST(1:3,1:3,IDIR,J)=INT_STRAIN  (PROCESSED_DISPL,1:3,1:3)
+       END DO
+    ENDIF
+
+    IF (IU6>=0) THEN
+       WRITE (IU6,130) 
+       IF (LEPSILON) THEN
+          ! for the sake of having everything at the very end print EPSILON again
+          IF (LRPA) THEN
+             WRITE(IO%IU6,1100) '(including local field effects in RPA (Hartree))',EPSILON
+          ELSE
+             WRITE(IO%IU6,1100) '(including local field effects in DFT)',EPSILON
+          ENDIF
+
+          FACT=EVTOJ*1E20_q/LATT_CUR%OMEGA
+          
+170       FORMAT(/ ' ',A,'  for field in x, y, z        (e  Angst)',/ &
+               10X,'XX', 10X,'YY', 10X,'ZZ',10X,'XY', 10X,'YZ', 10X,'ZX'/ &
+               '  ----------------------------------------------------', &
+               '----------------------------')
+
+180       FORMAT(/ ' ',A,'  for field in x, y, z        (C/m^2)',/ &
+               &        10X,'XX', 10X,'YY', 10X,'ZZ', 10X,'XY', 10X,'YZ', 10X,'ZX'/ &
+               &        '  ----------------------------------------------------', &
+               &        '----------------------------')
+          IF (.NOT.LRPA) THEN
+             WRITE (IU6,170) 'PIEZOELECTRIC TENSOR (including local field effects)'
+             DO I =1,3
+                WRITE (IU6,140) IDIR_TEXT(I),(PIEZO(I,J,J),J=1,3), & 
+                     PIEZO(I,1,2),PIEZO(I,2,3),PIEZO(I,3,1)
+             ENDDO
+             
+             CALL TSYM3(PIEZO,ISYMOP,NROTK,LATT_CUR%A)
+          
+             WRITE (IU6,180) 'PIEZOELECTRIC TENSOR (including local field effects)'
+             DO I =1,3
+                WRITE (IU6,140) IDIR_TEXT(I),(PIEZO(I,J,J)*FACT,J=1,3), & 
+                     PIEZO(I,1,2)*FACT,PIEZO(I,2,3)*FACT,PIEZO(I,3,1)*FACT
+             ENDDO
+140          FORMAT(2X,A1,6F12.5)
+
+             ! remove any drift from BORN charges
+             IF (IO%IU0>0) WRITE(IO%IU0,*) 'Born effective charges drift removed'
+             TMP=0
+             DO N=1,T_INFO%NIONS
+                TMP(:,:)=TMP(:,:)+BORN_CHARGES(:,:,N)/T_INFO%NIONS
+             ENDDO
+             DO N=1,T_INFO%NIONS
+                BORN_CHARGES(:,:,N)=BORN_CHARGES(:,:,N)-TMP(:,:)
+             ENDDO
+             
+          
+             WRITE (IU6,*)
+             WRITE (IU6,'(X,A)') 'BORN EFFECTIVE CHARGES (including local field effects) (in e, cummulative output)'
+             WRITE (IU6,'(X,A)') '---------------------------------------------------------------------------------'
+             
+             DO N=1,T_INFO%NIONS
+                WRITE (IU6,'(" ion ",I4)') N
+                DO IDIR =1,3
+                   WRITE (IU6,'(I5,3F12.5)') IDIR,BORN_CHARGES(IDIR,:,N)
+                ENDDO
+             ENDDO
+
+             CALL XML_BORN_CHARGES(BORN_CHARGES,T_INFO%NIONS)
+            ! now set the Born charges in the global array defined in pead
+             IF (.NOT. LBORN) THEN
+                LBORN=.TRUE.
+                IF (ALLOCATED(BORN_CHARGES_PEAD)) DEALLOCATE(BORN_CHARGES_PEAD)
+                ALLOCATE(BORN_CHARGES_PEAD(3,3,T_INFO%NIOND))
+             ENDIF
+             BORN_CHARGES_PEAD=BORN_CHARGES
+          ENDIF
+       ENDIF
+    ENDIF
+    IF (DOF>0 .AND. IU6>=0) THEN
+       IF (DYN%ISIF>0) THEN
+160       FORMAT(/ ' INTERNAL STRAIN TENSOR FOR ION ',I4,' for displacements in x,y,z  (eV/Angst):',/ &
+               10X,'X', 11X,'Y', 11X,'Z', 10X,'XY', 10X,'YZ', 10X,'ZX'/ &
+               '  ----------------------------------------------------', &
+               '----------------------------')
+          DO N=1,T_INFO%NIONS
+             WRITE(IU6,160) N
+             DO I =1,3
+                WRITE (IU6,140) IDIR_TEXT(I),(ST(J,J,I,N),J=1,3),ST(1,2,I,N),ST(2,3,I,N),ST(3,1,I,N)
+             ENDDO
+          ENDDO
+       END IF
+       WRITE (IU6,130)
+    ENDIF
+
+!=======================================================================
+! apply delta impulse in time DFIELD on ions, by adding 
+! a force term to FORCE
+!=======================================================================
+    IF (.NOT. DFIELD_DONE) THEN
+       DFIELD_DONE=.TRUE.
+       DO N=1,T_INFO%NIONS
+          DO IDIR =1,3 ! loop over cartesian direction of external field
+             FORCE(:,N)=FORCE(:,N)+BORN_CHARGES(IDIR,:,N)*DFIELD(IDIR)/DYN%POTIM
+          ENDDO
+       ENDDO
+       
+       ALLOCATE(POSION_LAST(3,T_INFO%NIONS))
+       ALLOCATE(BORN_CHARGES_SAVE(3,3,T_INFO%NIONS))
+
+       ! store initial postions for later use (required for evolution of dipole moment)
+       POSION_LAST=T_INFO_0%POSION
+    ENDIF
+
+    
+    IF (ALLOCATED(BORN_CHARGES_SAVE) .AND. LEPSILON) THEN
+       BORN_CHARGES_SAVE=BORN_CHARGES
+    ENDIF
+!=======================================================================
+!
+! final processing and output
+! vibrational frequencies etc.
+!
+!=======================================================================
+    IF (DOF>0 .AND. IU6>=0 ) THEN
+
+       ALLOCATE(SECOND_DERIV(DOF,DOF))
+       
+       DO N=1,DOF
+          CALL FIND_IJ(NIONS,T_INFO%LSFOR,T_INFO%LSDYN,N,I,J)       
+          DO M=1,DOF
+             SECOND_DERIV(M,N)=DISPL_FORCES(M,I,J)
+          END DO
+       END DO
+       
+       IF (IU6>=0) THEN
+          WRITE (IU6,*) 
+          WRITE (IU6,*) 'SECOND DERIVATIVES (NOT SYMMETRIZED)'
+          WRITE (IU6,*) '------------------------------------'
+          CALL PRINT_SECOND_DERIV(NIONS,DOF,SECOND_DERIV,T_INFO%LSFOR,T_INFO%LSDYN,IU6)
+       END IF
+
+       ! symmetrize Hessian matrix
+       DO N=1,DOF
+          DO M=N+1,DOF
+             X=0.5_q*(SECOND_DERIV(N,M)+SECOND_DERIV(M,N))
+             SECOND_DERIV(N,M)=X
+             SECOND_DERIV(M,N)=X
+          END DO
+       END DO
+
+       ALLOCATE(WORK(DOF,32),EIGENVECTORS(DOF,DOF),EIGENVALUES(DOF))
+
+       EIGENVECTORS=SECOND_DERIV
+       N=1
+       DO I=1,T_INFO%NTYP
+          DO J=1,T_INFO%NITYP(I)
+             DO K=1,3
+                CALL FIND_DOF_INDEX(NIONS,T_INFO%LSFOR,T_INFO%LSDYN,K,N,M)
+                IF (M>0) EIGENVECTORS(:,M)=EIGENVECTORS(:,M)/SQRT(T_INFO%POMASS(I))
+                IF (M>0) EIGENVECTORS(M,:)=EIGENVECTORS(M,:)/SQRT(T_INFO%POMASS(I))
+             END DO
+             N=N+1
+          END DO
+       END DO
+
+       CALL XML_TAG("dynmat")
+       CALL XML_VECARRAY("hessian")
+       CALL XML_ARRAY_REAL(EIGENVECTORS)
+       CALL XML_CLOSE_TAG
+
+       CALL DSYEV &
+            ('V','U',DOF,EIGENVECTORS,DOF, &
+            EIGENVALUES,WORK,32*DOF, IERROR)
+       IF (IERROR/=0) THEN
+          IF (IU6>=0) THEN
+             WRITE(IU6,*) "Error while diagonalisation DSYEV INFO=",IERROR
+             WRITE(IU6,*) "Some of (or all) eigenvectors and eigenvalues are not correct !"
+          END IF
+       END IF
+
+       CALL XML_VEC_REAL(EIGENVALUES,"eigenvalues",'(ES16.8)')
+       CALL XML_VECARRAY("eigenvectors")
+       CALL XML_ARRAY_REAL(EIGENVECTORS,'(ES16.8)')
+       CALL XML_CLOSE_TAG
+       CALL XML_CLOSE_TAG
+
+       CALL PRINT_EIGENVECTORS(NIONS,DOF,T_INFO_0%POSION,LATT_CUR%A, &
+            EIGENVECTORS,EIGENVALUES,       &
+            T_INFO%LSFOR,T_INFO%LSDYN,IU6)
+
+       N=1
+       DO I=1,T_INFO%NTYP
+          DO J=1,T_INFO%NITYP(I)
+             DO K=1,3
+                CALL FIND_DOF_INDEX(NIONS,T_INFO%LSFOR,T_INFO%LSDYN,K,N,M)
+                IF (M>0) EIGENVECTORS(M,:)=EIGENVECTORS(M,:)/SQRT(T_INFO%POMASS(I))
+             END DO
+             N=N+1
+          END DO
+       END DO
+
+       IF (IU6>=0 .AND. IO%NWRITE>=3) THEN
+          WRITE(IU6,*) "Eigenvectors after division by SQRT(mass)"
+          CALL PRINT_EIGENVECTORS(NIONS,DOF,T_INFO_0%POSION,LATT_CUR%A, &
+               EIGENVECTORS,EIGENVALUES,       &
+               T_INFO%LSFOR,T_INFO%LSDYN,IU6)
+       ENDIF
+       DEALLOCATE(WORK)
+
+       CALL STORE_RPA_SECOND_DERIV(SECOND_DERIV)
+!=======================================================================
+!
+! ionic contribution to dielectric, elastic and piezoelectric tensor
+!
+!=======================================================================
+       IF (DYN%ISIF>0 .OR. LEPSILON) THEN
+          WRITE(IO%IU6,130)
+          ! invert the matrix of the second derivatives
+          SECOND_DERIV=-SECOND_DERIV
+          CALL INV_SECOND_DERIV(SECOND_DERIV, DOF, IU6 )
+
+          ! ionic contribution to macroscopic dielectric tensor
+          IF (LBORN .AND. .NOT. LRPA .AND. IO%IU6>=0 ) THEN
+             CALL EPSILON_ION( T_INFO, DOF, SECOND_DERIV, BORN_CHARGES_PEAD, EPSILON )
+
+             ! induced polariation -> field
+             EPSILON=EPSILON*EDEPS/(LATT_CUR%OMEGA)
+             WRITE(IO%IU6,1100) 'IONIC CONTRIBUTION',EPSILON
+
+             CALL XML_TENSOR("epsilon_ion",EPSILON)
+
+             CALL EPSILON_ION_OMEGA( T_INFO, DOF, EIGENVECTORS, EIGENVALUES, BORN_CHARGES_PEAD, LATT_CUR%OMEGA )
+          ENDIF
+
+          IF (DYN%ISIF>0.AND.IO%IU6>=0) THEN
+100       FORMAT(/ &
+            A / &
+            ' Direction', &
+            4X,'XX', 10X,'YY', 10X,'ZZ', 10X,'XY', 10X,'YZ', 10X,'ZX'/ &
+            ' --------------------------------------------------------------------------------'/ &
+            ' XX     ',6F12.4/ &
+            ' YY     ',6F12.4/ &
+            ' ZZ     ',6F12.4/ &
+            ' XY     ',6F12.4/ &
+            ' YZ     ',6F12.4/ &
+            ' ZX     ',6F12.4/ &
+            ' --------------------------------------------------------------------------------'/)
+             CALL ELASTIC_ION( T_INFO, DOF, SECOND_DERIV, ST, ELASTIC )
+
+             ELASTICP(1,:,:)=ELASTIC(1,1,:,:)
+             ELASTICP(2,:,:)=ELASTIC(2,2,:,:)
+             ELASTICP(3,:,:)=ELASTIC(3,3,:,:)
+             ELASTICP(4,:,:)=ELASTIC(1,2,:,:)
+             ELASTICP(5,:,:)=ELASTIC(2,3,:,:)
+             ELASTICP(6,:,:)=ELASTIC(3,1,:,:)
+
+             FACT=EVTOJ*1E22_q/LATT_CUR%OMEGA
+
+             WRITE(IU6,100) ' ELASTIC MODULI CONTR FROM IONIC RELAXATION (kBar)', ( &
+                  (ELASTICP(J,I,I)*FACT,I=1,3), &
+                   ELASTICP(J,1,2)*FACT,ELASTICP(J,2,3)*FACT,ELASTICP(J,3,1)*FACT,J=1,6)
+          END IF
+
+          ! ionic contribution to piezoelectric tensor
+          IF ( DYN%ISIF>0 .AND. LBORN .AND. .NOT. LRPA .AND.IO%IU6>=0 ) THEN
+
+             CALL PIEZO_ION( T_INFO, DOF, SECOND_DERIV, ST, BORN_CHARGES_PEAD, PIEZO )
+             
+             WRITE (IU6,180) 'PIEZOELECTRIC TENSOR IONIC CONTR'
+             FACT=EVTOJ*1E20_q/LATT_CUR%OMEGA
+             DO I =1,3
+                WRITE (IU6,140) IDIR_TEXT(I),(PIEZO(I,J,J)*FACT,J=1,3), & 
+                     PIEZO(I,1,2)*FACT,PIEZO(I,2,3)*FACT,PIEZO(I,3,1)*FACT
+             ENDDO
+          ENDIF
+       END IF
+       DEALLOCATE(SECOND_DERIV, EIGENVECTORS, EIGENVALUES)
+    END IF
+    IF (IO%IU6>=0) WRITE(IO%IU6,130)
+
+    DEALLOCATE(T_INFO_0%POSION)
+    DEALLOCATE(INITIAL_FORCE)
+    DEALLOCATE(DISPL_FORCES,BORN_CHARGES,BORN_CHARGES2, &
+      PIEZO,INT_STRAIN)
+
+    IF (IBRION==8) THEN
+      DEALLOCATE(D, ND, IDIRD)
+    ENDIF
+
+    IF (IU0>=0 .AND. DOF>0) THEN
+       WRITE (IU0,*) 'Linear response finished'
+       WRITE (17,*) 'Linear response finished'
+    ENDIF
+
+    IF (IO%LOPEN) CALL WFORCE(IO%IU6)
+
+  END SUBROUTINE LR_SKELETON
+
+!************************ SUBROUTINE STORE_DIPOLE_AND_AUTOCORRELATE ****
+!
+! Routine to store the dipole moment as a function of time
+!
+!***********************************************************************
+
+  SUBROUTINE STORE_DIPOLE_AND_AUTOCORRELATE( T_INFO, LATT_CUR, POTIM, NSW, NSTEP, IO)
+    USE constant
+    USE lattice 
+    USE poscar
+    USE base
+    USE mlrf_main
+    IMPLICIT NONE
+    TYPE (type_info)   T_INFO     ! information on positions etc.
+    TYPE (latt)        LATT_CUR   ! lattice parameters
+    REAL(q)            POTIM
+    INTEGER            NSW        ! total number of steps
+    INTEGER            NSTEP      ! current step
+    TYPE (in_struct)   IO
+    REAL(q),PARAMETER :: PLANK=6.626075E-34
+  ! local variables
+    REAL(q) :: DIPOLE(3), TMP(3), OMEGA_MAX, OMEGA, DAMPING, SCALE
+    INTEGER :: N, I, J
+    COMPLEX(q), ALLOCATABLE :: EPSILON(:,:)
+    COMPLEX(q) :: EXPFAC
+    
+    ! first allocate if required
+    IF (.NOT. ALLOCATED(DIPOLE_TIME)) THEN
+       ALLOCATE(DIPOLE_TIME(3, NSW))
+       DIPOLE_TIME=0
+    ENDIF
+
+    ! first calculate current dipole
+    DIPOLE=0
+    
+    SCALE=1.0_q/SQRT(DFIELD(1)**2+DFIELD(2)**2+DFIELD(3)**2)
+    DO N=1,T_INFO%NIONS
+       TMP=T_INFO%POSION(:,N)-POSION_LAST(:,N)
+       TMP(1)=MOD(TMP(1)+4.5_q,1.0_q)-0.5_q
+       TMP(2)=MOD(TMP(2)+4.5_q,1.0_q)-0.5_q
+       TMP(3)=MOD(TMP(3)+4.5_q,1.0_q)-0.5_q
+       ! convert to cartesian coordinates
+       CALL DIRKAR(1, TMP, LATT_CUR%A)
+       ! divide by the absolute magnitude of the external field
+       ! to obtain response
+       DIPOLE(:)=DIPOLE(:)+MATMUL(BORN_CHARGES_SAVE(:,:,N), TMP)*SCALE
+    ENDDO
+    ! store current positions into last position array
+    POSION_LAST=T_INFO%POSION
+
+    IF (NSTEP==1) THEN
+       ! initial dipole is assumed to be zero
+       DIPOLE_TIME(:,NSTEP)=0
+    ELSE
+       ! accumulate the change of the dipole over time
+       DIPOLE_TIME(:,NSTEP)=DIPOLE(:)+DIPOLE_TIME(:,NSTEP-1)
+    ENDIF
+
+    IF (NSTEP==NSW) THEN
+       ALLOCATE(EPSILON(3, NSW))
+       EPSILON=0
+
+       OMEGA_MAX=PI/POTIM
+       DAMPING=4.0_q/(POTIM*NSW)
+
+       IF (IO%IU6>=0) THEN
+          DO I=0,NSW-1
+             WRITE(77,'(4F14.7)') POTIM*I, DIPOLE_TIME(:,I+1)
+          ENDDO
+       ENDIF
+
+       DO I=0,NSW-1
+          OMEGA=OMEGA_MAX/NSW*I
+          ! weight is the derivative of the function above
+          DO J=0,NSW-1
+             EXPFAC=EXP( ((0._q,1._q)*OMEGA-DAMPING )*POTIM*J) !expfac=exponential-factor
+             EPSILON(:,I+1)=EPSILON(:,I+1)-1.0_q*DIPOLE_TIME(:,J+1)*EXPFAC*POTIM
+          ENDDO
+       ENDDO !ENDDO omega_sum
+
+       ! in CALC_WRITE_DF there is another factor HARTREE**2 / AUTOA**2 
+       EPSILON=EPSILON*EDEPS/LATT_CUR%OMEGA
+
+       IF (IO%IU6>=0) THEN
+          DO I=0,NSW-1
+             ! convert from circular frequency to cm (see finite_diff.F)
+             WRITE(78,'(7F14.7)') OMEGA_MAX/NSW*I*1000, -REAL(EPSILON(:,I+1),q)
+          ENDDO
+          WRITE(78,*)
+          DO I=0,NSW-1
+             ! convert from circular frequency to cm (see finite_diff.F)
+             WRITE(78,'(7F14.7)') OMEGA_MAX/NSW*I*1000, -AIMAG(EPSILON(:,I+1))
+          ENDDO
+       ENDIF
+
+       DEALLOCATE(EPSILON)
+
+       
+    ENDIF
+
+  END SUBROUTINE STORE_DIPOLE_AND_AUTOCORRELATE
+
+
+!************************ SUBROUTINE INTERPOLATE_BAND_STR **************
+!
+! this routine interpolates the band structure to a dense k-point
+! grid 
+! the strategy is fairly simply
+! first the first derivative with respect to k is calculated
+!    (presently only the subspace of considered orbitals)
+! next the k-point grid is partly shifted and a diagonalization
+! in the subspace is performed
+! very little data is stored, to keep the routine simple
+! and concise
+! 
+!***********************************************************************
+
+    SUBROUTINE INTERPOLATE_BAND_STR(HAMILTONIAN, KPOINTS, GRID, LATT_CUR, LATT_INI, & 
+       &    T_INFO, NONLR_S, NONL_S, W, NEDOS, DOS, DOSI, NELECT, NUP_DOWN, &
+       &    LMDIM, P, SV, CQIJ, CDIJ, SYMM, IU0, IU6, RPHI)
+      USE prec
+      USE wave_high
+      USE lattice
+      USE poscar
+      USE mpimy
+      USE mgrid
+      USE nonl_high
+      USE base
+      USE pseudo
+      USE kpoints_change
+      USE constant
+      USE choleski
+      USE subrot
+      USE mlrf_main
+      USE hamil_high
+      IMPLICIT NONE
+
+      TYPE (ham_handle)  HAMILTONIAN
+      TYPE (kpoints_struct) KPOINTS
+      TYPE (grid_3d)     GRID
+      TYPE (latt)        LATT_CUR
+      TYPE (latt)        LATT_INI
+      TYPE (type_info)   T_INFO
+      TYPE (nonlr_struct)NONLR_S
+      TYPE (nonl_struct) NONL_S
+      TYPE (potcar)      P(:)
+      TYPE (wavespin), TARGET :: W
+      INTEGER LMDIM
+      OVERLAP         CQIJ (LMDIM,LMDIM,W%WDES%NIONS,W%WDES%NCDIJ)
+      OVERLAP         CDIJ (LMDIM,LMDIM,W%WDES%NIONS,W%WDES%NCDIJ)
+      TYPE (symmetry) SYMM
+      RGRID           SV(DIMREAL(GRID%MPLWV),W%WDES%NCDIJ)
+      INTEGER IU0, IU6
+      COMPLEX(qs), OPTIONAL :: RPHI(:,:,:,:,:)
+      INTEGER    NEDOS
+      REAL(q)    DOS(NEDOS,W%WDES%ISPIN),DOSI(NEDOS,W%WDES%ISPIN), NELECT, NUP_DOWN
+!    local
+      INTEGER NKPTS_ORIG, I, ISP, NK, NPOS, NB
+      INTEGER IKX, IKY, IKZ, IKXP, IKYP, IKZP, IWZ
+      REAL(q) DISPL(3), DISPL_CART(3), DISPL_FOUND(3), DIST, DIST_FOUND, KSTART
+      REAL(q) EFERMI, ENTROPY, PAR(1,1,1,1,W%WDES%NCDIJ),DOSPAR(1,1,1,W%WDES%NCDIJ)
+      REAL(q)    DOS_TMP(NEDOS,W%WDES%ISPIN),DOSI_TMP(NEDOS,W%WDES%ISPIN), EFERMI_TMP
+      INTEGER :: N
+      REAL(q) :: EXHF
+!-----------------------------------------------------------------------
+! double k-points in new structure
+! in the upper part of the wavefunction arrays the wavefunctions 
+! corresponding to the new shifted k-points are stored
+! in the lower part the original wavefunctions are stored
+!-----------------------------------------------------------------------
+
+      IF (KPOINTS%NKPX<1 .OR. KPOINTS%NKPY<1 .OR. KPOINTS%NKPZ<1 )  THEN
+         ! here we need some warning
+         ! the routine works only using regular gamma centered grids
+         WRITE(*,*) ' INTERPOLATE_BAND_STR: requires a regular k-point grid '
+         RETURN
+      ENDIF
+
+      CALL CHECK_FULL_KPOINTS
+
+      ! original number of k-points
+      NKPTS_ORIG=W%WDES%NKPTS
+#ifdef oldsym
+      CALL RE_READ_KPOINTS(KPOINTS,LATT_CUR, &
+           SYMM%ISYM>=0.AND..NOT.W%WDES%LSORBIT.AND..NOT.W%WDES%LSPIRAL, &
+           T_INFO%NIONS,SYMM%ROTMAP,SYMM%MAGROT,SYMM%ISYM, IU6, IU0, W%WDES%VKPT(:,1:NKPTS_ORIG))
+#else
+      CALL RE_READ_KPOINTS(KPOINTS,LATT_CUR, &
+           SYMM%ISYM>=0.AND..NOT.W%WDES%LNONCOLLINEAR, &
+           T_INFO%NIONS,SYMM%ROTMAP,SYMM%MAGROT,SYMM%ISYM, IU6, IU0, W%WDES%VKPT(:,1:NKPTS_ORIG))
+#endif
+      CALL KPAR_SYNC_ALL(W%WDES,W)
+      CALL RE_GEN_LAYOUT( GRID, W%WDES, KPOINTS, LATT_CUR, LATT_INI, IU6, IU0)
+      CALL REALLOCATE_WAVE( W, GRID, W%WDES, NONL_S, T_INFO, P, LATT_CUR)
+
+      CALL XML_TAG("eigenvalues", comment="interpolated")
+!-----------------------------------------------------------------------
+! loop over new super k-point grid
+! a  kind of Wigner Seitz procedure is used to generate the new supergrid
+! this can be bypassed by setting IWZ to 0
+! a few notes are in place here
+! ) only gamma centered grids do not violate the symmetry
+!   and are therefore recommended
+! ) such super grids are created by setting KINTER to an odd value
+! ) otherwise the super grids might spoil the symmetry
+!-----------------------------------------------------------------------
+      IWZ=2
+      KSTART=-REAL(ABS(KINTER),q)/2+0.5_q
+      DOS =0
+      DOSI=0
+      EFERMI=0
+
+      DO IKX=0,ABS(KINTER)-1
+      DO IKY=0,ABS(KINTER)-1
+      DO IKZ=0,ABS(KINTER)-1
+
+         ! search the equivalent k-point with the shortest length
+         DIST_FOUND=1E6
+         DO IKXP=-IWZ,IWZ
+         DO IKYP=-IWZ,IWZ
+         DO IKZP=-IWZ,IWZ
+            DISPL(1)=((IKX+KSTART)/ABS(KINTER)+IKXP)/KPOINTS%NKPX
+            DISPL(2)=((IKY+KSTART)/ABS(KINTER)+IKYP)/KPOINTS%NKPY
+            DISPL(3)=((IKZ+KSTART)/ABS(KINTER)+IKZP)/KPOINTS%NKPZ
+            ! k-point displacement in cartesian coordinates
+            DISPL_CART=DISPL
+            CALL DIRKAR(1, DISPL_CART(1), LATT_CUR%B)
+            DIST=DISPL_CART(1)**2+DISPL_CART(2)**2+DISPL_CART(3)**2
+            IF (DIST<DIST_FOUND) THEN
+               DISPL_FOUND=DISPL
+               DIST_FOUND =DIST
+            ENDIF
+         ENDDO
+         ENDDO
+         ENDDO
+         
+         DISPL=DISPL_FOUND
+         DISPL_CART=DISPL
+         CALL DIRKAR(1, DISPL_CART(1), LATT_CUR%B)
+
+         DO NK=1,NKPTS_ORIG
+            W%WDES%VKPT(:,NKPTS_ORIG+NK)=W%WDES%VKPT(:,NK)+DISPL
+         ENDDO
+
+         IF (PRESENT(RPHI)) THEN
+            DO ISP=1,W%WDES%ISPIN
+               DO NK=1,NKPTS_ORIG
+                  DO N=1,W%WDES%NBANDS
+                     W%CW(:,N,NKPTS_ORIG+NK,ISP)=W%CW(:,N,NK,ISP)+TPI*( &
+                          RPHI(:,N,NK,ISP,1)*(0.0_q,1.0_q)*DISPL_CART(1)+ & 
+                          RPHI(:,N,NK,ISP,2)*(0.0_q,1.0_q)*DISPL_CART(2)+ &
+                          RPHI(:,N,NK,ISP,3)*(0.0_q,1.0_q)*DISPL_CART(3))
+                  ENDDO
+               ENDDO
+            ENDDO
+         ELSE
+            DO ISP=1,W%WDES%ISPIN
+               DO NK=1,NKPTS_ORIG
+                  DO N=1,W%WDES%NBANDS
+                     W%CW(:,N,NKPTS_ORIG+NK,ISP)=W%CW(:,N,NK,ISP)
+                  ENDDO
+               ENDDO
+            ENDDO
+         ENDIF
+         CALL SET_DATAKE(W%WDES, LATT_CUR%B)
+         IF (NONLR_S%LREAL) THEN
+            CALL RSPHER(GRID,NONLR_S,LATT_CUR)
+         ELSE
+            CALL SPHER(GRID,NONL_S,P,W%WDES,LATT_CUR, 1)
+         ENDIF
+         CALL PROALL (GRID,LATT_CUR,NONLR_S,NONL_S,W)
+
+         CALL ORTHCH(W%WDES,W, W%WDES%LOVERL, LMDIM, CQIJ)
+         
+         CALL EDDIAG(HAMILTONIAN,GRID,LATT_CUR,NONLR_S,NONL_S,W,W%WDES,SYMM, &
+              LMDIM,CDIJ,CQIJ,2,SV,T_INFO,P,IU0,EXHF, & 
+              NKSTART=NKPTS_ORIG+1)
+
+         IF (KPOINTS%ISMEAR>=0) THEN
+         ! well this is not elegant, we now simply set the weights for
+         ! lower k-point set to 0, and that for the upper one to the
+         ! proper weight
+         KPOINTS%WTKPT(NKPTS_ORIG+1:NKPTS_ORIG*2)=KPOINTS%WTKPT(1:NKPTS_ORIG)
+         KPOINTS%WTKPT(1:NKPTS_ORIG)=0
+
+         ! sum dos
+         CALL DENSTA( IU0, IU6, W%WDES, W, KPOINTS, NELECT, &
+              NUP_DOWN, ENTROPY, EFERMI_TMP, KPOINTS%SIGMA, .TRUE., &
+              NEDOS, 0, 0, DOS_TMP, DOSI_TMP, PAR, DOSPAR)
+
+         ! restore weights
+         KPOINTS%WTKPT(1:NKPTS_ORIG)=KPOINTS%WTKPT(NKPTS_ORIG+1:NKPTS_ORIG*2)
+         KPOINTS%WTKPT(NKPTS_ORIG+1:NKPTS_ORIG*2)=0
+
+         DOS =DOS +DOS_TMP *(1_q/REAL(KINTER,q)/REAL(KINTER,q)/REAL(KINTER,q))
+         DOSI=DOSI+DOSI_TMP*(1_q/REAL(KINTER,q)/REAL(KINTER,q)/REAL(KINTER,q))
+         EFERMI=EFERMI+EFERMI_TMP*(1_q/REAL(KINTER,q)/REAL(KINTER,q)/REAL(KINTER,q))
+         ENDIF
+
+         IF (IU6>=0) THEN
+            
+            DO ISP=1,W%WDES%ISPIN
+               WRITE(IU6,'(/" k-point displacement            :",3F10.4 )') DISPL
+               WRITE(IU6,'( " k-point displacement (cartesian):",3F10.4 )') DISPL_CART
+               IF (W%WDES%ISPIN==2) WRITE(IU6,'(/A,I1)') ' spin component ',ISP
+               DO N=NKPTS_ORIG+1,W%WDES%NKPTS
+                  WRITE(IU6,2201) N-NKPTS_ORIG, W%WDES%VKPT(1,N),W%WDES%VKPT(2,N),W%WDES%VKPT(3,N), &
+                       &             (I,REAL( W%CELTOT(I,N,ISP) ,KIND=q) ,W%FERTOT(I,N,ISP)*W%WDES%RSPIN,I=1,W%WDES%NB_TOT)
+               ENDDO
+            ENDDO
+2201        FORMAT(/' k-point ',I3,' :',3X,3F10.4/ &
+                 &         '  band No.  band energies     occupation '/ &
+                 &           (3X,I4,3X,F10.4,3X,F10.5))
+
+            
+         ENDIF
+
+         CALL XML_VEC_REAL( DISPL, "displacement" )
+         CALL XML_VEC_REAL( DISPL_CART, "displacement_cart" )
+
+         CALL XML_EIGENVAL_NOHEAD( W%CELTOT(:,NKPTS_ORIG+1:W%WDES%NKPTS,:), W%FERTOT(:,NKPTS_ORIG+1:W%WDES%NKPTS,:), &
+              W%WDES%NB_TOT, W%WDES%NKPTS-NKPTS_ORIG, W%WDES%ISPIN)
+      
+      ENDDO
+      ENDDO
+      ENDDO
+!-----------------------------------------------------------------------
+! restore old data layout
+!-----------------------------------------------------------------------
+      CALL XML_CLOSE_TAG
+#ifdef oldsym
+      CALL RE_READ_KPOINTS(KPOINTS,LATT_CUR, &
+           SYMM%ISYM>=0.AND..NOT.W%WDES%LSORBIT.AND..NOT.W%WDES%LSPIRAL, &
+           T_INFO%NIONS,SYMM%ROTMAP,SYMM%MAGROT,SYMM%ISYM,-1,-1)
+#else
+      CALL RE_READ_KPOINTS(KPOINTS,LATT_CUR, &
+           SYMM%ISYM>=0.AND..NOT.W%WDES%LNONCOLLINEAR, &
+           T_INFO%NIONS,SYMM%ROTMAP,SYMM%MAGROT,SYMM%ISYM,-1,-1)
+#endif
+      CALL RE_GEN_LAYOUT( GRID, W%WDES, KPOINTS, LATT_CUR, LATT_INI, -1, -1)
+      CALL REALLOCATE_WAVE( W, GRID, W%WDES, NONL_S, T_INFO, P, LATT_CUR)
+
+      IF (KPOINTS%ISMEAR>=0) THEN
+      CALL XML_DOS(EFERMI, KPOINTS%EMIN, KPOINTS%EMAX, .FALSE., &
+           DOS, DOSI, DOSPAR, NEDOS, 1, 1, W%WDES%NCDIJ, comment='interpolated')
+      ENDIF
+
+
+    END SUBROUTINE INTERPOLATE_BAND_STR
+
+
+!************** SUBROUTINE INTERPOLATE_BANDSTR_GRDSHFT *****************
+!************************************************************************
+
+    SUBROUTINE INTERPOLATE_BANDSTR_GRDSHFT(HAMILTONIAN, E, KPOINTS, GRID, LATT_CUR, LATT_INI, & 
+       &    T_INFO, NONLR_S, NONL_S, W, NEDOS, &
+       &    LMDIM, P, SV, CQIJ, CDIJ, SYMM, INFO, IO, GRIDC, GRIDUS, C_TO_US, IRDMAX, RPHI)
+      USE prec
+      USE wave_high
+      USE hamil_high
+      USE lattice
+      USE poscar
+      USE mpimy
+      USE mgrid
+      USE nonl_high
+      USE base
+      USE pseudo
+      USE kpoints_change
+      USE constant
+      USE choleski
+      USE subrot
+      USE subrot_cluster
+      USE mlr_optic
+      USE mlrf_main
+      USE ini
+      USE david
+      IMPLICIT NONE
+
+      TYPE (ham_handle)     :: HAMILTONIAN
+      TYPE (energy)         :: E
+      TYPE (kpoints_struct) :: KPOINTS
+      TYPE (grid_3d)        :: GRID
+      TYPE (latt)           :: LATT_CUR
+      TYPE (latt)           :: LATT_INI
+      TYPE (type_info)      :: T_INFO
+      TYPE (nonlr_struct)   :: NONLR_S
+      TYPE (nonl_struct)    :: NONL_S
+      TYPE (potcar)         :: P(:)
+      TYPE (grid_3d)        :: GRIDC 
+      TYPE (grid_3d)        :: GRIDUS
+      TYPE (transit)        :: C_TO_US
+      TYPE (info_struct)    :: INFO
+      TYPE (in_struct)      :: IO
+      TYPE (symmetry)       :: SYMM
+      INTEGER               :: LMDIM, NEDOS
+      TYPE (wavespin), TARGET :: W
+      TYPE (eigenf_cluster_pointer),POINTER :: DEG_CLUSTER(:,:)
+      OVERLAP :: CQIJ (LMDIM,LMDIM,W%WDES%NIONS,W%WDES%NCDIJ)
+      OVERLAP :: CDIJ (LMDIM,LMDIM,W%WDES%NIONS,W%WDES%NCDIJ)
+      RGRID   :: SV(DIMREAL(GRID%MPLWV),W%WDES%NCDIJ)
+      REAL(q) :: DOS(NEDOS,W%WDES%ISPIN),DOSI(NEDOS,W%WDES%ISPIN)
+      COMPLEX(qs), OPTIONAL :: RPHI(:,:,:,:,:)
+      
+      TYPE (kpoints_struct) :: KPOINTS_INTER
+      TYPE (skpoints_full),SAVE,POINTER :: KPOINTS_INTER_FULL
+      TYPE (skpoints_full),SAVE,POINTER :: KPOINTS_FULL_TEMP
+      TYPE (wavedes)  :: WDES_INTER
+      TYPE (wavespin) :: W_INTER
+      TYPE (wavespin) :: WDIFF
+      ! eFL: I DO NOT THINK ALLOCW NEEDS THIS, REMOVE?
+      TYPE (wavefun)  :: WTMP
+
+      LOGICAL :: LDONE, LWARN, LDO_VEL
+      INTEGER :: I, L, K, J, ISP, NK, NPOS, NEDOS_DIEL, KPAR
+      INTEGER :: DISPINDEX, IBZINDEX, IDIR, JDIR, IRDMAX
+      INTEGER :: IK, N, NB, NB2, NSIM, NELM, ICOUEV, IWINDOW
+      REAL(q) :: EXHF, RMS, DESUM1, TOTEN, TOTENINTER, TOTENRDIFF, WO
+      REAL(q) :: TOTENORG, OTHERTERMS, EBANDSTR_INTER, DELTAE, EMAX
+      REAL(q) :: DER(3)
+      INTEGER :: MULTIPL(3)
+      REAL(q) :: EFERMI, ENTROPY, PAR(1,1,1,1,W%WDES%NCDIJ)
+      REAL(q) :: DOSPAR(1,1,1,W%WDES%NCDIJ)
+      REAL(q), ALLOCATABLE :: DISPL(:,:)
+      REAL(q) :: DISPLV(3), DISPLV_CART(3)
+      REAL(q), ALLOCATABLE :: EDER(:,:,:,:)
+      REAL(q), ALLOCATABLE :: EINTERPOL_FULL(:,:,:,:), EINTERPOL(:,:,:,:)
+      REAL(q), ALLOCATABLE :: KINTERPOL(:,:)
+      GDEFS, ALLOCATABLE :: CHAMD(:,:,:,:,:)
+      GDEFS, ALLOCATABLE :: CHAM(:,:,:,:,:)
+      COMPLEX(q), ALLOCATABLE  :: EPSDD(:,:,:)
+      COMPLEX(q), ALLOCATABLE  :: EPSJJ(:,:,:)
+      REAL(q), ALLOCATABLE :: WPLASM(:,:), COND(:,:)
+      REAL(q), ALLOCATABLE :: BIMAG(:,:)
+      COMPLEX(q), ALLOCATABLE :: CW_OLD(:,:,:,:)
+      REAL(q), ALLOCATABLE :: VKPT_OLD(:,:)
+      REAL(q) :: S(3,3)
+
+      INTEGER  ISYMOP,NROT,IGRPOP,NROTK,INVMAP,NPCELL
+      REAL(q)  GTRANS,AP
+      COMMON /SYMM/   ISYMOP(3,3,48),NROT,IGRPOP(3,3,48),NROTK, &
+           GTRANS(3,48),INVMAP(48),AP(3,3),NPCELL
+
+#ifdef MPI
+      IF (W%WDES%COMM_KINTER%NCPU.NE.1) THEN
+         CALL VTUTOR('E','NOKPAR',0.0_q,1,0,1,(0.0_q,0.0_q),1, &
+              .TRUE.,1, IO%IU6,3)
+         CALL VTUTOR('S','NOKPAR',0.0_q,1,0,1,(0.0_q,0.0_q),1, &
+              .TRUE.,1, IO%IU0,3)
+         RETURN
+      ENDIF
+#endif
+
+      IF (KPOINTS%ISMEAR <= -4) THEN
+         CALL VTUTOR('E','GRDSHFT_NOTET',0.0_q,1,0,1,(0.0_q,0.0_q),1, &
+              .TRUE.,1, IO%IU6,3)
+         CALL VTUTOR('S','GRDSHFT_NOTET',0.0_q,1,0,1,(0.0_q,0.0_q),1, &
+              .TRUE.,1, IO%IU0,3)
+         RETURN
+      ENDIF
+
+      LDO_VEL=LVEL.OR.IO%LOPTICS
+
+      TOTENORG = BANDSTRUCTURE_ENERGY(W%WDES,W)+E%DENC+E%XCENC+E%TEWEN+ &
+           E%PSCENC+E%EENTROPY+ E%PAWPS+E%PAWAE+INFO%EALLAT+E%EXHF
+      
+      CALL GENERATE_GRDSHFT_GRD_AND_DISPL(KPOINTS, W%WDES, LATT_CUR, T_INFO, &
+           SYMM, IO, KINTER, KPOINTS_INTER, KPOINTS_INTER_FULL, DISPL)
+      
+      ALLOCATE(EINTERPOL(W%WDES%NB_TOT,KPOINTS_INTER%NKPTS,W%WDES%ISPIN,4), & 
+               KINTERPOL(3,KPOINTS_INTER%NKPTS), VKPT_OLD(3,KPOINTS%NKPTS), &
+               CW_OLD(SIZE(W%CW,1),W%WDES%NBANDS,KPOINTS%NKPTS,W%WDES%ISPIN))
+      
+      EFERMI=0.0
+      DOS =0.0
+      DOSI=0.0
+     
+      IF (IO%LOPTICS) THEN
+         NEDOS_DIEL=MAX(NEDOS,1000)
+         ALLOCATE(EPSDD(NEDOS_DIEL,3,3), EPSJJ(NEDOS_DIEL,3,3), &
+              WPLASM(3,3), COND(3,3), BIMAG(3,3), &
+              CHAMD(W%WDES%NB_TOT, W%WDES%NB_TOT, W%WDES%NKPTS, &
+              W%WDES%ISPIN, 3), &
+              CHAM(W%WDES%NB_TOT, W%WDES%NB_TOT, KPOINTS_INTER%NKPTS, &
+              W%WDES%ISPIN, 3))
+         
+         EPSDD=0
+         EPSJJ=0
+         BIMAG=0
+         
+         ! eFL: NOT SO SURE ABOUT THIS BUCKET THING FOR EACH DIFFERENT
+         !      DISPLACEMENT. I SUSPECT THIS MIGHT CHANGE SLIGHTLY, SAY
+         !      WE HIT A K-POINT THAT MODIFIES THIS RANGE WHILE DISPLACING
+         !      MAYBE DO THIS FOR EACH DISPLACEMENT...BUT THEN WE HAVE THE
+         !      PROBLEM OF A DIFFERENT dENERGY FOR EACH INDEX...HMMM...
+         !      SO HERE WE USE THE BUCKETING FROM THE INPUT GRID
+         EMAX=MAX_ENERGY_UNOCCUPIED(W%WDES,W)*1.2
+         IF (EMAX<=0) THEN
+            CALL VTUTOR('E','NOOCC',0.0_q,1,0,1,(0.0_q,0.0_q),1,.TRUE.,1, &
+                 IO%IU6,3)
+            CALL VTUTOR('S','NOOCC',0.0_q,1,0,1,(0.0_q,0.0_q),1,.TRUE.,1, &
+                 IO%IU0,3)
+            RETURN
+         ENDIF
+         DELTAE=EMAX/(NEDOS_DIEL-1)
+         
+         CALL DENSTA( IO%IU0, IO%IU6, W%WDES, W, KPOINTS, &
+              INFO%NELECT, INFO%NUP_DOWN, ENTROPY, EFERMI, &
+              KPOINTS%SIGMA, .TRUE., NEDOS, 0, 0, &
+              DOS, DOSI, PAR, DOSPAR)
+      ENDIF
+      
+      IF (LDO_VEL) THEN
+         ALLOCATE(EDER(W%WDES%NB_TOT,KPOINTS%NKPTS,W%WDES%ISPIN,3)) 
+         CALL ALLOCW(W%WDES,WDIFF,WTMP,WTMP)
+      ENDIF
+
+      DO ISP=1,W%WDES%ISPIN
+         DO NK=1,KPOINTS%NKPTS
+            IF (ISP==1) THEN
+               VKPT_OLD(:,NK)=W%WDES%VKPT(:,NK)
+            ENDIF
+            DO N=1,W%WDES%NBANDS
+               CW_OLD(:,N,NK,ISP)=W%CW(:,N,NK,ISP)
+            ENDDO
+         ENDDO
+      ENDDO
+
+      
+      EINTERPOL=0.0
+      KINTERPOL=0.0
+      IBZINDEX=1
+      DISPINDEX=1
+
+      WDES_INTER=W%WDES
+      WDES_INTER%NKPTS= KPOINTS_INTER%NKPTS
+      WDES_INTER%VKPT =>KPOINTS_INTER%VKPT
+      WDES_INTER%WTKPT=>KPOINTS_INTER%WTKPT
+
+      CALL ALLOCW_NOPLANEWAVE(WDES_INTER, W_INTER)
+
+      IF (IO%IU0>=0) WRITE(IO%IU0,*) ' '
+      IF (IO%IU0>=0) WRITE(IO%IU0,*) &
+           '------------------------------------------------'// &
+           '--------------'
+      IF (IO%IU0>=0) WRITE(IO%IU0,*) &
+           'Starting gridshift interpolation of the bandstructure'
+      IF (IO%IU0>=0) WRITE(IO%IU0,*) &
+           '  original grid sampling:', KPOINTS%NKPX, &
+           KPOINTS%NKPY, KPOINTS%NKPZ
+      IF (IO%IU0>=0) WRITE(IO%IU0,*) &
+           '  new grid grid sampling:', KPOINTS%NKPX*ABS(KINTER), &
+           KPOINTS%NKPY*ABS(KINTER), KPOINTS%NKPZ*ABS(KINTER)
+      IF (IO%IU0>=0) WRITE(IO%IU0,*) &
+           '------------------------------------------------'// &
+           '--------------'
+            
+      DO IK=1,ABS(KINTER*KINTER*KINTER)
+         IF (IO%IU0>=0) THEN
+            WRITE(IO%IU0,*) 'Displacement', IK
+            WRITE(17,*)     'Displacement', IK
+         ENDIF
+
+         DISPLV=DISPL(:,IK)
+
+         DISPLV_CART=DISPLV
+         CALL DIRKAR(1, DISPLV_CART(1), LATT_CUR%B)
+
+         DO NK=1,KPOINTS%NKPTS
+            W%WDES%VKPT(:,NK)=VKPT_OLD(:,NK)+DISPLV
+         ENDDO
+
+         IF (KINTER>=0) THEN
+            DO ISP=1,W%WDES%ISPIN
+               DO NK=1,KPOINTS%NKPTS
+                  DO NB=1,W%WDES%NBANDS
+                     ! eFL: Here we not use RPHI even if we hit a
+                     ! displaced k-point that exists in the input IBZ
+                     ! The accuracy would most likely be improve by using
+                     ! the orginal CW values at these points.
+                     ! For this we need a mapping table between the
+                     ! KPOINTS_INTER and the grid created by the
+                     ! displacements
+                     W%CW(:,NB,NK,ISP)=CW_OLD(:,NB,NK,ISP)+TPI*( &
+                          RPHI(:,NB,NK,ISP,1)*(0.0_q,1.0_q)*DISPLV_CART(1)+ & 
+                          RPHI(:,NB,NK,ISP,2)*(0.0_q,1.0_q)*DISPLV_CART(2)+ &
+                          RPHI(:,NB,NK,ISP,3)*(0.0_q,1.0_q)*DISPLV_CART(3))
+                  ENDDO
+               ENDDO
+            ENDDO
+         ELSE
+            DO ISP=1,W%WDES%ISPIN
+               DO NK=1,KPOINTS%NKPTS
+                  DO NB=1,W%WDES%NBANDS
+                     W%CW(:,NB,NK,ISP)=CW_OLD(:,NB,NK,ISP)
+                  ENDDO
+               ENDDO
+            ENDDO
+         ENDIF
+         CALL SET_DATAKE(W%WDES, LATT_CUR%B)
+         IF (NONLR_S%LREAL) THEN
+            CALL RSPHER(GRID,NONLR_S,LATT_CUR)
+         ELSE
+            CALL SPHER(GRID,NONL_S,P,W%WDES,LATT_CUR, 1)
+         ENDIF
+         CALL PROALL (GRID,LATT_CUR,NONLR_S,NONL_S,W)
+
+         CALL ORTHCH(W%WDES,W, W%WDES%LOVERL, LMDIM, CQIJ)        
+
+         IF (.NOT. LINTERFAST) THEN
+            NSIM=W%WDES%NSIM*2
+#ifdef MPI
+            NSIM=((W%WDES%NSIM*2+W%WDES%COMM_INTER%NCPU-1)/ &
+                 W%WDES%COMM_INTER%NCPU)*W%WDES%COMM_INTER%NCPU
+#endif
+            DO NELM=1,10
+               CALL EDDAV(HAMILTONIAN,P, GRID,INFO,LATT_CUR,NONLR_S,NONL_S, &
+                    W,W%WDES, NSIM, LMDIM,CDIJ,CQIJ, RMS,DESUM1,ICOUEV, SV, &
+                    E%EXHF, IO%IU6,IO%IU0, .FALSE., .TRUE., .FALSE.)
+               E%EBANDSTR=BANDSTRUCTURE_ENERGY(W%WDES, W)
+
+               IF (IO%IU0>=0) WRITE(17, 200)      &
+                    NELM,E%EBANDSTR,E%EBANDSTR-TOTEN,DESUM1,ICOUEV,RMS
+               IF (IO%IU0>=0) WRITE(IO%IU0, 200)  &
+                    NELM,E%EBANDSTR,E%EBANDSTR-TOTEN,DESUM1,ICOUEV,RMS
+
+               TOTEN=E%EBANDSTR
+           
+200            FORMAT('DAV: ',I3,'   ',E20.12,'   ',E12.5,'   ',E12.5, &
+                    &       I6,'  ',E10.3)
+               
+               IF (ABS(DESUM1) < ABS(INFO%EDIFF) ) EXIT
+            ENDDO
+         ELSE IF (LDO_VEL) THEN
+            CALL EDDIAG(HAMILTONIAN,GRID,LATT_CUR,NONLR_S,NONL_S,W,W%WDES, &
+                 SYMM, LMDIM,CDIJ,CQIJ,3,SV,T_INFO,P,IO%IU0,EXHF)
+         ELSE
+            CALL EDDIAG(HAMILTONIAN,GRID,LATT_CUR,NONLR_S,NONL_S,W,W%WDES, &
+                 SYMM,LMDIM,CDIJ,CQIJ,2,SV,T_INFO,P,IO%IU0,EXHF)
+         ENDIF
+
+         E%EBANDSTR=BANDSTRUCTURE_ENERGY(W%WDES, W)
+
+! eFL: MARTIJN, CAN YOU CHECK IF THESE THINGS ARE OKEY FOR
+!      ISPIN=2? I THINK SO...
+
+         IF (LDO_VEL) THEN
+            WDIFF%CW   =0
+            WDIFF%CPROJ=0
+
+            NULLIFY(DEG_CLUSTER)
+            CALL FIND_DEG_CLUSTERS(W%WDES, W, DEG_CLUSTER)
+
+            IF (LUSEPEAD()) THEN
+               ALLOCATE(KPOINTS_FULL_TEMP)
+               KPOINTS_FULL_TEMP = KPOINTS_FULL
+               KPOINTS_FULL = KPOINTS_INTER_FULL
+            ENDIF
+ 
+            IF (IO%LOPTICS) THEN
+               IF (IO%IU0>=0) WRITE(IO%IU0,*) 'Calculating the energy '// &
+                    'derivatives and density matrix the displaced '// &
+                    'fine grid:'
+            ELSE
+               IF (IO%IU0>=0) WRITE(IO%IU0,*) 'Calculating the energy '// &
+                    'derivatives on the displaced fine grid:'
+            ENDIF
+
+            DO IDIR=1,3
+               IF (IO%IU0>=0) WRITE(IO%IU0,'(A,I4)') '  Direction:',IDIR
+
+               IF (LUSEPEAD()) THEN
+                  WDIFF%CW=0
+                  WDIFF%CPROJ=0
+                  WDIFF%CELTOT=0
+                  CALL PEAD_DPSI_DK_IDIR(W,KPOINTS,P,CQIJ,LATT_CUR, &
+                       T_INFO,IDIR,WDIFF)
+               ELSE
+                  CALL FOCK_K_DER_ANALYT(KPOINTS, GRID, LATT_CUR, LATT_INI, &
+                       T_INFO,  NONLR_S, NONL_S, W, WDIFF, LMDIM, P, CQIJ, &
+                       SYMM, IDIR, LDONE, IO%IU0, IO%IU6)
+
+                  CALL LRF_RPHI0( &
+                       P,NONLR_S,NONL_S,W,LATT_CUR, &
+                       T_INFO,INFO,IO,GRID,GRIDC,GRIDUS,C_TO_US,IRDMAX, &
+                       CDIJ,CQIJ,SV,LMDIM,DEG_CLUSTER, IDIR, WDIFF, LDONE)
+               ENDIF
+
+               IF (IO%LOPTICS) THEN
+                  CALL INPROD_W(WDIFF,W,CHAMD(:,:,:,:,IDIR), &
+                       W%WDES%LOVERL,IO%IU0)
+               ENDIF
+               DO ISP=1,W%WDES%ISPIN
+                  DO NK=1,W%WDES%NKPTS
+                     DO NB=1,W%WDES%NB_TOT
+                        EDER(NB,NK,ISP,IDIR)=REAL(WDIFF%CELTOT(NB,NK,ISP),KIND=q)
+                     ENDDO
+                  ENDDO
+               ENDDO
+            ENDDO
+         ENDIF
+
+         IF(LUSEPEAD()) THEN
+            KPOINTS_FULL = KPOINTS_FULL_TEMP            
+         ENDIF
+         
+         DO N=1,KPOINTS%NKPTS
+            NK=KPOINT_IN_FULL_GRID_KINTER(W%WDES%VKPT(:,N),KPOINTS_INTER)
+            IF (NK/=-1) THEN
+               DO IDIR=1,3
+                  KINTERPOL(IDIR,NK)=W%WDES%VKPT(IDIR,N)
+               ENDDO
+               DO ISP=1,W%WDES%ISPIN
+                  DO NB=1,W%WDES%NB_TOT
+                     EINTERPOL(NB,NK,ISP,1)=REAL(W%CELTOT(NB,N,ISP),KIND=q)
+                     W_INTER%CELTOT(NB,NK,ISP)=W%CELTOT(NB,N,ISP)
+                     W_INTER%FERTOT(NB,NK,ISP)=W%FERTOT(NB,N,ISP)
+                     IF (LDO_VEL) THEN
+                        DO IDIR=1,3
+                           IF (IO%LOPTICS) THEN
+                              DO NB2=1,W%WDES%NB_TOT
+                                 CHAM(NB,NB2,NK,ISP,IDIR) = &
+                                      CHAMD(NB,NB2,N,ISP,IDIR)
+                              ENDDO
+                           ENDIF
+                           EINTERPOL(NB,NK,ISP,IDIR+1)=EDER(NB,N,ISP,IDIR)
+                        ENDDO
+                     ENDIF
+                  ENDDO
+               ENDDO
+            ENDIF
+         ENDDO
+         DISPINDEX=DISPINDEX+1
+      ENDDO
+
+      IF (.NOT. LDO_VEL) THEN
+         CALL XML_TAG("eigenvalues", comment="interpolated")
+         CALL XML_TAG("kpoints")
+         CALL XML_KPOINTS_LIST(KINTERPOL, KPOINTS_INTER%WTKPT)
+         CALL XML_CLOSE_TAG("kpoints")
+         CALL XML_EIGENVALUES_EXT(EINTERPOL,1, W%WDES%NB_TOT, &
+              KPOINTS_INTER%NKPTS, W%WDES%ISPIN)
+         CALL XML_CLOSE_TAG("eigenvalues")
+      ENDIF
+
+      IF (IO%LOPTICS) THEN
+         NBANDS_CDER=MIN(LAST_FILLED_OPTICS(W_INTER)*2, W_INTER%WDES%NB_TOT)
+         IF (IO%IU0>=0) WRITE(IO%IU0,*) 'Calculating the imaginary ' // &
+              'part of the dielectric function.'
+         
+         DO IDIR=1,3
+            DO JDIR=1,3
+               CALL EPSILON_IMAG(W_INTER%WDES, W_INTER, CHAM(:,:,:,:,IDIR), &
+                    CHAM(:,:,:,:,JDIR), EINTERPOL(:,:,:,IDIR+1), &
+                    EINTERPOL(:,:,:,JDIR+1), EFERMI, NEDOS_DIEL, &
+                    EPSDD(:,IDIR,JDIR), EPSJJ(:,IDIR,JDIR), DELTAE, &
+                    KPOINTS%ISMEAR, KPOINTS%SIGMA, LATT_CUR%OMEGA, &
+                    WPLASM(IDIR, JDIR), COND(IDIR, JDIR), &
+                    BIMAG(IDIR, JDIR), RTIME, LCSHIFT)
+            ENDDO
+         ENDDO
+         
+         IF (KPOINTS%ISMEAR >= -1) THEN
+            CALLMPI( M_sum_z(W%WDES%COMM, EPSDD, SIZE(EPSDD)))
+            CALLMPI( M_sum_z(W%WDES%COMM, EPSJJ, SIZE(EPSJJ)))
+            CALLMPI( M_sum_d(W%WDES%COMM, BIMAG, SIZE(BIMAG)))
+         ENDIF
+         
+
+         ! eFL: MARTIJN, IS THE ISYMOP AND NROTK OKEY HERE FOR GENERAL CASES?
+         DO I=1,NEDOS_DIEL
+            IF (SYMM%ISYM>0) THEN
+               CALL TSYM_CMPLX(EPSDD(I,:,:),ISYMOP,NROTK,LATT_CUR%A)
+            ENDIF
+            IF (SYMM%ISYM>0) THEN
+               CALL TSYM_CMPLX(EPSJJ(I,:,:),ISYMOP,NROTK,LATT_CUR%A)
+            ENDIF
+         ENDDO
+         
+         IF (SYMM%ISYM>0) CALL TSYM(WPLASM(:,:),ISYMOP,NROTK,LATT_CUR%A)
+         IF (SYMM%ISYM>0) CALL TSYM(BIMAG(:,:),ISYMOP,NROTK,LATT_CUR%A)
+      
+      
+         
+         IWINDOW=0
+         LWARN=.FALSE.
+         IF (IO%IU0>=0) WRITE(IO%IU0,*) 'Calculating the real ' // &
+              'part of the dielectric function.'
+         DO IDIR=1,3
+            DO JDIR=1,3
+               CALL EPSILON_REAL(W%WDES%COMM, NEDOS_DIEL, &
+                    EPSDD(:,IDIR,JDIR), LWARN, DELTAE, LCSHIFT, IWINDOW)
+               IF (JDIR==IDIR) THEN
+                  EPSDD(:,IDIR,IDIR)=EPSDD(:,IDIR,IDIR)+1
+               ENDIF
+               CALL EPSILON_REAL(W%WDES%COMM, NEDOS_DIEL, &
+                    EPSJJ(:,IDIR,JDIR), LWARN, DELTAE, LCSHIFT, IWINDOW)
+            ENDDO
+         ENDDO
+         IF (LWARN) THEN
+            CALL VTUTOR('W','SMALL CSHIFT',0.0_q,1, &
+                 &           0,1,(0.0_q,0.0_q),1,.FALSE.,1,IO%IU6,2)
+            CALL VTUTOR('W','SMALL CSHIFT',0.0_q,1, &
+                 &           0,1,(0.0_q,0.0_q),1,.FALSE.,1,IO%IU0,2)
+         ENDIF
+         
+         DO IDIR=1,3
+            DO JDIR=1,3
+               IF (IDIR==JDIR) CYCLE
+#ifdef timeordered
+               DO I=2,NEDOS_DIEL
+                  EPSDD(I,IDIR,JDIR)=EPSDD(I,IDIR,JDIR)+ &
+                       (0._q,1._q)*BIMAG(IDIR,JDIR)/(DELTAE*(I-1))
+               ENDDO
+               EPSDD(1,IDIR,JDIR)=EPSDD(2,IDIR,JDIR)
+#else
+               DO I=1,NEDOS_DIEL
+                  EPSDD(I,IDIR,JDIR)=EPSDD(I,IDIR,JDIR)+ &
+                       (0._q,1._q)*BIMAG(IDIR,JDIR)/(DELTAE*(I-1)+ &
+                       CMPLX(0,LCSHIFT,q))
+               ENDDO
+#endif
+            ENDDO
+         ENDDO
+         DO IDIR=1,3
+            DO JDIR=1,3
+               DO I=2,NEDOS_DIEL
+                  EPSJJ(I,IDIR,JDIR)=(EPSJJ(I,IDIR,JDIR)- &
+                       EPSJJ(1,IDIR,JDIR))/(DELTAE*(I-1))**2
+               ENDDO
+               IF (JDIR==IDIR) EPSJJ(:,IDIR,IDIR)=EPSJJ(:,IDIR,IDIR)+1
+            ENDDO
+         ENDDO
+         EPSJJ(1,:,:)=EPSJJ(2,:,:)
+         IF (WPLASMAI>0) THEN
+            DO IDIR=1,3
+               DO I=1,NEDOS_DIEL
+                  WO=DELTAE*(I-1)
+                  EPSDD(I,IDIR,IDIR)=EPSDD(I,IDIR,IDIR)+ &
+                       WPLASMON(IDIR,IDIR)/(WO**2+WPLASMAI**2)* &
+                       CMPLX(-1.0_q,WPLASMAI/MAX(WO,DELTAE))
+                  EPSJJ(I,IDIR,IDIR)=EPSJJ(I,IDIR,IDIR)+ &
+                       WPLASMON(IDIR,IDIR)/(WO**2+WPLASMAI**2)* &
+                       CMPLX(-1.0_q,WPLASMAI/MAX(WO,DELTAE))
+               ENDDO
+            ENDDO
+         ENDIF
+         
+         CALL XML_EPSILON_W(DELTAE, REAL(EPSDD,q), AIMAG(EPSDD), NEDOS_DIEL)
+         CALL XML_EPSILON_W(DELTAE, REAL(EPSJJ,q), AIMAG(EPSJJ), NEDOS_DIEL)
+      ENDIF
+      
+      IF (LVEL) THEN
+         ALLOCATE(EINTERPOL_FULL(4,W%WDES%NB_TOT,KPOINTS_INTER_FULL%NKPTS, &
+              W%WDES%ISPIN))
+         DO N=1,KPOINTS_INTER_FULL%NKPTS
+            NK=KPOINTS_INTER_FULL%NEQUIV(N)
+            S=0
+            DO L=1,3
+               DO K=1,3
+                  DO J=1,3
+                     DO I=1,3
+                        S(L,I)=S(L,I)+LATT_CUR%A(L,K)* &
+                             KPOINTS_INTER_FULL%ISYMOP(J,K,N)*LATT_CUR%B(I,J)
+                     ENDDO
+                  ENDDO
+               ENDDO
+            ENDDO
+            DO ISP=1,W%WDES%ISPIN
+               DO NB=1,W%WDES%NB_TOT
+                  EINTERPOL_FULL(1,NB,N,ISP)=EINTERPOL(NB,NK,ISP,1)
+                  DER=0
+                  DO IDIR=1,3
+                     DER(:)=DER(:)+S(:,IDIR)*EINTERPOL(NB,NK,ISP,IDIR+1)
+                  ENDDO
+                  DO IDIR=1,3
+                     EINTERPOL_FULL(IDIR+1,NB,N,ISP)=DER(IDIR)
+                  ENDDO
+               ENDDO
+            ENDDO
+         ENDDO
+         CALL XML_TAG("eigenvelocities", comment="interpolated")
+         CALL XML_TAG("kpoints")
+         CALL XML_KPOINTS_LIST(KPOINTS_INTER_FULL%VKPT, &
+              KPOINTS_INTER_FULL%WTKPT)
+         CALL XML_CLOSE_TAG("kpoints")
+         CALL XML_EIGENVALUES_EXT(EINTERPOL_FULL, 4, W%WDES%NB_TOT, &
+              KPOINTS_INTER_FULL%NKPTS, W%WDES%ISPIN)
+         CALL XML_CLOSE_TAG("eigenvelocities")
+
+         DEALLOCATE(EINTERPOL_FULL,KPOINTS_INTER_FULL)
+      ENDIF
+      
+      CALL DENSTA( IO%IU0, IO%IU6, WDES_INTER, W_INTER, KPOINTS_INTER, &
+           INFO%NELECT, INFO%NUP_DOWN, ENTROPY, EFERMI, KPOINTS_INTER%SIGMA, &
+           .TRUE., NEDOS, 0, 0, DOS, DOSI, PAR, DOSPAR)
+      CALL XML_DOS(EFERMI, KPOINTS%EMIN, KPOINTS%EMAX, .FALSE., &
+           DOS, DOSI, DOSPAR, NEDOS, 1, 1, W%WDES%NCDIJ, &
+           comment='interpolated')
+
+      EBANDSTR_INTER = BANDSTRUCTURE_ENERGY(WDES_INTER, W_INTER)
+      OTHERTERMS = E%DENC+E%XCENC+E%TEWEN+E%PSCENC+E%EENTROPY+ &
+           E%PAWPS+E%PAWAE+INFO%EALLAT+E%EXHF
+      TOTENINTER = EBANDSTR_INTER+OTHERTERMS
+      TOTENRDIFF = (TOTENORG - TOTENINTER)/TOTENORG
+
+      IF (IO%IU0>=0) THEN
+         WRITE(IO%IU0,1000) TOTENINTER, TOTENRDIFF
+         WRITE(17,1000)     TOTENINTER, TOTENRDIFF
+      ENDIF
+1000  FORMAT('Energy from interpolated bandstructure: ',E20.12/ &
+             '                 (relative difference): ',E20.12)
+      
+      DO ISP=1,W%WDES%ISPIN
+         DO NK=1,KPOINTS%NKPTS
+            IF (ISP==1) THEN
+               W%WDES%VKPT(:,NK)=VKPT_OLD(:,NK)
+            ENDIF
+            DO N=1,W%WDES%NBANDS
+               W%CW(:,N,NK,ISP)=CW_OLD(:,N,NK,ISP)
+            ENDDO
+         ENDDO
+      ENDDO
+      CALL SET_DATAKE(W%WDES, LATT_CUR%B)
+      IF (NONLR_S%LREAL) THEN
+         CALL RSPHER(GRID,NONLR_S,LATT_CUR)
+      ELSE
+         CALL SPHER(GRID,NONL_S,P,W%WDES,LATT_CUR, 1)
+      ENDIF
+      CALL PROALL (GRID,LATT_CUR,NONLR_S,NONL_S,W)
+! should not be necessary
+!     CALL ORTHCH(W%WDES,W, W%WDES%LOVERL, LMDIM, CQIJ)        
+
+      IF (LDO_VEL) THEN
+         DEALLOCATE(EDER)
+         CALL DEALLOCW(WDIFF)
+      ENDIF
+      IF (IO%LOPTICS) THEN
+         DEALLOCATE(EPSDD, EPSJJ, &
+         CHAMD, CHAM, WPLASM, COND, BIMAG)
+      ENDIF
+      DEALLOCATE(EINTERPOL, KINTERPOL, CW_OLD, VKPT_OLD)
+      CALL DEALLOCW_NOPLANEWAVE(W_INTER)
+
+      IF (IO%IU0>=0) WRITE(IO%IU0,*) '------------------------------------------------'// &
+           '--------------'
+      
+    END SUBROUTINE INTERPOLATE_BANDSTR_GRDSHFT
+
+
+  SUBROUTINE GENERATE_GRDSHFT_GRD_AND_DISPL(KPOINTS, WDES, LATT_CUR, &
+       T_INFO, SYMM, IO, KINTER, KPOINTS_INTER, KPOINTS_INTER_FULL, DISPL)
+    USE lattice
+    USE base
+    USE wave
+    USE poscar
+    USE mkpoints
+    USE full_kpoints
+    IMPLICIT NONE
+
+    
+    TYPE (kpoints_struct)           KPOINTS
+    TYPE (kpoints_struct)           KPOINTS_INTER
+    TYPE (skpoints_full),POINTER :: KPOINTS_INTER_FULL
+    TYPE (skpoints_full),POINTER :: KPOINTS_FULL_TEMP  
+    TYPE (latt)                     LATT_CUR
+    TYPE (info_struct)              INFO
+    TYPE (in_struct)                IO
+    TYPE (symmetry)                 SYMM
+    TYPE (type_info)                T_INFO
+    ! eFL: CAN WE GET RID OF THIS WDES FROM THIS ROUTINE?
+    TYPE (wavedes)                  WDES
+
+    INTEGER KINTER, ABSKINTER
+    INTEGER, DIMENSION(3) :: MULTIPL
+    INTEGER I, N, NK, IWZ, IK, IKX, IKY, IKZ, IKXP, IKYP, IKZP, NUMDISPL
+    REAL(q) DIST, DIST_FOUND, KSTART
+    REAL(q) DISPLV(3), DISPLV_CART(3)
+    REAL(q), ALLOCATABLE :: DISPL(:,:)
+    LOGICAL LDONE
+    LOGICAL, ALLOCATABLE :: K_FOUND_IN_GRID(:)
+    CHARACTER (LEN=8) :: XMLTAG
+    
+    DISPLV=0.0
+    IF (KPOINT_IN_FULL_GRID_KINTER(DISPLV,KPOINTS)==-1)  THEN
+       CALL VTUTOR('E','GAMMAC',0.0_q,1,0,1,(0.0_q,0.0_q),1, &
+            .TRUE.,1, IO%IU6,3)
+       CALL VTUTOR('S','GAMMAC',0.0_q,1,0,1,(0.0_q,0.0_q),1, &
+            .TRUE.,1, IO%IU0,3)
+       RETURN
+    ENDIF
+    IF ((MOD(KPOINTS%NKPX,2)==0) .OR. (MOD(KPOINTS%NKPY,2)==0) &
+         .OR. (MOD(KPOINTS%NKPZ,2)==0)) THEN
+       CALL VTUTOR('E','NOODDGRID',0.0_q,1,0,1,(0.0_q,0.0_q),1, &
+            .TRUE.,1, IO%IU6,3)
+       CALL VTUTOR('S','NOODDGRID',0.0_q,1,0,1,(0.0_q,0.0_q),1, &
+            .TRUE.,1, IO%IU0,3)
+       RETURN
+    ENDIF
+    IF (MOD(ABS(KINTER),2)==0) THEN
+       CALL VTUTOR('E','GRDSHFT_K',0.0_q,1,0,1,(0.0_q,0.0_q),1, &
+            .TRUE.,1, IO%IU6,3)
+       CALL VTUTOR('S','GRDSHFT_K',0.0_q,1,0,1,(0.0_q,0.0_q),1, &
+            .TRUE.,1, IO%IU0,3)
+       RETURN
+    ENDIF
+
+    ABSKINTER = ABS(KINTER)
+    NUMDISPL = ABSKINTER * ABSKINTER * ABSKINTER
+    KPOINTS_INTER=KPOINTS
+    CALL CHECK_FULL_KPOINTS
+    MULTIPL=ABSKINTER
+#ifdef oldsym
+    CALL RD_KPOINTS(KPOINTS_INTER, LATT_CUR, &
+         SYMM%ISYM>=0.AND..NOT. WDES%LSORBIT.AND..NOT. WDES%LSPIRAL, &
+         SYMM%ISYM<0, -1, -1, MULTIPL = MULTIPL)
+#else
+    CALL RD_KPOINTS(KPOINTS_INTER, LATT_CUR, &
+         SYMM%ISYM>=0.AND..NOT. WDES%LNONCOLLINEAR, SYMM%ISYM<0, &
+         -1, -1, MULTIPL = MULTIPL)
+#endif
+
+    ALLOCATE(KPOINTS_INTER_FULL)
+    CALL IBZKPT_HF(LATT_CUR, KPOINTS_INTER, &
+         KPOINTS_INTER_FULL, T_INFO%NIONS, SYMM%ROTMAP, &
+         SYMM%MAGROT,SYMM%ISYM, IO%IU6, IO%IU0)
+    
+    IWZ=2
+    KSTART=-REAL(ABSKINTER,q)/2+0.5_q
+    IK=0
+    ALLOCATE(DISPL(3,NUMDISPL))
+    DISPL=0.0
+    DO IKX=0,ABSKINTER-1
+       DO IKY=0,ABSKINTER-1
+          DO IKZ=0,ABSKINTER-1
+             IK=IK+1
+             DIST_FOUND=1E6
+             DO IKXP=-IWZ,IWZ
+                DO IKYP=-IWZ,IWZ
+                   DO IKZP=-IWZ,IWZ
+                      DISPLV(1)=((IKX+KSTART)/ABSKINTER+IKXP)/KPOINTS%NKPX
+                      DISPLV(2)=((IKY+KSTART)/ABSKINTER+IKYP)/KPOINTS%NKPY
+                      DISPLV(3)=((IKZ+KSTART)/ABSKINTER+IKZP)/KPOINTS%NKPZ
+                      DISPLV_CART=DISPLV
+                      CALL DIRKAR(1, DISPLV_CART(1), LATT_CUR%B)
+                      DIST=DISPLV_CART(1)**2+ &
+                           DISPLV_CART(2)**2+ &
+                           DISPLV_CART(3)**2
+                      IF (DIST<=DIST_FOUND) THEN
+                         DISPL(:,IK)=DISPLV
+                         DIST_FOUND =DIST
+                      ENDIF
+                   ENDDO
+                ENDDO
+             ENDDO
+          ENDDO
+       ENDDO
+    ENDDO
+
+    ALLOCATE(K_FOUND_IN_GRID(KPOINTS_INTER%NKPTS))
+    K_FOUND_IN_GRID=.FALSE.
+    DO IK=1,NUMDISPL
+       DO N=1,KPOINTS%NKPTS
+          NK=KPOINT_IN_FULL_GRID_KINTER(KPOINTS%VKPT(:,N)+DISPL(:,IK), &
+               KPOINTS_INTER)
+          IF (NK/=-1) K_FOUND_IN_GRID(NK)=.TRUE.
+       ENDDO
+    ENDDO
+
+    LDONE=.FALSE.
+    DO IK=1,NUMDISPL
+       DO N=1,KPOINTS%NKPTS
+          NK=KPOINT_IN_FULL_GRID_KINTER(KPOINTS%VKPT(:,N)+DISPL(:,IK), &
+               KPOINTS_INTER)
+          IF (NK==-1) THEN
+             I=KPOINT_IN_FULL_GRID(KPOINTS%VKPT(:,N)+DISPL(:,IK), &
+                  KPOINTS_INTER_FULL)
+             NK=KPOINTS_INTER_FULL%NEQUIV(I)
+             IF (.NOT. K_FOUND_IN_GRID(NK)) THEN
+                KPOINTS_INTER%VKPT(:,NK)=KPOINTS_INTER_FULL%VKPT(:,I)
+                K_FOUND_IN_GRID(NK)=.TRUE.
+                LDONE=.TRUE.
+             ENDIF
+          ENDIF
+       ENDDO
+    ENDDO
+    
+    DO NK=1, KPOINTS_INTER%NKPTS
+       IF (.NOT. K_FOUND_IN_GRID(NK) ) THEN
+          IF (IO%IU0>=0) WRITE(IO%IU0,'(I6,3F14.7)') NK, &
+               KPOINTS_INTER%VKPT(:,NK)
+          CALL VTUTOR('E','GRDSHFT_NOT_IN_IBZ',0.0_q,1,0,1, &
+               (0.0_q,0.0_q),1, .TRUE.,1, IO%IU6,3)
+          CALL VTUTOR('S','GRDSHFT_NOT_IN_IBZ',0.0_q,1,0,1, &
+               (0.0_q,0.0_q),1, .TRUE.,1, IO%IU0,3)
+          STOP
+       ENDIF
+    ENDDO
+
+    IF (LDONE) THEN
+       CALL IBZKPT_HF(LATT_CUR, KPOINTS_INTER, &
+            KPOINTS_INTER_FULL, T_INFO%NIONS, SYMM%ROTMAP, &
+            SYMM%MAGROT,SYMM%ISYM, IO%IU6, IO%IU0)
+    ENDIF
+    
+  END SUBROUTINE GENERATE_GRDSHFT_GRD_AND_DISPL
+
+    
+END MODULE mlr_main
diff -urN file_ini/main.F file_modify/main.F
--- file_ini/main.F	1970-01-01 08:00:00.000000000 +0800
+++ file_modify/main.F	2024-07-13 10:37:23.000000000 +0800
@@ -0,0 +1,5070 @@
+#include "symbol.inc"
+#define usgrid
+!****************** PROGRAM VASP  Version 5.0 (f90)********************
+! RCS:  $Id: main.F,v 1.18 2003/06/27 13:22:18 kresse Exp kresse $
+! Vienna Ab initio total energy and Molecular-dynamics Program
+!            written  by   Kresse Georg
+!                     and  Juergen Furthmueller
+! Georg Kresse                       email: Georg.Kresse@univie.ac.at
+! Juergen Furthmueller               email: furth@ifto.physik.uni-jena.de
+! Institut fuer Materialphysik         voice: +43-1-4277-51402
+! Uni Wien, Sensengasse 8/12           fax:   +43-1-4277-9514 (or 9513)
+! A-1090 Wien, AUSTRIA                 http://cms.mpi.univie.ac.at/kresse
+!
+! This program comes without any waranty.
+! No part of this program must be distributed, modified, or supplied
+! to any other person for any reason whatsoever
+! without prior written permission of the Institut of Materials Science
+! University Vienna
+!
+! This program performs total energy calculations using
+! a selfconsistency cylce (i.e. mixing + iterative matrix diagonal.)
+! or a direct optimisation of the one electron wavefunctions
+! most of the algorithms implemented are described in
+! G. Kresse and J. Furthmueller
+!  Efficiency of ab--initio total energy calculations for
+!   metals and semiconductors using a plane--wave basis set
+!  Comput. Mat. Sci. 6,  15-50 (1996)
+! G. Kresse and J. Furthmueller
+!  Efficient iterative schemes for ab--initio total energy
+!   calculations using a plane--wave basis set
+!   Phys. Rev. B 54, 11169 (1996)
+!
+! The iterative matrix diagonalization is based
+! a) on the conjugated gradient eigenvalue minimisation proposed by
+!  D.M. Bylander, L. Kleinmann, S. Lee, Phys Rev. B 42, 1394 (1990)
+! and is a variant of an algorithm proposed by
+!  M.P. Teter, M.C. Payne and D.C. Allan, Phys. Rev. B 40,12255 (1989)
+!  T.A. Arias, M.C. Payne, J.D. Joannopoulos, Phys Rev. B 45,1538(1992)
+! b) or the residual vector minimization method (RMM-DIIS) proposed by
+!  P. Pulay,  Chem. Phys. Lett. 73, 393 (1980).
+!  D. M. Wood and A. Zunger, J. Phys. A, 1343 (1985)
+! For the mixing a Broyden/Pulay like method is used (see for instance):
+!  D. Johnson, Phys. Rev. B 38, 12807 (1988)
+!
+! The program can use normconserving PP, 
+! generalised ultrasoft-PP (Vanderbilt-PP Vanderbilt Phys Rev B 40,  
+! 12255 (1989)) and PAW (P.E. Bloechl, Phys. Rev. B{\bf 50}, 17953 (1994))
+! datasets. Partial core corrections can be handled
+! Spin and GGA and exact exchange functionals are implemented
+!
+! The units used in the programs are electron-volts and angstroms.
+! The unit cell is arbitrary, and arbitrary species of ions are handled.
+! A full featured symmetry-code is included, and calculation of
+! Monkhorst-Pack special-points is possible (tetrahedron method can be
+! used as well). This part was written by J. Furthmueller.
+!
+! The original version was written by  M.C. Payne
+! at Professor J. Joannopoulos research  group at the MIT
+! (3000 lines, excluding FFT, July 1989)
+! The program was completely rewritten and vasply extended by
+! Kresse Georg (gK) and Juergen Furthmueller. Currently the
+! code has about 200000 source lines
+!
+!** The following parts have been taken from other programs
+! - Tetrahedron method (original author unknown)
+!
+! please refer to the README file to learn about new features
+! notes on singe-precision:
+! USAGE NOT RECOMMENDED DUE TO FINITE DIFFERENCES IN FEW SPECIFIC
+! FORCE-SUBROUTINE
+! (except for native 64-bit-REAL machines like CRAY style machines)
+!**********************************************************************
+
+      PROGRAM VAMP
+      USE prec
+
+      USE charge
+      USE pseudo
+      USE lattice
+      USE steep
+      USE us
+      USE pawm
+      USE pot
+      USE force
+      USE fileio
+      USE nonl_high
+      USE rmm_diis
+      USE ini
+      USE ebs
+      USE wave_high
+      USE choleski
+      USE mwavpre
+      USE mwavpre_noio
+      USE msphpro
+      USE broyden
+      USE msymmetry
+      USE subrot
+      USE melf
+      USE base
+      USE mpimy
+      USE mgrid
+      USE mkpoints
+      USE constant
+      USE setexm
+      USE poscar
+      USE wave
+      USE hamil
+      USE main_mpi
+      USE chain
+      USE pardens
+      USE finite_differences
+      USE LDAPLUSU_MODULE
+      USE cl
+      USE Constrained_M_modular
+      USE writer
+      USE sym_prec
+      USE elpol
+      USE mdipol
+      USE wannier
+      USE vaspxml
+      USE full_kpoints
+      USE kpoints_change
+      USE fock
+      USE compat_gga
+      USE mlr_main
+      USE mlrf_main
+      USE mlr_optic
+      USE pwkli
+      USE gridq
+      USE twoelectron4o
+      USE dfast
+      USE aedens
+      USE xi
+      USE subrotscf
+      USE pead
+      USE egrad
+      USE hamil_high
+      USE morbitalmag
+      USE relativistic
+      USE rhfatm
+      USE meta
+      USE mkproj
+      USE classicfields
+      USE rpa_force
+! Thomas Bucko's code contributions
+#ifdef tbdyn
+      USE random_seeded
+      USE dynconstr
+#endif
+      USE vdwforcefield
+      USE dimer_heyden
+      USE dvvtrajectory
+
+      USE mlwf
+#ifdef VASP2WANNIER90 
+      USE dmft
+      USE crpa 
+#endif
+      USE chgfit
+      USE stockholder
+      USE mlr_main_nmr
+      USE hyperfine
+      USE wannier_interpolation
+      USE auger
+      USE dmatrix
+
+      USE lcao
+      USE wnpr
+! solvation__
+      USE solvation
+! solvation__
+      USE locproj
+#ifdef PROFILING
+      USE profiling
+#endif
+! elphon_
+      USE elphon
+! elphon
+! bexternal__
+      USE bexternal
+! bexternal__
+      USE openmp
+#ifdef CUDA_GPU
+      USE cuda_interface
+      USE main_gpu
+#endif
+      IMPLICIT COMPLEX(q) (C)
+      IMPLICIT REAL(q) (A-B,D-H,O-Z)
+
+!=======================================================================
+!  a small set of parameters might be set here
+!  but this is really rarely necessary :->
+!=======================================================================
+!----I/O-related things (adapt on installation or for special purposes)
+!     IU6    overall output ('console protocol'/'OUTCAR' I/O-unit)
+!     IU0    very important output ('standard [error] output I/O-unit')
+!     IU5    input-parameters ('standard input'/INCAR I/O-unit)
+!     ICMPLX size of complex items (in bytes/complex item)
+!     MRECL  maximum record length for direct access files
+!            (if no restictions set 0 or very large number)
+      INTEGER,PARAMETER :: ICMPLX=16,MRECL=10000000
+
+!=======================================================================
+!  structures
+!=======================================================================
+      TYPE (potcar),ALLOCATABLE :: P(:)
+      TYPE (wavedes)     WDES
+      TYPE (nonlr_struct), TARGET :: NONLR_S
+      TYPE (nonl_struct) NONL_S
+      TYPE (wavespin)    W          ! wavefunction
+      TYPE (wavespin)    W_F        ! wavefunction for all bands simultaneous
+      TYPE (wavespin)    W_G        ! same as above
+      TYPE (wavefun)     WUP
+      TYPE (wavefun)     WDW
+      TYPE (wavefun)     WTMP       ! temporary
+      TYPE (latt)        LATT_CUR
+      TYPE (latt)        LATT_INI
+      TYPE (type_info)   T_INFO
+      TYPE (dynamics)    DYN
+      TYPE (info_struct) INFO
+      TYPE (in_struct)   IO
+      TYPE (mixing)      MIX
+      TYPE (kpoints_struct) KPOINTS
+      TYPE (symmetry)    SYMM
+      TYPE (grid_3d)     GRID       ! grid for wavefunctions
+      TYPE (grid_3d)     GRID_SOFT  ! grid for soft chargedensity
+      TYPE (grid_3d)     GRIDC      ! grid for potentials/charge
+      TYPE (grid_3d)     GRIDUS     ! very find grid temporarily used in us.F
+      TYPE (grid_3d)     GRIDB      ! Broyden grid
+      TYPE (transit)     B_TO_C     ! index table between GRIDB and GRIDC
+      TYPE (transit)     SOFT_TO_C  ! index table between GRID_SOFT and GRIDC
+      TYPE (transit)     C_TO_US    ! index table between GRID_SOFT and GRIDC
+      TYPE( prediction)  PRED
+      TYPE (smear_struct) SMEAR_LOOP
+      TYPE (paco_struct) PACO
+      TYPE (energy)      E
+      TYPE (ham_handle)  HAMILTONIAN
+      TYPE (tau_handle)  KINEDEN
+
+#ifdef tbdyn
+       TYPE (gadget_io)   g_io
+       INTEGER :: SEED(3),SEED_INIT(3)
+       INTEGER :: DTVALUES(8)
+       INTEGER :: IDUMLONG
+       INTEGER :: CLOCK       
+       INTEGER, PARAMETER :: SEED1_MAX=900000000, K_SEED=3
+       INTEGER, PARAMETER :: SEED2_MAX=1000000
+#endif
+
+      INTEGER :: NGX,NGY,NGZ,NGXC,NGYC,NGZC
+      INTEGER :: NRPLWV,LDIM,LMDIM,LDIM2,LMYDIM
+      INTEGER :: IRMAX,IRDMAX,ISPIND
+      INTEGER :: NPLWV,MPLWV,NPLWVC,MPLWVC,NTYPD,NIOND,NIONPD,NTYPPD
+      INTEGER :: NEDOS
+      LOGICAL :: LNBANDS=.TRUE.
+      INTEGER :: TIU6, TIU0
+      INTEGER :: ISPECIAL=0         ! allows to select special undocumented features
+      INTEGER :: MDALGO=0           ! dublicates MDALGO in tbdyn
+!=======================================================================
+!  begin array dimensions ...
+!=======================================================================
+#if defined(CUDA_GPU) && defined(USE_PINNED_MEMORY)
+      COMPLEX(q),POINTER    :: CHTOT(:,:)    ! charge-density in real / reciprocal space
+      TYPE(C_PTR)           :: CHTOT_PTR
+      RGRID ,POINTER:: SV(:,:)               ! soft part of local potential
+      TYPE(C_PTR) :: SV_PTR
+      RGRID :: fake
+      COMPLEX(q) :: fakec
+#else
+      COMPLEX(q),ALLOCATABLE:: CHTOT(:,:)    ! charge-density in real / reciprocal space
+      RGRID  ,ALLOCATABLE:: SV(:,:)          ! soft part of local potential
+#endif
+      COMPLEX(q),ALLOCATABLE:: CHTOTL(:,:)   ! old charge-density
+      RGRID     ,ALLOCATABLE:: DENCOR(:)     ! partial core
+      COMPLEX(q),ALLOCATABLE:: CVTOT(:,:)    ! local potential
+      COMPLEX(q),ALLOCATABLE:: CSTRF(:,:)    ! structure-factor
+!-----non-local pseudopotential parameters
+      OVERLAP,ALLOCATABLE:: CDIJ(:,:,:,:) ! strength of PP
+      OVERLAP,ALLOCATABLE:: CQIJ(:,:,:,:) ! overlap of PP
+      OVERLAP,ALLOCATABLE:: CRHODE(:,:,:,:) ! augmentation occupancies
+!-----elements required for mixing in PAW method
+      REAL(q)   ,ALLOCATABLE::   RHOLM(:,:),RHOLM_LAST(:,:)
+!-----charge-density and potential on small grid
+      COMPLEX(q),ALLOCATABLE:: CHDEN(:,:)    ! pseudo charge density
+!-----description how to go from one grid to the second grid
+!-----density of states
+      REAL(q)   ,ALLOCATABLE::  DOS(:,:),DOSI(:,:)
+      REAL(q)   ,ALLOCATABLE::  DDOS(:,:),DDOSI(:,:)
+!-----local l-projected wavefunction characters
+      REAL(q)   ,ALLOCATABLE::   PAR(:,:,:,:,:),DOSPAR(:,:,:,:)
+!  all-band-simultaneous-update arrays
+      GDEF   ,POINTER::   CHF(:,:,:,:),CHAM(:,:,:,:)
+!  optics stuff
+      GDEF   ,ALLOCATABLE::   NABIJ(:,:)
+!  
+      LOGICAL :: LVCADER
+
+!-----remaining mainly work arrays
+      COMPLEX(q), ALLOCATABLE,TARGET :: CWORK1(:),CWORK2(:),CWORK(:,:)
+      TYPE (wavefun1)    W1            ! current wavefunction
+      TYPE (wavedes1)    WDES1         ! descriptor for one k-point
+
+      GDEF, ALLOCATABLE  ::  CPROTM(:),CMAT(:,:)
+!=======================================================================
+!  a few fixed size (or small) arrays
+!=======================================================================
+!-----Forces and stresses
+      REAL(q)   VTMP(3), XCSIF(3,3), EWSIF(3,3), TSIF(3,3), D2SIF(3,3)
+!-----forces on ions
+      REAL(q)   ,ALLOCATABLE::  EWIFOR(:,:), TIFOR(:,:)
+!-----data for STM simulation (Bardeen)
+      REAL(q)  STM(7)
+!-----Temporary data for tutorial messages ...
+      INTEGER,PARAMETER :: NTUTOR=1000
+      REAL(q)     RTUT(NTUTOR),RDUM
+      INTEGER  ITUT(NTUTOR),IDUM
+      COMPLEX(q)  CDUM  ; LOGICAL  LDUM
+!=======================================================================
+!  end array dimensions ...
+!=======================================================================
+      INTEGER NTYP_PP      ! number of types on POTCAR file
+
+      INTEGER I,J,N,NT,K
+!---- used for creation of param.inc
+      REAL(q)    WFACT,PSRMX,PSDMX
+      REAL(q)    XCUTOF,YCUTOF,ZCUTOF
+
+!---- timing information
+      INTEGER IERR
+
+      INTEGER NORDER   !   order of smearing
+!---- a few logical and string variables
+      LOGICAL    LTMP,LSTOP2
+      LOGICAL    LPAW           ! paw is used 
+      LOGICAL    LPARD          ! partial band decomposed charge density
+      LOGICAL    LREALLOCATE    ! reallocation of proj operators required
+      LOGICAL    L_NO_US        ! no ultrasoft PP
+      LOGICAL    LADDGRID       ! additional support grid
+
+
+      LOGICAL    LBERRY         ! calculate electronic polarisation
+
+#ifdef libbeef
+      LOGICAL    LBEEFENS       ! calculate BEEF-vdW ensemble XC energies
+      LOGICAL    LBEEFBAS       ! only print basis energies
+#endif
+
+      CHARACTER (LEN=40)  SZ
+      CHARACTER (LEN=1)   CHARAC
+      CHARACTER (LEN=5)   IDENTIFY
+!-----parameters for sphpro.f
+      INTEGER :: LDIMP,LMDIMP,LTRUNC=3
+!=======================================================================
+! All COMMON blocks
+!=======================================================================
+      INTEGER IXMIN,IXMAX,IYMIN,IYMAX,IZMIN,IZMAX
+      COMMON /WAVCUT/ IXMIN,IXMAX,IYMIN,IYMAX,IZMIN,IZMAX
+
+      REAL(q)  RHOTOT(4)
+      INTEGER(8) IL,I1,I2_0,I3,I4
+#ifdef gammareal
+      CHARACTER (LEN=80),PARAMETER :: VASP = &
+        'vasp.5.4.4.18Apr17-6-g9f103f2a35' // ' ' // &
+        '(build ' // __DATE__// ' ' //__TIME__// ') ' // &
+        'gamma-only'
+#else
+      CHARACTER (LEN=80),PARAMETER :: VASP = &
+        'vasp.5.4.4.18Apr17-6-g9f103f2a35' // ' ' // &
+        '(build ' // __DATE__// ' ' //__TIME__// ') ' // &
+        'complex'
+#endif
+
+      INTEGER  ISYMOP,NROT,IGRPOP,NROTK,INVMAP,NPCELL
+      REAL(q)  GTRANS,AP
+      LOGICAL, EXTERNAL :: USE_OEP_IN_GW
+
+      COMMON /SYMM/   ISYMOP(3,3,48),NROT,IGRPOP(3,3,48),NROTK, &
+     &                GTRANS(3,48),INVMAP(48),AP(3,3),NPCELL
+
+#ifdef libbeef
+      LOGICAL  LBEEFCALCBASIS
+      COMMON /BEEFENS/ LBEEFCALCBASIS,LBEEFBAS
+#endif
+#ifdef PROFILING
+!=======================================================================
+!  initialise profiling
+!=======================================================================
+      CALL INIT_PROFILING
+#endif
+!=======================================================================
+!  initialise / set constants and parameters ...
+!=======================================================================
+
+#ifdef libbeef
+      LBEEFCALCBASIS = .FALSE.
+#endif
+
+      IO%LOPEN =.TRUE.  ! open all files with file names
+      IO%IU0   = 6
+      IO%IU6   = 8
+      IO%IU5   = 7
+
+      IO%ICMPLX=ICMPLX
+      IO%MRECL =MRECL
+      PRED%ICMPLX=ICMPLX
+
+#ifdef tbdyn
+      g_io%REPORT=66
+      g_io%REFCOORD=67
+      g_io%CONSTRAINTS=69
+      g_io%STRUCTINPUT=533
+      g_io%PENALTY=534
+#endif
+!
+! with all the dynamic libraries (blas, lapack, scalapack etc. 
+! VASP has a size of at least 30 Mbyte
+!
+      CALL INIT_FINAL_TIMING
+      CALL REGISTER_ALLOCATE(30000000._q, "base")
+
+! switch off kill
+!     CALL sigtrp()
+
+      NPAR=1
+      IUXML_SET=20
+
+!$!-----------------------------------------------------------------------
+!$!  initialise openMP
+!$!-----------------------------------------------------------------------
+!$! prevent nesting in openMP
+!$! read thread related stuff from INCAR
+
+#if defined(MPI) || defined(MPI_CHAIN)
+      CALL INIT_MPI(NPAR,IO)
+      NODE_ME= COMM%NODE_ME
+      IONODE = COMM%IONODE
+      IF (NODE_ME/=IONODE) THEN
+         IUXML_SET=-1
+      ENDIF
+      IF (KIMAGES>0) IUXML_SET=-1
+#endif
+
+#ifdef CUDA_GPU
+      CALL GPU_BANNER(IO)
+#endif
+
+      TIU6 = IO%IU6
+      TIU0 = IO%IU0
+      CALL START_XML( IUXML_SET, "vasprun.xml" )
+
+!-----------------------------------------------------------------------
+!  open Files
+!-----------------------------------------------------------------------
+      IF (IO%IU0>=0) WRITE(TIU0,*) VASP
+#if defined(makeparam)
+      IF (IO%IU6/=6 .AND. IO%IU6>0) &
+      OPEN(UNIT=IO%IU6,FILE=DIR_APP(1:DIR_LEN)//'OUTPAR',STATUS='UNKNOWN')
+#elif defined(makekpoints)
+      IF (IO%IU6/=6 .AND. IO%IU6>0) &
+      OPEN(UNIT=IO%IU6,FILE=DIR_APP(1:DIR_LEN)//'OUTKPT',STATUS='UNKNOWN')
+#else
+      IF (IO%IU6/=6 .AND. IO%IU6>0) &
+      OPEN(UNIT=IO%IU6,FILE=DIR_APP(1:DIR_LEN)//'OUTCAR',STATUS='UNKNOWN')
+#endif
+      OPEN(UNIT=18,FILE=DIR_APP(1:DIR_LEN)//'CHGCAR',STATUS='UNKNOWN')
+#ifdef logflow
+      OPEN(UNIT=19,FILE=DIR_APP(1:DIR_LEN)//'JOBFLOW',ACCESS='APPEND',STATUS='UNKNOWN')
+      WRITE(19,'(A)') 'SECTION = "----------------------------------------------------------------------------------------------------"'
+#endif
+
+#ifndef makekpoints
+      CALL OPENWAV(IO, COMM)
+
+#ifndef makeparam
+      io_begin
+      IF (KIMAGES==0) THEN
+      OPEN(UNIT=22,FILE=DIR_APP(1:DIR_LEN)//'EIGENVAL',STATUS='UNKNOWN')
+      OPEN(UNIT=13,FILE=DIR_APP(1:DIR_LEN)//'CONTCAR',STATUS='UNKNOWN')
+      OPEN(UNIT=16,FILE=DIR_APP(1:DIR_LEN)//'DOSCAR',STATUS='UNKNOWN')
+      OPEN(UNIT=17,FILE=DIR_APP(1:DIR_LEN)//'OSZICAR',STATUS='UNKNOWN')
+      OPEN(UNIT=60,FILE=DIR_APP(1:DIR_LEN)//'PCDAT',STATUS='UNKNOWN')
+      OPEN(UNIT=61,FILE=DIR_APP(1:DIR_LEN)//'XDATCAR',STATUS='UNKNOWN')
+      OPEN(UNIT=70,FILE=DIR_APP(1:DIR_LEN)//'CHG',STATUS='UNKNOWN')
+#ifdef tbdyn
+      OPEN(UNIT=g_io%REPORT,FILE=DIR_APP(1:DIR_LEN)//'REPORT',STATUS='UNKNOWN')
+#endif
+      ENDIF
+      io_end
+#endif
+      IF (IO%IU6>=0) WRITE(IO%IU6,*) VASP
+      CALL XML_GENERATOR
+#if defined(MPI)
+      CALL PARSE_GENERATOR_XML(VASP//" parallel")
+#else
+      CALL PARSE_GENERATOR_XML(VASP//" serial")
+#endif
+      CALL MY_DATE_AND_TIME(IO%IU6)
+      CALL XML_CLOSE_TAG
+
+      CALL WRT_DISTR(IO%IU6)
+#endif
+
+! unit for extrapolation of wavefunction
+      PRED%IUDIR =21
+! unit for broyden mixing
+      MIX%IUBROY=23
+! unit for total potential
+      IO%IUVTOT=62
+
+ 130  FORMAT (5X, //, &
+     &'----------------------------------------------------', &
+     &'----------------------------------------------------'//)
+
+ 140  FORMAT (5X, //, &
+     &'----------------------------------------- Iteration ', &
+     &I4,'(',I4,')  ---------------------------------------'//)
+!-----------------------------------------------------------------------
+! read header of POSCAR file to get NTYPD, NTYPDD, NIOND and NIONPD
+!-----------------------------------------------------------------------
+      CALL RD_POSCAR_HEAD(LATT_CUR, T_INFO, &
+     &           NIOND,NIONPD, NTYPD,NTYPPD, IO%IU0, IO%IU6)
+
+      ALLOCATE(T_INFO%ATOMOM(3*NIOND),T_INFO%RWIGS(NTYPPD),T_INFO%ROPT(NTYPD),T_INFO%POMASS(NTYPD), & 
+               T_INFO%DARWIN_V(NTYPD), T_INFO%DARWIN_R(NTYPD),T_INFO%VCA(NTYPD))
+
+      IF (IO%IU6>=0) THEN
+         WRITE(TIU6,130)
+         WRITE(TIU6,*)'INCAR:'
+      ENDIF
+!  first scan of POTCAR to get LDIM, LMDIM, LDIM2 ...
+      LDIM =16
+      LDIM2=(LDIM*(LDIM+1))/2
+      LMDIM=64
+
+      ALLOCATE(P(NTYPD))
+      T_INFO%POMASS=0
+      T_INFO%RWIGS=0
+
+      INFO%NLSPLINE=.FALSE.
+!-----------------------------------------------------------------------
+! read pseudopotentials
+!-----------------------------------------------------------------------
+      CALL RD_PSEUDO(INFO,P, &
+     &           NTYP_PP,NTYPD,LDIM,LDIM2,LMDIM, &
+     &           T_INFO%POMASS,T_INFO%RWIGS,T_INFO%TYPE,T_INFO%VCA, &
+     &           IO%IU0,IO%IU6,-1,LPAW)
+
+!-----------------------------------------------------------------------
+! read INCAR
+!-----------------------------------------------------------------------
+      CALL XML_TAG("incar")
+
+      CALL READER( &
+          IO%IU5,IO%IU0,IO%INTERACTIVE,INFO%SZNAM1,INFO%ISTART,INFO%IALGO,MIX%IMIX,MIX%MAXMIX,MIX%MREMOVE, &
+          MIX%AMIX,MIX%BMIX,MIX%AMIX_MAG,MIX%BMIX_MAG,MIX%AMIN, &
+          MIX%WC,MIX%INIMIX,MIX%MIXPRE,MIX%MIXFIRST,IO%LFOUND,INFO%LDIAG,INFO%LSUBROT,INFO%LREAL,IO%LREALD,IO%LPDENS, &
+          DYN%IBRION,INFO%ICHARG,INFO%INIWAV,INFO%NELM,INFO%NELMALL,INFO%NELMIN,INFO%NELMDL,INFO%EDIFF,DYN%EDIFFG, &
+          DYN%NSW,DYN%ISIF,PRED%IWAVPR,SYMM%ISYM,DYN%NBLOCK,DYN%KBLOCK,INFO%ENMAX,DYN%POTIM,DYN%TEBEG, &
+          DYN%TEEND,DYN%NFREE, &
+          PACO%NPACO,PACO%APACO,T_INFO%NTYP,NTYPD,DYN%SMASS,SCALEE,T_INFO%POMASS, & 
+          T_INFO%DARWIN_V,T_INFO%DARWIN_R,T_INFO%VCA,LVCADER, &
+          T_INFO%RWIGS,INFO%NELECT,INFO%NUP_DOWN,INFO%TIME, & 
+          KPOINTS%EMIN,KPOINTS%EMAX,KPOINTS%EFERMI,KPOINTS%ISMEAR,KPOINTS%SPACING,KPOINTS%LGAMMA, & 
+          DYN%PSTRESS,INFO%NDAV, &
+          KPOINTS%SIGMA,KPOINTS%LTET,INFO%WEIMIN,INFO%EBREAK,INFO%DEPER,IO%NWRITE,INFO%LCORR, &
+          IO%IDIOT,T_INFO%NIONS,T_INFO%NTYPP,IO%LMUSIC,IO%LOPTICS,STM, &
+          INFO%ISPIN,T_INFO%ATOMOM,NIOND,IO%LWAVE,IO%LDOWNSAMPLE,IO%LCHARG,IO%LVTOT,IO%LVHAR,INFO%SZPREC, &
+          INFO%ENAUG,IO%LORBIT,IO%LELF,T_INFO%ROPT,INFO%ENINI, &
+          NGX,NGY,NGZ,NGXC,NGYC,NGZC,NBANDS,NEDOS,NBLK,LATT_CUR, &
+          LPLANE_WISE,LCOMPAT,LMAX_CALC,SET_LMAX_MIX_TO,WDES%NSIM,LPARD,LPAW,LADDGRID, &
+          WDES%LNONCOLLINEAR,WDES%LSORBIT,WDES%SAXIS,INFO%LMETAGGA, &
+          WDES%LSPIRAL,WDES%LZEROZ,WDES%QSPIRAL,WDES%LORBITALREAL, &
+          INFO%LASPH,INFO%TURBO,INFO%IRESTART,INFO%NREBOOT,INFO%NMIN,INFO%EREF, &
+          INFO%NLSPLINE,ISPECIAL,MDALGO &
+#ifdef libbeef
+         ,LBEEFENS,LBEEFBAS &
+#endif
+         )
+#ifdef tbdyn
+      SEED=0
+      !c user provided SEED for random number generator
+      CALL RDATAB(IO%LOPEN,INCAR,IO%IU5,'RANDOM_SEED','=','#',';','I', &
+            SEED,RDUM,CDUM,LDUM,CHARAC,N,K_SEED,IERR)
+      IF (((IERR/=0).AND.(IERR/=3)).OR. &
+                          ((IERR==0).AND.(N<1))) THEN
+         IF (IO%IU0>=0) &
+            WRITE(IO%IU0,*)'Error reading item ''RANDOM_SEED'' from file INCAR.'
+         STOP
+      ELSEIF (IERR==3) THEN
+         CALL DATE_AND_TIME(VALUES=DTVALUES)
+
+         !c with this choice we'r sure not to exceed
+         !c SEED1_MAX (maximal value we can get here is 893581000)
+         IDUMLONG=  DTVALUES(3)*24*60*60*300 &
+                +DTVALUES(5)*60*60*1000 &
+                +DTVALUES(6)*60*1000 &
+                +DTVALUES(7)*1000 &
+                +DTVALUES(8)
+         SEED(1)=MOD(IDUMLONG,SEED1_MAX)
+      ELSEIF ((SEED(1)<0).OR.(SEED(1)>SEED1_MAX).OR. &
+               (SEED(2)<0).OR.(SEED(2)>SEED2_MAX).OR. &
+                (SEED(3)<0)) THEN
+         CALL VTUTOR('E','RANDOMSEED',RTUT,1, &
+     &            SEED,3,CDUM,1,LDUM,1,IO%IU0,IO%IDIOT)
+         CALL VTUTOR('S','RANDOMSEED',RTUT,1, &
+     &            SEED,3,CDUM,1,LDUM,1,IO%IU6,IO%IDIOT)
+      ELSE
+         CALL XML_INCAR_V('RANDOM_SEED','I',SEED,RDUM,CDUM,LDUM,CHARAC,N)
+      ENDIF
+      CALLMPI( M_bcast_i(COMM_WORLD,SEED,K_SEED))
+      CALL RANE_ION(RDUM,PUT=SEED(1:K_SEED))
+      SEED_INIT=SEED
+#endif
+
+      KPOINTS%NKPX=MAX(1,CEILING(LATT_CUR%BNORM(1)*PI*2/KPOINTS%SPACING))
+      KPOINTS%NKPY=MAX(1,CEILING(LATT_CUR%BNORM(2)*PI*2/KPOINTS%SPACING))
+      KPOINTS%NKPZ=MAX(1,CEILING(LATT_CUR%BNORM(3)*PI*2/KPOINTS%SPACING))
+
+      CALL GGA_COMPAT_MODE(IO%IU5, IO%IU0, LCOMPAT)
+
+      IF (WDES%LNONCOLLINEAR) THEN
+         INFO%ISPIN = 1
+      ENDIF
+! METAGGA not implemented for non collinear magnetism
+!      IF (WDES%LNONCOLLINEAR .AND. INFO%LMETAGGA) THEN
+!         WRITE(*,*) 'METAGGA for non collinear magnetism not supported.' 
+!         WRITE(*,*) 'exiting VASP; sorry for the inconveniences.'
+!         STOP
+!      ENDIF
+!-MM- Spin spirals require LNONCOLLINEAR=.TRUE.
+      IF (.NOT.WDES%LNONCOLLINEAR .AND. WDES%LSPIRAL) THEN
+         WRITE(*,*) 'Spin spirals require LNONCOLLINEAR=.TRUE. '
+         WRITE(*,*) 'exiting VASP; sorry dude!'
+         STOP
+      ENDIF
+!-MM- end of addition
+
+      IF (LCOMPAT) THEN
+              CALL VTUTOR('W','VASP.4.4',RTUT,1, &
+     &                 ITUT,1,CDUM,1,LDUM,1,IO%IU6,IO%IDIOT)
+              CALL VTUTOR('W','VASP.4.4',RTUT,1, &
+     &                 ITUT,1,CDUM,1,LDUM,1,IO%IU0,IO%IDIOT)
+      ENDIF
+! WRITE out an advice if some force dependent ionic algorithm and METAGGA
+! or ASPH
+!      IF ((INFO%LMETAGGA) .AND. &
+!     &      (DYN%IBRION>0 .OR. (DYN%IBRION==0 .AND. DYN%SMASS/=-2))) THEN
+!         CALL VTUTOR('A','METAGGA and forces',RTUT,1, &
+!     &                 ITUT,1,CDUM,1,(/INFO%LASPH, INFO%LMETAGGA /),2, &
+!     &                 IO%IU0,IO%IDIOT)
+!      ENDIF
+! The meaning of LVTOT has changed w.r.t. previous VASP version,
+! therefore we write a warning
+      IF (IO%LVTOT) THEN
+         CALL VTUTOR('W','LVTOT',RTUT,1, &
+     &                 ITUT,1,CDUM,1,LDUM,1,IO%IU0,IO%IDIOT)
+      ENDIF
+
+#if defined(MPI) || defined(MPI_CHAIN)
+      IF ( REAL(COMM%NCPU,q)/COMM_INB%NCPU/COMM_INB%NCPU>4 .OR. &
+           REAL(COMM%NCPU,q)/COMM_INB%NCPU/COMM_INB%NCPU<0.25_q) THEN
+           CALL VTUTOR('W','NPAR efficiency',RTUT,1, &
+           ITUT,1,CDUM,1,LDUM,1,IO%IU6,IO%IDIOT)
+           CALL VTUTOR('W','NPAR efficiency',RTUT,1, &
+           ITUT,1,CDUM,1,LDUM,1,IO%IU0,IO%IDIOT)
+      ENDIF
+      IF (KPAR.GT.1) THEN
+              CALL VTUTOR('W','KPAR',RTUT,1, &
+     &                 ITUT,1,CDUM,1,LDUM,1,IO%IU6,IO%IDIOT)
+              CALL VTUTOR('W','KPAR',RTUT,1, &
+     &                 ITUT,1,CDUM,1,LDUM,1,IO%IU0,IO%IDIOT)
+      END IF
+#endif
+!-----------------------------------------------------------------------
+! core level shift related items (parses INCAR)
+!-----------------------------------------------------------------------
+      CALL INIT_CL_SHIFT(IO%IU5,IO%IU0, T_INFO%NIONS, T_INFO%NTYP )
+! Berry phase read INCAR
+      CALL READER_ADD_ON(IO%IU5,IO%IU0,LBERRY,IGPAR,NPPSTR, &
+            INFO%ICHARG,KPOINTS%ISMEAR,KPOINTS%SIGMA)
+! Do we want to write the AE-densities?
+      CALL INIT_AEDENS(IO%IU0,IO%IU5)
+
+      ISPIND=INFO%ISPIN
+
+      DYN%TEMP =DYN%TEBEG
+      INFO%RSPIN=3-INFO%ISPIN
+
+      CALL RESPONSE_READER(IO%IU5, IO%IU6, IO%IU0)
+      CALL CRPA_READER(IO%IU5, IO%IU6, IO%IU0, NBANDS, L2E4W, L2E4W_ALL ,IO%LDOWNSAMPLE)
+      CALL PEAD_READER(IO%IU5, IO%IU6, IO%IU0)
+      CALL DMATRIX_READER(IO%IU5, IO%IU6, IO%IU0)
+      CALL XC_FOCK_READER(IO%IU5, IO%IU0, IO%IU6, INFO%SZPREC, DYN%ISIF, SYMM%ISYM, INFO%IALGO, & 
+         LATT_CUR%OMEGA, T_INFO%NTYP, T_INFO%NIONS, MIX%IMIX, MIX%AMIX, MIX%AMIX_MAG, MIX%BMIX, MIX%BMIX_MAG, IO%LVTOT)
+      CALL EGRAD_READER(IO%IU5, IO%IU6, IO%IU0, T_INFO%NTYP)
+      CALL CLASSICFIELDS_READER(IO%IU5, IO%IU6, IO%IU0)
+      CALL HYPERFINE_READER(IO%IU5, IO%IU6, IO%IU0, T_INFO%NTYP)
+!-----------------------------------------------------------------------
+! loop over different smearing parameters
+!-----------------------------------------------------------------------
+#ifndef makekpoints
+      SMEAR_LOOP%ISMCNT=0
+      IF (KPOINTS%ISMEAR==-3) THEN
+        IF(IO%IU6>=0)   WRITE(TIU6,7219)
+ 7219   FORMAT('   Loop over smearing-parameters in INCAR')
+        CALL RDATAB(IO%LOPEN,INCAR,IO%IU5,'SMEARINGS','=','#',';','F', &
+     &            IDUM,SMEAR_LOOP%SMEARS(1),CDUM,LDUM,CHARAC,N,200,IERR)
+        IF ((IERR/=0).OR.((IERR==0).AND. &
+     &          ((N<2).OR.(N>200).OR.(MOD(N,2)/=0)))) THEN
+           IF (IO%IU0>=0) &
+           WRITE(TIU0,*)'Error reading item ''SMEARINGS'' from file INCAR.'
+           STOP
+        ENDIF
+        SMEAR_LOOP%ISMCNT=N/2
+        DYN%NSW   =SMEAR_LOOP%ISMCNT+1
+        DYN%KBLOCK=DYN%NSW
+        KPOINTS%LTET  =.TRUE.
+        DYN%IBRION=-1
+        KPOINTS%ISMEAR=-5
+      ENDIF
+!=======================================================================
+!  now read in Pseudopotential
+!  modify the potential if required (core level shifts)
+!=======================================================================
+      LMDIM=0
+      LDIM=0
+      DO NT=1,NTYP_PP
+        LMDIM=MAX(LMDIM,P(NT)%LMMAX)
+        LDIM =MAX(LDIM ,P(NT)%LMAX)
+      END DO
+      CALL DEALLOC_PP(P,NTYP_PP)
+
+      LDIM2=(LDIM*(LDIM+1))/2
+      LMYDIM=9
+! second scan with correct setting
+      CALL RD_PSEUDO(INFO,P, &
+     &           NTYP_PP,NTYPD,LDIM,LDIM2,LMDIM, &
+     &           T_INFO%POMASS,T_INFO%RWIGS,T_INFO%TYPE,T_INFO%VCA, &
+     &           IO%IU0,IO%IU6,IO%NWRITE,LPAW)
+      CALL CL_MODIFY_PP( NTYP_PP, P, INFO%ENAUG )
+! now check everything
+      CALL POST_PSEUDO(NTYPD,NTYP_PP,T_INFO%NTYP,T_INFO%NIONS,T_INFO%NITYP,T_INFO%VCA,P,INFO, &
+     &        IO%LREALD,T_INFO%ROPT, IO%IDIOT,IO%IU6,IO%IU0,LMAX_CALC,L_NO_US,WDES%LSPIRAL)
+      CALL LDIM_PSEUDO(IO%LORBIT, NTYPD, P, LDIMP, LMDIMP)
+! check the difference between ENINI and ENMAX for spin spiral calculations
+      IF (WDES%LSPIRAL) CALL CHECK_SPIRAL_ENCUT(WDES,INFO,LATT_CUR,IO)
+!-----------------------------------------------------------------------
+! LDA+U initialisation (parses INCAR)
+!-----------------------------------------------------------------------
+      CALL LDAU_READER(T_INFO%NTYP,IO%IU5,IO%IU0)
+      IF ( (LGW0 .OR. LGW .OR. LscQPGW) .AND. USELDApU()) THEN
+         CALL VTUTOR('E','Double counting',RTUT,1, &
+     &               ITUT,1,CDUM,1,LDUM,1,IO%IU0,IO%IDIOT)
+         CALL VTUTOR('E','Double counting',RTUT,1, &
+     &               ITUT,1,CDUM,1,LDUM,1,IO%IU6,IO%IDIOT)
+      ENDIF
+
+      IF (USELDApU().OR.LCALC_ORBITAL_MOMENT()) &
+     &   CALL INITIALIZE_LDAU(T_INFO%NIONS,T_INFO%NTYP,P,WDES%LNONCOLLINEAR,IO%IU0,IO%IDIOT)
+
+      CALL SET_PAW_AUG(T_INFO%NTYP, P, IO%IU6, LMAX_CALC, LCOMPAT)
+!-----------------------------------------------------------------------
+! optics initialisation (parses INCAR)
+!-----------------------------------------------------------------------
+      IF (IO%LOPTICS) CALL SET_NABIJ_AUG(P,T_INFO%NTYP)
+#endif
+!-----------------------------------------------------------------------
+!  Read UNIT=15: POSCAR Startjob and Continuation-job
+!-----------------------------------------------------------------------
+      CALL RD_POSCAR(LATT_CUR, T_INFO, DYN, &
+     &           NIOND,NIONPD, NTYPD,NTYPPD, &
+     &           IO%IU0,IO%IU6)
+
+!-----------------------------------------------------------------------
+! diverse INCAR readers
+!-----------------------------------------------------------------------
+      CALL RESPONSE_SET_ENCUT(INFO%ENMAX)
+      CALL CONSTRAINED_M_READER(T_INFO,WDES,IO%IU0,IO%IU5)
+      CALL WRITER_READER(IO%IU0,IO%IU5)
+      CALL WANNIER_READER(IO%IU0,IO%IU5,IO%IU6,IO%IDIOT)
+      CALL FIELD_READER(T_INFO,P,LATT_CUR,INFO%NELECT,IO%IU0,IO%IU5,IO%IU6)
+      CALL LR_READER(INFO%EDIFF,IO%IU0,IO%IU5,IO%IU6)
+      CALL ORBITALMAG_READER(IO%IU0, IO%IU5, IO%IU6, T_INFO%NIONS)
+      CALL RHFATM_READER(IO)
+      CALL XC_META_READER(IO,T_INFO%NTYP)
+      CALL CHGFIT_READER(IO,T_INFO%NTYP)
+      CALL STOCKHOLDER_READER(IO)
+      CALL LJ_READER(IO)
+      CALL MLWF_READER(IO%IU5,IO%IU6,IO%IU0,IO%LDOWNSAMPLE)
+      CALL WNPR_READER(T_INFO%NIONS,IO%IU0,IO%IU5)
+! locproj_
+      CALL LPRJ_READER(T_INFO,P,IO%IU0)
+! locproj_
+! elphon_
+      CALL ELPH_READER(IO%IU0,IO%IU5)
+! elphon_
+      CALL AUGER_READER(IO)
+      CALL WANNIER_INTERPOL_READER(IO)
+! solvation__
+      CALL SOL_READER(T_INFO%NIONS,INFO%EDIFF,IO)
+! solvation__
+! bexternal__
+      CALL BEXT_READER(IO%IU0,IO%IU5)
+! bexternal__
+      CALL CLASSICFIELDS_WRITE(IO%IU6)
+!-----------------------------------------------------------------------
+! exchange correlation table
+!-----------------------------------------------------------------------
+      CALL PUSH_XC_TYPE_FOR_GW ! switch now to AEXX=1.0 ; ALDAC = 0.0
+      IF (WDES%LNONCOLLINEAR .OR. INFO%ISPIN == 2) THEN
+         CALL SETUP_LDA_XC(2,IO%IU6,IO%IU0,IO%IDIOT)
+      ELSE
+         CALL SETUP_LDA_XC(1,IO%IU6,IO%IU0,IO%IDIOT)
+      ENDIF
+!-----------------------------------------------------------------------
+! init all chains (INCAR reader)
+!-----------------------------------------------------------------------
+      CALL chain_init( T_INFO, IO)
+!-----------------------------------------------------------------------
+!xml finish copying parameters from INCAR to xml file
+! no INCAR reading from here 
+      CALL XML_CLOSE_TAG("incar")
+!-----------------------------------------------------------------------
+#if CUDA_GPU
+      CALL GPU_TEST(INFO,NPAR,IO)
+#endif
+
+      CALL COUNT_DEGREES_OF_FREEDOM( T_INFO, NDEGREES_OF_FREEDOM, &
+          IO%IU6, IO%IU0, DYN%IBRION)
+
+!-----for static calculations or relaxation jobs DYN%VEL is meaningless
+      IF (DYN%INIT == -1) THEN
+        CALL INITIO(T_INFO%NIONS,T_INFO%LSDYN,NDEGREES_OF_FREEDOM, &
+               T_INFO%NTYP,T_INFO%ITYP,DYN%TEMP, &
+               T_INFO%POMASS,DYN%POTIM, &
+               DYN%POSION,DYN%VEL,T_INFO%LSFOR,LATT_CUR%A,LATT_CUR%B,DYN%INIT, COMM, IO%IU6)
+#ifdef tbdyn
+        ! TB dynamics will initialize the velocities for MDALGO>0
+        IF (MDALGO==0) DYN%INIT=0
+#else
+        DYN%INIT=0
+#endif
+      ENDIF
+      IF (DYN%IBRION/=0 .AND. DYN%IBRION/=40 .AND. DYN%IBRION/=44) THEN
+          DYN%VEL=0._q
+      ENDIF
+      IF (IO%IU6>=0) THEN
+         WRITE(TIU6,*)
+         WRITE(TIU6,130)
+      ENDIF
+
+
+#ifdef tbdyn
+      !c some MD methods (e.q. Langevin dynamics) do not conserve total momentum! 
+      IF ( T_INFO%LSDYN ) THEN
+         CALL SET_SELECTED_VEL_ZERO(T_INFO, DYN%VEL,LATT_CUR)
+      ELSE IF (MDALGO/=3 .AND. MDALGO/=31 .AND. DYN%IBRION/=44 .AND. DYN%IBRION/=40) THEN
+         CALL SYMVEL_WARNING( T_INFO%NIONS, T_INFO%NTYP, T_INFO%ITYP, &
+         T_INFO%POMASS, DYN%VEL, IO%IU6, IO%IU0 )
+      ENDIF
+#else
+      IF ( T_INFO%LSDYN ) THEN
+         CALL SET_SELECTED_VEL_ZERO(T_INFO, DYN%VEL,LATT_CUR)
+      ELSE
+         !tb beg
+         !c do not remove CoM motion if iDM or DVV is to be used
+         IF (DYN%IBRION/=44 .AND. DYN%IBRION/=40) THEN
+           CALL SYMVEL_WARNING( T_INFO%NIONS, T_INFO%NTYP, T_INFO%ITYP, &
+             T_INFO%POMASS, DYN%VEL, IO%IU6, IO%IU0 )
+         ENDIF
+         !tb end
+      ENDIF
+#endif
+
+      CALL NEAREST_NEIGHBOUR(IO%IU6, IO%IU0, T_INFO, LATT_CUR, P%RWIGS)
+!-----------------------------------------------------------------------
+!  initialize the symmetry stuff
+!-----------------------------------------------------------------------
+      ALLOCATE(SYMM%ROTMAP(NIOND,1,1), &
+               SYMM%TAU(NIOND,3), &
+     &         SYMM%TAUROT(NIOND,3),SYMM%WRKROT(3*(NIOND+2)), &
+     &         SYMM%PTRANS(NIOND+2,3),SYMM%INDROT(NIOND+2))
+      IF (INFO%ISPIN==2) THEN
+         ALLOCATE(SYMM%MAGROT(48,NIOND))
+      ELSE
+         ALLOCATE(SYMM%MAGROT(1,1))
+      ENDIF
+      ! break symmetry parallel to IGPAR
+      IF (LBERRY) THEN
+         LATT_CUR%A(:,IGPAR)=LATT_CUR%A(:,IGPAR)*(1+TINY*10)
+         CALL LATTIC(LATT_CUR)
+      ENDIF
+! Rotate the initial magnetic moments to counter the clockwise
+! rotation brought on by the spin spiral
+      IF (WDES%LSPIRAL) CALL COUNTER_SPIRAL(WDES%QSPIRAL,T_INFO%NIONS,T_INFO%POSION,T_INFO%ATOMOM)
+
+      IF (SYMM%ISYM>0) THEN
+! Finite temperature allows no symmetry by definition ...
+         NCDIJ=INFO%ISPIN
+         IF (WDES%LNONCOLLINEAR) NCDIJ=4
+         CALL INISYM(LATT_CUR%A,DYN%POSION,DYN%VEL,T_INFO%LSFOR, &
+                     T_INFO%LSDYN,T_INFO%NTYP,T_INFO%NITYP,NIOND, &
+                     SYMM%PTRANS,SYMM%NROT,SYMM%NPTRANS,SYMM%ROTMAP, &
+                     SYMM%TAU,SYMM%TAUROT,SYMM%WRKROT, &
+                     SYMM%INDROT,T_INFO%ATOMOM,WDES%SAXIS,SYMM%MAGROT,NCDIJ,IO%IU6)
+         IF (IO%NWRITE>=3) CALL WRTSYM(T_INFO%NIONS,NIOND,SYMM%PTRANS,SYMM%ROTMAP,SYMM%MAGROT,NCDIJ,IO%IU6)
+      ELSE
+! ... so take nosymm!
+         CALL NOSYMM(LATT_CUR%A,T_INFO%NTYP,T_INFO%NITYP,NIOND,SYMM%PTRANS, &
+        &   SYMM%NROT,SYMM%NPTRANS,SYMM%ROTMAP,SYMM%MAGROT,INFO%ISPIN,IO%IU6)
+      END IF
+      CALL SETUP_PRIMITIVE_CELL(LATT_CUR%A, DYN%POSION, IO%IU0)
+!=======================================================================
+!  Read UNIT=14: KPOINTS
+!  number of k-points and k-points in reciprocal lattice
+!=======================================================================
+      IF(IO%IU6>=0)  WRITE(TIU6,*)
+      ! use full k-point grid if finite differences are used or 
+      ! linear response is applied
+      IF (DYN%IBRION==5 .OR. DYN%IBRION==6 .OR. DYN%IBRION==7.OR. DYN%IBRION==8 .OR. DYN%IBRION==9 .OR. DYN%IBRION==19 & 
+          .OR. LEPSILON .OR. LVEL .OR. KINTER/=0 .OR. LMAGBLOCH  & 
+          .OR. LCHIMAG .OR. LTIME_EVOLUTION) CALL USE_FULL_KPOINTS
+      ! apply preferentially time inversion symmetry to generate orbitals at -k    
+      IF (WDES%LORBITALREAL) CALL USE_TIME_INVERSION
+
+      IF (LBERRY) THEN
+         CALL RD_KPOINTS_BERRY(KPOINTS,NPPSTR,IGPAR, &
+        &   LATT_CUR, &
+        &   SYMM%ISYM>=0.AND..NOT.WDES%LSORBIT.AND..NOT.WDES%LSPIRAL, &
+        &   IO%IU6,IO%IU0)
+          IF (LBERRY) THEN
+            LATT_CUR%A(:,IGPAR)=LATT_CUR%A(:,IGPAR)/(1+TINY*10)
+            CALL LATTIC(LATT_CUR)
+         ENDIF
+      ELSE
+#ifdef oldsym
+         CALL SETUP_KPOINTS(KPOINTS,LATT_CUR, &
+            SYMM%ISYM>=0.AND. &
+            .NOT.WDES%LSORBIT.AND. &
+            .NOT.WDES%LSPIRAL, &
+            SYMM%ISYM<0,IO%IU6,IO%IU0)
+
+         CALL SETUP_FULL_KPOINTS(KPOINTS,LATT_CUR,T_INFO%NIOND, & 
+            SYMM%ROTMAP,SYMM%MAGROT,SYMM%ISYM, &
+            SYMM%ISYM>=0.AND. &
+            .NOT.WDES%LSORBIT.AND. &
+            .NOT.WDES%LSPIRAL, &
+            IO%IU6,IO%IU0,LSYMGRAD)
+#else
+         CALL SETUP_KPOINTS(KPOINTS,LATT_CUR, &
+            SYMM%ISYM>=0.AND..NOT.WDES%LNONCOLLINEAR, &
+            SYMM%ISYM<0,IO%IU6,IO%IU0)
+
+         CALL SETUP_FULL_KPOINTS(KPOINTS,LATT_CUR,T_INFO%NIOND, & 
+            SYMM%ROTMAP,SYMM%MAGROT,SYMM%ISYM, &
+            SYMM%ISYM>=0.AND..NOT.WDES%LNONCOLLINEAR, &
+            IO%IU6,IO%IU0, LSYMGRAD)
+#endif
+      ENDIF
+      CALL SETUP_ORIG_KPOINTS
+
+!=======================================================================
+!  at this point we have enough information to
+!  create a param.inc file
+!=======================================================================
+      XCUTOF =SQRT(INFO%ENMAX /RYTOEV)/(2*PI/(LATT_CUR%ANORM(1)/AUTOA))
+      YCUTOF =SQRT(INFO%ENMAX /RYTOEV)/(2*PI/(LATT_CUR%ANORM(2)/AUTOA))
+      ZCUTOF =SQRT(INFO%ENMAX /RYTOEV)/(2*PI/(LATT_CUR%ANORM(3)/AUTOA))
+!
+!  setup NGX, NGY, NGZ if required
+!
+! high precision do not allow for wrap around
+      IF (INFO%SZPREC(1:1)=='h' .OR. INFO%SZPREC(1:1)=='a') THEN
+        WFACT=4
+      ELSE
+! medium-low precision allow for small wrap around
+        WFACT=3
+      ENDIF
+      GRID%NGPTAR(1)=XCUTOF*WFACT+0.5_q
+      GRID%NGPTAR(2)=YCUTOF*WFACT+0.5_q
+      GRID%NGPTAR(3)=ZCUTOF*WFACT+0.5_q
+      IF (NGX /= -1)   GRID%NGPTAR(1)=  NGX
+      IF (NGY /= -1)   GRID%NGPTAR(2)=  NGY
+      IF (NGZ /= -1)   GRID%NGPTAR(3)=  NGZ
+      CALL FFTCHK(GRID%NGPTAR)
+!
+!  setup NGXC, NGYC, NGZC if required
+!
+      IF (INFO%LOVERL) THEN
+        IF (INFO%ENAUG==0) INFO%ENAUG=INFO%ENMAX*1.5_q
+        IF (INFO%SZPREC(1:1)=='h') THEN
+          WFACT=16._q/3._q
+        ELSE IF (INFO%SZPREC(1:1)=='l') THEN
+          WFACT=3
+        ELSE
+          WFACT=4
+        ENDIF
+        XCUTOF =SQRT(INFO%ENAUG /RYTOEV)/(2*PI/(LATT_CUR%ANORM(1)/AUTOA))
+        YCUTOF =SQRT(INFO%ENAUG /RYTOEV)/(2*PI/(LATT_CUR%ANORM(2)/AUTOA))
+        ZCUTOF =SQRT(INFO%ENAUG /RYTOEV)/(2*PI/(LATT_CUR%ANORM(3)/AUTOA))
+        GRIDC%NGPTAR(1)=XCUTOF*WFACT
+        GRIDC%NGPTAR(2)=YCUTOF*WFACT
+        GRIDC%NGPTAR(3)=ZCUTOF*WFACT
+        ! prec Single no double grid technique
+        IF (INFO%SZPREC(1:1)=='s') THEN
+           GRIDC%NGPTAR(1)=GRID%NGPTAR(1)
+           GRIDC%NGPTAR(2)=GRID%NGPTAR(2)
+           GRIDC%NGPTAR(3)=GRID%NGPTAR(3)
+        ELSE IF (INFO%SZPREC(1:1)=='a' .OR. INFO%SZPREC(1:1)=='n') THEN
+           GRIDC%NGPTAR(1)=GRID%NGPTAR(1)*2
+           GRIDC%NGPTAR(2)=GRID%NGPTAR(2)*2
+           GRIDC%NGPTAR(3)=GRID%NGPTAR(3)*2
+        ENDIF
+        IF (NGXC /= -1)  GRIDC%NGPTAR(1)=NGXC
+        IF (NGYC /= -1)  GRIDC%NGPTAR(2)=NGYC
+        IF (NGZC /= -1)  GRIDC%NGPTAR(3)=NGZC
+        CALL FFTCHK(GRIDC%NGPTAR)
+      ELSE
+        GRIDC%NGPTAR(1)= 1
+        GRIDC%NGPTAR(2)= 1
+        GRIDC%NGPTAR(3)= 1
+      ENDIF
+
+      GRIDC%NGPTAR(1)=MAX(GRIDC%NGPTAR(1),GRID%NGPTAR(1))
+      GRIDC%NGPTAR(2)=MAX(GRIDC%NGPTAR(2),GRID%NGPTAR(2))
+      GRIDC%NGPTAR(3)=MAX(GRIDC%NGPTAR(3),GRID%NGPTAR(3))
+      GRIDUS%NGPTAR=GRIDC%NGPTAR
+      IF (LADDGRID) GRIDUS%NGPTAR=GRIDC%NGPTAR*2
+
+      NGX = GRID %NGPTAR(1); NGY = GRID %NGPTAR(2); NGZ = GRID %NGPTAR(3)
+      NGXC= GRIDC%NGPTAR(1); NGYC= GRIDC%NGPTAR(2); NGZC= GRIDC%NGPTAR(3)
+
+      IF (NBANDS == -1) THEN
+         LNBANDS=.FALSE.  ! NBANDS was not read from INCAR
+         IF (WDES%LNONCOLLINEAR)  THEN
+             NMAG=MAX(SUM(T_INFO%ATOMOM(1:T_INFO%NIONS*3-2:3)), &
+                      SUM(T_INFO%ATOMOM(2:T_INFO%NIONS*3-1:3)), &
+                      SUM(T_INFO%ATOMOM(3:T_INFO%NIONS*3:3)))
+         ELSE IF (INFO%ISPIN > 1) THEN
+             NMAG=SUM(T_INFO%ATOMOM(1:T_INFO%NIONS))
+         ELSE
+             NMAG=0
+         ENDIF
+         NMAG = (NMAG+1)/2
+         NBANDS=MAX(NINT(INFO%NELECT+2)/2+MAX(T_INFO%NIONS/2,3),INT(0.6*INFO%NELECT))+NMAG
+         IF (WDES%LNONCOLLINEAR) NBANDS = NBANDS*2
+         NBANDS=((NBANDS+NPAR-1)/NPAR)*NPAR
+      ENDIF
+
+      IF (NBANDS/=((NBANDS+NPAR-1)/NPAR)*NPAR) THEN
+         ITUT(1)=NBANDS
+         ITUT(2)=((NBANDS+NPAR-1)/NPAR)*NPAR
+         CALL VTUTOR('W','NBANDS changed',RTUT,1, &
+     &        ITUT,2,CDUM,1,LDUM,1,IO%IU0,IO%IDIOT)
+         CALL VTUTOR('W','NBANDS changed',RTUT,1, &
+     &        ITUT,2,CDUM,1,LDUM,1,IO%IU6,IO%IDIOT)
+         
+      ENDIF
+
+      NBANDS=((NBANDS+NPAR-1)/NPAR)*NPAR
+
+      IF (INFO%EBREAK == -1) INFO%EBREAK=0.25_q*MIN(INFO%EDIFF,ABS(DYN%EDIFFG)/10)/NBANDS
+
+      IF(INFO%TURBO==0)THEN
+         IF (((.NOT. WDES%LNONCOLLINEAR).AND.  INFO%NELECT>REAL(NBANDS*2,KIND=q)).OR. &
+                 ((WDES%LNONCOLLINEAR).AND.((INFO%NELECT*2)>REAL(NBANDS*2,KIND=q)))) THEN
+            ITUT(1)=INFO%NELECT ; ITUT(2)=NBANDS
+            CALL VTUTOR('E','Number of electrons',RTUT,1, &
+     &                  ITUT,2,CDUM,1,LDUM,1,IO%IU0,IO%IDIOT)
+            CALL VTUTOR('S','Number of electrons',RTUT,1, &
+     &                  ITUT,2,CDUM,1,LDUM,1,IO%IU6,IO%IDIOT)
+         ENDIF
+      ELSE
+         IF (( (.NOT. WDES%LNONCOLLINEAR).AND.  INFO%NELECT>REAL(NBANDS*2,KIND=q)).OR. &
+                    ((WDES%LNONCOLLINEAR).AND.((INFO%NELECT*2)>REAL(NBANDS*2,KIND=q)))) THEN
+            IF(KPOINTS%EFERMI==0) THEN
+               ITUT(1)=INFO%NELECT ; ITUT(2)=NBANDS
+               CALL VTUTOR('E','Number of electrons',RTUT,1, &
+     &              ITUT,2,CDUM,1,LDUM,1,IO%IU0,IO%IDIOT)
+               CALL VTUTOR('S','Number of electrons',RTUT,1, &
+     &              ITUT,2,CDUM,1,LDUM,1,IO%IU6,IO%IDIOT)
+            ENDIF
+         ENDIF
+      ENDIF
+
+      NRPLWV=4*PI*SQRT(INFO%ENMAX /RYTOEV)**3/3* &
+     &     LATT_CUR%OMEGA/AUTOA**3/(2*PI)**3*1.1_q+50
+#ifdef gammareal
+      NRPLWV=NRPLWV/2
+#endif
+      WDES%NRPLWV=NRPLWV
+      PSRMX=0
+      PSDMX=0
+      DO NT=1,T_INFO%NTYP
+        PSRMX=MAX(PSRMX,P(NT)%PSRMAX)
+        PSDMX=MAX(PSDMX,P(NT)%PSDMAX)
+      ENDDO
+      IF (INFO%LREAL) THEN
+       IRMAX=4*PI*PSRMX**3/3/(LATT_CUR%OMEGA/ &
+     &        (GRID%NGPTAR(1)*GRID%NGPTAR(2)*GRID%NGPTAR(3)))+50
+      ELSE
+       IRMAX=1
+      ENDIF
+      IRDMAX=1
+      IF (INFO%LOVERL) THEN
+       IRDMAX=4*PI*PSDMX**3/3/(LATT_CUR%OMEGA/ &
+     &        (GRIDC%NGPTAR(1)*GRIDC%NGPTAR(2)*GRIDC%NGPTAR(3)))+200
+      ENDIF
+#ifdef usgrid
+       IRDMAX=4*PI*PSDMX**3/3/(LATT_CUR%OMEGA/ &
+     &        (GRIDUS%NGPTAR(1)*GRIDUS%NGPTAR(2)*GRIDUS%NGPTAR(3)))+200
+#endif
+
+      NPLWV =NGX *NGY *NGZ;
+      MPLWV =NGX *NGY *NGZ
+      NPLWVC=NGXC*NGYC*NGZC;
+      MPLWVC=xm(NGXC)*NGYC*zm(NGZC)
+!=======================================================================
+!  set the basic quantities in WDES
+!  and set the grids
+!=======================================================================
+
+      WDES%ENMAX =INFO%ENMAX
+
+      WDES%NB_PAR=NPAR
+      WDES%NB_TOT=NBANDS
+      WDES%NBANDS=NBANDS/NPAR
+#ifdef MPI
+      WDES%NB_LOW=COMM_INTER%NODE_ME
+#else
+      WDES%NB_LOW=1
+#endif
+      CALL INIT_KPOINT_WDES(WDES, KPOINTS )
+      WDES%ISPIN =INFO%ISPIN
+      WDES%COMM  =>COMM
+      WDES%COMM_INB    =>COMM_INB
+      WDES%COMM_INTER  =>COMM_INTER
+      WDES%COMM_KIN    =>COMM_KIN
+      WDES%COMM_KINTER =>COMM_KINTER
+      NULLIFY( WDES%COMM_SHMEM )
+#ifdef use_shmem
+      WDES%COMM_SHMEM  =>COMM_SHMEM
+      WDES%COMM_intra_node =>COMM_intra_node
+      WDES%COMM_inter_node =>COMM_inter_node
+#endif
+
+      CALL  SET_FULL_KPOINTS(WDES%NKPTS_FOR_GEN_LAYOUT,WDES%VKPT)
+      CALL  SET_FOCK_KPOINTS(WDES%NKDIM)
+
+      IF (WDES%LNONCOLLINEAR) then
+         WDES%NRSPINORS = 2
+         INFO%RSPIN = 1
+      ELSE
+         WDES%NRSPINORS = 1 
+      ENDIF
+      WDES%RSPIN = INFO%RSPIN
+
+      CALL WDES_SET_NPRO(WDES,T_INFO,P,INFO%LOVERL)
+!
+! set up the descriptor for the initial wavefunctions
+! (read from file)
+      LATT_INI=LATT_CUR
+! get header from WAVECAR file (LATT_INI is important)
+! also set INFO%ISTART
+      IF (INFO%ISTART > 0) THEN
+        CALL INWAV_HEAD(WDES, LATT_INI, LATT_CUR, ENMAXI,INFO%ISTART, IO%IU0)
+        IF (INFO%ISTART == 0 .AND. INFO%ICHARG == 0) INFO%ICHARG=2
+      ENDIF
+
+      CALL INIT_SCALAAWARE( WDES%NB_TOT, NRPLWV, WDES%COMM_KIN )
+
+!=======================================================================
+!  Write all important information
+!=======================================================================
+      IF (DYN%IBRION==5 .OR. DYN%IBRION==6 ) THEN
+         DYN%NSW=4*(3*T_INFO%NIONS+9)+1
+         IF (DYN%NFREE /= 1 .AND. DYN%NFREE /= 2 .AND. DYN%NFREE /= 4)  DYN%NFREE =2
+         DYN%KBLOCK=DYN%NSW
+      ENDIF
+
+      IF (IO%IU6>=0) THEN
+
+      WRITE(TIU6,130)
+      WRITE(TIU6,7205) KPOINTS%NKPTS,WDES%NKDIM,WDES%NB_TOT,NEDOS, &
+     &              T_INFO%NIONS,LDIM,LMDIM, &
+     &              NPLWV,IRMAX,IRDMAX, &
+     &              NGX,NGY,NGZ, &
+     &              NGXC,NGYC,NGZC,GRIDUS%NGPTAR,T_INFO%NITYP
+
+      XAU= (NGX*PI/(LATT_CUR%ANORM(1)/AUTOA))
+      YAU= (NGY*PI/(LATT_CUR%ANORM(2)/AUTOA))
+      ZAU= (NGZ*PI/(LATT_CUR%ANORM(3)/AUTOA))
+      WRITE(TIU6,7211) XAU,YAU,ZAU
+      XAU= (NGXC*PI/(LATT_CUR%ANORM(1)/AUTOA))
+      YAU= (NGYC*PI/(LATT_CUR%ANORM(2)/AUTOA))
+      ZAU= (NGZC*PI/(LATT_CUR%ANORM(3)/AUTOA))
+      WRITE(TIU6,7212) XAU,YAU,ZAU
+
+      ENDIF
+
+ 7211 FORMAT('   NGX,Y,Z   is equivalent  to a cutoff of ', &
+     &           F6.2,',',F6.2,',',F6.2,' a.u.')
+ 7212 FORMAT('   NGXF,Y,Z  is equivalent  to a cutoff of ', &
+     &           F6.2,',',F6.2,',',F6.2,' a.u.'/)
+
+      XCUTOF =SQRT(INFO%ENMAX /RYTOEV)/(2*PI/(LATT_CUR%ANORM(1)/AUTOA))
+      YCUTOF =SQRT(INFO%ENMAX /RYTOEV)/(2*PI/(LATT_CUR%ANORM(2)/AUTOA))
+      ZCUTOF =SQRT(INFO%ENMAX /RYTOEV)/(2*PI/(LATT_CUR%ANORM(3)/AUTOA))
+! high precision do not allow for wrap around
+      IF (INFO%SZPREC(1:1)=='h'.OR.INFO%SZPREC(1:1)=='a') THEN
+        WFACT=4
+      ELSE
+! medium-low precision allow for small wrap around
+        WFACT=3
+      ENDIF
+      ITUT(1)=XCUTOF*WFACT+0.5_q
+      ITUT(2)=YCUTOF*WFACT+0.5_q
+      ITUT(3)=ZCUTOF*WFACT+0.5_q
+      CALL FFTCHK(ITUT(1:3))
+      IF (IO%IU6>=0 .AND. (ITUT(1)/=NGX .OR. ITUT(2)/=NGY .OR. ITUT(3)/=NGZ)) & 
+        WRITE(TIU6,72111) ITUT(1),ITUT(2),ITUT(3)
+
+72111 FORMAT(' Based on PREC, I would recommend the following setting:'/ &
+     &       '   dimension x,y,z NGX = ',I5,' NGY =',I5,' NGZ =',I5 /)
+
+      IF (NGX<ITUT(1) .OR. NGY<ITUT(2) .OR. NGZ<ITUT(3)) THEN
+               CALL VTUTOR('W','FFT-GRID IS NOT SUFFICIENT',RTUT,1, &
+     &                  ITUT,3,CDUM,1,LDUM,1,IO%IU6,IO%IDIOT)
+               CALL VTUTOR('W','FFT-GRID IS NOT SUFFICIENT',RTUT,1, &
+     &                  ITUT,3,CDUM,1,LDUM,1,IO%IU0,IO%IDIOT)
+      ENDIF
+
+
+      AOMEGA=LATT_CUR%OMEGA/T_INFO%NIONS
+      QF=(3._q*PI*PI*INFO%NELECT/(LATT_CUR%OMEGA))**(1._q/3._q)*AUTOA
+
+! chose the mass so that the typical Nose frequency is 40 timesteps
+!-----just believe this (or look out  for all this factors in  STEP)
+      IF (DYN%SMASS==0)  DYN%SMASS= &
+         ((40._q*DYN%POTIM*1E-15_q/2._q/PI/LATT_CUR%ANORM(1))**2)* &
+         2.E20_q*BOLKEV*EVTOJ/AMTOKG*NDEGREES_OF_FREEDOM*MAX(DYN%TEBEG,DYN%TEEND)
+!      IF (DYN%SMASS<0)  DYN%SMASS= &
+!         ((ABS(DYN%SMASS)*DYN%POTIM*1E-15_q/2._q/PI/LATT_CUR%ANORM(1))**2)* &
+!         2.E20_q*BOLKEV*EVTOJ/AMTOKG*NDEGREES_OF_FREEDOM*MAX(DYN%TEBEG,DYN%TEEND)
+
+      SQQ=  DYN%SMASS*(AMTOKG/EVTOJ)*(1E-10_q*LATT_CUR%ANORM(1))**2
+      SQQAU=SQQ/RYTOEV
+      IF (DYN%SMASS>0) THEN
+        WOSZI= SQRT(2*BOLKEV*DYN%TEMP*NDEGREES_OF_FREEDOM/SQQ)
+      ELSE
+        WOSZI=1E-30_q
+      ENDIF
+!-----initial temperature
+      CALL EKINC(EKIN,T_INFO%NIONS,T_INFO%NTYP,T_INFO%ITYP,T_INFO%POMASS,DYN%POTIM,LATT_CUR%A,DYN%VEL)
+      TEIN = 2*EKIN/BOLKEV/NDEGREES_OF_FREEDOM
+!-----be carefull about division by 0
+      DYN%NBLOCK=MAX(1,DYN%NBLOCK)
+      DYN%KBLOCK=MAX(1,DYN%KBLOCK)
+      IF (DYN%NSW<DYN%KBLOCK*DYN%NBLOCK) DYN%KBLOCK=1
+      IF (DYN%NSW<DYN%KBLOCK*DYN%NBLOCK) DYN%NBLOCK=MAX(DYN%NSW,1)
+
+      DYN%NSW=INT(DYN%NSW/DYN%NBLOCK/DYN%KBLOCK)*DYN%NBLOCK*DYN%KBLOCK
+      IF (IO%IU6>=0) THEN
+
+      WRITE(TIU6,7210) INFO%SZNAM1,T_INFO%SZNAM2
+
+      WRITE(TIU6,7206) IO%NWRITE,INFO%SZPREC,INFO%ISTART,INFO%ICHARG,WDES%ISPIN,WDES%LNONCOLLINEAR, &
+     &      WDES%LSORBIT, INFO%INIWAV, &
+     &      INFO%LASPH,INFO%LMETAGGA, &
+     &      INFO%ENMAX,INFO%ENMAX/RYTOEV,SQRT(INFO%ENMAX/RYTOEV), &
+     &      XCUTOF,YCUTOF,ZCUTOF,INFO%ENINI, &
+     &      INFO%ENAUG, &
+     &      INFO%NELM,INFO%NELMIN,INFO%NELMDL,INFO%EDIFF,INFO%LREAL,INFO%NLSPLINE,LCOMPAT,GGA_COMPAT, &
+     &      LMAX_CALC,SET_LMAX_MIX_TO,LFCI, &
+     &      T_INFO%ROPT
+      WRITE(TIU6,7204) &
+     &      DYN%EDIFFG,DYN%NSW,DYN%NBLOCK,DYN%KBLOCK, &
+     &      DYN%IBRION,DYN%NFREE,DYN%ISIF,PRED%IWAVPR,SYMM%ISYM,INFO%LCORR
+
+      TMP=0
+      IF (DYN%POTIM>0) TMP=1/(WOSZI*(DYN%POTIM*1E-15_q)/2._q/PI)
+
+      WRITE(TIU6,7207) &
+     &      DYN%POTIM,TEIN,DYN%TEBEG,DYN%TEEND, &
+     &      DYN%SMASS,WOSZI,TMP,SQQAU,SCALEE, &
+     &      PACO%NPACO,PACO%APACO,DYN%PSTRESS
+
+      WRITE(TIU6,7215) (T_INFO%POMASS(NI),NI=1,T_INFO%NTYP)
+      RTUT(1:T_INFO%NTYP)=P(1:T_INFO%NTYP)%ZVALF ! work around IBM bug
+      WRITE(TIU6,7216) (RTUT(NI),NI=1,T_INFO%NTYP)
+      WRITE(TIU6,7203) (T_INFO%RWIGS(NI),NI=1,T_INFO%NTYP)
+      WRITE(TIU6,72031) (T_INFO%VCA(NI),NI=1,T_INFO%NTYP)
+
+      WRITE(TIU6,7208) &
+     &      INFO%NELECT,INFO%NUP_DOWN, &
+     &      KPOINTS%EMIN,KPOINTS%EMAX,KPOINTS%EFERMI,KPOINTS%ISMEAR,KPOINTS%SIGMA
+
+      WRITE(TIU6,7209) &
+     &      INFO%IALGO,INFO%LDIAG,INFO%LSUBROT, &
+     &      INFO%TURBO,INFO%IRESTART,INFO%NREBOOT,INFO%NMIN,INFO%EREF,&
+     &      MIX%IMIX,MIX%AMIX,MIX%BMIX,MIX%AMIX_MAG,MIX%BMIX_MAG,MIX%AMIN, &
+     &      MIX%WC,MIX%INIMIX,MIX%MIXPRE,MIX%MAXMIX, &
+     &      INFO%WEIMIN,INFO%EBREAK,INFO%DEPER,INFO%TIME, &
+     &      AOMEGA,AOMEGA/(AUTOA)**3, &
+     &      QF,QF/AUTOA,QF**2*RYTOEV,QF**2,SQRT(QF/AUTOA/AUTOA*4/PI)
+      WRITE(TIU6,*)
+      WRITE(TIU6,7224) IO%LWAVE,IO%LDOWNSAMPLE,IO%LCHARG,IO%LVTOT,IO%LVHAR,IO%LELF,IO%LORBIT
+
+      CALL WRITE_EFIELD(TIU6)
+      ENDIF
+
+ 7210 FORMAT( &
+     &       ' SYSTEM =  ',A40/ &
+     &       ' POSCAR =  ',A40/)
+
+ 7205 FORMAT(//' Dimension of arrays:'/ &
+     &       '   k-points           NKPTS = ',I6, &
+     &       '   k-points in BZ     NKDIM = ',I6, &
+     &       '   number of bands    NBANDS= ',I6/ &
+     &       '   number of dos      NEDOS = ',I6, &
+     &       '   number of ions     NIONS = ',I6/ &
+     &       '   non local maximal  LDIM  = ',I6, &
+     &       '   non local SUM 2l+1 LMDIM = ',I6/ &
+     &       '   total plane-waves  NPLWV = ',I6/ &
+     &       '   max r-space proj   IRMAX = ',I6, &
+     &       '   max aug-charges    IRDMAX= ',I6/ &
+     &       '   dimension x,y,z NGX = ',I5,' NGY =',I5,' NGZ =',I5/ &
+     &       '   dimension x,y,z NGXF= ',I5,' NGYF=',I5,' NGZF=',I5/ &
+     &       '   support grid    NGXF= ',I5,' NGYF=',I5,' NGZF=',I5/ &
+     &       '   ions per type =            ',10I4/)
+
+ 7206 FORMAT(' Startparameter for this run:'/ &
+     &       '   NWRITE = ',I6,  '    write-flag & timer' / &
+     &       '   PREC   = ',A6,  '    normal or accurate (medium, high low for compatibility)'/ &
+     &       '   ISTART = ',I6,  '    job   : 0-new  1-cont  2-samecut'/ &
+     &       '   ICHARG = ',I6,  '    charge: 1-file 2-atom 10-const'/ &
+     &       '   ISPIN  = ',I6,  '    spin polarized calculation?'/ &
+     &       '   LNONCOLLINEAR = ',L6, ' non collinear calculations'/ &
+     &       '   LSORBIT = ',L6, '    spin-orbit coupling'/ &
+     &       '   INIWAV = ',I6,  '    electr: 0-lowe 1-rand  2-diag'/ &
+     &       '   LASPH  = ',L6,  '    aspherical Exc in radial PAW'/ &
+     &       '   METAGGA= ',L6,  '    non-selfconsistent MetaGGA calc.'// &
+     &       ' Electronic Relaxation 1'/ &
+     &       '   ENCUT  = ', &
+     &              F6.1,' eV ',F6.2,' Ry  ',F6.2,' a.u. ', &
+     &              3F6.2,'*2*pi/ulx,y,z'/ &
+     &       '   ENINI  = ',F6.1,'     initial cutoff'/ &
+     &       '   ENAUG  = ',F6.1,' eV  augmentation charge cutoff'/ &
+     &       '   NELM   = ',I6,  ';   NELMIN=',I3,'; NELMDL=',I3, &
+     &         '     # of ELM steps '    / &
+     &       '   EDIFF  = ',E7.1,'   stopping-criterion for ELM'/ &
+     &       '   LREAL  = ',L6,  '    real-space projection'     / &
+     &       '   NLSPLINE    = ',L1,'    spline interpolate recip. space projectors'/ &
+     &       '   LCOMPAT= ',L6,  '    compatible to vasp.4.4'/&
+     &       '   GGA_COMPAT  = ',L1,'    GGA compatible to vasp.4.4-vasp.4.6'/&
+     &       '   LMAXPAW     = ',I4,' max onsite density'/&
+     &       '   LMAXMIX     = ',I4,' max onsite mixed and CHGCAR'/&
+     &       '   VOSKOWN= ',I6,  '    Vosko Wilk Nusair interpolation'/&
+     &      ('   ROPT   = ',4F10.5))
+ 7204 FORMAT( &
+     &       ' Ionic relaxation'/ &
+     &       '   EDIFFG = ',E7.1,'   stopping-criterion for IOM'/ &
+     &       '   NSW    = ',I6,  '    number of steps for IOM' / &
+     &       '   NBLOCK = ',I6,  ';   KBLOCK = ',I6, &
+     &         '    inner block; outer block '/ &
+     &       '   IBRION = ',I6, &
+     &         '    ionic relax: 0-MD 1-quasi-New 2-CG'/ &
+     &       '   NFREE  = ',I6,  &
+     &         '    steps in history (QN), initial steepest desc. (CG)'/ &
+     &       '   ISIF   = ',I6,  '    stress and relaxation' / &
+     &       '   IWAVPR = ',I6, &
+     &         '    prediction:  0-non 1-charg 2-wave 3-comb' / &
+     &       '   ISYM   = ',I6, &
+     &         '    0-nonsym 1-usesym 2-fastsym' / &
+     &       '   LCORR  = ',L6, &
+     &         '    Harris-Foulkes like correction to forces' /)
+
+ 7207 FORMAT( &
+     &       '   POTIM  =' ,F7.4,'    time-step for ionic-motion'/ &
+     &       '   TEIN   = ',F6.1,'    initial temperature'       / &
+     &       '   TEBEG  = ',F6.1,';   TEEND  =',F6.1, &
+     &               ' temperature during run'/ &
+     &       '   SMASS  = ',F6.2,'    Nose mass-parameter (am)'/ &
+     &       '   estimated Nose-frequenzy (Omega)   = ',E9.2, &
+     &           ' period in steps =',F6.2,' mass=',E12.3,'a.u.'/ &
+     &       '   SCALEE = ',F6.4,'    scale energy and forces'       / &
+     &       '   NPACO  = ',I6,  ';   APACO  = ',F4.1, &
+     &       '  distance and # of slots for P.C.'  / &
+     &       '   PSTRESS= ',F6.1,' pullay stress'/)
+
+!    &       '   damping for Cell-Motion     SIDAMP = ',F6.2/
+!    &       '   mass for Cell-Motion        SIMASS = ',F6.2/
+
+ 7215 FORMAT('  Mass of Ions in am'/ &
+     &       ('   POMASS = ',8F6.2))
+ 7216 FORMAT('  Ionic Valenz'/ &
+     &       ('   ZVAL   = ',8F6.2))
+ 7203 FORMAT('  Atomic Wigner-Seitz radii'/ &
+     &       ('   RWIGS  = ',8F6.2))
+72031 FORMAT('  virtual crystal weights '/ &
+     &       ('   VCA    = ',8F6.2))
+
+ 7208 FORMAT( &
+     &       '   NELECT = ',F12.4,  '    total number of electrons'/ &
+     &       '   NUPDOWN= ',F12.4,  '    fix difference up-down'// &
+     &       ' DOS related values:'/ &
+     &       '   EMIN   = ',F6.2,';   EMAX   =',F6.2, &
+     &       '  energy-range for DOS'/ &
+     &       '   EFERMI = ',F6.2,/ &
+     &       '   ISMEAR =',I6,';   SIGMA  = ',F6.2, &
+     &       '  broadening in eV -4-tet -1-fermi 0-gaus'/)
+
+ 7209 FORMAT( &
+     &       ' Electronic relaxation 2 (details)'/  &
+     &       '   IALGO  = ',I6,  '    algorithm'            / &
+     &       '   LDIAG  = ',L6,  '    sub-space diagonalisation (order eigenvalues)' / &
+     &       '   LSUBROT= ',L6,  '    optimize rotation matrix (better conditioning)' / &
+     &       '   TURBO    = ',I6,  '    0=normal 1=particle mesh'/ &
+     &       '   IRESTART = ',I6,  '    0=no restart 2=restart with 2 vectors'/ &
+     &       '   NREBOOT  = ',I6,  '    no. of reboots'/ &
+     &       '   NMIN     = ',I6,  '    reboot dimension'/ &
+     &       '   EREF     = ',F6.2,  '    reference energy to select bands'/ &
+     &       '   IMIX   = ',I6,  '    mixing-type and parameters'/ &
+     &       '     AMIX     = ',F6.2,';   BMIX     =',F6.2/ &
+     &       '     AMIX_MAG = ',F6.2,';   BMIX_MAG =',F6.2/ &
+     &       '     AMIN     = ',F6.2/ &
+     &       '     WC   = ',F6.0,';   INIMIX=',I4,';  MIXPRE=',I4,';  MAXMIX=',I4// &
+     &       ' Intra band minimization:'/ &
+     &       '   WEIMIN = ',F6.4,'     energy-eigenvalue tresh-hold'/ &
+     &       '   EBREAK = ',E9.2,'  absolut break condition' / &
+     &       '   DEPER  = ',F6.2,'     relativ break condition  ' // &
+     &       '   TIME   = ',F6.2,'     timestep for ELM'          // &
+     &       '  volume/ion in A,a.u.               = ',F10.2,3X,F10.2/ &
+     &       '  Fermi-wavevector in a.u.,A,eV,Ry     = ',4F10.6/ &
+     &       '  Thomas-Fermi vector in A             = ',2F10.6/)
+
+
+ 7224 FORMAT( &
+     &       ' Write flags'/  &
+     &       '   LWAVE        = ',L6,  '    write WAVECAR' / &
+     &       '   LDOWNSAMPLE  = ',L6,  '    k-point downsampling of WAVECAR' / &
+     &       '   LCHARG       = ',L6,  '    write CHGCAR' / &
+     &       '   LVTOT        = ',L6,  '    write LOCPOT, total local potential' / &
+     &       '   LVHAR        = ',L6,  '    write LOCPOT, Hartree potential only' / &
+     &       '   LELF         = ',L6,  '    write electronic localiz. function (ELF)'/&
+     &       '   LORBIT       = ',I6,  '    0 simple, 1 ext, 2 COOP (PROOUT), +10 PAW based schemes'//)
+
+       CALL WRITE_CL_SHIFT(IO%IU6)
+       IF (USELDApU()) CALL WRITE_LDApU(IO%IU6)
+
+       CALL WRITE_FOCK(IO%IU6)
+
+       CALL WRITE_BERRY_PARA(IO%IU6,LBERRY,IGPAR,NPPSTR)
+       CALL LR_WRITER(IO%IU6)
+       CALL WRITE_ORBITALMAG(IO%IU6)
+       CALL WRITE_RESPONSE(IO%IU6)
+       CALL PEAD_WRITER(IO%IU6)
+       CALL CHGFIT_WRITER(IO)
+! solvation__
+       CALL SOL_WRITER(IO)
+! solvation__
+
+#ifdef logflow
+       CLOSE(19)
+#endif
+       CALL XML_TAG("parameters")
+       CALL XML_WRITER( &
+          NPAR, &
+          INFO%SZNAM1,INFO%ISTART,INFO%IALGO,MIX%IMIX,MIX%MAXMIX,MIX%MREMOVE, &
+          MIX%AMIX,MIX%BMIX,MIX%AMIX_MAG,MIX%BMIX_MAG,MIX%AMIN, &
+          MIX%WC,MIX%INIMIX,MIX%MIXPRE,MIX%MIXFIRST,IO%LFOUND,INFO%LDIAG,INFO%LSUBROT,INFO%LREAL,IO%LREALD,IO%LPDENS, &
+          DYN%IBRION,INFO%ICHARG,INFO%INIWAV,INFO%NELM,INFO%NELMIN,INFO%NELMDL,INFO%EDIFF,DYN%EDIFFG, &
+          DYN%NSW,DYN%ISIF,PRED%IWAVPR,SYMM%ISYM,DYN%NBLOCK,DYN%KBLOCK,INFO%ENMAX,DYN%POTIM,DYN%TEBEG, &
+          DYN%TEEND,DYN%NFREE, &
+          PACO%NPACO,PACO%APACO,T_INFO%NTYP,NTYPD,DYN%SMASS,SCALEE,T_INFO%POMASS,T_INFO%DARWIN_V,T_INFO%DARWIN_R,  &
+          T_INFO%RWIGS,INFO%NELECT,INFO%NUP_DOWN,INFO%TIME,KPOINTS%EMIN,KPOINTS%EMAX,KPOINTS%EFERMI, & 
+          KPOINTS%ISMEAR,KPOINTS%SPACING,KPOINTS%LGAMMA,DYN%PSTRESS,INFO%NDAV, &
+          KPOINTS%SIGMA,KPOINTS%LTET,INFO%WEIMIN,INFO%EBREAK,INFO%DEPER,IO%NWRITE,INFO%LCORR, &
+          IO%IDIOT,T_INFO%NIONS,T_INFO%NTYPP,IO%LMUSIC,IO%LOPTICS,STM, &
+          INFO%ISPIN,T_INFO%ATOMOM,NIOND,IO%LWAVE,IO%LDOWNSAMPLE,IO%LCHARG,IO%LVTOT,IO%LVHAR,INFO%SZPREC, &
+          INFO%ENAUG,IO%LORBIT,IO%LELF,T_INFO%ROPT,INFO%ENINI, &
+          NGX,NGY,NGZ,NGXC,NGYC,NGZC,NBANDS,NEDOS,NBLK,LATT_CUR, &
+          LPLANE_WISE,LCOMPAT,LMAX_CALC,SET_LMAX_MIX_TO,WDES%NSIM,LPARD,LPAW,LADDGRID, &
+          WDES%LNONCOLLINEAR,WDES%LSORBIT,WDES%SAXIS,INFO%LMETAGGA, &
+          WDES%LSPIRAL,WDES%LZEROZ,WDES%QSPIRAL, &
+          INFO%LASPH,WDES%LORBITALREAL, &
+          INFO%TURBO,INFO%IRESTART,INFO%NREBOOT,INFO%NMIN,INFO%EREF, &
+          INFO%NLSPLINE,ISPECIAL,MDALGO)
+
+       CALL  XML_WRITE_GGA_COMPAT_MODE
+       CALL  XML_WRITE_BERRY(LBERRY, IGPAR, NPPSTR)
+       CALL  XML_WRITE_CL_SHIFT
+       CALL  XML_WRITE_LDAU
+       CALL  XML_WRITE_CONSTRAINED_M(T_INFO%NIONS)
+       CALL  XML_WRITE_XC_FOCK
+       CALL  XML_WRITE_LR
+       CALL  XML_WRITE_ORBITALMAG
+       CALL  XML_WRITE_RESPONSE
+       CALL  XML_WRITE_CLASSICFIELDS
+! solvation__
+       CALL XML_WRITE_SOL
+! solvation__
+
+       CALL XML_CLOSE_TAG("parameters")
+!=======================================================================
+!  set some important flags and write out text information
+!  DYN%IBRION        selects dynamic
+!  INFO%LCORR =.TRUE. calculate Harris corrections to forces
+!=======================================================================
+       IF (MIX%AMIN>=0.1_q .AND. MAXVAL(LATT_CUR%ANORM(:))>50) THEN
+          CALL VTUTOR('W','long lattice',RTUT,1, &
+     &         ITUT,1,CDUM,1,LDUM,1,IO%IU6,IO%IDIOT)
+          CALL VTUTOR('W','long lattice',RTUT,1, &
+     &         ITUT,1,CDUM,1,LDUM,1,IO%IU0,IO%IDIOT)
+       ENDIF
+!---- relaxation related information
+      IF (DYN%IBRION==10) THEN
+         INFO%NELMDL=ABS(INFO%NELM)
+         INFO%LCORR=.TRUE.
+         IF (DYN%POTIM <= 0.0001_q ) DYN%POTIM=1E-20_q
+      ENDIF
+
+      IF (IO%IU6>=0) THEN
+
+      WRITE(TIU6,130)
+
+      IF (DYN%IBRION == -1) THEN
+        WRITE(TIU6,*)'Static calculation'
+      ELSE IF (DYN%IBRION==0) THEN
+        WRITE(TIU6,*)'molecular dynamics for ions'
+        IF (DYN%SMASS>0) THEN
+          WRITE(TIU6,*)'  using nose mass (canonical ensemble)'
+        ELSE IF (DYN%SMASS==-3) THEN
+          WRITE(TIU6,*)'  using a microcanonical ensemble'
+        ELSE IF (DYN%SMASS==-1) THEN
+          WRITE(TIU6,*)'  scaling velocities every NBLOCK steps'
+        ELSE IF (DYN%SMASS==-2) THEN
+          WRITE(TIU6,*)'  keeping initial velocities unchanged'
+        ENDIF
+      ELSE IF (DYN%IBRION==1) THEN
+           WRITE(TIU6,*)'quasi-Newton-method for relaxation of ions'
+      ELSE IF (DYN%IBRION==2) THEN
+           WRITE(TIU6,*)'conjugate gradient relaxation of ions'
+      ELSE IF (DYN%IBRION==3) THEN
+              WRITE(TIU6,*)'quickmin algorithm: (dynamic with friction)'
+      ELSE IF (DYN%IBRION==5) THEN
+              WRITE(TIU6,*)'finite differences'
+      ELSE IF (DYN%IBRION==6) THEN
+              WRITE(TIU6,*)'finite differences with symmetry'
+      ELSE IF (DYN%IBRION==7) THEN
+              WRITE(TIU6,*)'linear response'
+      ELSE IF (DYN%IBRION==8) THEN
+              WRITE(TIU6,*)'linear response using symmetry'
+      ELSE IF (DYN%IBRION==9) THEN
+              WRITE(TIU6,*)'electromagnetic linear response'
+      ELSE IF (DYN%IBRION==19) THEN
+                  WRITE(TIU6,*)'adiabatic magnon calculation'
+      ELSE IF (DYN%IBRION==10) THEN
+           WRITE(TIU6,*)'relaxation of ions and charge simultaneously'
+      ELSE IF (DYN%IBRION==11) THEN
+           WRITE(TIU6,*)'interactive mode, write forces and read positions'
+      !tb beg 
+      ELSE IF (DYN%IBRION==44) THEN
+          WRITE(TIU6,*)'improved dimer method for transition state relaxation'
+      !tb end
+      ENDIF
+
+      IF (DYN%IBRION/=-1 .AND. T_INFO%LSDYN) THEN
+        WRITE(TIU6,*)'  using selective dynamics as specified on POSCAR'
+        IF (.NOT.T_INFO%LDIRCO) THEN
+          WRITE(TIU6,*)'  WARNING: If single coordinates had been '// &
+     &                'selected the selection of coordinates'
+          WRITE(TIU6,*)'           is made according to the '// &
+     &                'corresponding   d i r e c t   coordinates!'
+          WRITE(TIU6,*)'           Don''t support selection of '// &
+     &                'single cartesian coordinates -- sorry ... !'
+        ENDIF
+      ENDIF
+      ENDIF
+
+      IF (INFO%ICHARG>=10) THEN
+        INFO%LCHCON=.TRUE.
+        IF(IO%IU6>=0)  WRITE(TIU6,*)'charge density and potential remain constant during run'
+        MIX%IMIX=0
+      ELSE
+        INFO%LCHCON=.FALSE.
+        IF(IO%IU6>=0)  WRITE(TIU6,*)'charge density and potential will be updated during run'
+      ENDIF
+
+      IF ((WDES%ISPIN==2).AND.INFO%LCHCON.AND.(DYN%IBRION/=-1)) THEN
+         IF (IO%IU0>=0)  &
+         WRITE(TIU0,*) &
+          'Spin polarized Harris functional dynamics is a good joke ...'
+         IF (IO%IU6>=0) &
+         WRITE(TIU6,*) &
+          'Spin polarized Harris functional dynamics is a good joke ...'
+         STOP
+      ENDIF
+      IF (IO%IU6>=0) THEN
+        IF (WDES%ISPIN==1 .AND. .NOT. WDES%LNONCOLLINEAR ) THEN
+          WRITE(TIU6,*)'non-spin polarized calculation'
+        ELSE IF ( WDES%LNONCOLLINEAR ) THEN
+          WRITE(TIU6,*)'non collinear spin polarized calculation'
+        ELSE
+          WRITE(TIU6,*)'spin polarized calculation'
+        ENDIF
+      ENDIF
+
+! paritial dos
+      JOBPAR=1
+!     IF (DYN%IBRION>=0) JOBPAR=0
+      DO NT=1,T_INFO%NTYP
+         IF (T_INFO%RWIGS(NT)<=0._q) JOBPAR=0
+      ENDDO
+
+!  INFO%LCDIAG  call EDDIAG after  eigenvalue optimization
+!  INFO%LPDIAG  call EDDIAG before eigenvalue optimization
+!  INFO%LDIAG   perform sub space rotation (when calling EDDIAG)
+!  INFO%LORTHO  orthogonalization of wavefcuntions within optimization
+!                     no Gramm-Schmidt required
+!  INFO%LRMM    use RMM-DIIS minimization
+!  INFO%LDAVID  use blocked Davidson
+!  INFO%LCHCON  charge constant during run
+!  INFO%LCHCOS  charge constant during band minimisation
+!  INFO%LONESW  all band simultaneous
+
+      INFO%LCHCOS=.TRUE.
+      INFO%LONESW=.FALSE.
+      INFO%LONESW_AUTO=.FALSE.
+      INFO%LDAVID=.FALSE.
+      INFO%LRMM  =.FALSE.
+      INFO%LORTHO=.TRUE.
+      INFO%LCDIAG=.FALSE.
+      INFO%LPDIAG=.TRUE.
+      INFO%LPRECONDH=.FALSE.
+      INFO%IHARMONIC=0
+      INFO%LEXACT_DIAG=.FALSE.
+
+!  all bands conjugate gradient (CG) or damped orbital optimization
+!  with fall back to DIIS when convergence is save
+      IF (INFO%IALGO>=100) THEN
+        IF (INFO%LDIAG) THEN
+           IF(IO%IU6>=0)  WRITE(TIU6,*) 'Conjugate gradient for all bands (Freysoldt, et al. PRB 79, 241103 (2009))'
+        ELSE
+           IF(IO%IU6>=0)  WRITE(TIU6,*) 'Conjugate gradient for all bands (Kresse, et al. variant)'
+        ENDIF
+        IF(IO%IU6>=0)  WRITE(TIU6,*) 'Fall back to RMM-DIIS when convergence is save'
+        INFO%IALGO=MOD(INFO%IALGO,10)
+        INFO%LCHCOS=INFO%LCHCON
+        INFO%LONESW=.TRUE.
+        INFO%LONESW_AUTO=.TRUE.
+        INFO%LRMM  =.TRUE.    ! this is tricky, set some usefull defaults for calling
+        INFO%LORTHO=.FALSE.   !  routines in electron.F  (fall back is DIIS)
+!  exact diagonalization
+      ELSE IF (INFO%IALGO>=90) THEN
+        IF(IO%IU6>=0)  WRITE(TIU6,*) 'Exact diagonalization'
+        INFO%IALGO=MOD(INFO%IALGO,10)
+        INFO%LEXACT_DIAG=.TRUE.
+        INFO%LORTHO=.TRUE.
+        INFO%LCDIAG=.FALSE.
+        INFO%LPDIAG=.FALSE.
+!  routines implemented in david_inner (Harmonic Jacobi Davidson, and Davidson)
+      ELSE IF (INFO%IALGO>=80 .OR. (INFO%IALGO>=70 .AND. INFO%EREF==0)) THEN
+        IF(IO%IU6>=0)  WRITE(TIU6,*) 'Davidson algorithm suitable for deep iteration (NRMM>8)'
+        INFO%IALGO=MOD(INFO%IALGO,10)
+        INFO%IHARMONIC=2
+        INFO%LORTHO=.FALSE.
+        INFO%LCDIAG=.TRUE.
+        INFO%LPDIAG=.FALSE.
+      ELSE IF (INFO%IALGO>=70) THEN
+        IF(IO%IU6>=0)  WRITE(TIU6,*) 'Jacobi Davidson Harmonic (JDH) for inner eigenvalue problems'
+        INFO%IALGO=INFO%IALGO-70
+        INFO%IHARMONIC=1
+        INFO%LORTHO=.FALSE.
+        INFO%LCDIAG=.TRUE.
+        INFO%LPDIAG=.FALSE.
+!  RMM-DIIS + Davidson
+      ELSE IF (INFO%IALGO>=60) THEN
+        IF(IO%IU6>=0)  WRITE(TIU6,*) 'RMM-DIIS sequential band-by-band and'
+        IF(IO%IU6>=0)  WRITE(TIU6,*) ' variant of blocked Davidson during initial phase' 
+        INFO%IALGO=INFO%IALGO-60
+        INFO%LRMM   =.TRUE.
+        INFO%LDAVID =.TRUE.
+        INFO%LORTHO =.FALSE.
+        INFO%LDIAG  =.TRUE.        ! subspace rotation is always selected
+!  all bands conjugate gradient (CG) or damped orbital optimization
+      ELSE IF (INFO%IALGO>=50) THEN
+        IF (INFO%LDIAG) THEN
+           IF(IO%IU6>=0)  WRITE(TIU6,*) 'Conjugate gradient for all bands (Freysoldt, et al. PRB 79, 241103 (2009))'
+        ELSE
+           IF(IO%IU6>=0)  WRITE(TIU6,*) 'Conjugate gradient for all bands (Kresse, et al. variant)'
+        ENDIF
+        INFO%IALGO=MOD(INFO%IALGO,10)
+        INFO%LCHCOS=INFO%LCHCON
+        INFO%LONESW=.TRUE.
+!  RMM-DIIS
+      ELSE IF (INFO%IALGO>=40) THEN
+        IF(IO%IU6>=0)  WRITE(TIU6,*) 'RMM-DIIS sequential band-by-band'
+        INFO%IALGO=MOD(INFO%IALGO,10)
+        INFO%LRMM  =.TRUE.
+        INFO%LORTHO=.FALSE.
+!  blocked Davidson (Liu)
+      ELSE IF (INFO%IALGO>=30) THEN
+        IF(IO%IU6>=0)  WRITE(TIU6,*) 'Variant of blocked Davidson'
+        INFO%IALGO=INFO%IALGO-30
+        IF (INFO%LDIAG) THEN    ! if LDIAG is set
+           IF(IO%IU6>=0)  WRITE(TIU6,*) 'Davidson routine will perform the subspace rotation'
+           INFO%LCDIAG=.FALSE.  ! routine does the diagonalisation itself
+           INFO%LPDIAG=.FALSE.  ! hence LPDIAG and LCDIAG are set to .FALSE.
+        ENDIF
+        INFO%LDAVID=.TRUE.
+      ELSE IF (INFO%IALGO>=20) THEN
+        IF(IO%IU6>=0)  WRITE(TIU6,*) 'Conjugate gradient sequential band-by-band (Teter, Alan, Payne)'
+        INFO%IALGO  =INFO%IALGO-20
+        INFO%LORTHO=.FALSE.
+         CALL VTUTOR('S','IALGO8',RTUT,1,ITUT,1,CDUM,1,LDUM,1,IO%IU0,IO%IDIOT)
+      ELSE IF (INFO%IALGO>=10) THEN
+        IF(IO%IU6>=0)  WRITE(TIU6,*) 'Compatibility mode'
+        IF(IO%IU6>=0)  WRITE(TIU6,*) 'Conjugate gradient sequential band-by-band (Teter, Alan, Payne)'
+        INFO%IALGO=INFO%IALGO-10
+        INFO%LCDIAG=.TRUE.
+        INFO%LPDIAG=.FALSE.
+         CALL VTUTOR('S','IALGO8',RTUT,1,ITUT,1,CDUM,1,LDUM,1,IO%IU0,IO%IDIOT)
+      ELSE IF (INFO%IALGO>=5 .OR. INFO%IALGO==0) THEN
+        IF(IO%IU6>=0)  WRITE(TIU6,*) 'Conjugate gradient sequential band-by-band (Teter, Alan, Payne)'
+         CALL VTUTOR('S','IALGO8',RTUT,1,ITUT,1,CDUM,1,LDUM,1,IO%IU0,IO%IDIOT)
+      ELSE IF (INFO%IALGO<0) THEN
+        IF(IO%IU6>=0)  WRITE(TIU6,*) 'Performance tests'
+      ELSE IF (INFO%IALGO <1) THEN
+        IF (IO%IU0>=0) &
+        WRITE(TIU0,*) 'Algorithms no longer implemented'
+        STOP
+      ELSE IF (INFO%IALGO==2) THEN
+        IF(IO%IU6>=0)  WRITE(TIU6,*) 'None: do nothing, only one-electron occupancies are recalculated'
+        INFO%LDIAG =.FALSE.
+      ELSE IF (INFO%IALGO==3) THEN
+        IF(IO%IU6>=0)  WRITE(TIU6,*) 'Eigenval: update one-electron energies, occupancies fixed'
+        INFO%LDIAG =.FALSE.
+      ELSE IF (INFO%IALGO==4) THEN
+        IF(IO%IU6>=0)  WRITE(TIU6,*) 'Subrot: only subspace diagonalization (rotation)'
+      ENDIF
+
+      SZ=' '
+      IF (INFO%LCHCOS) THEN
+         SZ='   charged. constant during bandupdate'
+      ELSE
+         INFO%LCORR=.FALSE.
+!        IMIX used to be set to 0, removed
+!         MIX%IMIX=0
+      ENDIF
+
+      IF (IO%IU6>=0) THEN
+
+      IF (.NOT. INFO%LRMM .AND. .NOT. INFO%LDAVID) THEN
+        IF (INFO%IALGO==5) THEN
+          WRITE(TIU6,*)'steepest descent',SZ
+        ELSEIF (INFO%IALGO==6) THEN
+          WRITE(TIU6,*)'conjugated gradient',SZ
+        ELSEIF (INFO%IALGO==7) THEN
+          WRITE(TIU6,*)'preconditioned steepest descent',SZ
+        ELSEIF (INFO%IALGO==8) THEN
+          WRITE(TIU6,*)'preconditioned conjugated gradient',SZ
+        ELSEIF (INFO%IALGO==0) THEN
+          WRITE(TIU6,*)'preconditioned conjugated gradient (Jacobi prec)',SZ
+        ENDIF
+        IF (.NOT.INFO%LONESW) THEN
+          WRITE(TIU6,*)'   band-by band algorithm'
+        ENDIF
+      ENDIF
+
+      IF (INFO%LDIAG) THEN
+        WRITE(TIU6,*)'perform sub-space diagonalisation'
+      ELSE
+        WRITE(TIU6,*)'perform Loewdin sub-space diagonalisation'
+        WRITE(TIU6,*)'   ordering is kept fixed'
+      ENDIF
+
+      IF (INFO%LPDIAG) THEN
+        WRITE(TIU6,*)'   before iterative eigenvector-optimisation'
+      ELSE
+        WRITE(TIU6,*)'   after iterative eigenvector-optimisation'
+      ENDIF
+
+      IF (MIX%IMIX==1 .OR. MIX%IMIX==2 .OR. MIX%IMIX==3) THEN
+        WRITE(TIU6,*)'Kerker-like  mixing scheme'
+      ELSE IF (MIX%IMIX==4) THEN
+       WRITE(TIU6,'(A,F10.1)')' modified Broyden-mixing scheme, WC = ',MIX%WC
+       IF (MIX%INIMIX==1) THEN
+         WRITE(TIU6,'(A,F8.4,A,F12.4)') &
+     &     ' initial mixing is a Kerker type mixing with AMIX =',MIX%AMIX, &
+     &     ' and BMIX =',MIX%BMIX
+       ELSE IF (MIX%INIMIX==2) THEN
+         WRITE(TIU6,*)'initial mixing equals unity matrix (no mixing!)'
+       ELSE
+         WRITE(TIU6,'(A,F8.4)') &
+     &     ' initial mixing is a simple linear mixing with ALPHA =',MIX%AMIX
+       ENDIF
+       IF (MIX%MIXPRE==1) THEN
+         WRITE(TIU6,*)'Hartree-type preconditioning will be used'
+       ELSE IF (MIX%MIXPRE==2) THEN
+         WRITE(TIU6,'(A,A,F12.4)') &
+     &     ' (inverse) Kerker-type preconditioning will be used', &
+     &     ' corresponding to BMIX =',MIX%BMIX
+       ELSE
+         WRITE(TIU6,*)'no preconditioning will be used'
+       ENDIF
+      ELSE
+        WRITE(TIU6,*)'no mixing'
+      ENDIF
+      IF (WDES%NB_TOT*2==NINT(INFO%NELECT)) THEN
+        WRITE(TIU6,*)'2*number of bands equal to number of electrons'
+        IF (MIX%IMIX/=0 .AND..NOT.INFO%LCHCOS) THEN
+          WRITE(TIU6,*) &
+     &      'WARNING: mixing without additional bands will not converge'
+        ELSE IF (MIX%IMIX/=0) THEN
+          WRITE(TIU6,*) 'WARNING: mixing has no effect'
+        ENDIF
+
+      ELSE
+        WRITE(TIU6,*)'using additional bands ',INT(WDES%NB_TOT-INFO%NELECT/2)
+        IF (KPOINTS%SIGMA<=0) THEN
+          WRITE(TIU6,*) &
+     &  'WARNING: no broadening specified (might cause bad convergence)'
+        ENDIF
+      ENDIF
+
+      IF (INFO%LREAL) THEN
+        WRITE(TIU6,*)'real space projection scheme for non local part'
+      ELSE
+        WRITE(TIU6,*)'reciprocal scheme for non local part'
+      ENDIF
+
+      IF (INFO%LCORE) THEN
+        WRITE(TIU6,*)'use partial core corrections'
+      ENDIF
+
+      IF (INFO%LCORR) THEN
+        WRITE(TIU6,*)'calculate Harris-corrections to forces ', &
+     &              '  (improved forces if not selfconsistent)'
+      ELSE
+        WRITE(TIU6,*)'no Harris-corrections to forces '
+      ENDIF
+
+      IF (ISGGA()) THEN
+        WRITE(TIU6,*)'use gradient corrections '
+        IF (INFO%LCHCON) THEN
+           IF (IO%IU0>=0) &
+           WRITE(TIU0,*)'WARNING: stress and forces are not correct'
+           WRITE(TIU6,*)'WARNING: stress and forces are not correct'
+           WRITE(TIU6,*)' (second derivative of E(xc) not defined)'
+        ENDIF
+      ENDIF
+
+      IF (INFO%LOVERL) THEN
+         WRITE(TIU6,*)'use of overlap-Matrix (Vanderbilt PP)'
+      ENDIF
+      IF (KPOINTS%ISMEAR==-1) THEN
+        WRITE(TIU6,7213) KPOINTS%SIGMA
+ 7213 FORMAT(' Fermi-smearing in eV        SIGMA  = ',F6.2)
+
+      ELSE IF (KPOINTS%ISMEAR==-2) THEN
+        WRITE(TIU6,7214)
+ 7214 FORMAT(' partial occupancies read from INCAR or WAVECAR (fixed during run)')
+      ELSE IF (KPOINTS%ISMEAR==-4) THEN
+        WRITE(TIU6,7222)
+ 7222 FORMAT(' Fermi weights with tetrahedron method witout', &
+     &       ' Bloechl corrections')
+      ELSE IF (KPOINTS%ISMEAR==-5) THEN
+        WRITE(TIU6,7223)
+ 7223 FORMAT(' Fermi weights with tetrahedron method with', &
+     &       ' Bloechl corrections')
+
+      ELSE IF (KPOINTS%ISMEAR>0) THEN
+        WRITE(TIU6,7217) KPOINTS%ISMEAR,KPOINTS%SIGMA
+ 7217 FORMAT(' Methfessel and Paxton  Order N=',I2, &
+     &       ' SIGMA  = ',F6.2)
+      ELSE
+        WRITE(TIU6,7218) KPOINTS%SIGMA
+ 7218 FORMAT(' Gauss-broadening in eV      SIGMA  = ',F6.2)
+      ENDIF
+
+      WRITE(TIU6,130)
+!=======================================================================
+!  write out the lattice parameters
+!=======================================================================
+      WRITE(TIU6,7220) INFO%ENMAX,LATT_CUR%OMEGA, &
+     &    ((LATT_CUR%A(I,J),I=1,3),(LATT_CUR%B(I,J),I=1,3),J=1,3), &
+     &    (LATT_CUR%ANORM(I),I=1,3),(LATT_CUR%BNORM(I),I=1,3)
+
+      WRITE(TIU6,*)
+
+      IF (INFO%ISTART==1 .OR.INFO%ISTART==2) THEN
+
+      WRITE(TIU6,*)'old parameters found on file WAVECAR:'
+      WRITE(TIU6,7220) ENMAXI,LATT_INI%OMEGA, &
+     &    ((LATT_INI%A(I,J),I=1,3),(LATT_INI%B(I,J),I=1,3),J=1,3)
+
+
+      WRITE(TIU6,*)
+ 7220 FORMAT('  energy-cutoff  :  ',F10.2/ &
+     &       '  volume of cell :  ',F10.2/ &
+     &       '      direct lattice vectors',17X,'reciprocal lattice vectors'/ &
+     &       3(2(3X,3F13.9)/) / &
+     &       '  length of vectors'/ &
+     &        (2(3X,3F13.9)/) /)
+
+      ENDIF
+!=======================================================================
+!  write out k-points,weights,size & positions
+!=======================================================================
+
+ 7104 FORMAT(' k-points in units of 2pi/SCALE and weight: ',A40)
+ 7105 FORMAT(' k-points in reciprocal lattice and weights: ',A40)
+ 7016 FORMAT(' position of ions in fractional coordinates (direct lattice) ')
+ 7017 FORMAT(' position of ions in cartesian coordinates  (Angst):')
+ 7009 FORMAT(1X,3F12.8,F12.3)
+ 7007 FORMAT(1X,3F12.8)
+
+      WRITE(TIU6,7104) KPOINTS%SZNAMK
+
+      DO NKP=1,KPOINTS%NKPTS
+        VTMP(1)=WDES%VKPT(1,NKP)
+        VTMP(2)=WDES%VKPT(2,NKP)
+        VTMP(3)=WDES%VKPT(3,NKP)
+        CALL DIRKAR(1,VTMP,LATT_CUR%B)
+        WRITE(TIU6,7009) VTMP(1)*LATT_CUR%SCALE,VTMP(2)*LATT_CUR%SCALE, &
+                  VTMP(3)*LATT_CUR%SCALE,KPOINTS%WTKPT(NKP)
+      ENDDO
+
+      WRITE(TIU6,*)
+      WRITE(TIU6,7105) KPOINTS%SZNAMK
+      DO NKP=1,KPOINTS%NKPTS
+        WRITE(TIU6,7009) WDES%VKPT(1,NKP),WDES%VKPT(2,NKP),WDES%VKPT(3,NKP),KPOINTS%WTKPT(NKP)
+      ENDDO
+      WRITE(TIU6,*)
+
+      WRITE(TIU6,7016)
+      WRITE(TIU6,7007) ((DYN%POSION(I,J),I=1,3),J=1,T_INFO%NIONS)
+      WRITE(TIU6,*)
+      WRITE(TIU6,7017)
+
+      DO J=1,T_INFO%NIONS
+        VTMP(1)=DYN%POSION(1,J)
+        VTMP(2)=DYN%POSION(2,J)
+        VTMP(3)=DYN%POSION(3,J)
+        CALL  DIRKAR(1,VTMP,LATT_CUR%A)
+        WRITE(TIU6,7007) (VTMP(I),I=1,3)
+      ENDDO
+      WRITE(TIU6,*)
+      CALL  WRITE_EULER(IO%IU6, WDES%LNONCOLLINEAR, WDES%SAXIS)
+
+      WRITE(TIU6,130)
+      ENDIF
+
+      io_begin
+      IF (KIMAGES==0) THEN
+!=======================================================================
+!  write out initial header for PCDAT, XDATCAR
+!=======================================================================
+      CALL PCDAT_HEAD(60,T_INFO, LATT_CUR, DYN, PACO, INFO%SZNAM1)
+      IF (.NOT. (DYN%ISIF==3 .OR. DYN%ISIF>=7 )) THEN
+        ! for DYN%ISIF=3 and >=7, the header is written in each step
+        CALL XDAT_HEAD(61, T_INFO, LATT_CUR, DYN, INFO%SZNAM1)
+      ENDIF
+!=======================================================================
+!  write out initial header for DOS
+!=======================================================================
+      JOBPAR_=JOBPAR
+      IF (IO%LORBIT>=10 ) JOBPAR_=1
+
+      WRITE(16,'(4I4)') T_INFO%NIONP,T_INFO%NIONS,JOBPAR_,WDES%NCDIJ
+      WRITE(16,'(5E15.7)')AOMEGA,((LATT_CUR%ANORM(I)*1E-10),I=1,3),DYN%POTIM*1E-15
+      WRITE(16,*) DYN%TEMP
+      WRITE(16,*) ' CAR '
+      WRITE(16,*) INFO%SZNAM1
+
+!=======================================================================
+!  write out initial header for EIGENVALUES
+!=======================================================================
+      WRITE(22,'(4I5)') T_INFO%NIONS,T_INFO%NIONS,DYN%NBLOCK*DYN%KBLOCK,WDES%ISPIN
+      WRITE(22,'(5E15.7)') &
+     &         AOMEGA,((LATT_CUR%ANORM(I)*1E-10_q),I=1,3),DYN%POTIM*1E-15_q
+      WRITE(22,*) DYN%TEMP
+      WRITE(22,*) ' CAR '
+      WRITE(22,*) INFO%SZNAM1
+      WRITE(22,'(3I7)') NINT(INFO%NELECT),KPOINTS%NKPTS,WDES%NB_TOT
+      ENDIF
+      io_end
+
+      IF (IO%IU0>=0) &
+      WRITE(TIU0,*)'POSCAR, INCAR and KPOINTS ok, starting setup'
+!=======================================================================
+! initialize the required grid structures
+!=======================================================================
+      CALL INILGRD(NGX,NGY,NGZ,GRID)
+      CALL INILGRD(NGX,NGY,NGZ,GRID_SOFT)
+      CALL INILGRD(NGXC,NGYC,NGZC,GRIDC)
+      CALL INILGRD(GRIDUS%NGPTAR(1),GRIDUS%NGPTAR(2),GRIDUS%NGPTAR(3),GRIDUS)
+#ifdef MPI
+! only wavefunction grid uses local communication
+      GRID%COMM     =>COMM_INB
+! all other grids use world wide communication at the moment set their
+! communication boards to the world wide communicator
+
+!PK Charge density grids are replicated per set of distributed k-points
+      GRID_SOFT%COMM=>COMM_KIN
+      GRIDC%COMM    =>COMM_KIN
+      GRIDUS%COMM   =>COMM_KIN
+      GRIDB%COMM    =>COMM_KIN
+
+      GRIDC%COMM_KIN    =>COMM_KIN
+      GRIDC%COMM_KINTER =>COMM_KINTER
+#endif
+#ifdef usgrid
+      CALL GEN_RC_GRID(GRIDUS)
+      CALL GEN_RC_SUB_GRID(GRIDC,GRIDUS, C_TO_US, .TRUE.,.TRUE.)
+#else
+      CALL GEN_RC_GRID(GRIDC)
+#endif
+      CALL GEN_RC_SUB_GRID(GRID_SOFT, GRIDC, SOFT_TO_C, .TRUE.,.TRUE.)
+      CALL GEN_RC_GRID(GRIDUS)
+!=======================================================================
+!  allocate work arrays
+!=======================================================================
+!
+! GEN_LAYOUT determines the data layout (distribution) of the columns on parallel
+! computers and allocates all required arrays of the WDES descriptor
+      IF (INFO%ISTART==1) THEN
+         CALL GEN_LAYOUT(GRID,WDES, LATT_CUR%B,LATT_CUR%B,IO%IU6,.TRUE.)
+         CALL GEN_INDEX(GRID,WDES, LATT_CUR%B,LATT_CUR%B,IO%IU6,IO%IU0,.TRUE.)
+! all other cases use LATT_INI for setup of GENSP
+      ELSE
+         DWRITE0 'call to genlay'
+         CALL GEN_LAYOUT(GRID,WDES, LATT_CUR%B,LATT_INI%B,IO%IU6,.TRUE.)
+         DWRITE0 'call to genind'
+         CALL GEN_INDEX(GRID,WDES, LATT_CUR%B,LATT_INI%B,IO%IU6,IO%IU0,.TRUE.)
+      ENDIF
+#ifdef CUDA_GPU
+      CALL GPU_INIT(WDES)
+#endif
+      CALL SET_NBLK_NSTRIP( WDES)
+!
+! non local projection operators
+!
+      CALL NONL_ALLOC(NONL_S,T_INFO,P,WDES,INFO%LREAL)
+      CALL NONLR_SETUP(NONLR_S,T_INFO,P,INFO%LREAL,WDES%LSPIRAL)
+!  optimize grid for real space representation and calculate IRMAX, IRALLOC
+      NONLR_S%IRMAX=0 ; NONLR_S%IRALLOC=0
+      CALL REAL_OPTLAY(GRID,LATT_CUR,NONLR_S,LPLANE_WISE,LREALLOCATE, IO%IU6, IO%IU0)
+! allign GRID_SOFT with GRID in real space
+      CALL SET_RL_GRID(GRID_SOFT,GRID)
+! allocate real space projectors
+      CALL NONLR_ALLOC(NONLR_S)
+!  init FFT
+      CALL FFTINI(WDES%NINDPW(1,1),WDES%NGVECTOR(1),KPOINTS%NKPTS,WDES%NGDIM,GRID) 
+#ifdef MPI
+      CALL MAPSET(GRID)   ! generate the communication maps (patterns) for FFT
+      IF (IO%IU6 >=0) THEN
+         IF (GRID%RL%NFAST==1) THEN
+            WRITE(TIU6,"(/' serial   3D FFT for wavefunctions')")
+         ELSE IF (GRID%IN_RL%LOCAL  ) THEN
+            WRITE(TIU6,"(/' parallel 3D FFT for wavefunctions:'/'    minimum data exchange during FFTs selected (reduces bandwidth)')")
+         ENDIF
+      ENDIF
+      DWRITE0  'mapset aug done'
+      CALL MAPSET(GRID_SOFT)
+      DWRITE0  'mapset soft done'
+      CALL MAPSET(GRIDC)
+      IF (GRIDC%IN_RL%LOCAL .AND. IO%IU6 >=0) THEN
+         WRITE(TIU6,"(' parallel 3D FFT for charge:'/'    minimum data exchange during FFTs selected (reduces bandwidth)'/)")
+      ENDIF
+      DWRITE0  'mapset wave done'
+#ifdef usgrid
+      CALL MAPSET(GRIDUS)
+#endif
+#endif
+
+! allocate all other arrays
+!
+      ISP     =WDES%ISPIN
+      NCDIJ   =WDES%NCDIJ
+      NTYP    =T_INFO%NTYP
+      NIOND   =T_INFO%NIOND
+      NIOND_LOC=WDES%NIONS
+      LMDIM   =P(1)%LMDIM
+
+#if defined(CUDA_GPU) && defined(USE_PINNED_MEMORY)
+      CALL nvpinnedmalloc(SV_PTR,DIMREAL(GRID%MPLWV)*NCDIJ*int(c_sizeof(fake),c_size_t)) 
+      CALL c_f_pointer(SV_PTR,SV,(/DIMREAL(GRID%MPLWV),NCDIJ/))
+! charges, potentials and so on
+      CALL nvpinnedmalloc(CHTOT_PTR, GRIDC%MPLWV * NCDIJ*int(c_sizeof(fakec),c_size_t))
+      CALL c_f_pointer(CHTOT_PTR, CHTOT, (/GRIDC%MPLWV,NCDIJ/))
+#else   
+      ALLOCATE(CHTOT(GRIDC%MPLWV,NCDIJ),SV(DIMREAL(GRID%MPLWV),NCDIJ))
+#endif
+      ALLOCATE(CHTOTL(GRIDC%MPLWV,NCDIJ),DENCOR(GRIDC%RL%NP), &
+               CVTOT(GRIDC%MPLWV,NCDIJ),CSTRF(GRIDC%MPLWV,NTYP), &
+! small grid quantities
+               CHDEN(GRID_SOFT%MPLWV,NCDIJ), &
+! non local things
+               CDIJ(LMDIM,LMDIM,NIOND_LOC,NCDIJ), &
+               CQIJ(LMDIM,LMDIM,NIOND_LOC,NCDIJ), &
+               CRHODE(LMDIM,LMDIM,NIOND_LOC,NCDIJ), &
+! forces (depend on NIOND)
+               EWIFOR(3,NIOND),TIFOR(3,NIOND), &
+! dos
+               DOS(NEDOS,NCDIJ),DOSI(NEDOS,NCDIJ), &
+               DDOS(NEDOS,NCDIJ),DDOSI(NEDOS,NCDIJ), &
+               PAR(1,1,1,1,NCDIJ),DOSPAR(1,1,1,NCDIJ), &
+! paco
+               PACO%SIPACO(0:PACO%NPACO))
+
+      CALL REGISTER_ALLOCATE(16._q*(SIZE(CHTOT)+SIZE(CHTOTL)+SIZE(DENCOR)+SIZE(CVTOT)+SIZE(CSTRF)+SIZE(CHDEN)+SIZE(SV)), "grid")
+      IF (WDES%LGAMMA) THEN
+         CALL REGISTER_ALLOCATE(8._q*(SIZE(CDIJ)+SIZE(CQIJ)+SIZE(CRHODE)), "one-center")
+      ELSE
+         CALL REGISTER_ALLOCATE(16._q*(SIZE(CDIJ)+SIZE(CQIJ)+SIZE(CRHODE)), "one-center")
+      ENDIF
+
+      CALL ALLOCATE_AVEC(HAMILTONIAN%AVEC, HAMILTONIAN%AVTOT, GRID, GRIDC)
+      
+      CALL ALLOCATE_MU(HAMILTONIAN%MU, HAMILTONIAN%MUTOT, GRID, GRIDC, WDES)
+! test_
+!     CALL GENERATE_TAU_HANDLE(KINEDEN, GRIDC, WDES%NCDIJ)
+      CALL ALLOCATE_TAU(KINEDEN%TAU,KINEDEN%TAUC,KINEDEN%TAUL,GRIDC,WDES%NCDIJ)
+! test_
+      CALL CREATE_CMBJ_AUX(GRIDC,T_INFO,LATT_CUR)
+      
+      DWRITE0 'allocation done'
+!
+      ALLOCATE(CWORK1(GRID%MPLWV))
+      IF (IO%IU0>=0) WRITE(TIU0,*)'FFT: planning ...'
+      CALL INIDAT(GRID%RC%NP,CWORK1)
+      CALL FFTMAKEPLAN(CWORK1(1),GRID)
+      DEALLOCATE(CWORK1)
+
+
+      MPLMAX=MAX(GRIDC%MPLWV,GRID_SOFT%MPLWV,GRID%MPLWV)
+#ifdef MPI
+! give T3D opportunity to allocate all required shmem workspace
+      CALL SHM_MAX(WDES, MPLMAX, MALLOC)
+      CALL SHM_ALLOC(MALLOC)
+#endif
+      MIX%NEIG=0
+! calculate required numbers elements which must be mixed in PAW
+! set table for Clebsch-Gordan coefficients, maximum L is 2*3 (f states)
+      LMAX_TABLE=6;  CALL YLM3ST_(LMAX_TABLE)
+
+      N_MIX_PAW=0
+      CALL SET_RHO_PAW_ELEMENTS(WDES, P , T_INFO, INFO%LOVERL, N_MIX_PAW )
+      ALLOCATE( RHOLM(N_MIX_PAW,WDES%NCDIJ), RHOLM_LAST(N_MIX_PAW,WDES%NCDIJ))
+! solve pseudo atomic problem
+      IF (WANPROJ().OR.LPRJ_LCAO()) CALL LCAO_INIT(P,INFO,IO%IU0,IO%IU6)
+! setup fock (requires YLM)
+      CALL SETUP_FOCK(T_INFO, P, WDES, GRID, LATT_CUR, LMDIM,  INFO%SZPREC, IO%IU6, IO%IU0 )
+! setup atomic PAW terms
+      IF (LRHFATM()) THEN
+         CALL SET_PAW_ATOM_POT_RHF(P,T_INFO,INFO%LOVERL,INFO%EALLAT,IO)
+      ELSE
+        CALL RHFATM_CROP_PSEUDO(P,T_INFO,INFO%LOVERL,IO)
+        CALL SET_PAW_ATOM_POT(P , T_INFO, INFO%LOVERL,  &
+             LMDIM, INFO%EALLAT, INFO%LMETAGGA, IO%IU6  )
+      ENDIF
+! possibly setup of the scf determination of the subspace rotation
+      CALL SETUP_SUBROT_SCF(INFO,WDES,LATT_CUR,GRID,GRIDC,GRID_SOFT,SOFT_TO_C,IO%IU0,IO%IU5,IO%IU6)
+! setup pead
+      CALL PEAD_SETUP(WDES,GRID,GRIDC,GRIDUS,C_TO_US,KPOINTS,LATT_CUR,LATT_INI,T_INFO,P,LMDIM,INFO%LOVERL,IRDMAX,IO)
+!=======================================================================
+! allocate wavefunctions
+!=======================================================================
+      CALL ALLOCW(WDES,W,WUP,WDW)
+      IF (INFO%LONESW) THEN
+        CALL ALLOCW(WDES,W_F,WTMP,WTMP)
+        CALL ALLOCW(WDES,W_G,WTMP,WTMP)
+        ALLOCATE(CHAM(WDES%NB_TOT,WDES%NB_TOT,WDES%NKPTS,WDES%ISPIN), &
+                 CHF (WDES%NB_TOT,WDES%NB_TOT,WDES%NKPTS,WDES%ISPIN))
+      ELSE
+        ALLOCATE(CHAM(1,1,1,1), &
+                 CHF (1,1,1,1))
+      ENDIF
+      CALL DUMP_ALLOCATE(IO%IU6)
+!=======================================================================
+! now read in wavefunctions
+!=======================================================================
+
+      W%CELTOT=0
+      CALL START_TIMING("G")
+      IF (INFO%ISTART>0) THEN
+         IF (IO%IU0>=0) WRITE(TIU0,*)'reading WAVECAR'
+         IF (IO%LDOWNSAMPLE ) THEN
+            CALL INWAV_DOWNFOLD(IO, WDES, W, SYMM, KPOINTS, GRID, LATT_CUR, LATT_INI, INFO%ISTART,  EFERMI )
+         ELSE
+            CALL INWAV_FAST(IO, WDES, W, GRID, LATT_CUR, LATT_INI, INFO%ISTART,  EFERMI )
+         ENDIF
+      ELSE
+         IF (IO%IU0>=0) WRITE(TIU0,*)'WAVECAR not read'
+      ENDIF
+      CALL CLOSEWAV
+
+      IF (WDES%LSPIRAL.AND.(INFO%ISTART>0)) CALL CLEANWAV(WDES,W,INFO%ENINI)
+      CALL STOP_TIMING("G",IO%IU6,'INWAV')
+
+
+      IF (INFO%ISTART/=2) LATT_INI=LATT_CUR
+!=======================================================================
+! At this very point everything has been read in 
+! and we are ready to write all important information
+! to the xml file
+!=======================================================================
+      CALL XML_ATOMTYPES(T_INFO%NIONS, T_INFO%NTYP, T_INFO%NITYP, T_INFO%ITYP, P%ELEMENT, P%POMASS, P%ZVALF, P%SZNAMP )
+
+      CALL XML_TAG("structure","initialpos")
+      CALL XML_CRYSTAL(LATT_CUR%A, LATT_CUR%B, LATT_CUR%OMEGA)
+      CALL XML_POSITIONS(T_INFO%NIONS, DYN%POSION)
+      IF (T_INFO%LSDYN) CALL XML_LSDYN(T_INFO%NIONS,T_INFO%LSFOR(1,1))
+      IF (DYN%IBRION<=0 .AND. DYN%NSW>0 ) CALL XML_VEL(T_INFO%NIONS, DYN%VEL)
+      IF (T_INFO%LSDYN) CALL XML_NOSE(DYN%SMASS)
+      CALL XML_CLOSE_TAG("structure")
+!=======================================================================
+! initialize index tables for broyden mixing
+!=======================================================================
+      IF (((MIX%IMIX==4).AND.(.NOT.INFO%LCHCON)).OR.DYN%IBRION==10) THEN
+! Use a reduced mesh but only if using preconditioning ... :
+         IF (EXXOEP>=1) THEN
+            CALL BRGRID(GRIDC,GRIDB,MAX(INFO%ENMAX*2,ENCUTGW_IN_CHI()),IO%IU6,LATT_CUR%B)
+         ELSE
+            CALL BRGRID(GRIDC,GRIDB,INFO%ENMAX,IO%IU6,LATT_CUR%B)
+         ENDIF
+         CALL INILGRD(GRIDB%NGX,GRIDB%NGY,GRIDB%NGZ,GRIDB)
+         CALL GEN_RC_SUB_GRID(GRIDB,GRIDC, B_TO_C, .FALSE.,.TRUE.)
+      ENDIF
+! calculate the structure-factor, initialize some arrays
+      IF (INFO%TURBO==0) CALL STUFAK(GRIDC,T_INFO,CSTRF)
+      CHTOT=0 ; CHDEN=0; CVTOT=0
+!=======================================================================
+! construct initial  charge density:  a bit of heuristic is used
+!  to get sensible defaults if the user specifies stupid values in the
+!  INCAR files
+! for the initial charge density there are several possibilties
+! if INFO%ICHARG= 1 read in charge-density from a File
+! if INFO%ICHARG= 2-3 construct atomic charge-densities of overlapping atoms
+! if INFO%ICHARG= 4 read potential from file
+! if INFO%ICHARG= 5 read GAMMA file and update orbitals accordingly
+! if INFO%ICHARG >=10 keep chargedensity constant
+!
+!=======================================================================
+      ! subtract 10 from ICHARG (10 means fixed charge density)
+      IF (INFO%ICHARG>10) THEN
+        INFO%INICHG= INFO%ICHARG-10
+      ELSE
+        INFO%INICHG= INFO%ICHARG
+      ENDIF
+
+      IF (INFO%INICHG==5) THEN
+         ! no convergence correction for forces (reread GAMMA in last electronic step)
+         IF (.NOT. MIX%MIXFIRST) INFO%LCORR=.FALSE.
+         CALL CREATE_VASP_LOCK(COMM)
+         ! and reset INICHG to 1 so that CHGCAR is read as well
+         INFO%INICHG=1
+      ENDIF
+ 
+      ! then initialize CRHODE and than RHOLM (PAW related occupancies)
+      CALL DEPATO(WDES, LMDIM, CRHODE, INFO%LOVERL, P, T_INFO)
+      CALL SET_RHO_PAW(WDES, P, T_INFO, INFO%LOVERL, WDES%NCDIJ, LMDIM, &
+           CRHODE, RHOLM)
+
+! MM: Stuff for Janos Angyan: write the AE-charge density for the
+      IF (LWRT_AECHG()) THEN
+      ! overlapping atomic charges to AECCAR1
+         ! add overlapping atomic charges on dense regular grid
+         CALL RHOATO_WORK(.TRUE.,.FALSE.,GRIDC,T_INFO,LATT_CUR%B,P,CSTRF,CHTOT)
+         ! add (n_ae - n_ps - n_comp) as defined on radial grid
+         CALL AUGCHG(WDES,GRID_SOFT,GRIDC,GRIDUS,C_TO_US, &
+        &             LATT_CUR,P,T_INFO,SYMM, INFO%LOVERL, SOFT_TO_C,&
+        &              LMDIM,CRHODE, CHTOT,CHDEN, IRDMAX,.FALSE.,.FALSE.)
+
+#ifdef MPI
+         IF (WDES%COMM_KINTER%NODE_ME.EQ.1) THEN
+#endif
+         io_begin
+         ! write AECCAR1
+         OPEN(UNIT=99,FILE=DIR_APP(1:DIR_LEN)//'AECCAR1',STATUS='UNKNOWN')
+         ! write header
+         CALL OUTPOS(99,.FALSE.,INFO%SZNAM1,T_INFO,LATT_CUR%SCALE,LATT_CUR%A, &
+        &             .FALSE., DYN%POSION)
+         io_end
+         ! write AE charge density
+         CALL OUTCHG(GRIDC,99,.TRUE.,CHTOT)
+         io_begin
+         CLOSE(99)
+         io_end
+         ! reset charge densities to zero again
+         CHTOT=0; CHDEN=0
+      ! AE core density to AECCAR0
+         ! add partial core density on dense regular grid
+         IF (INFO%LCORE) THEN
+            CALL RHOATO_WORK(.TRUE.,.TRUE.,GRIDC,T_INFO,LATT_CUR%B,P,CSTRF,CHTOT)
+         ENDIF
+         ! add core densities (nc_ae-nc_ps) as defined on radial grid
+         CALL AUGCHG(WDES,GRID_SOFT,GRIDC,GRIDUS,C_TO_US, &
+        &             LATT_CUR,P,T_INFO,SYMM, INFO%LOVERL, SOFT_TO_C,&
+        &              LMDIM,CRHODE, CHTOT,CHDEN, IRDMAX,.FALSE.,.TRUE.)
+         io_begin
+         ! write AECCAR0
+         OPEN(UNIT=99,FILE=DIR_APP(1:DIR_LEN)//'AECCAR0',STATUS='UNKNOWN')
+         ! write header
+         CALL OUTPOS(99,.FALSE.,INFO%SZNAM1,T_INFO,LATT_CUR%SCALE,LATT_CUR%A, &
+        &             .FALSE., DYN%POSION)
+         io_end
+         ! write AE core charge density
+         CALL OUTCHG(GRIDC,99,.TRUE.,CHTOT)
+         io_begin
+         CLOSE(99)
+         io_end
+         ! and reset charge densities to zero again
+
+#ifdef MPI
+         END IF
+#endif
+         CHTOT=0; CHDEN=0
+      ENDIF
+
+     ! initial set of wavefunctions from diagonalization of Hamiltonian
+     ! set INICHG to 2
+
+      IF (INFO%INICHG==0 .AND. INFO%INIWAV==2) THEN
+        INFO%INICHG=2
+        IF (IO%IU6>=0) &
+        WRITE(TIU6,*)'WARNING: no initial charge-density supplied,', &
+                       ' atomic charge-density will be used'
+      ENDIF
+
+      IF (INFO%INICHG==1 .OR.INFO%INICHG==2 .OR.INFO%INICHG==3) THEN
+         IF (IO%IU6>=0) WRITE(TIU6,*)'initial charge density was supplied:'
+      ENDIF
+
+      IF (INFO%INICHG==1) THEN
+
+!PK Only first k-point group reads charge density
+!PK Broadcast results outside of READCH due to awkward error logic in READCH
+#ifdef MPI
+         IF (COMM_KINTER%NODE_ME.EQ.1 ) THEN
+#endif
+           CALL READCH(GRIDC, INFO%LOVERL, T_INFO, CHTOT, RHOLM, INFO%INICHG, WDES%NCDIJ, &
+             LATT_CUR, P, CSTRF(1,1), 18, IO%IU0)
+#ifdef MPI
+         END IF
+#endif
+        CALLMPI( M_bcast_i( COMM_KINTER, INFO%INICHG, 1))
+        IF (INFO%INICHG.NE.0) THEN
+           CALLMPI( M_bcast_z( COMM_KINTER, CHTOT, GRIDC%MPLWV*WDES%NCDIJ))
+           CALLMPI( M_bcast_d( COMM_KINTER, RHOLM, SIZE(RHOLM)) )
+        END IF
+
+        IF (INFO%ICHARG>10 .AND. INFO%INICHG==0) THEN
+           WRITE(*,*)'ERROR: charge density could not be read from file CHGCAR', &
+               ' for ICHARG>10'
+           STOP
+        ENDIF
+        ! error on reading CHGCAR, set INFO%INICHG to 2
+        IF (INFO%INICHG==0)  INFO%INICHG=2
+        ! no magnetization density set it according to MAGMOM
+        IF (INFO%INICHG==-1) THEN
+           IF (WDES%NCDIJ>1) & 
+                CALL MRHOATO(.FALSE.,GRIDC,T_INFO,LATT_CUR%B,P,CHTOT(1,2),WDES%NCDIJ-1)
+           INFO%INICHG=1
+           IF( TIU0 >=0) WRITE(TIU0,*)'magnetization density of overlapping atoms calculated'
+        ENDIF
+
+      ENDIF
+
+      IF (INFO%INICHG==1) THEN
+      ELSE IF (INFO%INICHG==2 .OR.INFO%INICHG==3) THEN
+         IF(INFO%TURBO==0)THEN
+            CALL RHOATO_WORK(.FALSE.,.FALSE.,GRIDC,T_INFO,LATT_CUR%B,P,CSTRF,CHTOT)
+         ELSE
+            CALL RHOATO_PARTICLE_MESH(.FALSE.,.FALSE.,GRIDC,LATT_CUR,T_INFO,INFO,P,CHTOT,IO%IU6)
+         ENDIF
+         IF (WDES%NCDIJ>1) & 
+              CALL MRHOATO(.FALSE.,GRIDC,T_INFO,LATT_CUR%B,P,CHTOT(1,2),WDES%NCDIJ-1)
+
+         IF (IO%IU6>=0) WRITE(TIU6,*)'charge density of overlapping atoms calculated'
+      ELSE IF (INFO%INICHG==4) THEN
+         IF (IO%IU6>=0) WRITE(TIU6,*)'potential read from file POT'
+         INFO%INICHG=4
+      ELSE
+         INFO%INICHG=0
+      ENDIF
+
+      IF (INFO%INICHG==1 .OR.INFO%INICHG==2 .OR.INFO%INICHG==3) THEN
+         DO I=1,WDES%NCDIJ
+            RHOTOT(I) =RHO0(GRIDC, CHTOT(1,I))
+         ENDDO
+         IF(IO%IU6>=0)  WRITE(TIU6,200) RHOTOT(1:WDES%NCDIJ)
+ 200     FORMAT(' number of electron ',F15.7,' magnetization ',3F15.7)
+      ENDIF
+
+      ! set the partial core density
+      DENCOR=0
+      IF (INFO%LCORE) CALL RHOPAR(GRIDC,T_INFO,INFO,LATT_CUR,P,CSTRF,DENCOR,IO%IU6)
+      IF (LDO_METAGGA()) CALL TAUPAR(GRIDC,T_INFO,LATT_CUR%B,LATT_CUR%OMEGA,P,CSTRF,KINEDEN%TAUC)
+
+      IF (INFO%INIWAV==2) THEN
+         IF (IO%IU0>=0) &
+         WRITE(TIU0,*) 'ERROR: this version does not support INIWAV=2'
+         STOP
+      ENDIF
+
+      IF (IO%IU6>=0) THEN
+        IF (INFO%INICHG==0 .OR. INFO%INICHG==4 .OR. (.NOT.INFO%LCHCOS.AND. INFO%NELMDL==0) ) THEN
+          WRITE(TIU6,*)'charge density for first step will be calculated', &
+           ' from the start-wavefunctions'
+        ELSE
+          WRITE(TIU6,*)'keeping initial charge density in first step'
+        ENDIF
+        WRITE(TIU6,130)
+      ENDIF
+
+      ! add Gaussian "charge-transfer" charges, if required 
+      CALL RHOADD_GAUSSIANS(T_INFO,LATT_CUR,P,GRIDC,NCDIJ,CHTOT,CSTRF) 
+      CALL RHOADD_GAUSSIANS_LIST(LATT_CUR,GRIDC,NCDIJ,CHTOT)
+
+      DWRITE0 'atomic charge done'
+!========================subroutine SPHER ==============================
+! RSPHER calculates the real space projection operators
+!    (VOLUME)^.5 Y(L,M)  VNLR(L) EXP(-i r k)
+! subroutine SPHER calculates the nonlocal pseudopotential
+! multiplied by the spherical harmonics and (1/VOLUME)^.5:
+!    1/(VOLUME)^.5 Y(L,M)  VNL(L)
+! (routine must be called if the size of the unit cell is changed)
+!=======================================================================
+      IF (INFO%LREAL) THEN
+         CALL RSPHER(GRID,NONLR_S,LATT_CUR)
+
+         INDMAX=0
+         DO NI=1,T_INFO%NIONS
+            INDMAX=MAX(INDMAX,NONLR_S%NLIMAX(NI))
+         ENDDO
+         IF (IO%IU6>=0) &
+         WRITE(TIU6,*)'Maximum index for non-local projection operator ',INDMAX
+      ELSE
+         CALL SPHER(GRID, NONL_S, P, WDES, LATT_CUR,  1)
+         CALL PHASE(WDES,NONL_S,0)
+      ENDIF
+
+      DWRITE0 'non local setup done'
+!=======================================================================
+! set the coefficients of the plane wave basis states to zero before
+! initialising the wavefunctions by calling WFINIT (usually random)
+!=======================================================================
+      IF (INFO%ISTART<=0) THEN
+        W%CPTWFP=0
+        CALL WFINIT(WDES, W, INFO%ENINI)
+      IF (INFO%INIWAV==1 .AND. INFO%NELMDL==0 .AND. INFO%INICHG/=0) THEN
+        IF (IO%IU0>=0) &
+        WRITE(TIU0,*) 'WARNING: random wavefunctions but no delay for ', &
+                        'mixing, default for NELMDL'
+        INFO%NELMDL=-5
+        IF (INFO%LRMM .AND. .NOT. INFO%LDAVID) INFO%NELMDL=-12
+      ENDIF
+
+      ! initialize the occupancies, in the spin polarized case
+      ! we try to set up and down occupancies individually
+      ELEKTR=INFO%NELECT
+      CALL DENINI(W%FERTOT(1,1,1),WDES%NB_TOT,KPOINTS%NKPTS,ELEKTR,WDES%LNONCOLLINEAR)
+
+      IF (WDES%ISPIN==2) THEN
+        RHOMAG=RHO0(GRIDC,CHTOT(1,2))
+        ELEKTR=INFO%NELECT+RHOMAG
+        CALL DENINI(W%FERTOT(1,1,1),WDES%NB_TOT,KPOINTS%NKPTS,ELEKTR,WDES%LNONCOLLINEAR)
+        ELEKTR=INFO%NELECT-RHOMAG
+        CALL DENINI(W%FERTOT(1,1,2),WDES%NB_TOT,KPOINTS%NKPTS,ELEKTR,WDES%LNONCOLLINEAR)
+      ENDIF
+
+      ENDIF
+      DWRITE0 'wavefunctions initialized'
+!=======================================================================
+! INFO%LONESW initialize W_F%CELEN fermi-weights and augmentation charge
+!=======================================================================
+      E%EENTROPY=0
+
+      IF ((INFO%LONESW .AND. KPOINTS%ISMEAR/=-2) .OR. (INFO%IALGO==3 .AND. KPOINTS%ISMEAR/=-2)) THEN
+         E%EENTROPY=0
+         IF (INFO%LONESW) W_F%CELTOT = W%CELTOT
+         CALL DENSTA( IO%IU0, IO%IU6, WDES, W, KPOINTS, INFO%NELECT, &
+               INFO%NUP_DOWN,  E%EENTROPY, EFERMI, KPOINTS%SIGMA, .FALSE., &
+               NEDOS, 0, 0, DOS, DOSI, PAR, DOSPAR)
+      ENDIF
+!=======================================================================
+!  read Fermi-weigths from INCAR if supplied
+!=======================================================================
+      OPEN(UNIT=IO%IU5,FILE=INCAR,STATUS='OLD')
+      CALL RDATAB(.FALSE.,INCAR,IO%IU5,'FERWE','=','#',';','F', &
+     &     IDUM,W%FERTOT(1,1,1),CDUM,LDUM,CHARAC,N,KPOINTS%NKPTS*WDES%NB_TOT,IERR)
+
+      IF ( ((IERR/=0) .AND. (IERR/=3)) .OR. &
+     &     ((IERR==0).AND.(N<(KPOINTS%NKPTS*WDES%NB_TOT)))) THEN
+         IF (IO%IU0>=0) &
+         WRITE(TIU0,*)'Error reading item ''FERWE'' from file INCAR.'
+         STOP
+      ENDIF
+! attention this feature is not supported by the xml writer
+!      CALL XML_INCAR_V('FERWE','F',IDUM,W%FERTOT(1,1,1),CDUM,LDUM,CHARAC,N)
+
+      IF (WDES%ISPIN==2) THEN
+         CALL RDATAB(.FALSE.,INCAR,IO%IU5,'FERDO','=','#',';','F', &
+     &        IDUM,W%FERTOT(1,1,INFO%ISPIN),CDUM,LDUM,CHARAC,N,KPOINTS%NKPTS*WDES%NB_TOT,IERR)
+         IF ( ((IERR/=0) .AND. (IERR/=3)) .OR. &
+     &        ((IERR==0).AND.(N<(KPOINTS%NKPTS*WDES%NB_TOT)))) THEN
+            IF (IO%IU0>=0) &
+            WRITE(TIU0,*)'Error reading item ''FERDO'' from file INCAR.'
+            STOP
+         ENDIF
+! attention this feature is not supported by the xml writer
+!         CALL XML_INCAR_V('FERDO','F',IDUM,W%FERTOT(1,1,INFO%ISPIN),CDUM,LDUM,CHARAC,N)
+      ENDIF
+      CLOSE(IO%IU5)
+ 
+! if ISMEAR == -2 occupancies will be kept fixed
+      IF (KPOINTS%ISMEAR==-2) THEN
+         KPOINTS%SIGMA=-ABS(KPOINTS%SIGMA)
+      ENDIF
+
+!=======================================================================
+! write out STM file if wavefunctions exist
+!=======================================================================
+       IF (STM(1) < STM(2) .AND. STM(3) /= 0 .AND. STM(4) < 0 .AND. INFO%ISTART == 1) THEN
+        IF (STM(7) == 0) THEN
+          CALL DENSTA( IO%IU0, IO%IU6, WDES, W, KPOINTS, INFO%NELECT, &
+               INFO%NUP_DOWN,  E%EENTROPY, EFERMI, KPOINTS%SIGMA, .FALSE., &
+               NEDOS, 0, 0, DOS, DOSI, PAR, DOSPAR)
+        ELSEIF (STM(7) /= 0) THEN
+          EFERMI = STM(7)
+          do_io WRITE(*,*)'-------------  VASP_IETS  --------------'
+          do_io write(*,*) 'Efermi FROM INPUT= ',EFERMI
+          do_io WRITE(*,*)'STM(7)=',STM(7)
+          do_io WRITE(*,*)'-------------  VASP_IETS  --------------'
+
+        ELSE
+          do_io WRITE(*,*)'-------------  VASP_IETS  --------------'
+          do_io WRITE(*,*)'ERROR WITH STM(7) STOP NOW'
+          do_io WRITE(*,*)'STM(7)=',STM(7)
+          STOP
+        ENDIF
+         do_io WRITE(*,*) 'Writing STM file'
+         CALL  WRT_STM_FILE(GRID, WDES, WUP, WDW, EFERMI, LATT_CUR, &
+               STM, T_INFO)
+         do_io WRITE(*,*) "STM File written, ..."
+         STOP
+       ENDIF
+
+!=======================================================================
+! calculate the projections of the wavefunctions onto the projection
+! operators using real-space projection scheme or reciprocal scheme
+! then perform an orthogonalisation of the wavefunctions
+!=======================================================================
+      ! first call SETDIJ to set the array CQIJ
+      CALL SETDIJ(WDES,GRIDC,GRIDUS,C_TO_US,LATT_CUR,P,T_INFO,INFO%LOVERL, &
+                  LMDIM,CDIJ,CQIJ,CVTOT,IRDMAA,IRDMAX)
+
+      CALL CALC_JPAW_HAMIL(T_INFO, P)
+      ! set vector potential
+      CALL VECTORPOT(GRID, GRIDC, GRID_SOFT, SOFT_TO_C,  WDES%COMM_INTER, & 
+                 LATT_CUR, T_INFO%POSION, HAMILTONIAN%AVEC, HAMILTONIAN%AVTOT)
+      ! first call to SETDIJ_AVEC only sets phase twisted projectors
+      CALL SETDIJ_AVEC(WDES,GRIDC,GRIDUS,C_TO_US,LATT_CUR,P,T_INFO,INFO%LOVERL, &
+                 LMDIM, CDIJ, HAMILTONIAN%AVTOT, NONLR_S, NONL_S, IRDMAX )
+
+      DWRITE0 'setdij done'
+
+      IF (IO%IU6>=0) &
+      WRITE(TIU6,*)'Maximum index for augmentation-charges ', &
+                     IRDMAA,'(set IRDMAX)'
+      CALL WVREAL_PRECISE(W)
+
+      CALL PROALL (GRID,LATT_CUR,NONLR_S,NONL_S,W)
+      DWRITE0 'proall done'
+ 
+      CALL ORTHCH(WDES,W, INFO%LOVERL, LMDIM,CQIJ)
+      CALL REDIS_PW_OVER_BANDS(WDES, W)
+      DWRITE0 'orthch done'
+
+      IF (IO%IU6>=0) WRITE(TIU6,130)
+
+      ! strictly required for HF, since SET_CHARGE fails for ISYM=3
+      CALL KPAR_SYNC_ALL(WDES,W)
+!=======================================================================
+! partial band decomposed chargedensities PARDENS
+!=======================================================================
+      IF (LPARD) THEN
+           CALL DENSTA( IO%IU0, IO%IU6, WDES, W, KPOINTS, INFO%NELECT, &
+                INFO%NUP_DOWN,  E%EENTROPY, EFERMI, KPOINTS%SIGMA, .FALSE., &
+                NEDOS, 0, 0, DOS, DOSI, PAR, DOSPAR)
+           CALL PARCHG(W,WUP,WDW,WDES,CHDEN,CHTOT,CRHODE,INFO,GRID, &
+                GRID_SOFT,GRIDC,GRIDUS,C_TO_US, &
+                LATT_CUR,P,T_INFO,SOFT_TO_C,SYMM,IO, &
+                DYN,EFERMI,LMDIM,IRDMAX,NIOND)
+      ENDIF
+!=======================================================================
+! calculate initial chargedensity if
+! ) we do not have any chargedensity
+! ) we use a selfconsistent minimization scheme and do not have a delay
+!=======================================================================
+      IF (INFO%INICHG==0 .OR. INFO%INICHG==4 .OR. (.NOT.INFO%LCHCOS .AND. INFO%NELMDL==0)  ) THEN
+         IF (IO%IU6>=0) &
+              WRITE(TIU6,*)'initial charge from wavefunction'
+         
+         IF (IO%IU0>=0) &
+              WRITE(TIU0,*)'initial charge from wavefunction'
+
+         CALL SET_CHARGE(W, WDES, INFO%LOVERL, &
+              GRID, GRIDC, GRID_SOFT, GRIDUS, C_TO_US, SOFT_TO_C, &
+              LATT_CUR, P, SYMM, T_INFO, &
+              CHDEN, LMDIM, CRHODE, CHTOT, RHOLM, N_MIX_PAW, IRDMAX)
+
+         CALL SET_KINEDEN(GRID,GRID_SOFT,GRIDC,SOFT_TO_C,LATT_CUR,SYMM, &
+              T_INFO%NIONS,W,WDES,KINEDEN)      
+      ENDIF
+
+!=======================================================================
+! initialise the predictor for the wavefunction with
+! the first available ionic positions
+! PRED%INIPRE=2 continue with existing file
+! PRED%INIPRE=1 initialise
+!=======================================================================
+      IF (INFO%ISTART==3) THEN
+        PRED%INIPRE=2
+      ELSE
+        PRED%INIPRE=1
+      ENDIF
+
+      IF (DYN%IBRION/=-1 .AND. PRED%IWAVPR >= 12 ) THEN
+        CALL WAVPRE_NOIO(GRIDC,P,PRED,T_INFO,W,WDES,LATT_CUR,IO%LOPEN, &
+           CHTOT,RHOLM,N_MIX_PAW, CSTRF, KINEDEN, LMDIM,CQIJ,INFO%LOVERL,IO%IU0)
+      ELSE IF (DYN%IBRION/=-1 .AND. PRED%IWAVPR >= 2 .AND. PRED%IWAVPR <10 )  THEN
+        CALL WAVPRE(GRIDC,P,PRED,T_INFO,W,WDES,LATT_CUR,IO%LOPEN, &
+           CHTOT,RHOLM,N_MIX_PAW, CSTRF, LMDIM,CQIJ,INFO%LOVERL,IO%IU0)
+      ENDIF
+      DWRITE0 "wavpre is ok"
+
+!=======================================================================
+! if INFO%IALGO < 0 make some performance tests
+!=======================================================================
+      IF (INFO%IALGO<0) THEN
+         CALL PERFORMANCE_TEST
+         GOTO 5100
+      ENDIF
+
+!======================== SUBROUTINE FEWALD ============================
+! calculate ewald energy forces, and stress
+!=======================================================================
+      CALL START_TIMING("G")
+      IF(INFO%TURBO==0) THEN
+         CALL FEWALD(DYN%POSION,EWIFOR,LATT_CUR%A,LATT_CUR%B,LATT_CUR%ANORM,LATT_CUR%BNORM, &
+              LATT_CUR%OMEGA,EWSIF,E%TEWEN,T_INFO%NTYP,P%ZVALF,T_INFO%VCA, &
+              T_INFO%NIONS,NIOND,T_INFO%ITYP,T_INFO%NITYP,IO%IU6,.TRUE.)
+      ELSE
+         ALLOCATE(CWORK1(GRIDC%MPLWV))
+         CALL POTION_PARTICLE_MESH(GRIDC,P,LATT_CUR,T_INFO,CWORK1,E%PSCENC,E%TEWEN,EWIFOR)
+         DEALLOCATE(CWORK1)
+      ENDIF
+      CALL STOP_TIMING("G",TIU6,'FEWALD')
+!=======================================================================
+! Set INFO%LPOTOK to false: this requires  a recalculation of the
+! total local potential
+!=======================================================================
+      INFO%LPOTOK=.FALSE.
+      TOTENG=0
+      INFO%LSTOP=.FALSE.
+      INFO%LSOFT=.FALSE.
+
+      IF (INFO%INICHG==4) THEN
+
+         IF (IO%LOPEN) OPEN(IO%IUVTOT,FILE='POT',STATUS='UNKNOWN')
+         REWIND IO%IUVTOT
+
+         CALL READPOT(GRIDC, T_INFO, CVTOT, INFO%INICHG, WDES, &
+              LATT_CUR, P, LMDIM, CDIJ, N_MIX_PAW, IO%IUVTOT, IO%IU0)
+
+        IF (INFO%INICHG==4) THEN
+           DO ISP=1,WDES%NCDIJ
+              CALL FFT_RC_SCALE(CVTOT(1,ISP),CVTOT(1,ISP),GRIDC)
+           ENDDO
+
+           CALL SET_SV( GRID, GRIDC, GRID_SOFT, WDES%COMM_INTER, SOFT_TO_C, WDES%NCDIJ, SV, CVTOT)
+           INFO%LPOTOK=.TRUE.
+        ELSE
+           IF (IO%IU0>=0) THEN
+              WRITE(IO%IU0,*)'reading POT failed can not continue'
+           ENDIF
+
+           STOP
+        ENDIF
+      ENDIF
+!=======================================================================
+! some special calculation routines such as GW, MP2, MP2NO, ...
+!=======================================================================
+      IF (LMP2 .OR. LMP2KPAR .OR. LMP2NO .OR. LFCIDUMP  .OR. LRPAX .OR.  LCCSD .OR. LBRACKETST) THEN
+         CALL PSI_CORR_MAIN(P,WDES,NONLR_S,NONL_S,W,LATT_CUR,LATT_INI,  &
+          & T_INFO, DYN, IO,KPOINTS,SYMM,GRID,INFO,MIX%AMIX,MIX%BMIX)
+      ENDIF
+
+      IF(FOURORBIT==1) THEN
+         CALL TWOELECTRON4O_MAIN( &
+              P,WDES,NONLR_S,NONL_S,W,LATT_CUR,LATT_INI, &
+              T_INFO,DYN,INFO,IO,KPOINTS,SYMM,GRID, LMDIM)
+         CALL STOP_TIMING("G",IO%IU6,'TWOE4O')
+      ENDIF
+      IF (LMP2 .OR. LMP2KPAR .OR. LMP2NO .OR. LFCIDUMP  .OR. LRPAX .OR.  LCCSD .OR. &
+        & LBRACKETST .OR. FOURORBIT==1 ) THEN
+         STOP
+      ENDIF
+
+#ifdef VASP2WANNIER90
+      IF (L2E4W) THEN
+         CALL DMFT_MATRIX_ELEMENTS( &
+        &   WDES,W,KPOINTS,GRID,T_INFO,INFO,P, &
+        &   NONL_S,NONLR_S,SYMM,LATT_CUR,CQIJ,LMDIM,IO)
+         ! stop execution of VASP (wave functions have been messed up so let's quit)
+         GOTO 5100
+      ENDIF
+#endif
+      IF (LCHI) THEN
+         IF (.NOT. LUSEPEAD() .AND. .NOT. LNABLA .AND. .NOT. EXXOEP>=1 .AND. .NOT. USE_OEP_IN_GW()) THEN
+         ! optical properties do not work for conventional GW
+         ! because the potential is non-local
+         ! OEP are fine however
+            IO%LOPTICS=.FALSE. 
+         ENDIF
+         IF (.NOT. LRPAFORCE) THEN
+            CALL DO_RPA
+            INFO%LSTOP=.TRUE.   ! stop ionic loop immediately
+         ENDIF
+      ENDIF
+!***********************************************************************
+!***********************************************************************
+!
+! ++++++++++++ do 1000 n=1,required number of timesteps ++++++++++++++++
+!
+! this is the main loop of the program during which one complete step of
+! the electron dynamics and ionic movements is performed.
+! NSTEP           loop counter for ionic movement
+! N               loop counter for self-consistent loop
+! INFO%NELM            number of electronic movement loops
+!***********************************************************************
+!***********************************************************************
+
+      IF (IO%IU0>=0) WRITE(TIU0,*)'entering main loop'
+
+      NSTEP = 0
+      CALL START_TIMING("LOOP+")
+
+      CALL CONSTRAINED_M_INIT(T_INFO,GRIDC,LATT_CUR)
+      CALL INIT_WRITER(P,T_INFO,WDES)
+!=======================================================================
+      ion: DO
+      IF (INFO%LSTOP) EXIT ion
+!=======================================================================
+
+!  reset broyden mixing
+      MIX%LRESET=.TRUE.
+io_begin
+      IF (IO%LOPEN) CALL WFORCE(IO%IU6)            ! write of OUTCAR
+      IF (IO%LOPEN .AND. NSTEP/=0) CALL WFORCE(17) ! write of OSZICAR
+io_end
+!=======================================================================
+! initialize pair-correlation funtion to zero
+! also set TMEAN und SMEAN to zero
+! TMEAN/SMEAN  is the mean temperature
+!=======================================================================
+      IF (MOD(NSTEP,DYN%NBLOCK*DYN%KBLOCK)==0) THEN
+        SMEANP=0
+        PACO%SIPACO=0
+        TMEAN=0
+        TMEAN0=0
+        SMEAN=0
+        SMEAN0=0
+        DDOSI=0._q
+        DDOS =0._q
+      ENDIF
+
+      NSTEP = NSTEP + 1
+
+    IF (INFO%NELM==0 .AND. IO%IU6>=0) WRITE(TIU6,140) NSTEP,0
+
+!***********************************************************************
+!***********************************************************************
+! this part performs the total energy minimisation
+! INFO%NELM loops are made, if the difference between two steps
+! is less then INFO%EDIFF the loop is aborted
+!***********************************************************************
+!***********************************************************************
+    IF (.NOT. LJ_ONLY .AND. .NOT. LCHI) THEN
+      CALL XML_TAG("calculation")
+
+      CALL ELECTRONIC_OPTIMIZATION
+
+      ! possibly orbitals have been updated
+      ! force them to be real again be calling WVREAL_PRECISE
+      ! costs some extra work, but it is ultimately safer to do it here
+      IF (W%WDES%LORBITALREAL .AND. (INFO%LDIAG .OR. INFO%LEXACT_DIAG)) THEN
+        CALL WVREAL_PRECISE(W)
+        CALL PROALL (GRID,LATT_CUR,NONLR_S,NONL_S,W)
+        CALL STOP_TIMING("G",IO%IU6,"WVREAL",XMLTAG="wvreal")
+        CALL ORTHCH(WDES,W, INFO%LOVERL, LMDIM,CQIJ)
+        CALL STOP_TIMING("G",IO%IU6,"ORTHCH",XMLTAG="orth")
+      ENDIF
+
+      IF (NSTEP==1) THEN
+         IF (.NOT.INFO%LONESW.AND.(LPEAD_CALC_EPS().OR.LPEAD_NONZERO_EFIELD())) THEN
+            CALL ALLOCW(WDES,W_F,WTMP,WTMP)
+            CALL ALLOCW(WDES,W_G,WTMP,WTMP)
+            DEALLOCATE(CHAM, CHF)
+            ALLOCATE(CHAM(WDES%NB_TOT,WDES%NB_TOT,WDES%NKPTS,WDES%ISPIN), &
+              CHF (WDES%NB_TOT,WDES%NB_TOT,WDES%NKPTS,WDES%ISPIN))
+!           ! setup for scf subspace rotation
+!           INFO%LONESW=.TRUE.
+!           CALL SETUP_SUBROT_SCF(INFO,WDES,LATT_CUR,GRID,GRIDC,GRID_SOFT,SOFT_TO_C,IO%IU0,IO%IU5,IO%IU6)
+!           INFO%LONESW=.FALSE.
+         ENDIF
+
+         CALL PEAD_ELMIN( &
+          HAMILTONIAN,KINEDEN, &
+          P,WDES,NONLR_S,NONL_S,W,W_F,W_G,LATT_CUR,LATT_INI, &
+          T_INFO,DYN,INFO,IO,MIX,KPOINTS,SYMM,GRID,GRID_SOFT, &
+          GRIDC,GRIDB,GRIDUS,C_TO_US,B_TO_C,SOFT_TO_C,E, &
+          CHTOT,CHTOTL,DENCOR,CVTOT,CSTRF, &
+          CDIJ,CQIJ,CRHODE,N_MIX_PAW,RHOLM,RHOLM_LAST, &
+          CHDEN,SV,DOS,DOSI,CHF,CHAM,ECONV, &
+          NSTEP,LMDIM,IRDMAX,NEDOS, &
+          TOTEN,EFERMI,LDIMP,LMDIMP)
+
+         IF (.NOT.INFO%LONESW.AND.(LPEAD_CALC_EPS().OR.LPEAD_NONZERO_EFIELD())) THEN
+            CALL DEALLOCW(W_F)
+            CALL DEALLOCW(W_G)
+            DEALLOCATE(CHAM, CHF)
+            ALLOCATE(CHAM(1,1,1,1),CHF (1,1,1,1))
+         ENDIF        
+      ENDIF
+
+#ifdef VASP2WANNIER90
+      IF ((.NOT.(KINTER/=0)).AND.(.NOT.L2E4W) .AND. WANNIER90()) THEN
+         CALL KPAR_SYNC_ALL(WDES,W)
+         !switch off symmetry if UWAN files are written
+         IF ((SYMM%ISYM>=0.AND. .NOT.WDES%LGAMMA) .AND. LWRITE_WANPROJ) THEN
+            ! switch of symmetry
+            CALL NOSYMM(LATT_CUR%A,T_INFO%NTYP,T_INFO%NITYP,T_INFO%NIONS,SYMM%PTRANS, &
+                 SYMM%NROT,SYMM%NPTRANS,SYMM%ROTMAP,SYMM%MAGROT,WDES%ISPIN,IO%IU6)
+            ! reread k-points with LINVERSION=.FALSE. to generate full mesh
+            CALL RE_READ_KPOINTS(KPOINTS,LATT_CUR,.FALSE., &
+                 T_INFO%NIONS,SYMM%ROTMAP,SYMM%MAGROT,SYMM%ISYM,IO%IU6,IO%IU0)
+            CALL KPAR_SYNC_ALL(WDES,W)
+            CALL RE_GEN_LAYOUT( GRID, WDES, KPOINTS, LATT_CUR, LATT_CUR,-1, IO%IU0)
+            CALL PEAD_RESETUP_WDES(WDES, GRID, KPOINTS, LATT_CUR, LATT_CUR, IO) 
+            CALL REALLOCATE_WAVE( W, GRID, WDES, NONL_S, T_INFO, P, LATT_CUR)
+         ENDIF
+         CALL MLWF_WANNIER90(WDES,W,P,CQIJ,T_INFO,LATT_CUR,INFO,IO)
+         IF ((SYMM%ISYM>=0.AND. .NOT.WDES%LGAMMA) .AND. LWRITE_WANPROJ) THEN
+            CALL INISYM(LATT_CUR%A,T_INFO%POSION,DYN%VEL,T_INFO%LSFOR, &
+                 T_INFO%LSDYN,T_INFO%NTYP,T_INFO%NITYP,T_INFO%NIONS, &
+                 SYMM%PTRANS,SYMM%NROT,SYMM%NPTRANS,SYMM%ROTMAP,SYMM%TAU,SYMM%TAUROT,SYMM%WRKROT, &
+                 SYMM%INDROT,T_INFO%ATOMOM,WDES%SAXIS,SYMM%MAGROT,WDES%NCDIJ,-1)
+            CALL RE_READ_KPOINTS(KPOINTS,LATT_CUR, &
+                 SYMM%ISYM>=0.AND..NOT.WDES%LNONCOLLINEAR, &
+                 T_INFO%NIONS,SYMM%ROTMAP,SYMM%MAGROT,SYMM%ISYM,-1,IO%IU0)
+            CALL KPAR_SYNC_ALL(WDES,W)
+            CALL RE_GEN_LAYOUT( GRID, WDES, KPOINTS, LATT_CUR, LATT_INI, IO%IU6, IO%IU0)
+            CALL REALLOCATE_WAVE( W, GRID, WDES, NONL_S, T_INFO, P, LATT_CUR)
+         ENDIF
+      ENDIF
+#endif
+      CALL WNPR_PROJECT(W,WDES,T_INFO,INFO,P,CQIJ,LATT_CUR,IO)
+    ELSE IF (LCHI) THEN
+       CALL DO_RPA
+    END IF ! LJ_ONLY
+
+!  'soft stop': stop after the next ionic step finished
+!  in order to do this create file STOPCAR and set an entry INFO%LSTOP=.TRUE.
+      LTMP=.FALSE.
+      CALL RDATAB(IO%LOPEN,'STOPCAR',99,'LSTOP','=','#',';','L', &
+     &            IDUM,RDUM,CDUM,LTMP,CHARAC,NCOUNT,1,IERR)
+      ITMP=0 ; IF (LTMP) ITMP=1 ; CALLMPI ( M_sum_i(W%WDES%COMM, ITMP, 1))
+      IF (ITMP>0) THEN
+        IF (IO%IU0>=0) &
+             WRITE(TIU0,*) 'soft stop encountered!  aborting job ...'
+        IF (IO%IU6>=0) &
+        WRITE(TIU6,*) 'soft stop encountered!  aborting job ...'
+
+        INFO%LSOFT=.TRUE.
+      ENDIF
+
+    IF (.NOT. LJ_ONLY) THEN
+!=======================================================================
+! do some check for occupation numbers (do we have enough bands]:
+!=======================================================================
+      IOCCUP=0
+      IOCCVS=0
+      SUMNEL=0._q
+      DO ISP=1,WDES%ISPIN
+      DO NN=1,KPOINTS%NKPTS
+         IF (ABS(W%FERTOT(WDES%NB_TOT,NN,ISP))>1.E-2_q) THEN
+            IOCCUP=IOCCUP+1
+! total occupancy ('number of electrons in this band'):
+            SUMNEL=SUMNEL+WDES%RSPIN*W%FERTOT(WDES%NB_TOT,NN,ISP)*KPOINTS%WTKPT(NN)
+            IF (IOCCUP<NTUTOR) THEN
+               ITUT(IOCCUP)=NN
+               RTUT(IOCCUP)=W%FERTOT(WDES%NB_TOT,NN,ISP)
+            ENDIF
+         ENDIF
+! count seperately 'seriously large occupations' ...
+         IF (ABS(W%FERTOT(WDES%NB_TOT,NN,ISP))>2.E-1_q) IOCCVS=IOCCVS+1
+      ENDDO
+      ENDDO
+
+      IF (((IOCCUP/=0).AND.(SUMNEL>1E-3_q)).OR.(IOCCVS/=0)) THEN
+         IOCC=MIN(IOCCUP+1,NTUTOR)
+         ITUT(IOCC)=WDES%NB_TOT
+         RTUT(IOCC)=SUMNEL
+         CALL VTUTOR('U','HIGHEST BANDS OCCUPIED', &
+     &               RTUT,IOCC,ITUT,IOCC,CDUM,1,LDUM,1,IO%IU6,IO%IDIOT)
+         CALL VTUTOR('U','HIGHEST BANDS OCCUPIED', &
+     &               RTUT,1,ITUT,IOCC,CDUM,1,LDUM,1,IO%IU0,IO%IDIOT)
+! no matter how the IO%IDIOT-flag is set: for seriously large occupations
+! give always a message to the user because this is very important!!
+         IF ((IO%IDIOT<=0).AND.((IOCCVS/=0).OR.(SUMNEL>1E-2_q))) THEN
+            CALL VTUTOR('U','HIGHEST BANDS OCCUPIED', &
+     &                  RTUT,IOCC,ITUT,IOCC,CDUM,1,LDUM,1,IO%IU6,1)
+            CALL VTUTOR('U','HIGHEST BANDS OCCUPIED', &
+     &                  RTUT,1,ITUT,IOCC,CDUM,1,LDUM,1,IO%IU0,1)
+         ENDIF
+      ELSE IF (IOCCUP/=0) THEN
+! for less serious occupancies give just some 'good advice' ...
+         IOCC=MIN(IOCCUP+1,NTUTOR)
+         ITUT(IOCC)=WDES%NB_TOT
+         RTUT(IOCC)=SUMNEL
+         CALL VTUTOR('A','HIGHEST BANDS OCCUPIED', &
+     &               RTUT,IOCC,ITUT,IOCC,CDUM,1,LDUM,1,IO%IU6,IO%IDIOT)
+         CALL VTUTOR('A','HIGHEST BANDS OCCUPIED', &
+     &               RTUT,1,ITUT,IOCC,CDUM,1,LDUM,1,IO%IU0,IO%IDIOT)
+      ENDIF
+
+! Okay when we arrive here first then we got it for the first ionic
+! configuration and if more steps follow we might not need any further
+! 'delay' switching on the selfconsistency? (if NELMDL<0 switch off!).
+      IF (INFO%NELMDL<0) INFO%NELMDL=0
+
+! calculation partial DOS
+      IF (IO%LORBIT>=10) THEN
+         CALL SPHPRO_FAST( &
+          GRID,LATT_CUR, P,T_INFO,W, WDES, 71,IO%IU6,&
+          INFO%LOVERL,LMDIM,CQIJ, LDIMP, LDIMP,LMDIMP,.FALSE., IO%LORBIT,PAR, &
+          EFERMI, KPOINTS%EMIN, KPOINTS%EMAX)
+      ENDIF
+!***********************************************************************
+!***********************************************************************
+! Now perform the ion movements:
+!***********************************************************************
+!***********************************************************************
+
+!====================== FORCES+STRESS ==================================
+!
+!=======================================================================
+      NORDER=0
+      IF (KPOINTS%ISMEAR>=0) NORDER=KPOINTS%ISMEAR
+
+ 7261 FORMAT(/ &
+     &        A/ &
+     &        '  ---------------------------------------------------'/ &
+     &        '  free  energy   TOTEN  = ',F18.8,' eV'// &
+     &        '  energy  without entropy=',F18.8, &
+     &        '  energy(sigma->0) =',F18.8)
+
+      ! no forces for OEP methods (EXXOEP/=0)
+      ! no forces for IALGO=1-4
+      ! no forces if potential was read in INFO%INICHG==4
+      ! no forces if inner eigenvalue solver are used
+      ! no forces for RPA (has already been done)
+      IF ( EXXOEP==0 .AND.  (INFO%LONESW .OR. INFO%LDIAG .OR. INFO%IALGO>4) & 
+           .AND. INFO%INICHG/=4 .AND. INFO%IHARMONIC==0 .AND. (.NOT. LCHI)) THEN
+        CALL FORCE_AND_STRESS( &
+          KINEDEN,HAMILTONIAN,P,WDES,NONLR_S,NONL_S,W,LATT_CUR, &
+          T_INFO,T_INFO,DYN,INFO,IO,MIX,SYMM,GRID,GRID_SOFT, &
+          GRIDC,GRIDB,GRIDUS,C_TO_US,B_TO_C,SOFT_TO_C, &
+          CHTOT,CHTOTL,DENCOR,CVTOT,CSTRF, &
+          CDIJ,CQIJ,CRHODE,N_MIX_PAW,RHOLM,RHOLM_LAST, &
+          CHDEN,SV, &
+          LMDIM, IRDMAX, (NSTEP==1 .OR.NSTEP==DYN%NSW).OR.IO%NWRITE>=1, &
+          DYN%ISIF/=0, DYN%ISIF/=0,.TRUE.,  &
+          XCSIF, EWSIF, TSIF, EWIFOR, TIFOR, PRESS, TOTEN, KPOINTS )
+      ENDIF
+
+!     trigger calculation of ensemble energies in next call to POTLOK
+#ifdef libbeef
+      IF(LBEEFENS) LBEEFCALCBASIS = .TRUE.
+#endif
+
+      IF (IO%IU6>=0) THEN
+         WRITE(TIU6,130)
+         WRITE(TIU6,7261) '  FREE ENERGIE OF THE ION-ELECTRON SYSTEM (eV)', & 
+            TOTEN,TOTEN-E%EENTROPY,TOTEN-E%EENTROPY/(2+NORDER)
+      ENDIF
+
+      IF (DYN%PSTRESS/=0) THEN
+         TOTEN=TOTEN+DYN%PSTRESS/(EVTOJ*1E22_q)*LATT_CUR%OMEGA
+
+         IF (IO%IU6>=0) &
+              WRITE(TIU6,7264) TOTEN,DYN%PSTRESS/(EVTOJ*1E22_q)*LATT_CUR%OMEGA
+ 7264    FORMAT ('  enthalpy is  TOTEN    = ',F18.8,' eV   P V=',F18.8/)
+
+      ELSE
+         IF (IO%IU6>=0) WRITE(TIU6,*)
+      ENDIF
+
+      CALL XML_TAG("structure")
+      CALL XML_CRYSTAL(LATT_CUR%A, LATT_CUR%B, LATT_CUR%OMEGA)
+      CALL XML_POSITIONS(T_INFO%NIONS, DYN%POSION)
+      CALL XML_CLOSE_TAG("structure")
+      CALL XML_FORCES(T_INFO%NIONS, TIFOR)
+      IF (DYN%ISIF/=0) THEN
+         CALL XML_STRESS(TSIF*EVTOJ*1E22_q/LATT_CUR%OMEGA)
+      ENDIF
+
+
+! check the consistency of forces and total energy
+      CALL CHECK(T_INFO%NIONS,DYN%POSION,TIFOR,EWIFOR,TOTEN,E%TEWEN,LATT_CUR%A,IO%IU6) 
+      IF (IO%IU6>=0) WRITE(IO%IU6,130)
+
+!-----------------------------------------------------------------------
+! we have maybe to update CVTOT here (which might have been destroyed
+!  by the force routines)
+!-----------------------------------------------------------------------
+      IF (LVCADER) THEN
+         ! derivative with respect to VCA parameters
+         CALL VCA_DER( & 
+              HAMILTONIAN,KINEDEN, &
+              P,WDES,NONLR_S,NONL_S,W,LATT_CUR, &
+              T_INFO,INFO,IO,KPOINTS,GRID,GRID_SOFT, &
+              GRIDC,GRIDUS,C_TO_US,SOFT_TO_C,SYMM, &
+              CHTOT,DENCOR,CVTOT,CSTRF, &
+              CDIJ,CQIJ,CRHODE,N_MIX_PAW,RHOLM, &
+              CHDEN,SV,DOS,DOSI,CHAM, &
+              LMDIM,IRDMAX,NEDOS)
+          CALL STOP_TIMING("G",TIU6,'VCADER')
+      ENDIF
+
+      IF (.NOT.INFO%LPOTOK) THEN
+
+
+      CALL POTLOK(GRID,GRIDC,GRID_SOFT, WDES%COMM_INTER, WDES,  &
+                  INFO,P,T_INFO,E,LATT_CUR, &
+                  CHTOT,CSTRF,CVTOT,DENCOR,SV, SOFT_TO_C,XCSIF)
+
+      CALL POTLOK_METAGGA(KINEDEN, &
+                  GRID,GRIDC,GRID_SOFT,WDES%COMM_INTER,WDES,INFO,P,T_INFO,E,LATT_CUR, &
+                  CHDEN,CHTOT,DENCOR,CVTOT,SV,HAMILTONIAN%MUTOT,HAMILTONIAN%MU,SOFT_TO_C,XCSIF)
+
+      CALL SETDIJ(WDES,GRIDC,GRIDUS,C_TO_US,LATT_CUR,P,T_INFO,INFO%LOVERL, &
+                  LMDIM,CDIJ,CQIJ,CVTOT,IRDMAA,IRDMAX)
+
+      CALL SETDIJ_AVEC(WDES,GRIDC,GRIDUS,C_TO_US,LATT_CUR,P,T_INFO,INFO%LOVERL, &
+                  LMDIM,CDIJ,HAMILTONIAN%AVTOT, NONLR_S, NONL_S, IRDMAX)
+
+      CALL SET_DD_MAGATOM(WDES, T_INFO, P, LMDIM, CDIJ)
+
+      CALL SET_DD_PAW(WDES, P , T_INFO, INFO%LOVERL, &
+         WDES%NCDIJ, LMDIM, CDIJ, RHOLM, CRHODE, &
+         E, LMETA=.FALSE., LASPH =INFO%LASPH, LCOREL=.FALSE.)
+
+      CALL UPDATE_CMBJ(GRIDC,T_INFO,LATT_CUR,IO%IU6)
+
+      CALL STOP_TIMING("G",TIU6,'POTLOK')
+
+      ENDIF
+
+      CALL EGRAD_EFG_PW_HAR_ONLY(T_INFO,LATT_CUR,WDES,GRIDC,P,CSTRF,CHTOT(:,1))
+      CALL EGRAD_WRITE_EFG(T_INFO,WDES,IO)
+
+      IF (WDES%NCDIJ>1) THEN
+         CALL HYPERFINE_PW(T_INFO,LATT_CUR,GRIDC,CHTOT(:,2))
+         CALL HYPERFINE_WRITE_TENSORS(T_INFO,WDES,IO)
+      ENDIF
+
+      IF (WDES%ISPIN==2) THEN
+         CALL DMATRIX_CALC(WDES,W,T_INFO,LATT_CUR,P,NONL_S,NONLR_S,GRID,GRIDC,CHTOT,LMDIM,CRHODE,IO%IU6,IO%IU0)
+      ENDIF
+
+!=======================================================================
+!
+!  electronic polarisation
+! 
+!=======================================================================
+      IF (LBERRY) THEN
+      io_begin
+         IF (IO%IU6>=0) THEN
+            WRITE(TIU6,7230) IGPAR,NPPSTR
+         ENDIF
+      io_end
+         CALL BERRY(WDES,W,GRID,GRIDC,GRIDUS,C_TO_US,LATT_CUR,KPOINTS, &
+           IGPAR,NPPSTR,P,T_INFO,LMDIM,CQIJ,IRDMAX,INFO%LOVERL,IO%IU6, &
+           DIP%POSCEN)
+      ENDIF
+
+ 7230 FORMAT(/' Berry-Phase calculation of electronic polarization'// &
+     &        '   IGPAR = ',I1,'   NPPSTR = ',I4/)
+      IF (IO%IU6>=0) WRITE(TIU6,130)
+
+      IF (LWANNIER()) THEN
+         CALL LOCALIZE(W,WDES,GRID,GRIDC,GRIDUS,C_TO_US,LATT_CUR,T_INFO,P, &
+        &     LMDIM,INFO%LOVERL,IRDMAX,IO%IU0,IO%IU6)
+      ENDIF
+      IF ( (DYN%IBRION /= -1 .AND. DYN%IBRION /=8 .AND. DYN%IBRION /=7) .AND. LEPSILON ) THEN
+         ! if LEPSILON is set LR_SKELETON is called every NBLOCK*KBLOCK steps
+         ! to calculate autocorrelation functions of the polarization
+         IF (MOD(NSTEP-1,DYN%NBLOCK*DYN%KBLOCK)==0) THEN
+            CALL LR_SKELETON( &
+              KINEDEN,HAMILTONIAN,P,WDES,NONLR_S,NONL_S,W,LATT_CUR,LATT_INI, &
+              T_INFO,DYN,INFO,IO,MIX,KPOINTS,SYMM,GRID,GRID_SOFT, &
+              GRIDC,GRIDB,GRIDUS,C_TO_US,B_TO_C,SOFT_TO_C,E, &
+              CHTOT,CHTOTL,DENCOR,CVTOT,CSTRF, &
+              CDIJ,CQIJ,CRHODE,N_MIX_PAW,RHOLM,RHOLM_LAST, &
+              CHDEN,SV,DOS,DOSI,CHAM, &
+              DYN%IBRION,LMDIM,IRDMAX,NEDOS, &
+              TOTEN,EFERMI, TIFOR, LFAST=.TRUE. )
+         ENDIF
+
+         CALL STORE_DIPOLE_AND_AUTOCORRELATE( T_INFO, LATT_CUR, DYN%POTIM, DYN%NSW, NSTEP, IO)
+      ENDIF
+!=======================================================================
+! add chain forces and constrain forces
+!=======================================================================
+      CALL VCA_FORCE(T_INFO, TIFOR)
+
+      IF (DYN%IBRION /=5 .AND. DYN%IBRION /=6  .AND. DYN%IBRION /=7 ) &
+      CALL SET_SELECTED_FORCES_ZERO(T_INFO,DYN%VEL,TIFOR,LATT_CUR)
+
+      ! scale forces and total energy by scaling argument
+      ! this allows  integration from ideal gas to liquid state
+      ! alternatively if the DYNMATFULL file exists add forces from
+      ! second order Hessian matrix (allows thermodynamic integration from 
+      ! harmonic model)
+      ! maybe this should go over to the force.F file
+      ! of course it is unique since it  changes radically energy
+      CALL DYNMATFULL_ENERGY_FORCE(SCALEE, T_INFO%NIONS, DYN%POSION, TOTEN, TIFOR, LATT_CUR%A , IO%IU0)
+      IF (SCALEE/=1) THEN
+         EENTROPY=E%EENTROPY*SCALEE
+         IF (IO%IU6>=0) WRITE(TIU6,7261) '  SCALED FREE ENERGIE OF THE ION-ELECTRON SYSTEM (eV)', & 
+            TOTEN,TOTEN-EENTROPY,TOTEN-EENTROPY/(2+NORDER)
+      ENDIF
+
+      CALL CHAIN_FORCE(T_INFO%NIONS,DYN%POSION,TOTEN,TIFOR, &
+           LATT_CUR%A,LATT_CUR%B,IO%IU6)
+
+      CALL PARALLEL_TEMPERING(NSTEP,T_INFO%NIONS,DYN%POSION,DYN%VEL,TOTEN,TIFOR,DYN%TEBEG,DYN%TEEND, &
+           LATT_CUR%A,LATT_CUR%B,IO%IU6)
+
+      IF (DYN%IBRION /=5 .AND. DYN%IBRION /=6 .AND. DYN%IBRION /=7 ) &
+      CALL SET_SELECTED_FORCES_ZERO(T_INFO,DYN%VEL,TIFOR,LATT_CUR)
+  
+      EKIN=0
+      EKIN_LAT=0
+      TEIN=0
+      ES =0
+      EPS=0
+
+!     CYCLE ion ! if uncommented VASP iterates forever without ionic upd
+
+      DO I=1,WDES%NCDIJ
+         RHOTOT(I)=RHO0(GRIDC, CHTOT(1,I))
+      END DO
+    END IF ! LJ_ONLY
+
+      IF (LJ_IS_ACTIVE()) THEN
+        !FIXME: TOTEN should be declared explicitly
+        TOTEN = 0.0_q
+        CALL FORCE_AND_STRESS_LJ(GRIDC,IO,WDES,P,LATT_CUR,DYN,T_INFO,TSIF,TIFOR,TOTEN)
+
+        IF (DYN%IBRION /=5 .AND. DYN%IBRION /=6 .AND. DYN%IBRION /=7 ) &
+          CALL SET_SELECTED_FORCES_ZERO(T_INFO,DYN%VEL,TIFOR,LATT_CUR)
+      END IF
+
+      DYN%AC=  LATT_CUR%A
+
+    IF (.NOT. LJ_ONLY) THEN
+!=======================================================================
+!
+! write statement for static calculations with possibly extensive
+! post processing (GW, dielectric response, ...)
+! 
+!=======================================================================
+      IF (DYN%IBRION/=0) THEN
+         CALL XML_TAG("energy")
+         EENTROPY=E%EENTROPY*SCALEE
+         CALL XML_ENERGY(TOTEN,TOTEN-EENTROPY/(2+NORDER),EENTROPY)
+         CALL XML_CLOSE_TAG
+      ENDIF
+
+      IF (DYN%IBRION==-1 .OR. DYN%IBRION==5 .OR. DYN%IBRION==6 .OR. &
+           DYN%IBRION==7.OR.DYN%IBRION==8 .OR. DYN%IBRION==9 .OR. DYN%IBRION==19) THEN
+         EENTROPY=E%EENTROPY*SCALEE
+         io_begin
+         WRITE(17 ,7281,ADVANCE='NO') NSTEP,TOTEN, &
+              TOTEN-EENTROPY/(2+NORDER),EENTROPY
+         IF (IO%IU0>=0) &
+              WRITE(TIU0,7281,ADVANCE='NO') NSTEP,TOTEN, &
+              TOTEN-EENTROPY/(2+NORDER),EENTROPY
+
+         IF ( WDES%NCDIJ>=2 ) THEN
+           WRITE(17,77281) RHOTOT(2:WDES%NCDIJ)
+           IF (IO%IU0>=0) WRITE(TIU0,77281) RHOTOT(2:WDES%NCDIJ)
+         ELSE
+           WRITE(17,*)
+           IF (IO%IU0>=0) WRITE(TIU0,*)
+         ENDIF
+
+         IF (M_CONSTRAINED()) CALL WRITE_CONSTRAINED_M(17,.TRUE.)
+
+         io_end
+      ENDIF
+    END IF ! LJ_ONLY
+!=======================================================================
+! IBRION = 0  molecular dynamics
+! ------------------------------
+! ) calculate the accelerations in reduced units
+!   the scaling is brain-damaging, so here it is in a more native form
+!    convert dE/dr from EV/Angst to J/m   EVTOJ/1E-10
+!    divide by mass                       1/T_INFO%POMASS*AMTOKG
+!    multiply by timestep*2               (DYN%POTIM*1E-15)**2
+! ) transform to direct mesh KARDIR
+! ) integrate the equations of motion for the ions using nose dynamic
+!   and a predictor-corrector scheme
+!=======================================================================
+ibrion: IF (DYN%IBRION==0) THEN
+
+        FACT=(DYN%POTIM**2)*EVTOJ/AMTOKG *1E-10_q
+        NI=1
+        DO NT=1,T_INFO%NTYP
+        DO NI=NI,T_INFO%NITYP(NT)+NI-1
+          DYN%D2C(1,NI)=TIFOR(1,NI)*FACT/2/T_INFO%POMASS(NT)
+          DYN%D2C(2,NI)=TIFOR(2,NI)*FACT/2/T_INFO%POMASS(NT)
+          DYN%D2C(3,NI)=TIFOR(3,NI)*FACT/2/T_INFO%POMASS(NT)
+        ENDDO
+        ENDDO
+
+        CALL KARDIR(T_INFO%NIONS,DYN%D2C,LATT_CUR%B)
+
+        ISCALE=0
+        IF (DYN%SMASS==-1 .AND. MOD(NSTEP-1,DYN%NBLOCK)==0 ) THEN
+          ISCALE=1
+        ENDIF
+
+        DYN%TEMP=DYN%TEBEG+(DYN%TEEND-DYN%TEBEG)*NSTEP/ABS(DYN%NSW)
+
+#ifdef tbdyn
+        IF (NSTEP==1) THEN
+           IF (IO%IU6>0) THEN
+             WRITE(IO%IU6,ADVANCE='NO',FMT='(3X,A22)') '        RANDOM_SEED = '
+             DO i=1,K_SEED
+               WRITE(IO%IU6,ADVANCE='NO',FMT='(X,I16)') SEED_INIT(i)
+             ENDDO
+             WRITE(IO%IU6,ADVANCE='NO',FMT='(/)')
+
+             WRITE(g_io%REPORT,ADVANCE='NO',FMT='(3X,A22)') '        RANDOM_SEED = '
+             DO i=1,K_SEED
+               WRITE(g_io%REPORT,ADVANCE='NO',FMT='(X,I16)') SEED_INIT(i)
+             ENDDO
+             WRITE(g_io%REPORT,ADVANCE='NO',FMT='(/)')
+           ENDIF
+        ENDIF
+
+        CALL STEP_tb(DYN,T_INFO,INFO,LATT_CUR,EKIN,EKIN_LAT,EPS,ES,DISMAX,NDEGREES_OF_FREEDOM,&
+                          IO,TOTEN,g_io,WDES,TSIF,ISCALE,TEIN,TIFOR)
+
+
+        CALL RANE_ION(RDUM,GET=SEED(1:K_SEED))
+
+        IF (IO%IU6>0) THEN
+           WRITE(IO%IU6,ADVANCE='NO',FMT='(3X,A22)') '        RANDOM_SEED = '
+           DO i=1,K_SEED
+              WRITE(IO%IU6,ADVANCE='NO',FMT='(X,I16)') SEED(i)
+           ENDDO
+           WRITE(IO%IU6,ADVANCE='NO',FMT='(/)')
+
+           WRITE(g_io%REPORT,ADVANCE='NO',FMT='(/,3X,A22)')  '        RANDOM_SEED = '
+           DO i=1,K_SEED
+             WRITE(g_io%REPORT,ADVANCE='NO',FMT='(X,I16)') SEED(i)
+           ENDDO
+           WRITE(g_io%REPORT,ADVANCE='NO',FMT='(/)')
+        ENDIF
+#else
+        IF (.NOT. T_INFO%LSDYN) THEN
+           CALL SYMVEL (T_INFO%NIONS,T_INFO%NTYP,T_INFO%ITYP,T_INFO%POMASS, &
+           DYN%POSION,DYN%D2C,LATT_CUR%A,LATT_CUR%B)
+        ENDIF
+
+        CALL STEP(DYN%INIT,ISCALE,T_INFO%NIONS,LATT_CUR%A,LATT_CUR%ANORM,DYN%D2C,DYN%SMASS,DYN%POSION,DYN%POSIOC, &
+             DYN%POTIM,T_INFO%POMASS,T_INFO%NTYP,T_INFO%ITYP,DYN%TEMP,DYN%VEL,DYN%D2,DYN%D3,DYN%SNOSE, &
+             EKIN,EPS,ES,DISMAX,NDEGREES_OF_FREEDOM, IO%IU6)
+
+        TEIN = 2*EKIN/BOLKEV/NDEGREES_OF_FREEDOM
+#endif
+        CALL STOP_TIMING("G",TIU6,'IONSTEP')
+
+! sum energy of images along chain
+
+        CALLMPI_C( sum_chain( TOTEN ))
+        CALLMPI_C( sum_chain( EKIN ))
+        CALLMPI_C( sum_chain( EKIN_LAT ))
+        CALLMPI_C( sum_chain( ES ))
+        CALLMPI_C( sum_chain( EPS ))
+
+        ETOTAL=TOTEN+EKIN+ES+EPS
+
+!  report  energy  of electrons + kinetic energy + nose-energy
+        io_begin
+
+        WRITE(TIU6,7260) TOTEN,EKIN-EKIN_LAT,EKIN_LAT,TEIN,ES,EPS,ETOTAL
+
+        CALL OFIELD_WRITE(TIU6)
+        IF (LJ_IS_ACTIVE()) THEN
+          WRITE(TIU6, 7262) TEIN * BOLKEV / LJ_EPSILON
+    7262  FORMAT('  reduced temperature T*= ',F16.6, ' eps/DOF'/)
+        END IF
+
+
+        CALL XML_TAG("energy")
+        CALL XML_ENERGY(TOTEN,TOTEN-E%EENTROPY/(2+NORDER),E%EENTROPY)
+        CALL XML_TAG_REAL("kinetic",EKIN-EKIN_LAT)
+        CALL XML_TAG_REAL("lattice kinetic",EKIN_LAT)
+        CALL XML_TAG_REAL("nosepot",ES)
+        CALL XML_TAG_REAL("nosekinetic",EPS)
+        CALL XML_TAG_REAL("total",ETOTAL)
+        CALL XML_CLOSE_TAG
+
+        WRITE(17,7280,ADVANCE='NO') NSTEP,TEIN,ETOTAL,TOTEN, &
+             TOTEN-E%EENTROPY/(2+NORDER),EKIN,ES,EPS
+        IF (IO%IU0>=0) &
+             WRITE(TIU0,7280,ADVANCE='NO')NSTEP,TEIN,ETOTAL,TOTEN, &
+             TOTEN-E%EENTROPY/(2+NORDER),EKIN,ES,EPS         
+        IF (WDES%NCDIJ>=2) THEN
+           WRITE(17,77280) RHOTOT(2:WDES%NCDIJ)
+           IF (IO%IU0>=0) WRITE(TIU0,77280) RHOTOT(2:WDES%NCDIJ)
+        ELSE
+           WRITE(17,*)
+           IF (IO%IU0>=0) WRITE(TIU0,*)
+        ENDIF
+
+    IF (.NOT. LJ_ONLY) THEN
+        WRITE(TIU6,7270) DISMAX
+    END IF        
+        io_end
+
+7260  FORMAT(/ &
+     &        '  ENERGY OF THE ELECTRON-ION-THERMOSTAT SYSTEM (eV)'/ &
+     &        '  ---------------------------------------------------'/ &
+     &        '% ion-electron   TOTEN  = ',F16.6,'  see above'/ &
+     &        '  kinetic energy EKIN   = ',F16.6/ &
+     &        '  kin. lattice  EKIN_LAT= ',F16.6, &
+     &        '  (temperature',F8.2,' K)'/ &
+     &        '  nose potential ES     = ',F16.6/ &
+     &        '  nose kinetic   EPS    = ',F16.6/ &
+     &        '  ---------------------------------------------------'/ &
+     &        '  total energy   ETOTAL = ',F16.6,' eV'/)
+
+ 7270 FORMAT( '  maximum distance moved by ions :',E14.2/)
+
+ 7280 FORMAT(I5,' T= ',F6.0,' E= ',E14.8, &
+     &   ' F= ',E14.8,' E0= ',E14.8,1X,' EK= ',E11.5, &
+     &   ' SP= ',E8.2,' SK= ',E8.2)
+77280 FORMAT(' mag=',3F11.3)
+
+!=======================================================================
+! DYN%IBRION =
+! 1  quasi-Newton algorithm
+! 2  conjugate gradient
+! 3  quickmin
+! 4  not supported yet
+! 5  finite differences
+! 6  finite differences with symmetry
+! 7  linear response
+!  IBRION ==5 finite differences
+!=======================================================================
+      ELSE IF (DYN%IBRION==5) THEN ibrion
+       IF (.NOT. LJ_ONLY) THEN
+        DYN%POSIOC=DYN%POSION
+        CALL FINITE_DIFF( INFO%LSTOP, DYN%POTIM, T_INFO%NIONS, T_INFO%NTYP, &
+             T_INFO%NITYP, T_INFO%POMASS, DYN%POSION, TIFOR, DYN%NFREE, &
+             T_INFO%LSDYN,T_INFO%LSFOR, LATT_CUR%A, LATT_CUR%B,  &
+             IO%IU6, IO%IU0 , IO%NWRITE)
+        CALL LATTIC(LATT_CUR)
+        ! we need to reinitialise the symmetry code at this point
+        ! the number of k-points is changed on the fly
+        IF (SYMM%ISYM>0) THEN
+          CALL INISYM(LATT_CUR%A,DYN%POSION,DYN%VEL,T_INFO%LSFOR, &
+             T_INFO%LSDYN,T_INFO%NTYP,T_INFO%NITYP,NIOND, &
+             SYMM%PTRANS,SYMM%NROT,SYMM%NPTRANS,SYMM%ROTMAP,SYMM%TAU,SYMM%TAUROT,SYMM%WRKROT, &
+             SYMM%INDROT,T_INFO%ATOMOM,WDES%SAXIS,SYMM%MAGROT,NCDIJ,IO%IU6)
+#ifdef oldsym
+          CALL RE_READ_KPOINTS(KPOINTS,LATT_CUR, &
+               SYMM%ISYM>=0.AND..NOT.WDES%LSORBIT.AND..NOT.WDES%LSPIRAL, &
+               T_INFO%NIONS,SYMM%ROTMAP,SYMM%MAGROT,SYMM%ISYM,IO%IU6,IO%IU0)
+#else
+          CALL RE_READ_KPOINTS(KPOINTS,LATT_CUR, &
+               SYMM%ISYM>=0.AND..NOT.WDES%LNONCOLLINEAR, &
+               T_INFO%NIONS,SYMM%ROTMAP,SYMM%MAGROT,SYMM%ISYM,IO%IU6,IO%IU0)
+#endif
+          CALL KPAR_SYNC_ALL(WDES,W)
+          CALL RE_GEN_LAYOUT( GRID, WDES, KPOINTS, LATT_CUR, LATT_INI, IO%IU6, IO%IU0)
+          CALL REALLOCATE_WAVE( W, GRID, WDES, NONL_S, T_INFO, P, LATT_CUR)
+          IF (INFO%LONESW) THEN
+             CALL DEALLOCW(W_F)
+             CALL DEALLOCW(W_G)
+             DEALLOCATE(CHAM, CHF)
+             CALL ALLOCW(WDES,W_F,WTMP,WTMP)
+             CALL ALLOCW(WDES,W_G,WTMP,WTMP)
+             ALLOCATE(CHAM(WDES%NB_TOT,WDES%NB_TOT,WDES%NKPTS,WDES%ISPIN), &
+               CHF (WDES%NB_TOT,WDES%NB_TOT,WDES%NKPTS,WDES%ISPIN))
+          ENDIF
+        ENDIF
+       END IF !LJ_ONLY
+      ELSE IF (DYN%IBRION==6) THEN ibrion
+       IF (.NOT. LJ_ONLY) THEN
+        DYN%POSIOC=DYN%POSION
+        CALL FINITE_DIFF_ID( INFO%LSTOP, DYN%POTIM, T_INFO,  &
+             DYN%POSION, TOTEN, TIFOR, TSIF, DYN%NFREE, &
+             DYN%ISIF>=3, LATT_CUR%A, LATT_CUR%B, WDES%SAXIS, SYMM, NCDIJ, &
+             ISPECIAL, DYN%TEBEG, IO%IU6, IO%IU0 , IO%NWRITE)
+        CALL LATTIC(LATT_CUR)
+        ! we need to reinitialise the symmetry code at this point
+        ! the number of k-points is changed on the fly
+        IF (SYMM%ISYM>0) THEN
+          CALL INISYM(LATT_CUR%A,DYN%POSION,DYN%VEL,T_INFO%LSFOR, &
+             T_INFO%LSDYN,T_INFO%NTYP,T_INFO%NITYP,NIOND, &
+             SYMM%PTRANS,SYMM%NROT,SYMM%NPTRANS,SYMM%ROTMAP,SYMM%TAU,SYMM%TAUROT,SYMM%WRKROT, &
+             SYMM%INDROT,T_INFO%ATOMOM,WDES%SAXIS,SYMM%MAGROT,NCDIJ,IO%IU6)
+#ifdef oldsym
+          CALL RE_READ_KPOINTS(KPOINTS,LATT_CUR, &
+               SYMM%ISYM>=0.AND..NOT.WDES%LSORBIT.AND..NOT.WDES%LSPIRAL, &
+               T_INFO%NIONS,SYMM%ROTMAP,SYMM%MAGROT,SYMM%ISYM,IO%IU6,IO%IU0)
+#else
+          CALL RE_READ_KPOINTS(KPOINTS,LATT_CUR, &
+               SYMM%ISYM>=0.AND..NOT.WDES%LNONCOLLINEAR, &
+               T_INFO%NIONS,SYMM%ROTMAP,SYMM%MAGROT,SYMM%ISYM,IO%IU6,IO%IU0)
+#endif
+          CALL KPAR_SYNC_ALL(WDES,W)
+          CALL RE_GEN_LAYOUT( GRID, WDES, KPOINTS, LATT_CUR, LATT_INI, IO%IU6, IO%IU0)
+          CALL REALLOCATE_WAVE( W, GRID, WDES, NONL_S, T_INFO, P, LATT_CUR)
+          IF (INFO%LONESW) THEN
+             CALL DEALLOCW(W_F)
+             CALL DEALLOCW(W_G)
+             DEALLOCATE(CHAM, CHF)
+             CALL ALLOCW(WDES,W_F,WTMP,WTMP)
+             CALL ALLOCW(WDES,W_G,WTMP,WTMP)
+             ALLOCATE(CHAM(WDES%NB_TOT,WDES%NB_TOT,WDES%NKPTS,WDES%ISPIN), &
+             CHF (WDES%NB_TOT,WDES%NB_TOT,WDES%NKPTS,WDES%ISPIN))
+          ENDIF
+        ENDIF
+       END IF !LJ_ONLY
+
+      ELSE IF (DYN%IBRION==7.OR.DYN%IBRION==8.OR.DYN%IBRION==9 .OR.DYN%IBRION==19) THEN ibrion
+
+       IF (.NOT. LJ_ONLY) THEN
+         CALL LR_SKELETON( &
+          KINEDEN,HAMILTONIAN,P,WDES,NONLR_S,NONL_S,W,LATT_CUR,LATT_INI, &
+          T_INFO,DYN,INFO,IO,MIX,KPOINTS,SYMM,GRID,GRID_SOFT, &
+          GRIDC,GRIDB,GRIDUS,C_TO_US,B_TO_C,SOFT_TO_C,E, &
+          CHTOT,CHTOTL,DENCOR,CVTOT,CSTRF, &
+          CDIJ,CQIJ,CRHODE,N_MIX_PAW,RHOLM,RHOLM_LAST, &
+          CHDEN,SV,DOS,DOSI,CHAM, &
+          DYN%IBRION,LMDIM,IRDMAX,NEDOS, &
+          TOTEN,EFERMI, TIFOR)
+
+       END IF ! LJ_ONLY
+!=======================================================================
+! meaning of DYN%ISIF :
+!  DYN%ISIF  calculate                           relax
+!        force     stress                    ions      lattice
+!   0     X                                   X
+!   1     X        uniform                    X
+!   2     X          X                        X
+!   3     X          X                        X          X
+!   4     X          X                        X          X **
+!   5     X          X                                   X **
+!   6     X          X                                   X
+!   7     X          X                                  uniform
+!
+!   **  for DYN%ISIF=4 & DYN%ISIF=5 isotropic pressure will be subtracted
+!       (-> cell volume constant, optimize only the cell shape)
+!
+!=======================================================================
+      ELSE IF (DYN%IBRION>0) THEN ibrion
+       IF (.NOT. LJ_ONLY) THEN
+! sum energy of images along chain
+        EENTROPY=E%EENTROPY*SCALEE
+        
+        IF (IMAGES==0) THEN
+           CALLMPI_C( sum_chain( TOTEN ))
+           CALLMPI_C( sum_chain( EENTROPY ))
+        ENDIF
+
+        io_begin
+        WRITE(17,7281,ADVANCE='NO') NSTEP,TOTEN, &
+             TOTEN-EENTROPY/(2+NORDER),TOTEN-TOTENG
+        IF (IO%IU0>=0) &
+             WRITE(TIU0,7281,ADVANCE='NO')NSTEP,TOTEN, &
+             TOTEN-EENTROPY/(2+NORDER),TOTEN-TOTENG
+
+        IF ( WDES%NCDIJ>=2 ) THEN
+           WRITE(17,77281) RHOTOT(2:WDES%NCDIJ) 
+           IF (IO%IU0>=0) WRITE(TIU0,77281) RHOTOT(2:WDES%NCDIJ)
+        ELSE
+           WRITE(17,*)
+           IF (IO%IU0>=0) WRITE(TIU0,*)
+        ENDIF
+
+        io_end
+ 7281 FORMAT(I4,' F= ',E14.8,' E0= ',E14.8,1X,' d E =',E12.6)
+77281 FORMAT('  mag=',3F15.8)
+!-----------------------------------------------------------------------
+!  set DYN%D2C to forces in cartesian coordinates multiplied by FACT
+!  FACT is determined from timestep in a way, that a stable timestep
+!   gives a good trial step
+!-----------------------------------------------------------------------
+        FACT=0
+        IF (DYN%ISIF<5) FACT=10*DYN%POTIM*EVTOJ/AMTOKG *1E-10_q
+        LSTOP2=.TRUE.
+
+        NI=1
+        DO NT=1,T_INFO%NTYP
+        DO NI=NI,T_INFO%NITYP(NT)+NI-1
+           DYN%D2C(1,NI)=TIFOR(1,NI)*FACT
+           DYN%D2C(2,NI)=TIFOR(2,NI)*FACT
+           DYN%D2C(3,NI)=TIFOR(3,NI)*FACT
+           IF (SQRT(TIFOR(1,NI)**2+TIFOR(2,NI)**2+TIFOR(3,NI)**2) &
+                &       >ABS(DYN%EDIFFG)) LSTOP2=.FALSE.
+        ENDDO
+        ENDDO
+! for all DYN%ISIF greater or equal 3 cell shape optimisations will be done
+        FACTSI = 0
+        IF (DYN%ISIF>=3) FACTSI=10*DYN%POTIM*EVTOJ/AMTOKG/T_INFO%NIONS *1E-10_q
+
+        DO I=1,3
+        DO K=1,3
+           D2SIF(I,K)=TSIF(I,K)*FACTSI
+        ENDDO
+        D2SIF(I,I)=D2SIF(I,I)-DYN%PSTRESS/(EVTOJ*1E22_q)*LATT_CUR%OMEGA*FACTSI
+        ENDDO
+! For DYN%ISIF =4 or =5 we take only pure shear stresses: subtract pressure
+        IF ((DYN%ISIF==4).OR.(DYN%ISIF==5)) THEN
+           DO I=1,3
+              D2SIF(I,I)=D2SIF(I,I)-PRESS*FACTSI
+           ENDDO
+        ENDIF
+! For DYN%ISIF =7 take only pressure (volume relaxation)
+        IF (DYN%ISIF==7) THEN
+           DO I=1,3
+           DO J=1,3
+              D2SIF(J,I)=0
+           ENDDO
+           D2SIF(I,I)=PRESS*FACTSI
+           ENDDO
+        ENDIF
+
+        CALL CONSTR_CELL_RELAX(D2SIF)
+
+        IF (FACTSI/=0) THEN
+           DO I=1,3
+           DO J=1,3
+              IF (FACTSI/=0) THEN
+                 IF (ABS(D2SIF(J,I))/FACTSI/T_INFO%NIONS>ABS(DYN%EDIFFG)) LSTOP2=.FALSE.
+              ENDIF
+           ENDDO
+          ENDDO
+        ENDIF
+!-----------------------------------------------------------------------
+!  do relaxations using diverse algorithms
+!-----------------------------------------------------------------------
+        ! change of the energy between two ionic step used as stopping criterion
+        INFO%LSTOP=(ABS(TOTEN-TOTENG)<DYN%EDIFFG)
+        
+        CALLMPI_C ( and_chain( LSTOP2 ))
+        CALLMPI_C ( and_chain( INFO%LSTOP ))
+
+        ! IFLAG=0 means no reinit of wavefunction prediction
+        IFLAG=0
+        IF (DYN%IBRION==1) THEN
+           CALL BRIONS(T_INFO%NIONS,DYN%POSION,DYN%POSIOC,DYN%D2C,LATT_CUR%A,LATT_CUR%B,D2SIF, &
+                MAX(DYN%NSW+1,DYN%NFREE+1),DYN%NFREE,IO%IU6,IO%IU0,FACT,FACTSI,E1TEST)
+! Sometimes there is the danger that the optimisation scheme (especially
+! the Broyden scheme) fools itself by performing a 'too small' step - to
+! avoid this use a second break condition ('trial step energy change'):
+           INFO%LSTOP=INFO%LSTOP .AND. (ABS(E1TEST) < DYN%EDIFFG)
+! if we have very small forces (small trial energy change) we can stop
+           INFO%LSTOP=INFO%LSTOP .OR. (ABS(E1TEST) < 0.1_q*DYN%EDIFFG)
+           TOTENG=TOTEN
+!-----------------------------------------------------------------------
+        ELSE IF (DYN%IBRION==3 .AND. DYN%SMASS<=0) THEN
+           CALL ION_VEL_QUENCH(T_INFO%NIONS,LATT_CUR%A,LATT_CUR%B,IO%IU6,IO%IU0, &
+                T_INFO%LSDYN, &
+                DYN%POSION,DYN%POSIOC,FACT,DYN%D2C,FACTSI,D2SIF,DYN%D2,E1TEST)
+           IF (IFLAG==1) INFO%LSTOP=INFO%LSTOP .OR. (ABS(E1TEST) < 0.1_q*DYN%EDIFFG)
+           TOTENG=TOTEN
+!-----------------------------------------------------------------------
+        ELSE IF (DYN%IBRION==3) THEN
+           CALL IONDAMPED(T_INFO%NIONS,LATT_CUR%A,LATT_CUR%B,IO%IU6,IO%IU0, &
+                T_INFO%LSDYN, &
+                DYN%POSION,DYN%POSIOC,FACT,DYN%D2C,FACTSI,D2SIF,DYN%D2,E1TEST,DYN%SMASS)
+           IF (IFLAG==1) INFO%LSTOP=INFO%LSTOP .OR. (ABS(E1TEST) < 0.1_q*DYN%EDIFFG)
+           TOTENG=TOTEN
+!-----------------------------------------------------------------------
+        ELSE IF (DYN%IBRION==2) THEN
+           IFLAG=1
+           IF (NSTEP==1) IFLAG=0
+!  set accuracy of energy (determines whether cubic interpolation is used)
+           EACC=MAX(ABS(INFO%EDIFF),ABS(ECONV))
+
+           CALLMPI_C( sum_chain( EACC))
+           IF ( LHYPER_NUDGE() ) EACC=1E10    ! energy not very accurate, use only force
+
+           CALL IONCGR(IFLAG,T_INFO%NIONS,TOTEN,LATT_CUR%A,LATT_CUR%B,DYN%NFREE,DYN%POSION,DYN%POSIOC, &
+                FACT,DYN%D2C,FACTSI,D2SIF,DYN%D2,DYN%D3,DISMAX,IO%IU6,IO%IU0, &
+                EACC,DYN%EDIFFG,E1TEST,LSTOP2)
+!    if IFLAG=1 new trial step -> reinit of waveprediction
+           INFO%LSTOP=.FALSE.
+           IF (IFLAG==1) THEN
+              INFO%LSTOP=(ABS(TOTEN-TOTENG)<DYN%EDIFFG)
+              TOTENG=TOTEN
+           ENDIF
+           IF (IFLAG==2) INFO%LSTOP=.TRUE.
+! if we have very small forces (small trial energy change) we can stop
+           IF (IFLAG==1) INFO%LSTOP=INFO%LSTOP .OR. (ABS(E1TEST) < 0.1_q*DYN%EDIFFG)
+!tb start
+        ! dimer method
+        ELSE IF (DYN%IBRION==44) THEN
+           CALL dimer(DYN,T_INFO,INFO,LATT_CUR,IO,TOTEN,FACT,LSTOP2)
+           CALLMPI_C ( and_chain( LSTOP2 ))
+           CALLMPI_C ( and_chain( INFO%LSTOP ))
+           TOTENG=TOTEN
+
+        ! damped velocity Verler to calculate IRC (not optimization!!!)
+        ELSE IF (DYN%IBRION==40) THEN
+           FACT=(DYN%POTIM**2)*EVTOJ/AMTOKG *1E-10_q
+           NI=1
+           DO NT=1,T_INFO%NTYP
+             DO NI=NI,T_INFO%NITYP(NT)+NI-1
+               DYN%D2C(1,NI)=TIFOR(1,NI)*FACT/2/T_INFO%POMASS(NT)
+               DYN%D2C(2,NI)=TIFOR(2,NI)*FACT/2/T_INFO%POMASS(NT)
+               DYN%D2C(3,NI)=TIFOR(3,NI)*FACT/2/T_INFO%POMASS(NT)
+             ENDDO
+           ENDDO
+           CALL KARDIR(T_INFO%NIONS,DYN%D2C,LATT_CUR%B)
+
+           CALL dvv(DYN,T_INFO,INFO,LATT_CUR,IO,TOTEN,FACT)
+           FACT=10*DYN%POTIM*EVTOJ/AMTOKG *1E-10_q
+           NI=1
+           DO NT=1,T_INFO%NTYP
+             DO NI=NI,T_INFO%NITYP(NT)+NI-1
+               DYN%D2C(1,NI)=TIFOR(1,NI)*FACT
+               DYN%D2C(2,NI)=TIFOR(2,NI)*FACT
+               DYN%D2C(3,NI)=TIFOR(3,NI)*FACT
+             ENDDO
+           ENDDO
+           TOTENG=TOTEN
+!tb end
+
+!-----------------------------------------------------------------------
+! interactive mode
+!-----------------------------------------------------------------------
+        ELSE IF (DYN%IBRION==11) THEN
+           CALL INPOS(LATT_CUR, T_INFO, DYN, IO%IU6, IO%IU0, INFO%LSTOP, WDES%COMM)
+        ENDIF
+
+! restrict volume for constant volume relaxation
+        IF (DYN%ISIF==4 .OR. DYN%ISIF==5) THEN
+           OMEGA_OLD=LATT_CUR%OMEGA
+           CALL LATTIC(LATT_CUR)
+           SCALEQ=(ABS(OMEGA_OLD) / ABS(LATT_CUR%OMEGA))**(1._q/3._q)
+           DO I=1,3
+              LATT_CUR%A(1,I)=SCALEQ*LATT_CUR%A(1,I)
+              LATT_CUR%A(2,I)=SCALEQ*LATT_CUR%A(2,I)
+              LATT_CUR%A(3,I)=SCALEQ*LATT_CUR%A(3,I)
+           ENDDO
+        ENDIF
+        CALL LATTIC(LATT_CUR)
+!-----------------------------------------------------------------------
+!  reinitialize the prediction algorithm for the wavefunction if needed
+!-----------------------------------------------------------------------
+        PRED%INIPRE=3
+        IF ( PRED%IWAVPR >=12 .AND. &
+             &     (ABS(TOTEN-TOTENG)/T_INFO%NIONS>1.0_q .OR. IFLAG==1)) THEN
+           CALL WAVPRE_NOIO(GRIDC,P,PRED,T_INFO,W,WDES,LATT_CUR,IO%LOPEN, &
+                CHTOT,RHOLM,N_MIX_PAW, CSTRF, KINEDEN, LMDIM,CQIJ,INFO%LOVERL,IO%IU0)
+
+        ELSE IF ( PRED%IWAVPR >=2 .AND. PRED%IWAVPR <10   .AND. &
+             &     (ABS(TOTEN-TOTENG)/T_INFO%NIONS>1.0_q .OR. IFLAG==1)) THEN
+           CALL WAVPRE(GRIDC,P,PRED,T_INFO,W,WDES,LATT_CUR,IO%LOPEN, &
+                CHTOT,RHOLM,N_MIX_PAW, CSTRF, LMDIM,CQIJ,INFO%LOVERL,IO%IU0)
+        ENDIF
+
+        ! use forces as stopping criterion if EDIFFG<0
+        IF (DYN%EDIFFG<0) INFO%LSTOP=LSTOP2
+        io_begin
+        WRITE(TIU6,130)
+
+        IF (INFO%LSTOP) THEN
+           IF (IO%IU0>=0) &
+                WRITE(TIU0,*) 'reached required accuracy - stopping ', &
+                'structural energy minimisation'
+           WRITE(TIU6,*) ' '
+           WRITE(TIU6,*) 'reached required accuracy - stopping ', &
+                'structural energy minimisation'
+        ENDIF
+        io_end
+       END IF !LJ_ONLY
+      ELSE IF ( DYN%IBRION == -1 .AND. (LEPSILON  .OR. KINTER/=0 .OR. LMAGBLOCH)) THEN ibrion
+       IF (.NOT. LJ_ONLY) THEN
+         CALL LR_SKELETON( &
+              KINEDEN,HAMILTONIAN,P,WDES,NONLR_S,NONL_S,W,LATT_CUR,LATT_INI, &
+              T_INFO,DYN,INFO,IO,MIX,KPOINTS,SYMM,GRID,GRID_SOFT, &
+              GRIDC,GRIDB,GRIDUS,C_TO_US,B_TO_C,SOFT_TO_C,E, &
+              CHTOT,CHTOTL,DENCOR,CVTOT,CSTRF, &
+              CDIJ,CQIJ,CRHODE,N_MIX_PAW,RHOLM,RHOLM_LAST, &
+              CHDEN,SV,DOS,DOSI,CHAM, &
+              DYN%IBRION,LMDIM,IRDMAX,NEDOS, &
+              TOTEN,EFERMI, TIFOR)
+       END IF !LJ_ONLY
+      ELSE IF ( DYN%IBRION == -1 .AND. LAUGER) THEN ibrion
+       IF (.NOT. LJ_ONLY) THEN
+         CALL CALCULATE_AUGER(W,WDES,LATT_CUR,SYMM,T_INFO,GRID,P,NONL_S,KPOINTS,IO)
+       END IF !LJ_ONLY
+      ELSE IF ( LCHIMAG ) THEN ibrion
+       IF (.NOT. LJ_ONLY) THEN
+         CALL MLR_SKELETON( &
+              HAMILTONIAN,W,WDES,GRID,GRID_SOFT,GRIDC,GRIDUS,C_TO_US,SOFT_TO_C,KPOINTS,LATT_CUR,LATT_INI, &
+              T_INFO,DYN,SYMM,P,NONL_S,NONLR_S,LMDIM,CDIJ,CQIJ,SV,E,INFO,IRDMAX,IO)
+       END IF !LJ_ONLY
+      ENDIF ibrion
+!=======================================================================
+!  update of ionic positions performed
+!  in any case POSION should now hold the new positions and
+!  POSIOC the old one
+!=======================================================================
+
+!   reached required number of time steps
+      IF (NSTEP>=DYN%NSW) INFO%LSTOP=.TRUE.
+#ifdef tbdyn
+      IF (INFO%LSTOP) THEN
+        CLOSE(g_io%REPORT)
+      END IF
+#endif
+!   soft stop or hard stop
+      IF (INFO%LSOFT) INFO%LSTOP=.TRUE.
+
+!   if we need to pull the brake, then POSION is reset to POSIOC
+!   except for molecular dynamics, where the next electronic
+!   step should indeed correspond to POSIOC 
+      IF ( INFO%LSTOP .AND. DYN%IBRION>0 ) THEN
+         LATT_CUR%A=DYN%AC
+         DYN%POSION=DYN%POSIOC
+      ENDIF
+
+      CALLMPI ( M_bcast_d(WDES%COMM, DYN%POSION , T_INFO%NIONS*3))
+      CALLMPI ( M_bcast_d(WDES%COMM, LATT_CUR%A(1,1) , 9))
+      CALL LATTIC(LATT_CUR)
+
+!=======================================================================
+!  update mean temperature mean energy
+!=======================================================================
+      SMEAN =SMEAN +1._q/DYN%SNOSE(1)
+      SMEAN0=SMEAN0+DYN%SNOSE(1)
+      TMEAN =TMEAN +TEIN/DYN%SNOSE(1)
+      TMEAN0=TMEAN0+TEIN
+
+    IF (.NOT. LJ_ONLY) THEN
+!=======================================================================
+!  SMEAR_LOOP%ISMCNT != 0 Loop over several KPOINTS%SIGMA-values
+!  set new smearing parameters and continue main loop
+!=======================================================================
+      IF (SMEAR_LOOP%ISMCNT/=0) THEN
+         KPOINTS%ISMEAR=NINT(SMEAR_LOOP%SMEARS(2*SMEAR_LOOP%ISMCNT-1))
+         KPOINTS%SIGMA=SMEAR_LOOP%SMEARS(2*SMEAR_LOOP%ISMCNT)
+         
+         SMEAR_LOOP%ISMCNT=SMEAR_LOOP%ISMCNT-1
+         
+         io_begin
+         IF (IO%IU0>=0) &
+              WRITE(TIU0,7283) KPOINTS%ISMEAR,KPOINTS%SIGMA
+         WRITE(17,7283) KPOINTS%ISMEAR,KPOINTS%SIGMA
+         io_end
+         
+7283     FORMAT('ISMEAR = ',I4,' SIGMA = ',F10.3)
+         
+         KPOINTS%LTET=((KPOINTS%ISMEAR<=-4).OR.(KPOINTS%ISMEAR>=30))
+         IF (KPOINTS%ISMEAR==-6) KPOINTS%ISMEAR=-1
+         IF (KPOINTS%ISMEAR>=0)  KPOINTS%ISMEAR=MOD(KPOINTS%ISMEAR,30)
+         SIGMA=ABS(KPOINTS%SIGMA)
+         
+         CALL DENSTA( IO%IU0, IO%IU6, WDES, W, KPOINTS, INFO%NELECT, &
+              INFO%NUP_DOWN, E%EENTROPY, EFERMI, SIGMA, .FALSE.,  &
+              NEDOS, 0, 0, DOS, DOSI, PAR, DOSPAR)
+      ENDIF
+!=======================================================================
+! tasks which are done all DYN%NBLOCK   steps:
+!=======================================================================
+!-----------------------------------------------------------------------
+!  write out the position of the IONS to XDATCAR
+!-----------------------------------------------------------------------
+      IF (INFO%INICHG==3) THEN
+        IF (MOD(NSTEP,DYN%NBLOCK)==1) THEN
+           IF (IO%IU0>=0) &
+           WRITE(TIU0,*) 'non selfconsistent'
+           INFO%LCHCON=.FALSE.
+        ELSE
+           IF (IO%IU0>=0) &
+           WRITE(TIU0,*) 'selfconsistent'
+           INFO%LCHCON=.TRUE.
+        ENDIF
+      ENDIF
+    END IF !LJ_ONLY
+
+   nblock: IF (MOD(NSTEP,DYN%NBLOCK)==0) THEN
+        io_begin
+        ! tb: write lattice vectors to XDATCAR
+        IF (DYN%ISIF>=3) THEN
+           CALL XDAT_HEAD_AC(61, T_INFO, LATT_CUR, DYN, INFO%SZNAM1)
+        ENDIF
+        WRITE(61,'(A,I6)') 'Direct configuration=',NSTEP
+        WRITE(61,7007) ((DYN%POSIOC(I,J),I=1,3),J=1,T_INFO%NIONS)
+        IF (IO%LOPEN) CALL WFORCE(61)
+        io_end
+
+    IF (.NOT. LJ_ONLY) THEN
+!-----------------------------------------------------------------------
+! acummulate dos
+!-----------------------------------------------------------------------
+        DO ISP=1,WDES%NCDIJ
+        DO I=1,NEDOS
+          DDOSI(I,ISP)=DDOSI(I,ISP)+DOSI(I,ISP)
+          DDOS (I,ISP)=DDOS (I,ISP)+DOS (I,ISP)
+        ENDDO
+        ENDDO
+    END IF !LJ_ONLY
+
+!-----------------------------------------------------------------------
+! evaluate the pair-correlation function  using the exact places
+! also sum up mean temperatur
+!-----------------------------------------------------------------------
+        SMEANP =SMEANP +1._q
+        CALL SPACO(T_INFO%NIONS,1._q,DYN%POSIOC,DYN%AC,LATT_CUR%BNORM,PACO%SIPACO(0),PACO%NPACO,PACO%APACO)
+      ENDIF nblock
+
+!=======================================================================
+! tasks which are done all DYN%NBLOCK*DYN%KBLOCK   steps
+!=======================================================================
+!-----------------------------------------------------------------------
+! write  pair-correlation and density of states
+! quantities are initialized to 0 at the beginning of the main-loop
+!-----------------------------------------------------------------------
+    wrtpair: IF (MOD(NSTEP,DYN%NBLOCK*DYN%KBLOCK)==0 .AND. DYN%IBRION ==0) THEN
+       io_begin
+
+       PCFAK = 1.5_q/PI/T_INFO%NIONS**2*LATT_CUR%OMEGA*(PACO%NPACO/PACO%APACO)**3
+       WRITE(60,'(3E15.7)') TMEAN0/(DYN%NBLOCK*DYN%KBLOCK),TMEAN/SMEAN
+       WRITE(TIU6,8022) SMEAN0/(DYN%NBLOCK*DYN%KBLOCK),TMEAN0/(DYN%NBLOCK*DYN%KBLOCK), &
+            &                TMEAN/SMEAN
+8022   FORMAT(/' mean value of Nose-termostat <S>:',F10.3, &
+            &        ' mean value of <T> :',F10.3/ &
+            &        ' mean temperature <T/S>/<1/S>  :',F10.3/)
+       
+       DO  I=0,PACO%NPACO-1
+          WRITE(60,'(F7.3)') &
+               PCFAK*PACO%SIPACO(I)/ REAL( 3*I*(I+1)+1 ,KIND=q) /SMEANP
+       ENDDO
+       IF (IO%LOPEN) CALL WFORCE(60)
+       
+    IF (.NOT. LJ_ONLY) THEN
+       DELTAE=(KPOINTS%EMAX-KPOINTS%EMIN)/(NEDOS-1)
+
+       WRITE(16,'(2F16.8,I5,2F16.8)') KPOINTS%EMAX,KPOINTS%EMIN,NEDOS,EFERMI,1.0
+       DO I=1,NEDOS
+          EN=KPOINTS%EMIN+DELTAE*(I-1)
+          WRITE(16,7062) EN,(DDOS(I,ISP)/DYN%KBLOCK,ISP=1,WDES%ISPIN),(DDOSI(I,ISP)/DYN%KBLOCK,ISP=1,WDES%ISPIN)
+       ENDDO
+       IF (IO%LOPEN) CALL WFORCE(16)
+7062   FORMAT(3X,F8.3,8E12.4)
+       CALL XML_DOS(EFERMI, KPOINTS%EMIN, KPOINTS%EMAX, .FALSE., &
+            DDOS, DDOSI, DOSPAR, NEDOS, LPAR, T_INFO%NIONP, WDES%NCDIJ)
+    END IF !LJ_ONLY
+       io_end
+    ENDIF wrtpair
+!-----------------------------------------------------------------------
+!  update file CONTCAR
+!-----------------------------------------------------------------------
+
+!-----write out positions (only done on IONODE)
+#ifdef MPI
+    IF (WDES%COMM_KINTER%NODE_ME.EQ.1) THEN
+#endif
+     io_begin
+
+      CALL OUTPOS(13,.TRUE.,T_INFO%SZNAM2,T_INFO,LATT_CUR%SCALE,DYN%AC,T_INFO%LSDYN,DYN%POSIOC)
+      CALL OUTPOS_TRAIL(13,IO%LOPEN, LATT_CUR, T_INFO, DYN)
+
+     io_end
+
+    IF (.NOT. LJ_ONLY) THEN
+!=======================================================================
+!  append new chargedensity to file CHG
+!=======================================================================
+      IF (IO%LCHARG .AND. MOD(NSTEP,10)==1) THEN
+
+      io_begin
+      CALL OUTPOS(70,.FALSE.,INFO%SZNAM1,T_INFO,LATT_CUR%SCALE,LATT_CUR%A,.FALSE.,DYN%POSIOC)
+      io_end
+
+      DO ISP=1,WDES%NCDIJ
+         CALL OUTCHG(GRIDC,70,.FALSE.,CHTOT(:,ISP))
+      ENDDO
+      io_begin
+      IF (IO%LOPEN) CALL WFORCE(70)
+      io_end
+      ENDIF
+    END IF !LJ_ONLY
+
+#ifdef MPI
+    ENDIF
+#endif
+
+    IF (.NOT. LJ_ONLY) THEN
+!=======================================================================
+! if ions were moved recalculate some quantities
+!=======================================================================
+!=======================================================================
+! WAVPRE prediction of the new wavefunctions and charge-density
+! if charge-density constant during ELM recalculate the charge-density
+! according to overlapping atoms
+! for relaxation jobs do not predict in the last step
+!=======================================================================
+      INFO%LPOTOK=.FALSE.
+  prepare_next_step: &
+    & IF ( .NOT. INFO%LSTOP .OR. DYN%IBRION==0 ) THEN
+
+      ! extrapolate charge using  atomic charges
+      IF (PRED%IWAVPR==1 .OR.PRED%IWAVPR==11) PRED%INIPRE=5
+      ! extrapolate wavefunctions and charge
+      IF (PRED%IWAVPR==2 .OR.PRED%IWAVPR==12) PRED%INIPRE=0
+      ! mixed mode
+      IF (PRED%IWAVPR==3 .OR.PRED%IWAVPR==13) PRED%INIPRE=4
+      PRED%IPRE=0
+
+      IF (PRED%IWAVPR >=11) THEN
+        CALL WAVPRE_NOIO(GRIDC,P,PRED,T_INFO,W,WDES,LATT_CUR,IO%LOPEN, &
+           CHTOT,RHOLM,N_MIX_PAW, CSTRF, KINEDEN, LMDIM,CQIJ,INFO%LOVERL,IO%IU0)
+      ELSE IF (PRED%IWAVPR >=1 .AND. PRED%IWAVPR<10 ) THEN
+        CALL WAVPRE(GRIDC,P,PRED,T_INFO,W,WDES,LATT_CUR,IO%LOPEN, &
+           CHTOT,RHOLM,N_MIX_PAW, CSTRF, LMDIM,CQIJ,INFO%LOVERL,IO%IU0)
+      ENDIF
+
+      IF (PRED%IPRE<0) THEN
+        io_begin
+        IF (IO%IU0>=0) &
+        WRITE(TIU0,*)'bond charge predicted'
+        io_end
+        PRED%IPRE=ABS(PRED%IPRE)
+      ELSE
+      ! PRED%IPRE < 0 then WAVPRE calculated new structure factor
+      !     in all other cases we have to recalculate s.f.
+         IF (INFO%TURBO==0) CALL STUFAK(GRIDC,T_INFO,CSTRF)
+      ENDIF
+
+      IF (INFO%LCHCON.AND.INFO%INICHG==2) THEN
+        IF (IO%IU0>=0)  WRITE(TIU0,*)'charge from overlapping atoms'
+        ! then initialize CRHODE and than RHOLM (PAW related occupancies)
+        CALL DEPATO(WDES, LMDIM, CRHODE, INFO%LOVERL, P, T_INFO)
+        CALL SET_RHO_PAW(WDES, P, T_INFO, INFO%LOVERL, WDES%NCDIJ, LMDIM, &
+           CRHODE, RHOLM)
+
+        CALL RHOATO_WORK(.FALSE.,.FALSE.,GRIDC,T_INFO,LATT_CUR%B,P,CSTRF,CHTOT)
+        ! set magnetization to 0
+        DO ISP=2,WDES%NCDIJ
+           CALL RC_ADD(CHTOT(1,ISP),0.0_q,CHTOT(1,ISP),0.0_q,CHTOT(1,ISP),GRIDC)
+        ENDDO
+        ! add Gaussian "charge-transfer" charges, if required 
+        CALL RHOADD_GAUSSIANS(T_INFO,LATT_CUR,P,GRIDC,NCDIJ,CHTOT,CSTRF) 
+        CALL RHOADD_GAUSSIANS_LIST(LATT_CUR,GRIDC,NCDIJ,CHTOT)
+      ENDIF
+
+      IF (INFO%LCORE) CALL RHOPAR(GRIDC,T_INFO,INFO,LATT_CUR,P,CSTRF,DENCOR,IO%IU6)
+      IF (LDO_METAGGA()) CALL TAUPAR(GRIDC,T_INFO,LATT_CUR%B,LATT_CUR%OMEGA,P,CSTRF,KINEDEN%TAUC)
+
+      CALL STOP_TIMING("G",TIU6,'WAVPRE')
+!-----------------------------------------------------------------------
+! call the ewald program to get the energy of the new ionic
+! configuration
+!-----------------------------------------------------------------------
+      IF(INFO%TURBO==0) THEN
+         CALL FEWALD(DYN%POSION,EWIFOR,LATT_CUR%A,LATT_CUR%B,LATT_CUR%ANORM,LATT_CUR%BNORM, &
+              &     LATT_CUR%OMEGA,EWSIF,E%TEWEN,T_INFO%NTYP,P%ZVALF,T_INFO%VCA, &
+              &     T_INFO%NIONS,NIOND,T_INFO%ITYP,T_INFO%NITYP,IO%IU6,.TRUE.)
+      ELSE
+         ALLOCATE(CWORK1(GRIDC%MPLWV))
+         CALL POTION_PARTICLE_MESH(GRIDC,P,LATT_CUR,T_INFO,CWORK1,E%PSCENC,E%TEWEN,EWIFOR)
+         DEALLOCATE(CWORK1)
+      ENDIF
+
+      CALL STOP_TIMING("G",TIU6,'FEWALD')
+
+! volume might have changed restet IRDMAX
+      IRDMAX=4*PI*PSDMX**3/3/(LATT_CUR%OMEGA/ &
+     &     (GRIDC%NGPTAR(1)*GRIDC%NGPTAR(2)*GRIDC%NGPTAR(3)))+200
+#ifdef usgrid
+       IRDMAX=4*PI*PSDMX**3/3/(LATT_CUR%OMEGA/ &
+     &        (GRIDUS%NGPTAR(1)*GRIDUS%NGPTAR(2)*GRIDUS%NGPTAR(3)))+200
+#endif
+!-----------------------------------------------------------------------
+! if basis cell changed recalculate kinetic-energy array and tables
+!-----------------------------------------------------------------------
+      IF (DYN%ISIF>=3) THEN
+        CALL GEN_INDEX(GRID,WDES, LATT_CUR%B,LATT_INI%B,-1,-1,.TRUE.)
+        CALL STOP_TIMING("G",TIU6,'GENKIN')
+        IF (WDES%LSPIRAL) CALL CLEANWAV(WDES,W,INFO%ENINI)
+      ENDIF
+!-----------------------------------------------------------------------
+!  recalculate the real-space projection operators
+!  if volume changed also recalculate reciprocal projection operators
+!  and reset the cache for the phase-factor
+!-----------------------------------------------------------------------
+      IF (INFO%LREAL) THEN
+! reset IRMAX, IRALLOC if required (no redistribution of GRIDS allowed)
+
+        CALL REAL_OPTLAY(GRID,LATT_CUR,NONLR_S,.TRUE.,LREALLOCATE, IO%IU6,IO%IU0)
+        IF (LREALLOCATE) THEN
+           ! reallocate real space projectors
+           CALL NONLR_DEALLOC(NONLR_S)
+           CALL NONLR_ALLOC(NONLR_S)
+        END IF
+        CALL RSPHER(GRID,NONLR_S,LATT_CUR)
+
+      ELSE
+        IF (DYN%ISIF>=3) THEN
+          CALL SPHER(GRID,NONL_S,P,WDES,LATT_CUR, 1)
+        ENDIF
+        CALL PHASE(WDES,NONL_S,0)
+      ENDIF
+
+      CALL RESETUP_FOCK( WDES, LATT_CUR)
+!-----------------------------------------------------------------------
+! recalculate projections and perform Gramm-Schmidt orthogonalization
+!-----------------------------------------------------------------------
+      CALL WVREAL(WDES,GRID,W) ! only for gamma some action
+      CALL START_TIMING("G")
+      CALL PROALL (GRID,LATT_CUR,NONLR_S,NONL_S,W)
+      CALL ORTHCH(WDES,W, INFO%LOVERL, LMDIM,CQIJ)
+      CALL REDIS_PW_OVER_BANDS(WDES, W)
+
+      CALL KPAR_SYNC_ALL(WDES,W)
+
+      CALL STOP_TIMING("G",TIU6,'ORTHCH')
+!-----------------------------------------------------------------------
+! set  INFO%LPOTOK to .F. this requires a recalculation of the local pot.
+!-----------------------------------------------------------------------
+      INFO%LPOTOK=.FALSE.
+!-----------------------------------------------------------------------
+! if prediction of wavefunctions was performed and
+! diagonalization of sub-space-matrix is selected then
+! )  POTLOK: calculate potential according to predicted charge-density
+! )  SETDIJ: recalculate the energy of the augmentation charges
+! )  then perform a sub-space-diagonal. and generate new Fermi-weights
+! )  set INFO%LPOTOK to true because potential is OK
+! )  recalculate total energy
+! if charge density not constant during band minimization
+! )  calculate charge-density according to new wavefunctions
+!     and set LPOTOK to false (requires recalculation of loc. potential)
+! in all other cases the predicted charge density is used in the next
+!   step of ELM
+!-----------------------------------------------------------------------
+  pre_done: IF (PRED%IPRE>1) THEN
+      io_begin
+      IF (IO%IU0>=0) &
+      WRITE(TIU0,*)'prediction of wavefunctions'
+
+      WRITE(TIU6,2450) PRED%ALPHA,PRED%BETA
+      io_end
+ 2450 FORMAT(' Prediction of Wavefunctions ALPHA=',F6.3,' BETA=',F6.3)
+
+!   wavefunctions are not diagonal, so if they are written to the file
+!   or if we do not diagonalize before the optimization
+!   rotate them now
+  pre_subrot: IF (.NOT.INFO%LDIAG .OR. INFO%LONESW .OR. &
+     &     INFO%LSTOP .OR. (MOD(NSTEP,10)==0 &
+     &     .AND. PRED%IWAVPR >= 2 .AND.  PRED%IWAVPR < 10) ) THEN
+
+      CALL START_TIMING("G")
+      IF (IO%IU0>=0) &
+      WRITE(TIU0,*)'wavefunctions rotated'
+      CALL POTLOK(GRID,GRIDC,GRID_SOFT, WDES%COMM_INTER, WDES, &
+                  INFO,P,T_INFO,E,LATT_CUR, &
+                  CHTOT,CSTRF,CVTOT,DENCOR,SV, SOFT_TO_C,XCSIF)
+
+      CALL POTLOK_METAGGA(KINEDEN, &
+                  GRID,GRIDC,GRID_SOFT,WDES%COMM_INTER,WDES,INFO,P,T_INFO,E,LATT_CUR, &
+                  CHDEN,CHTOT,DENCOR,CVTOT,SV,HAMILTONIAN%MUTOT,HAMILTONIAN%MU,SOFT_TO_C,XCSIF)
+
+      CALL SETDIJ(WDES,GRIDC,GRIDUS,C_TO_US,LATT_CUR,P,T_INFO,INFO%LOVERL, &
+                  LMDIM,CDIJ,CQIJ,CVTOT,IRDMAA,IRDMAX)
+
+      CALL SET_DD_PAW(WDES, P , T_INFO, INFO%LOVERL, &
+         WDES%NCDIJ, LMDIM, CDIJ,  RHOLM, CRHODE, &
+          E, LMETA =  .FALSE., LASPH =INFO%LASPH , LCOREL=.FALSE.)
+
+      CALL UPDATE_CMBJ(GRIDC,T_INFO,LATT_CUR,IO%IU6)
+
+      CALL STOP_TIMING("G",TIU6,'POTLOK')
+      INFO%LPOTOK=.TRUE.
+
+      IFLAG=3
+      CALL EDDIAG(HAMILTONIAN,GRID,LATT_CUR,NONLR_S,NONL_S,W,WDES,SYMM, &
+          LMDIM,CDIJ,CQIJ, IFLAG,SV,T_INFO,P,IO%IU0,E%EXHF)
+
+      CALL REDIS_PW_OVER_BANDS(WDES, W)
+
+      SIGMA=ABS(KPOINTS%SIGMA)
+      CALL DENSTA( IO%IU0, IO%IU6, WDES, W, KPOINTS, &
+               INFO%NELECT, INFO%NUP_DOWN, E%EENTROPY, EFERMI, SIGMA, .FALSE.,  &
+               NEDOS, 0, 0, DOS, DOSI, PAR, DOSPAR)
+
+     ! for the selfconsistent update set W_F%CELTOT and TOTEN now
+      IF (INFO%LONESW) W_F%CELTOT=W%CELTOT
+      E%EBANDSTR= BANDSTRUCTURE_ENERGY(WDES, W)
+      TOTEN=E%EBANDSTR+E%DENC+E%XCENC+E%TEWEN+E%PSCENC+E%EENTROPY+Ediel_sol
+
+      CALL STOP_TIMING("G",IO%IU6,'EDDIAG')
+
+  ENDIF pre_subrot
+
+  ENDIF pre_done
+
+    IF (INFO%LONESW) THEN
+
+      CALL START_TIMING("G")
+
+      CALL SET_CHARGE(W, WDES, INFO%LOVERL, &
+           GRID, GRIDC, GRID_SOFT, GRIDUS, C_TO_US, SOFT_TO_C, &
+           LATT_CUR, P, SYMM, T_INFO, &
+           CHDEN, LMDIM, CRHODE, CHTOT, RHOLM, N_MIX_PAW, IRDMAX)
+
+      CALL SET_KINEDEN(GRID,GRID_SOFT,GRIDC,SOFT_TO_C,LATT_CUR,SYMM, &
+           T_INFO%NIONS,W,WDES,KINEDEN)      
+
+      INFO%LPOTOK=.FALSE.
+
+      CALL STOP_TIMING("G",IO%IU6,'CHARGE')
+
+    ENDIF
+
+  ELSE prepare_next_step
+! in any case we have to call RSPHER at this point even if the ions do not move
+! since the force routine overwrites the required arrays
+      IF (INFO%LREAL) THEN
+         CALL RSPHER(GRID,NONLR_S,LATT_CUR)
+      ENDIF
+  ENDIF prepare_next_step
+!=======================================================================
+!  update file WAVECAR if INFO%LSTOP = .TRUE.
+!  or if wavefunctions on file TMPCAR are rotated
+!=======================================================================
+! after 10 steps rotate the wavefunctions on the file
+      LTMP= MOD(NSTEP,10) == 0 .AND. PRED%IWAVPR >= 2 .AND. PRED%IWAVPR < 10
+  wrtwave: IF ( IO%LWAVE .AND. ( INFO%LSTOP .OR. LTMP .OR. LHFCALC)  ) THEN
+
+      CALL OUTWAV(IO, WDES, W, LATT_INI,  EFERMI)
+!-----------------------------------------------------------------------
+! rotate wavefunctions on file (gives a better prediction)
+!------------------------------------------------------------------------
+      IF (LTMP) THEN
+        PRED%INIPRE=10
+
+        CALL WAVPRE(GRIDC,P,PRED,T_INFO,W,WDES,LATT_CUR,IO%LOPEN, &
+           CHTOT,RHOLM,N_MIX_PAW, CSTRF, LMDIM,CQIJ,INFO%LOVERL,IO%IU0)
+
+        IF (IO%IU0>=0) &
+             WRITE(TIU0,*)'wavefunctions on file TMPCAR rotated'
+! and read in wavefunctions  (destroyed by WAVPRE)
+        CALL OPENWAV(IO, COMM)
+        CALL INWAV_FAST(IO, WDES, W, GRID, LATT_CUR, LATT_INI, INFO%ISTART,  EFERMI )
+        CALL CLOSEWAV
+
+        CALL PROALL (GRID,LATT_CUR,NONLR_S,NONL_S,W)
+        CALL ORTHCH(WDES,W, INFO%LOVERL, LMDIM,CQIJ)
+        CALL REDIS_PW_OVER_BANDS(WDES, W)
+      ENDIF
+   ENDIF wrtwave
+
+!elphon_
+   IF (ELPH_LWSWQ()) CALL ELPH_OVERLAP_W_WP(W,LATT_CUR,LMDIM,CQIJ,NONLR_S,NONL_S,IO)
+!elphon_
+!=======================================================================
+! next electronic energy minimisation
+      CALL STOP_TIMING("LOOP+",IO%IU6,XMLTAG='totalsc')
+
+      IF (.NOT. INFO%LSTOP )  THEN
+         CALL XML_CLOSE_TAG("calculation")
+         CALL XML_FLUSH
+      ENDIF
+    END IF !LJ_ONLY
+
+      ENDDO ion
+!=======================================================================
+! here we are at the end of the required number of timesteps
+!=======================================================================
+      io_begin
+      IF (IO%LOPEN) CALL WFORCE(IO%IU6)
+      io_end
+
+    IF (.NOT. LJ_ONLY) THEN
+      IF (LWRT_CHGFIT()) THEN
+         ! subtract the overlapping atomic charge density from CHTOT
+         CALL ATOMIC_CHARGES(T_INFO,LATT_CUR,P,GRIDC,CSTRF,1.0_q,-1.0_q,CHTOT)
+         ! write CHGFIT
+         CALL WRITE_CHARGE_RC(INFO,T_INFO,LATT_CUR,GRIDC,CHTOT,IO,99)
+         ! restore CHTOT
+         CALL ATOMIC_CHARGES(T_INFO,LATT_CUR,P,GRIDC,CSTRF,1.0_q,1.0_q,CHTOT)
+      ENDIF
+      ! calculate stockholder charge partitioning
+      CALL STOCKHOLDER_ANALYSIS(INFO,T_INFO,LATT_CUR,P,GRIDC,NCDIJ,CHTOT,DENCOR,IO)
+!=======================================================================
+!  write out some additional information
+!  create the File CHGCAR
+!=======================================================================
+      IF (IO%LCHARG) THEN
+#ifdef MPI
+         IF (WDES%COMM_KINTER%NODE_ME.EQ.1) THEN
+#endif
+         io_begin
+         REWIND 18
+         CALL OUTPOS(18,.FALSE.,INFO%SZNAM1,T_INFO,LATT_CUR%SCALE,LATT_CUR%A,.FALSE.,DYN%POSION)
+         io_end
+! if you uncomment the following lines the pseudo core charge density
+! is added to the pseudo charge density         
+!         CALL FFT3D(CHTOT(1,1),GRIDC,1)
+!         CALL RL_ADD(CHTOT(1,1),1._q/GRIDC%NPLWV,DENCOR(1),1._q/GRIDC%NPLWV,CHTOT(1,1),GRIDC)
+!         CALL FFT3D(CHTOT(1,1),GRIDC,-1)
+         CALL OUTCHG(GRIDC,18,.TRUE.,CHTOT)
+         CALL WRT_RHO_PAW(P, T_INFO, INFO%LOVERL, RHOLM(:,1), GRIDC%COMM, 18 )
+         DO ISP=2,WDES%NCDIJ
+            do_io WRITE(18,'(5E20.12)') (T_INFO%ATOMOM(NI),NI=1,T_INFO%NIONS)
+            CALL OUTCHG(GRIDC,18,.TRUE.,CHTOT(:,ISP))
+            CALL WRT_RHO_PAW(P, T_INFO, INFO%LOVERL, RHOLM(:,ISP), GRIDC%COMM, 18 )
+         ENDDO
+         IF (IO%LOPEN) THEN
+            do_io CALL REOPEN(18)
+         ELSE
+            do_io REWIND 18
+         ENDIF
+#ifdef MPI
+         END IF
+#endif
+      ENDIF
+!-----if we are interested in the total (local) potential write it here:
+      IF (IO%LVTOT.OR.IO%LVHAR) THEN
+#ifdef MPI
+         IF (WDES%COMM_KINTER%NODE_ME.EQ.1) THEN
+#endif
+         io_begin
+         IF (IO%LOPEN) OPEN(IO%IUVTOT,FILE='LOCPOT',STATUS='UNKNOWN')
+         REWIND IO%IUVTOT
+         CALL OUTPOS(IO%IUVTOT,.FALSE.,INFO%SZNAM1,T_INFO,LATT_CUR%SCALE,LATT_CUR%A,.FALSE.,DYN%POSION)
+         io_end
+! comment out the following line to add  exchange correlation
+         IF (IO%LVHAR) CALL SET_LEXCH(-1)
+         CALL POTLOK(GRID,GRIDC,GRID_SOFT, WDES%COMM_INTER, WDES, &
+                  INFO,P,T_INFO,E,LATT_CUR, &
+                  CHTOT,CSTRF,CVTOT,DENCOR,SV, SOFT_TO_C,XCSIF)
+
+         IF (.NOT. IO%LVHAR) THEN
+           CALL POTLOK_METAGGA(KINEDEN, &
+                 GRID,GRIDC,GRID_SOFT,WDES%COMM_INTER,WDES,INFO,P,T_INFO,E,LATT_CUR, &
+                 CHDEN,CHTOT,DENCOR,CVTOT,SV,HAMILTONIAN%MUTOT,HAMILTONIAN%MU,SOFT_TO_C,XCSIF)
+         ENDIF
+
+         ! call the dipol routine without changing the potential
+         IF ( DIP%IDIPCO >0 ) THEN
+           DIP%LCOR_DIP=.FALSE.
+           CALL CDIPOL_CHTOT_REC(GRIDC, LATT_CUR,P,T_INFO, &
+               CHTOT,CSTRF,CVTOT, WDES%NCDIJ, INFO%NELECT, E%PSCENC )
+
+           CALL WRITE_VACUUM_LEVEL(IO%IU6)
+         ENDIF
+
+!        CALL OUTPOT(GRIDC, IO%IUVTOT,.TRUE.,HAMILTONIAN%MUTOT)
+         CALL OUTPOT(GRIDC, IO%IUVTOT,.TRUE.,CVTOT)
+         DO ISP=2,WDES%NCDIJ
+            do_io WRITE(IO%IUVTOT,'(5E20.12)') (T_INFO%ATOMOM(NI),NI=1,T_INFO%NIONS)
+            CALL OUTPOT(GRIDC, IO%IUVTOT,.TRUE.,CVTOT(1,ISP))
+         ENDDO
+         IF (IO%LOPEN) THEN
+            do_io CALL REOPEN(IO%IUVTOT)
+         ELSE
+            do_io REWIND IO%IUVTOT
+         ENDIF
+#ifdef MPI
+         ENDIF
+#endif
+      ENDIF
+!=======================================================================
+!  Write out the Eigenvalues
+!=======================================================================
+
+#ifdef MPI
+      IF (WDES%COMM_KINTER%NCPU.GT.1) THEN
+         CALL KPAR_SYNC_CELTOT(WDES,W)
+      END IF
+#endif
+
+      io_begin
+      DO NK=1,KPOINTS%NKPTS
+        WRITE(22,*)
+        WRITE(22,'(4E15.7)') WDES%VKPT(1,NK),WDES%VKPT(2,NK),WDES%VKPT(3,NK),KPOINTS%WTKPT(NK)
+        DO N=1,WDES%NB_TOT
+          IF (INFO%ISPIN==1) WRITE(22,852) N,REAL( W%CELTOT(N,NK,1) ,KIND=q), W%FERTOT(N,NK,1)
+          IF (INFO%ISPIN==2) &
+            WRITE(22,8852) N,REAL( W%CELTOT(N,NK,1) ,KIND=q) ,REAL( W%CELTOT(N,NK,INFO%ISPIN) ,KIND=q), W%FERTOT(N,NK,1), W%FERTOT(N,NK,INFO%ISPIN)
+        ENDDO
+      ENDDO
+      IF (IO%LOPEN) CALL WFORCE(22)
+      io_end
+      CALL XML_EIGENVALUES(W%CELTOT, W%FERTOT, WDES%NB_TOT, KPOINTS%NKPTS, INFO%ISPIN)
+
+  852 FORMAT(1X,I4,4X,F12.6,2X,F9.6)
+ 8852 FORMAT(1X,I4,4X,F12.6,2X,F12.6,2X,F9.6,2X,F9.6)
+!=======================================================================
+!  get current density and write output
+!=======================================================================
+      CALL CURRENT( W, GRID_SOFT, GRIDC, GRIDUS, C_TO_US, SOFT_TO_C, P, LATT_CUR, &
+          HAMILTONIAN%AVEC, HAMILTONIAN%AVTOT, CHTOT, NONLR_S, NONL_S, &
+          T_INFO, LMDIM, CRHODE, CDIJ, CQIJ, IRDMAX, IO%IU6, IO%IU0,  IO%NWRITE)
+
+      CALL WRITE_ORBITALMAGOUT(IO%IU6)
+      CALL XML_WRITE_ORBITALMAGOUT
+!=======================================================================
+!  calculate optical matrix elements
+!=======================================================================
+
+      IF (IO%LOPTICS.AND.KINTER==0) THEN
+        CALL START_TIMING("G")
+        ! VASP onboard optics
+        CALL LR_OPTIC( &
+             P,WDES,NONLR_S,NONL_S,W,LATT_CUR,LATT_INI, &
+             T_INFO,INFO,IO,KPOINTS,SYMM,GRID,GRID_SOFT, &
+             GRIDC,GRIDUS,C_TO_US,SOFT_TO_C, &
+             CHTOT,DENCOR,CVTOT,CSTRF, &
+             CDIJ,CQIJ,CRHODE,N_MIX_PAW,RHOLM, &
+             CHDEN,SV,LMDIM,IRDMAX,EFERMI,NEDOS, & 
+             LPOT= EXXOEP==0 .AND. INFO%INICHG/=4 .AND.  .NOT. USE_OEP_IN_GW() .AND. .NOT. LDO_METAGGA())
+         ! potential must not be updated for OEP methods
+         ! if potential was read from a file INFO%INICHG/=4
+         ! or if a meta-GGA is used
+        IF (NPAR ==1 .AND. KPAR==1 .AND. LPAW) THEN
+           ! offboard optics by Juergen Furthmueller
+           ALLOCATE(NABIJ(WDES%NB_TOT,WDES%NB_TOT))
+
+           CALL CALC_NABIJ(NABIJ,W,WDES,P,KPOINTS,GRID_SOFT,LATT_CUR, &
+                IO,INFO,T_INFO,COMM,IU0,55)
+           DEALLOCATE(NABIJ)
+        ENDIF
+        CALL STOP_TIMING("G",IO%IU6,'OPTICS')
+      ENDIF
+!=======================================================================
+!  calculate four orbital integrals
+!=======================================================================
+      CALL START_TIMING("G")
+
+      CALL TWOELECTRON4O_MAIN( &
+      P,WDES,NONLR_S,NONL_S,W,LATT_CUR,LATT_INI, &
+      T_INFO,DYN,INFO,IO,KPOINTS,SYMM,GRID,LMDIM )
+
+      IF (FOURORBIT/=0) THEN
+         ! Set all DFT exchange contributions to zero
+         CALL PUSH_XC_TYPE(LEXCH,1._q,1._q,0._q,1._q,LDASCREEN)
+         ! Initialize xc tables
+         CALL SETUP_LDA_XC(1,IO%IU6,IO%IU0,IO%IDIOT)
+         ! calculate correlation contributions on PW grid
+         CALL POTLOK(GRID,GRIDC,GRID_SOFT, WDES%COMM_INTER, WDES,  &
+                     INFO,P,T_INFO,E,LATT_CUR, &
+                     CHTOT,CSTRF,CVTOT,DENCOR,SV, SOFT_TO_C,XCSIF)
+         CALL POTLOK_METAGGA(KINEDEN, &
+                     GRID,GRIDC,GRID_SOFT,WDES%COMM_INTER,WDES,INFO,P,T_INFO,E,LATT_CUR, &
+                     CHDEN,CHTOT,DENCOR,CVTOT,SV,HAMILTONIAN%MUTOT,HAMILTONIAN%MU,SOFT_TO_C,XCSIF)
+         io_begin
+            WRITE(*,'(A,F14.7)') 'LDA correlation energy (PW grid):',E%EXCG
+         io_end
+         ! Restore the original situation
+         CALL POP_XC_TYPE
+         ! reset the xc tables
+         CALL SETUP_LDA_XC(1,IO%IU6,IO%IU0,IO%IDIOT)
+         ! recalculate plane wave contributions
+         CALL POTLOK(GRID,GRIDC,GRID_SOFT, WDES%COMM_INTER, WDES,  &
+                     INFO,P,T_INFO,E,LATT_CUR, &
+                     CHTOT,CSTRF,CVTOT,DENCOR,SV, SOFT_TO_C,XCSIF)
+         CALL POTLOK_METAGGA(KINEDEN, &
+                     GRID,GRIDC,GRID_SOFT,WDES%COMM_INTER,WDES,INFO,P,T_INFO,E,LATT_CUR, &
+                     CHDEN,CHTOT,DENCOR,CVTOT,SV,HAMILTONIAN%MUTOT,HAMILTONIAN%MU,SOFT_TO_C,XCSIF)
+      ENDIF
+      CALL STOP_TIMING("G",IO%IU6,'4ORBIT')
+
+!=======================================================================
+! MM: Stuff for Janos Angyan: write the AE-charge density to AECCAR2
+!=======================================================================
+      IF (LWRT_AECHG()) THEN
+         CALL AUGCHG(WDES,GRID_SOFT,GRIDC,GRIDUS,C_TO_US, &
+        &             LATT_CUR,P,T_INFO,SYMM, INFO%LOVERL, SOFT_TO_C,&
+        &              LMDIM,CRHODE, CHTOT,CHDEN, IRDMAX,.TRUE.,.FALSE.)
+
+#ifdef MPI
+         IF (WDES%COMM_KINTER%NODE_ME.EQ.1) THEN
+#endif
+         OPEN(UNIT=99,FILE=DIR_APP(1:DIR_LEN)//'AECCAR2',STATUS='UNKNOWN')
+         io_begin     
+         ! write header
+         CALL OUTPOS(99,.FALSE.,INFO%SZNAM1,T_INFO,LATT_CUR%SCALE,LATT_CUR%A, &
+        &             .FALSE., DYN%POSION)
+         io_end
+         ! write AE charge density
+         CALL OUTCHG(GRIDC,99,.TRUE.,CHTOT)
+         CLOSE(99)     
+         ! write Fourier transform of AE charge density
+         IF (LWRTSTRF()) THEN
+            OPEN(UNIT=99,FILE=DIR_APP(1:DIR_LEN)//'STRFAC',STATUS='UNKNOWN')
+            CALL WRTSTRF(GRIDC,LATT_CUR,CHTOT,99)
+            CLOSE(99)
+         ENDIF
+!        OPEN(UNIT=99,FILE=DIR_APP(1:DIR_LEN)//'RADCHG',STATUS='UNKNOWN')
+!        CALL WRT_RHO_RAD(WDES,P,T_INFO,INFO%LOVERL,LMDIM,CRHODE,99)
+!        CLOSE(99)
+
+         END IF
+
+         ! and restore the total charge density
+         CALL DEPLE(WDES,GRID_SOFT,GRIDC,GRIDUS,C_TO_US, &
+                  LATT_CUR,P,T_INFO,SYMM, INFO%LOVERL, SOFT_TO_C,&
+                  LMDIM,CRHODE, CHTOT,CHDEN, IRDMAX)
+#ifdef MPI
+      ENDIF
+#endif
+! MM: end of addition
+
+!=======================================================================
+!  calculate ELF
+!=======================================================================
+      IF (IO%LELF) THEN
+      ALLOCATE(CWORK(GRID_SOFT%MPLWV,WDES%NCDIJ))
+
+      CALL ELF(GRID,GRID_SOFT,LATT_CUR,SYMM,NIOND, W,WDES,  &
+               CHDEN,CWORK)
+
+#ifdef MPI
+     IF (WDES%COMM_KINTER%NODE_ME.EQ.1) THEN
+#endif
+! write ELF to file ELFCAR
+      io_begin
+      OPEN(UNIT=53,FILE='ELFCAR',STATUS='UNKNOWN')
+      CALL OUTPOS(53,.FALSE.,INFO%SZNAM1,T_INFO,LATT_CUR%SCALE,LATT_CUR%A,.FALSE.,DYN%POSION)
+      io_end
+
+      DO ISP=1,WDES%NCDIJ
+         CALL OUTCHG(GRID_SOFT,53,.FALSE.,CWORK(1,ISP))
+      ENDDO
+
+      DEALLOCATE(CWORK)
+
+      do_io CLOSE(53)
+
+      END IF
+#ifdef MPI
+      ENDIF
+#endif
+#ifdef MPI
+      IF (WDES%COMM_KINTER%NODE_ME.EQ.1) THEN
+#endif
+      IF (WRITE_MOMENTS()) CALL WR_MOMENTS(GRID,LATT_CUR,P,T_INFO,W,WDES,.TRUE.)
+      IF (WRITE_DENSITY()) CALL WR_PROJ_CHARG(GRID,P,LATT_CUR,T_INFO,WDES)
+#ifdef MPI
+      END IF
+#endif
+      IF (LCALC_ORBITAL_MOMENT().AND.WDES%LNONCOLLINEAR) CALL WRITE_ORBITAL_MOMENT(WDES,T_INFO%NIONS,IO%IU6)
+      IF (WDES%LSORBIT) CALL WRITE_SPINORB_MATRIX_ELEMENTS(WDES,T_INFO,IO)
+
+!=======================================================================
+!-WAH Write augmentation charges and projectors for differential waves
+!=======================================================================
+
+      IF (INFO%LOVERL) THEN
+       IF (STM(4) > 0) THEN
+#ifdef MPI
+         IF (WDES%COMM_KINTER%NODE_ME.EQ.1) THEN
+#endif
+          do_io WRITE(*,*) "writing IETS projectors"
+          CALL WRT_IETS(LMDIM, WDES%NIONS, WDES%NRSPINORS, CQIJ, WDES, W)
+          do_io WRITE(*,*) "IETS projectors  written, exiting"
+         END IF
+#ifdef MPI
+       END IF
+#endif
+      END IF
+!=======================================================================
+!  possibly decompose into Bloch states of a given primitive cell
+!=======================================================================
+!     CALL  KPROJ(IO%IU5, IO%IU0, IO%IU6, GRID, NONL_S, T_INFO, SYMM, P, LATT_CUR, KPOINTS, W)
+      CALL  KPROJ(IO%IU5, IO%IU0, IO%IU6, GRID, LATT_CUR, W, SYMM, CQIJ)
+
+!=======================================================================
+!  total DOS, calculate ion and lm decomposed occupancies and dos
+!=======================================================================
+!     IF (JOBPAR/=0  .AND. IO%LORBIT<10 .AND. NPAR /=1) THEN
+!        CALL VTUTOR('W','partial DOS',RTUT,1, &
+!             &                  ITUT,1,CDUM,1,LDUM,1,IO%IU6,IO%IDIOT)
+!        CALL VTUTOR('W','partial DOS',RTUT,1, &
+!             &                  ITUT,1,CDUM,1,LDUM,1,IO%IU0,IO%IDIOT)
+!     ELSE IF (JOBPAR/=0 .OR. IO%LORBIT>=10  ) THEN
+      IF (JOBPAR/=0 .OR. IO%LORBIT>=10  ) THEN
+         DEALLOCATE(PAR,DOSPAR)
+         
+         IF (IO%LORBIT==1 .OR. IO%LORBIT==2 .OR. (IO%LORBIT>=11 .AND. IO%LORBIT<=14)) THEN
+            LPAR=LMDIMP
+         ELSE
+            LPAR=LDIMP
+         ENDIF
+         
+         ALLOCATE(PAR(WDES%NB_TOT,WDES%NKPTS,LPAR,T_INFO%NIONP,WDES%NCDIJ))
+         
+         IF (IO%LORBIT>=10) THEN
+            CALL SPHPRO_FAST( &
+                 GRID,LATT_CUR, P,T_INFO,W, WDES, 71,IO%IU6,&
+                 INFO%LOVERL,LMDIM,CQIJ, LPAR, LDIMP, LMDIMP, .TRUE., IO%LORBIT,PAR, &
+                 EFERMI, KPOINTS%EMIN, KPOINTS%EMAX)
+! locproj_
+                 CALL LPRJ_PROALL(W,WDES,GRID,P,CQIJ,LATT_CUR,T_INFO,INFO,IO%IU6,IO%IU0)
+! locproj_
+         ELSE
+            CALL SPHPRO( &
+                 GRID,LATT_CUR, P,T_INFO,W, WDES, 71,IO%IU6,&
+                 INFO%LOVERL,LMDIM,CQIJ, LPAR, LDIMP, LMDIMP, LTRUNC, IO%LORBIT,PAR)
+         ENDIF
+         
+         CALL CHGLOC(WDES%NB_TOT,KPOINTS%NKPTS,LPAR,T_INFO%NIONS,WDES%ISPIN,PAR,W%FERWE)
+         
+         !  get and write partial / projected DOS ...
+         
+         !  some compilers require to remove this statment
+         DEALLOCATE(W%CW)         ! make space free so that DOSPAR can take this space
+         ALLOCATE (DOSPAR(NEDOS,LPAR,T_INFO%NIONP,WDES%NCDIJ))
+         SIGMA=ABS(KPOINTS%SIGMA)
+         CALL DENSTA( IO%IU0, IO%IU6, WDES, W, KPOINTS, INFO%NELECT, &
+              INFO%NUP_DOWN, E%EENTROPY, EFERMI, SIGMA, .FALSE.,  &
+              NEDOS, LPAR, T_INFO%NIONP, DOS, DOSI, PAR, DOSPAR)
+         io_begin
+         DELTAE=(KPOINTS%EMAX-KPOINTS%EMIN)/(NEDOS-1)
+
+         WRITE(16,'(2F16.8,I5,2F16.8)') KPOINTS%EMAX,KPOINTS%EMIN,NEDOS,EFERMI,1.0
+         DO I=1,NEDOS
+            EN=KPOINTS%EMIN+DELTAE*(I-1)
+            WRITE(16,7062) EN,(DOS(I,ISP)/DYN%KBLOCK,ISP=1,WDES%ISPIN),(DOSI(I,ISP)/DYN%KBLOCK,ISP=1,WDES%ISPIN)
+         ENDDO
+         
+         DO NI=1,T_INFO%NIONP
+            WRITE(16,'(2F16.8,I5,2F16.8)') KPOINTS%EMAX,KPOINTS%EMIN,NEDOS,EFERMI,1.0
+            DO I=1,NEDOS
+               EN=KPOINTS%EMIN+DELTAE*(I-1)
+               WRITE(16,'(3X,F8.3,36E12.4)') &
+                    &            EN,((DOSPAR(I,LPRO,NI,ISP),ISP=1,WDES%NCDIJ),LPRO=1,LPAR)
+            ENDDO
+         ENDDO
+         
+         CALL XML_DOS(EFERMI, KPOINTS%EMIN, KPOINTS%EMAX, .TRUE., &
+              DOS, DOSI, DOSPAR, NEDOS, LPAR, T_INFO%NIONP, WDES%NCDIJ)
+         CALL XML_PROCAR(PAR, W%CELTOT, W%FERTOT, WDES%NB_TOT, WDES%NKPTS, LPAR ,T_INFO%NIONP,WDES%NCDIJ)
+         io_end
+      ELSE IF (DYN%IBRION/=1) THEN
+         CALL DENSTA( IO%IU0, IO%IU6, WDES, W, KPOINTS, INFO%NELECT, &
+              INFO%NUP_DOWN, E%EENTROPY, EFERMI, KPOINTS%SIGMA, .FALSE.,  &
+              NEDOS, 0, 0, DOS, DOSI, PAR, DOSPAR)
+         
+         io_begin
+         DELTAE=(KPOINTS%EMAX-KPOINTS%EMIN)/(NEDOS-1)
+
+         WRITE(16,'(2F16.8,I5,2F16.8)') KPOINTS%EMAX,KPOINTS%EMIN,NEDOS,EFERMI,1.0
+         DO I=1,NEDOS
+            EN=KPOINTS%EMIN+DELTAE*(I-1)
+            WRITE(16,7062) EN,(DOS(I,ISP)/DYN%KBLOCK,ISP=1,WDES%ISPIN),(DOSI(I,ISP)/DYN%KBLOCK,ISP=1,WDES%ISPIN)
+         ENDDO
+         CALL XML_DOS(EFERMI, KPOINTS%EMIN, KPOINTS%EMAX, .FALSE., &
+              DOS, DOSI, DOSPAR, NEDOS, LPAR, T_INFO%NIONP, WDES%NCDIJ)
+         io_end
+! locproj_
+         CALL LPRJ_PROALL(W,WDES,GRID,P,CQIJ,LATT_CUR,T_INFO,INFO,IO%IU6,IO%IU0)
+! locproj_
+
+      ELSE
+! locproj_
+         CALL LPRJ_PROALL(W,WDES,GRID,P,CQIJ,LATT_CUR,T_INFO,INFO,IO%IU6,IO%IU0)
+! locproj_
+      ENDIF
+
+      CALL XML_CLOSE_TAG("calculation")
+    END IF !LJ_ONLY
+! locproj_
+!=======================================================================
+!  project the wave functions onto local functions and write to
+!  PROJCAR and LOCPROJ
+!=======================================================================
+      CALL LPRJ_WRITE(IO%IU6, IO%IU0, W)
+      CALL LPRJ_DEALLOC_COVL
+! locproj_
+
+
+      CALL XML_TAG("structure","finalpos")
+      CALL XML_CRYSTAL(LATT_CUR%A, LATT_CUR%B, LATT_CUR%OMEGA)
+      CALL XML_POSITIONS(T_INFO%NIONS, DYN%POSION)
+      IF (T_INFO%LSDYN) CALL XML_LSDYN(T_INFO%NIONS,T_INFO%LSFOR(1,1))
+      IF (DYN%IBRION<=0 .AND. DYN%NSW>0 ) CALL XML_VEL(T_INFO%NIONS, DYN%VEL)
+      IF (T_INFO%LSDYN) CALL XML_NOSE(DYN%SMASS)
+      CALL XML_CLOSE_TAG("structure")
+!=======================================================================
+! breath a sigh of relief - you have finished
+! this jump is just a jump to the END statement
+!=======================================================================
+ 5100 CONTINUE
+
+      IF (MIX%IMIX==4 .AND. INFO%IALGO.NE.-1) THEN
+        CALL CLBROYD(MIX%IUBROY)
+      ENDIF
+
+      IF (INFO%LSOFT) THEN
+         io_begin
+         IF (IO%IU0>0) &
+         WRITE(TIU0,*) 'deleting file STOPCAR'
+         IF (IO%LOPEN) OPEN(99,FILE='STOPCAR',ERR=5111)
+         CLOSE(99,STATUS='DELETE',ERR=5111)
+ 5111    CONTINUE
+         io_end
+      ENDIF
+#ifdef CUDA_GPU
+#ifdef USE_PINNED_MEMORY
+      CALL nvpinnedfree(CHTOT_PTR)
+      CALL nvpinnedfree(SV_PTR)
+#endif
+      CALL GPU_FINALIZE()
+#endif
+      CALL DUMP_ALLOCATE(IO%IU6)
+      CALL DUMP_FINAL_TIMING(IO%IU6)
+      CALL STOP_XML
+#ifdef PROFILING
+      ! started in INIT_PROFILING
+      PROFILING_STOP('total_time')
+      IF (IO%IU0>=0) THEN
+        POUT=0
+        PTHRESHOLD=0.0_q
+        CALL RDATAB(IO%LOPEN,'INCAR',IO%IU5,'PTHRESHOLD','=','#',';','F', &
+        &            IDUM,PTHRESHOLD,CDUM,LDUM,CHARAC,N,1,IERR)
+        IF ((IERR/=0).AND.(IERR/=3)) THEN
+          WRITE(IU0,*)'Error reading item ''PTHRESHOLD'' from file INCAR.'
+          STOP
+        ENDIF
+        IF (PTHRESHOLD/=0._q) POUT=POUT+1
+        PROUTINE=''
+        CALL RDATAB(IO%LOPEN,'INCAR',IO%IU5,'PROUTINE','=','#',';','S', &
+        &            IDUM,RDUM,CDUM,LDUM,PROUTINE,N,40,IERR)
+        IF ((IERR/=0).AND.(IERR/=3)) THEN
+         WRITE(IU0,*)'Error reading item ''PROUTINE'' from file INCAR.'
+         STOP
+        ENDIF
+        CALL STRIP(PROUTINE,N,'A')
+        CALL LOWER(PROUTINE)
+        IF (PROUTINE/='') POUT=POUT+1
+        PLEVEL=0
+        CALL RDATAB(IO%LOPEN,'INCAR',IO%IU5,'PLEVEL','=','#',';','I', &
+        &            PLEVEL,RDUM,CDUM,LDUM,CHARAC,N,1,IERR)
+        IF ((IERR/=0).AND.(IERR/=3)) THEN
+          WRITE(IU0,*)'Error reading item ''PLEVEL'' from file INCAR.'
+          STOP
+        ENDIF
+        IF (PLEVEL/=0) POUT=POUT+1
+        PFLAT=.FALSE.
+        CALL RDATAB(IO%LOPEN,'INCAR',IO%IU5,'PFLAT','=','#',';','L', &
+        &            IDUM,RDUM,CDUM,PFLAT,CHARAC,N,1,IERR)
+        IF ((IERR/=0).AND.(IERR/=3)) THEN
+          WRITE(IU0,*)'Error reading item ''PFLAT'' from file INCAR.'
+          STOP
+        ENDIF
+
+        IF (PTHRESHOLD/=0.0_q) CALL PRINT_FULL_PROFILE(IO%IU6,PTHRESHOLD=PTHRESHOLD,PFLAT=PFLAT)
+        IF (PROUTINE/='') CALL PRINT_ROUTINE_PROFILE(IO%IU6,PROUTINE=PROUTINE,PFLAT=PFLAT)
+        IF (PLEVEL/=0) CALL PRINT_LEVEL_PROFILE(IO%IU6,PLEVEL=PLEVEL,PFLAT=PFLAT)
+        IF (POUT==0)  CALL PRINT_FULL_PROFILE(IO%IU6,PFLAT=PFLAT)
+      ENDIF
+#endif
+      CALLMPI_C(M_exit())
+
+      CONTAINS
+
+!**********************************************************************
+!
+!  internal subroutine to perform optimization of electronic
+!  degrees of freedom
+!
+!**********************************************************************
+
+      SUBROUTINE ELECTRONIC_OPTIMIZATION
+
+      IF ( EXXOEP==1 ) THEN
+         CALL ELMIN_LHF( &
+          HAMILTONIAN,KINEDEN, &
+          P,WDES,NONLR_S,NONL_S,W,W_F,W_G,LATT_CUR,LATT_INI, &
+          T_INFO,DYN,INFO,IO,MIX,KPOINTS,SYMM,GRID,GRID_SOFT, &
+          GRIDC,GRIDB,GRIDUS,C_TO_US,B_TO_C,SOFT_TO_C,E, &
+          CHTOT,CHTOTL,DENCOR,CVTOT,CSTRF, &
+          CDIJ,CQIJ,CRHODE,N_MIX_PAW,RHOLM,RHOLM_LAST, &
+          CHDEN,SV,DOS,DOSI,CHF,CHAM,ECONV,XCSIF, &
+          NSTEP,LMDIM,IRDMAX,NEDOS, &
+          TOTEN,EFERMI,LDIMP,LMDIMP)
+      ELSEIF ( EXXOEP>1) THEN
+         CALL ELMIN_OEP( &
+          HAMILTONIAN,KINEDEN, &
+          P,WDES,NONLR_S,NONL_S,W,W_F,W_G,LATT_CUR,LATT_INI, &
+          T_INFO,DYN,INFO,IO,MIX,KPOINTS,SYMM,GRID,GRID_SOFT, &
+          GRIDC,GRIDB,GRIDUS,C_TO_US,B_TO_C,SOFT_TO_C,E, &
+          CHTOT,CHTOTL,DENCOR,CVTOT,CSTRF, &
+          CDIJ,CQIJ,CRHODE,N_MIX_PAW,RHOLM,RHOLM_LAST, &
+          CHDEN,SV,DOS,DOSI,CHF,CHAM,ECONV,XCSIF, &
+          NSTEP,LMDIM,IRDMAX,NEDOS, &
+          TOTEN,EFERMI,LDIMP,LMDIMP)
+      ELSEIF ( INFO%LONESW ) THEN
+         CALL ELMIN_ALL( &
+          HAMILTONIAN,KINEDEN, &
+          P,WDES,NONLR_S,NONL_S,W,W_F,W_G,LATT_CUR,LATT_INI, &
+          T_INFO,DYN,INFO,IO,MIX,KPOINTS,SYMM,GRID,GRID_SOFT, &
+          GRIDC,GRIDB,GRIDUS,C_TO_US,B_TO_C,SOFT_TO_C,E, &
+          CHTOT,CHTOTL,DENCOR,CVTOT,CSTRF, &
+          CDIJ,CQIJ,CRHODE,N_MIX_PAW,RHOLM,RHOLM_LAST, &
+          CHDEN,SV,DOS,DOSI,CHF,CHAM,ECONV,XCSIF, &
+          NSTEP,LMDIM,IRDMAX,NEDOS, &
+          TOTEN,EFERMI,LDIMP,LMDIMP)
+
+          ! convergence reached switch back to DIIS
+          IF (.NOT. INFO%LABORT .AND. INFO%LONESW_AUTO) THEN
+             INFO%LONESW=.FALSE.
+          ENDIF
+
+      ELSE
+         CALL ELMIN( &
+          HAMILTONIAN,KINEDEN, &
+          P,WDES,NONLR_S,NONL_S,W,W_F,W_G,LATT_CUR,LATT_INI, &
+          T_INFO,DYN,INFO,IO,MIX,KPOINTS,SYMM,GRID,GRID_SOFT, &
+          GRIDC,GRIDB,GRIDUS,C_TO_US,B_TO_C,SOFT_TO_C,E, &
+          CHTOT,CHTOTL,DENCOR,CVTOT,CSTRF, &
+          CDIJ,CQIJ,CRHODE,N_MIX_PAW,RHOLM,RHOLM_LAST, &
+          CHDEN,SV,DOS,DOSI,CHF,CHAM,ECONV,XCSIF, &
+          NSTEP,LMDIM,IRDMAX,NEDOS, &
+          TOTEN,EFERMI,LDIMP,LMDIMP)
+
+
+         IF (INFO%LABORT .AND. INFO%LONESW_AUTO) THEN
+          INFO%LONESW=.TRUE.
+          W_F%CELTOT=W%CELTOT ! copy current weights to W_F%CELTOT
+          MIX%HARD_RESET=.TRUE.
+         ! no convergence
+         ! try to switch to CG for all bands
+          CALL ELMIN_ALL( &
+          HAMILTONIAN,KINEDEN, &
+          P,WDES,NONLR_S,NONL_S,W,W_F,W_G,LATT_CUR,LATT_INI, &
+          T_INFO,DYN,INFO,IO,MIX,KPOINTS,SYMM,GRID,GRID_SOFT, &
+          GRIDC,GRIDB,GRIDUS,C_TO_US,B_TO_C,SOFT_TO_C,E, &
+          CHTOT,CHTOTL,DENCOR,CVTOT,CSTRF, &
+          CDIJ,CQIJ,CRHODE,N_MIX_PAW,RHOLM,RHOLM_LAST, &
+          CHDEN,SV,DOS,DOSI,CHF,CHAM,ECONV,XCSIF, &
+          NSTEP,LMDIM,IRDMAX,NEDOS, &
+          TOTEN,EFERMI,LDIMP,LMDIMP)
+
+         ENDIF
+      ENDIF
+      
+      END SUBROUTINE ELECTRONIC_OPTIMIZATION
+
+!**********************************************************************
+!
+!  internal subroutine to perform RPA calculations
+!  TODO: there are still logical flaws in this routine
+!  - LRPAFORCE will not work if LNBANDS is .TRUE.
+!    since STORE_WDES_GROUNDSTATE is not called
+!
+!**********************************************************************
+
+      SUBROUTINE DO_RPA
+        CALL START_TIMING("LOOPX")
+
+            CALL CALCULATE_XI( &
+                KINEDEN,HAMILTONIAN,P,WDES,NONLR_S,NONL_S,W,LATT_CUR,LATT_INI, &
+                GRID, GRIDC, GRID_SOFT, GRIDUS, C_TO_US, SOFT_TO_C,E, &
+                CHTOT, CHTOTL, DENCOR, CVTOT, CSTRF, IRDMAX, &
+                T_INFO, DYN, INFO, IO, KPOINTS, SYMM, MIX, &
+                LMDIM, CQIJ, CDIJ, CRHODE, N_MIX_PAW, RHOLM, RHOLM_LAST, CHDEN, SV, &
+                EFERMI, NEDOS, DOS, DOSI)
+         CALL PEAD_RESETUP_WDES(WDES,GRID,KPOINTS,LATT_CUR,LATT_INI,IO)
+
+#ifdef VASP2WANNIER90
+         CALL KPAR_SYNC_ALL(WDES,W)
+         CALL MLWF_WANNIER90(WDES,W,P,CQIJ,T_INFO,LATT_CUR,INFO,IO)
+#endif
+         CALL SEPERATOR_TIMING(IO%IU6)
+         CALL STOP_TIMING("LOOPX",IO%IU6,'GWTOTAL')
+
+         IF (LRPAFORCE) THEN
+            CALL LR_SKELETON( &
+                 KINEDEN,HAMILTONIAN,P,WDES,NONLR_S,NONL_S,W,LATT_CUR,LATT_INI, &
+                 T_INFO,DYN,INFO,IO,MIX,KPOINTS,SYMM,GRID,GRID_SOFT, &
+                 GRIDC,GRIDB,GRIDUS,C_TO_US,B_TO_C,SOFT_TO_C,E, &
+                 CHTOT,CHTOTL,DENCOR,CVTOT,CSTRF, &
+                 CDIJ,CQIJ,CRHODE,N_MIX_PAW,RHOLM,RHOLM_LAST, &
+                 CHDEN,SV,DOS,DOSI,CHAM, &
+                 8,LMDIM,IRDMAX,NEDOS, &
+                 TOTEN,EFERMI, TIFOR)
+            
+            CALL WRITE_RPA_FORCE( TIFOR, T_INFO, LATT_CUR, SYMM, DYN%POSIOC, DYN%IBRION, IO)
+            CALL SEPERATOR_TIMING(IO%IU6)
+            CALL STOP_TIMING("LOOPX",IO%IU6,'LINEAR')
+         ENDIF
+
+         ! now we restore the HF xc-correlation functional
+         CALL PUSH_XC_TYPE_FOR_GW
+         IF (WDES%LNONCOLLINEAR .OR. INFO%ISPIN == 2) THEN
+            CALL SETUP_LDA_XC(2,-1,-1,IO%IDIOT)
+         ELSE
+            CALL SETUP_LDA_XC(1,-1,-1,IO%IDIOT)
+         ENDIF
+         ! now update the PAW one-center terms to current functional
+         CALL SET_PAW_ATOM_POT( P , T_INFO, WDES%LOVERL, LMDIM, INFO%EALLAT, INFO%LMETAGGA, IO%IU6 )
+         ! and restore the convergence corrections
+         DO NK=1,WDES%NKPTS
+            FSG_STORE(NK)=SET_FSG(GRIDHF, LATT_CUR, NK)
+         ENDDO
+    END SUBROUTINE DO_RPA
+
+
+!**********************************************************************
+!
+!  internal subroutine to perform a few performance tests
+!  Output is written to IUT
+!
+!**********************************************************************
+
+    SUBROUTINE PERFORMANCE_TEST
+      io_begin
+      IUT=IO%IU0
+
+      IF (IUT>0) WRITE(IUT,5001)
+ 5001 FORMAT(/ &
+     & ' All results refer to a run over all bands and one k-point'/ &
+     & ' VNLACC   non local part of H'/ &
+     & ' PROJ     calculate projection of all bands (contains FFTWAV)'/ &
+     & ' RACC     non local part of H in real space (contains FFTEXT)'/ &
+     & ' RPRO     calculate projection of all bands in real space '/ &
+     & '          both calls contain on FFT (to be subtracted)'/ &
+     & ' FFTWAV   FFT of a wavefunction to real space'/ &
+     & ' FFTEXT   FFT to real space'/ &
+     & ' ECCP     internal information only (subtract FFTWAV)'/ &
+     & ' POTLOK   update of local potential (including one FFT)'/ &
+     & ' SETDIJ   calculate stregth of US PP'/ &
+     & ' ORTHCH   gramm-schmidt orth.  applying Choleski decomp.'/ &
+     & ' LINCOM   unitary transformation of wavefunctions'/ &
+     & ' LINUP    upper triangle transformation of wavefunctions'/ &
+     & ' ORTHON   orthogonalisation of one band to all others')
+       io_end
+
+
+! set the wavefunction descriptor
+      ISP=1
+      NK=1
+      CALL SETWDES(WDES,WDES1,NK)
+
+      INFO%ISPIN=1
+      INFO%RSPIN=2
+
+      NPL=WDES%NPLWKP(NK)
+      ALLOCATE(CWORK1(GRID%MPLWV),CWORK2(GRID%MPLWV),CPROTM(LMDIM*NIOND))
+      W1%CR=>CWORK1
+
+      CALLMPI( MPI_barrier( WDES%COMM%MPI_COMM, ierror ))
+#ifdef MPI
+      IF (WDES%COMM_INTER%NCPU/=1) THEN
+      CALL START_TIMING("G")
+      DO I=1,10
+         CALL REDIS_PW(WDES1, WDES%NBANDS, W%CW   (1,1,NK,1))
+      ENDDO
+      CALL STOP_TIMING("G",IUT,'10xRED')
+      ENDIF
+#endif
+
+      IF(INFO%TURBO==0)THEN
+         CALL START_TIMING("G")
+         CALL STUFAK(GRIDC,T_INFO,CSTRF)
+         CALL STOP_TIMING("G",IUT,'STUFAK')
+      ENDIF
+
+      CALL POTLOK(GRID,GRIDC,GRID_SOFT, WDES%COMM_INTER, WDES, &
+                  INFO,P,T_INFO,E,LATT_CUR, &
+                  CHTOT,CSTRF,CVTOT,DENCOR,SV, SOFT_TO_C,XCSIF)
+      CALL POTLOK_METAGGA(KINEDEN, &
+                  GRID,GRIDC,GRID_SOFT,WDES%COMM_INTER,WDES,INFO,P,T_INFO,E,LATT_CUR, &
+                  CHDEN,CHTOT,DENCOR,CVTOT,SV,HAMILTONIAN%MUTOT,HAMILTONIAN%MU,SOFT_TO_C,XCSIF)
+      CALL STOP_TIMING("G",IUT,'POTLOK ')
+
+      CALL FORLOC(GRIDC,P,T_INFO,LATT_CUR, CHTOT,TIFOR)
+      CALL STOP_TIMING("G",IUT,'FORLOC')
+
+      CALL SOFT_CHARGE(GRID,GRID_SOFT,W,WDES, CHDEN(1,1))
+      CALL STOP_TIMING("G",IUT,'CHSP  ')
+
+
+      CALL DEPLE(WDES,GRID_SOFT,GRIDC,GRIDUS,C_TO_US, &
+               LATT_CUR,P,T_INFO,SYMM, INFO%LOVERL, SOFT_TO_C,&
+               LMDIM,CRHODE, CHTOT,CHDEN, IRDMAX)
+
+      CALL SET_RHO_PAW(WDES, P, T_INFO, INFO%LOVERL, WDES%NCDIJ, LMDIM, &
+           CRHODE, RHOLM)
+      CALL STOP_TIMING("G",IUT,'DEPLE ')
+
+      IF (INFO%LREAL) THEN
+
+        CALL RSPHER(GRID,NONLR_S,LATT_CUR)
+        CALL STOP_TIMING("G",IUT,'RSPHER')
+        CWORK2=0
+        CALL START_TIMING("G")
+        CALL RACCT(NONLR_S,WDES,W,GRID,CDIJ,CQIJ, ISP, LMDIM, NK)
+        CALL STOP_TIMING("G",IUT,'RACC')
+
+      ELSE
+
+        CALL PHASE(WDES,NONL_S,NK)
+        NPL=WDES%NPLWKP(NK)
+        CALL START_TIMING("G")
+        DO N=1,WDES%NBANDS
+          EVALUE=W%CELEN(N,1,1)
+          CALL SETWAV(W,W1,WDES1,N,1)  ! allocation for W1%CR done above
+          CALL VNLACC(NONL_S,W1,CDIJ,CQIJ, ISP, EVALUE,  CWORK2)
+        ENDDO
+        CALL STOP_TIMING("G",IUT,'VNLACC')
+      ENDIF
+
+
+      CALL START_TIMING("G")
+      IF (INFO%LREAL) THEN
+        CALL START_TIMING("G")
+        CALL RPRO(NONLR_S,WDES,W,GRID,NK)
+        CALL STOP_TIMING("G",IUT,'RPRO  ')
+      ELSE
+        CALL PROJ(NONL_S,WDES,W,NK)
+        CALL STOP_TIMING("G",IUT,'PROJ  ')
+      ENDIF
+
+      CALL START_TIMING("G")
+      DO  N=1,WDES%NBANDS
+        CALL FFTWAV(NPL,WDES%NINDPW(1,NK),CWORK1,W%CPTWFP(1,N,NK,1),GRID)
+      ENDDO
+      CALL STOP_TIMING("G",IUT,'FFTWAV')
+
+      DO N=1,WDES%NBANDS
+        CALL INIDAT(GRID%RC%NP,CWORK1)
+      ENDDO
+      CALL STOP_TIMING("G",IUT,'FFTINI')
+
+
+      DO N=1,WDES%NBANDS
+        CALL INIDAT(GRID%RC%NP,CWORK1)
+        CALL FFT3D(CWORK1,GRID,1)
+      ENDDO
+      CALL STOP_TIMING("G",IUT,'FFT3DF')
+
+      DO N=1,WDES%NBANDS
+        CALL INIDAT(GRID%RC%NP,CWORK1)
+        CALL FFT3D(CWORK1,GRID,1)
+        CALL FFT3D(CWORK1,GRID,-1)
+      ENDDO
+      CALL STOP_TIMING("G",IUT,'FFTFB ')
+
+      DO N=1,WDES%NBANDS
+        CALL INIDAT(GRID%RL%NP,CWORK1)
+        CALL FFTEXT(NPL,WDES%NINDPW(1,NK),CWORK1,CWORK2,GRID,.FALSE.)
+      ENDDO
+
+      CALL STOP_TIMING("G",IUT,'FFTEXT ')
+
+      DO N=1,WDES%NBANDS
+          CALL FFTWAV(NPL,WDES%NINDPW(1,NK),CWORK1,W%CPTWFP(1,N,NK,1),GRID)
+          CALL SETWAV(W,W1,WDES1,N,1)  ! allocation for W1%CR done above
+          IF (ASSOCIATED(HAMILTONIAN%MU)) THEN
+             CALL ECCP_TAU(WDES1,W1,W1,LMDIM,CDIJ,GRID,SV,LATT_CUR,HAMILTONIAN%MU,W1%CELEN)
+          ELSE
+             CALL ECCP(WDES1,W1,W1,LMDIM,CDIJ,GRID,SV, W1%CELEN)
+          ENDIF
+      ENDDO
+
+      CALL STOP_TIMING("G",IUT,'ECCP ')
+
+      CALL SETDIJ(WDES,GRIDC,GRIDUS,C_TO_US,LATT_CUR,P,T_INFO,INFO%LOVERL, &
+                  LMDIM,CDIJ,CQIJ,CVTOT,IRDMAA,IRDMAX)
+
+      CALL STOP_TIMING("G",IUT,'SETDIJ ')
+
+      CALL SET_DD_PAW(WDES, P , T_INFO, INFO%LOVERL, &
+         INFO%ISPIN, LMDIM, CDIJ,  RHOLM, CRHODE, &
+          E,  LMETA =  .FALSE., LASPH =INFO%LASPH , LCOREL=.FALSE.)
+
+      CALL UPDATE_CMBJ(GRIDC,T_INFO,LATT_CUR,IO%IU6)
+
+      CALL STOP_TIMING("G",IUT,'SETPAW ')
+
+      CALL ORTHCH(WDES,W, INFO%LOVERL, LMDIM,CQIJ)
+      CALL REDIS_PW_OVER_BANDS(WDES, W)
+      CALL STOP_TIMING("G",IUT,'ORTHCH')
+
+      IF (INFO%LDIAG) THEN
+        IFLAG=3
+      ELSE
+        IFLAG=4
+      ENDIF
+      CALL EDDIAG(HAMILTONIAN,GRID,LATT_CUR,NONLR_S,NONL_S,W,WDES,SYMM, &
+          LMDIM,CDIJ,CQIJ, IFLAG,SV,T_INFO,P,IO%IU0,E%EXHF)
+
+      CALL REDIS_PW_OVER_BANDS(WDES, W)
+      CALL STOP_TIMING("G",IUT,'EDDIAG')
+
+! avoid that MATMUL is too clever
+      ALLOCATE(CMAT(WDES%NB_TOT,WDES%NB_TOT))
+      DO N1=1,WDES%NB_TOT
+      DO N2=1,WDES%NB_TOT
+        IF (N1==N2)  THEN
+         CMAT(N1,N2)=0.99999_q
+        ELSE
+         CMAT(N1,N2)=EXP((0.7_q,0.5_q)/100)
+       ENDIF
+      ENDDO
+      ENDDO
+
+      NPRO= WDES%NPRO
+      CALLMPI( SET_NPL_NPRO(WDES1, NPL, NPRO))
+#ifdef MPI
+      NCPU=WDES%COMM_INTER%NCPU ! number of procs involved in band dis.
+#else
+      NCPU=1
+#endif
+      NRPLWV_RED=WDES%NRPLWV/NCPU
+      NPROD_RED =WDES%NPROD /NCPU
+
+      CALL START_TIMING("G")
+      CALL LINCOM('F',W%CPTWFP(:,:,NK,1),W%CPROJ(:,:,NK,1),CMAT(1,1), &
+       WDES%NB_TOT,WDES%NB_TOT,NPL,0,NRPLWV_RED,NPROD_RED,WDES%NB_TOT, &
+       W%CPTWFP(:,:,NK,1),W%CPROJ(:,:,NK,1))
+      CALL STOP_TIMING("G",IUT,'LINCOM')
+
+      CALL LINCOM('F',W%CPTWFP(:,:,NK,1),W%CPROJ(:,:,NK,1),CMAT(1,1), &
+       WDES%NB_TOT,WDES%NB_TOT,NPL,NPRO,NRPLWV_RED,NPROD_RED,WDES%NB_TOT, &
+       W%CPTWFP(:,:,NK,1),W%CPROJ(:,:,NK,1))
+      CALL STOP_TIMING("G",IUT,'LINCOM')
+
+      CALL LINCOM('U',W%CPTWFP(:,:,NK,1),W%CPROJ(:,:,NK,1),CMAT(1,1), &
+       WDES%NB_TOT,WDES%NB_TOT,NPL,NPRO,NRPLWV_RED,NPROD_RED,WDES%NB_TOT, &
+       W%CPTWFP(:,:,NK,1),W%CPROJ(:,:,NK,1))
+      CALL STOP_TIMING("G",IUT,'LINUP ')
+    END SUBROUTINE PERFORMANCE_TEST
+
+  END PROGRAM
diff -urN file_ini/.objects file_modify/.objects
--- file_ini/.objects	2024-07-13 10:37:12.000000000 +0800
+++ file_modify/.objects	2024-07-13 10:37:23.000000000 +0800
@@ -1,377 +1,382 @@
-SOURCE=\
-	c2f_interface.o \
-	base.o \
-	profiling.o \
-	openmp.o \
-	mpi.o \
-	mpi_shmem.o \
-	smart_allocate.o \
-	xml.o \
-	constant.o \
-	jacobi.o  \
-	main_mpi.o \
-	scala.o \
-	asa.o \
-	lattice.o \
-	poscar.o \
-	ini.o \
-	mgrid.o \
-	xclib.o \
-	vdw_nl.o \
-	xclib_grad.o \
-	radial.o \
-	pseudo.o \
-	gridq.o \
-	ebs.o \
-	mkpoints.o \
-	wave.o \
-	wave_mpi.o \
-	wave_high.o \
-	bext.o \
-	spinsym.o \
-	symlib.o \
-	symmetry.o \
-	lattlib.o \
-	random.o \
-	nonl.o \
-	nonlr.o \
-	nonl_high.o \
-	dfast.o \
-	choleski2.o \
-	mix.o \
-	hamil.o \
-	xcgrad.o \
-	xcspin.o \
-	potex1.o \
-	potex2.o \
-	constrmag.o \
-	cl_shift.o \
-	relativistic.o \
-	LDApU.o \
-	paw_base.o \
-	metagga.o \
-	egrad.o \
-	pawsym.o \
-	pawfock.o \
-	pawlhf.o \
-	rhfatm.o \
-	hyperfine.o \
-	paw.o \
-	mkpoints_full.o \
-	charge.o \
-	Lebedev-Laikov.o \
-	stockholder.o \
-	dipol.o \
-	solvation.o \
-	pot.o \
-	dos.o \
-	elf.o \
-	tet.o \
-	tetweight.o \
-	hamil_rot.o \
-	chain.o \
-	dyna.o \
-	k-proj.o \
-	sphpro.o \
-	us.o \
-	core_rel.o \
-	aedens.o \
-	wavpre.o \
-	wavpre_noio.o \
-	broyden.o \
-	dynbr.o \
-	reader.o \
-	writer.o \
-	tutor.o \
-	xml_writer.o \
-	brent.o \
-	stufak.o \
-	fileio.o \
-	opergrid.o \
-	stepver.o \
-	chgloc.o \
-	fast_aug.o \
-	fock_multipole.o \
-	fock.o \
-	fock_dbl.o \
-	mkpoints_change.o \
-	subrot_cluster.o \
-	sym_grad.o \
-	mymath.o \
-	npt_dynamics.o \
-	subdftd3.o \
-	internals.o \
-	dynconstr.o \
-	dimer_heyden.o \
-	dvvtrajectory.o \
-	vdwforcefield.o \
-	hamil_high.o \
-	nmr.o \
-	pead.o \
-	subrot.o \
-	subrot_scf.o \
-	paircorrection.o \
-	rpa_force.o \
-	force.o \
-	pwlhf.o \
-	gw_model.o \
-	optreal.o \
-	steep.o \
-	rmm-diis.o \
-	davidson.o \
-	david_inner.o \
-	lcao_bare.o \
-	locproj.o \
-	electron.o \
-	rot.o \
-	electron_all.o \
-	shm.o \
-	pardens.o \
-	optics.o \
-	constr_cell_relax.o \
-	stm.o \
-	finite_diff.o \
-	elpol.o \
-	hamil_lr.o \
-	rmm-diis_lr.o \
-	subrot_lr.o \
-	lr_helper.o \
-	hamil_lrf.o \
-	elinear_response.o \
-	ilinear_response.o \
-	linear_optics.o \
-	setlocalpp.o \
-	wannier.o \
-	electron_OEP.o \
-	electron_lhf.o \
-	twoelectron4o.o \
-	gauss_quad.o \
-	m_unirnk.o \
-	varpro.o \
-	minimax.o \
-	mlwf.o \
-	wnpr.o \
-	ratpol.o \
-	pade_fit.o \
-	screened_2e.o \
-	wave_cacher.o \
-	crpa.o \
-	chi_base.o \
-	wpot.o \
-	local_field.o \
-	ump2.o \
-	ump2kpar.o \
-	fcidump.o \
-	ump2no.o \
-	bse_te.o \
-	bse.o \
-	acfdt.o \
-	chi.o \
-	sydmat.o \
-	rmm-diis_mlr.o \
-	linear_response_NMR.o \
-	wannier_interpol.o \
-	linear_response.o \
-	dmft.o \
-	auger.o \
-	dmatrix.o \
-	elphon.o
-
-SOURCE_O1 = \
-	cl_shift.o \
-	paw.o
-
-SOURCE_O2 = \
-	wave.o \
-	wave_gpu.o \
-	us.o \
-	LDApU.o
-
-SOURCE_IN= \
-	xcgrad.o \
-	xcspin.o
-
-SOURCE_GPU =  \
-	c2f_interface.o \
-	cuda_interface.o \
-	base.o \
-	base_gpu.o \
-	profiling.o \
-	openmp.o \
-	mpi_gpu.o \
-	smart_allocate.o \
-	xml.o \
-	constant.o \
-	jacobi.o \
-	main_mpi.o \
-	scala.o \
-	asa.o \
-	lattice.o \
-	poscar.o \
-	ini.o \
-	mgrid.o \
-	xclib.o \
-	vdw_nl.o \
-	xclib_grad_gpu.o \
-	radial.o \
-	pseudo.o \
-	gridq.o \
-	ebs.o \
-	mkpoints.o \
-	wave_gpu.o \
-	wave_mpi_gpu.o \
-	wave_high_gpu.o \
-	bext.o \
-	spinsym.o \
-	symlib.o \
-	symmetry.o \
-	lattlib.o \
-	random.o \
-	nonl.o \
-	nonlr_gpu.o \
-	nonl_high.o \
-	nonl_high_gpu.o \
-	dfast.o \
-	dfast_gpu.o \
-	choleski2_gpu.o \
-	mix.o \
-	hamil.o \
-	hamil_gpu.o \
-	xcgrad_gpu.o \
-	xcspin.o \
-	potex1.o \
-	potex2.o \
-	constrmag.o \
-	cl_shift.o \
-	relativistic.o \
-	LDApU.o \
-	paw_base.o \
-	metagga.o \
-	egrad.o \
-	pawsym.o \
-	pawfock.o \
-	pawlhf.o \
-	rhfatm.o \
-	hyperfine.o \
-	paw.o \
-	mkpoints_full.o \
-	charge.o \
-	charge_gpu.o \
-	Lebedev-Laikov.o \
-	stockholder.o \
-	dipol.o \
-	solvation.o\
-	pot.o \
-	pot_gpu.o \
-	dos.o \
-	elf.o \
-	tet.o \
-	tetweight.o \
-	hamil_rot.o \
-	chain.o \
-	dyna.o \
-	k-proj.o \
-	sphpro.o \
-	us.o \
-	core_rel.o \
-	aedens.o \
-	wavpre.o \
-	wavpre_noio_gpu.o \
-	broyden.o \
-	dynbr.o \
-	reader.o \
-	writer.o \
-	tutor.o \
-	xml_writer.o \
-	brent.o \
-	stufak.o \
-	fileio.o \
-	opergrid.o \
-	stepver.o \
-	chgloc.o \
-	fast_aug.o \
-	fock_multipole.o \
-	fock_gpu.o \
-	mkpoints_change.o \
-	subrot_cluster.o \
-	sym_grad.o \
-	mymath.o \
-	npt_dynamics.o \
-	subdftd3.o \
-	internals.o \
-	dynconstr.o \
-	dimer_heyden.o \
-	dvvtrajectory.o \
-	vdwforcefield.o \
-	hamil_high.o \
-	nmr.o \
-	pead.o \
-	subrot_gpu.o \
-	subrot_scf.o \
-	paircorrection.o \
-	rpa_force.o \
-	force.o \
-	pwlhf.o \
-	gw_model.o \
-	optreal.o \
-	steep.o \
-	rmm-diis_gpu.o \
-	davidson_gpu.o \
-	david_inner.o \
-	lcao_bare.o \
-	locproj.o \
-	electron_gpu.o \
-	rot.o \
-	electron_all.o \
-	shm.o \
-	pardens.o \
-	optics.o \
-	constr_cell_relax.o \
-	stm.o \
-	finite_diff.o \
-	elpol.o \
-	hamil_lr.o \
-	rmm-diis_lr.o \
-	subrot_lr.o \
-	lr_helper.o \
-	hamil_lrf.o \
-	elinear_response.o \
-	ilinear_response.o \
-	linear_optics.o \
-	setlocalpp.o \
-	wannier.o \
-	electron_OEP.o \
-	electron_lhf.o \
-	twoelectron4o.o \
-	gauss_quad.o \
-	m_unirnk.o \
-	varpro.o\
-	minimax.o \
-	mlwf.o \
-	wnpr.o \
-	ratpol.o \
-	pade_fit.o \
-	screened_2e.o \
-	wave_cacher.o \
-	crpa.o \
-	chi_base.o \
-	wpot.o \
-	local_field.o \
-	ump2.o \
-	ump2kpar.o \
-	fcidump.o \
-	ump2no.o \
-	bse_te.o \
-	bse.o \
-	acfdt.o \
-	main_gpu.o \
-	chi.o \
-	sydmat.o \
-	rmm-diis_mlr.o \
-	linear_response_NMR.o \
-	wannier_interpol.o \
-	linear_response.o \
-	dmft.o \
-	auger.o \
-	dmatrix.o \
-	elphon.o
+SOURCE=\
+	c2f_interface.o \
+	base.o \
+	profiling.o \
+	openmp.o \
+	mpi.o \
+	mpi_shmem.o \
+	smart_allocate.o \
+	xml.o \
+	constant.o \
+	jacobi.o  \
+	main_mpi.o \
+	scala.o \
+	asa.o \
+	lattice.o \
+	poscar.o \
+	ini.o \
+	mgrid.o \
+	xclib.o \
+	vdw_nl.o \
+	xclib_grad.o \
+	radial.o \
+	pseudo.o \
+	gridq.o \
+	ebs.o \
+	mkpoints.o \
+	wave.o \
+	wave_mpi.o \
+	wave_high.o \
+	bext.o \
+	spinsym.o \
+	symlib.o \
+	symmetry.o \
+	lattlib.o \
+	random.o \
+	nonl.o \
+	nonlr.o \
+	nonl_high.o \
+	dfast.o \
+	choleski2.o \
+	mix.o \
+	hamil.o \
+	xcgrad.o \
+	xcspin.o \
+	potex1.o \
+	potex2.o \
+	constrmag.o \
+	cl_shift.o \
+	relativistic.o \
+	LDApU.o \
+	paw_base.o \
+	metagga.o \
+	egrad.o \
+	pawsym.o \
+	pawfock.o \
+	pawlhf.o \
+	rhfatm.o \
+	hyperfine.o \
+	paw.o \
+	mkpoints_full.o \
+	charge.o \
+	Lebedev-Laikov.o \
+	stockholder.o \
+	dipol.o \
+	solvation.o \
+	pot.o \
+	dos.o \
+	elf.o \
+	tet.o \
+	tetweight.o \
+	hamil_rot.o \
+	chain.o \
+	dyna.o \
+	k-proj.o \
+	sphpro.o \
+	us.o \
+	core_rel.o \
+	aedens.o \
+	wavpre.o \
+	wavpre_noio.o \
+	broyden.o \
+	dynbr.o \
+	reader.o \
+	writer.o \
+	tutor.o \
+	xml_writer.o \
+	brent.o \
+	stufak.o \
+	fileio.o \
+	opergrid.o \
+	stepver.o \
+	chgloc.o \
+	fast_aug.o \
+	fock_multipole.o \
+	fock.o \
+	fock_dbl.o \
+	mkpoints_change.o \
+	subrot_cluster.o \
+	sym_grad.o \
+	mymath.o \
+	npt_dynamics.o \
+	subdftd3.o \
+	internals.o \
+	dynconstr.o \
+	dimer_heyden.o \
+	dvvtrajectory.o \
+	vdwforcefield.o \
+	hamil_high.o \
+	nmr.o \
+	pead.o \
+	subrot.o \
+	subrot_scf.o \
+	paircorrection.o \
+	rpa_force.o \
+	force.o \
+	pwlhf.o \
+	gw_model.o \
+	optreal.o \
+	steep.o \
+	rmm-diis.o \
+	davidson.o \
+	david_inner.o \
+	lcao_bare.o \
+	locproj.o \
+	electron.o \
+	rot.o \
+	electron_all.o \
+	shm.o \
+	pardens.o \
+	optics.o \
+	constr_cell_relax.o \
+	stm.o \
+	finite_diff.o \
+	elpol.o \
+	hamil_lr.o \
+	rmm-diis_lr.o \
+	subrot_lr.o \
+	lr_helper.o \
+	hamil_lrf.o \
+	elinear_response.o \
+	ilinear_response.o \
+	emlr_potential.o \
+	emlr_hamiltonian.o \
+	emlr_broyden.o \
+	emlr.o \
+	adiabatic_magnon.o \
+	linear_optics.o \
+	setlocalpp.o \
+	wannier.o \
+	electron_OEP.o \
+	electron_lhf.o \
+	twoelectron4o.o \
+	gauss_quad.o \
+	m_unirnk.o \
+	varpro.o \
+	minimax.o \
+	mlwf.o \
+	wnpr.o \
+	ratpol.o \
+	pade_fit.o \
+	screened_2e.o \
+	wave_cacher.o \
+	crpa.o \
+	chi_base.o \
+	wpot.o \
+	local_field.o \
+	ump2.o \
+	ump2kpar.o \
+	fcidump.o \
+	ump2no.o \
+	bse_te.o \
+	bse.o \
+	acfdt.o \
+	chi.o \
+	sydmat.o \
+	rmm-diis_mlr.o \
+	linear_response_NMR.o \
+	wannier_interpol.o \
+	linear_response.o \
+	dmft.o \
+	auger.o \
+	dmatrix.o \
+	elphon.o
+
+SOURCE_O1 = \
+	cl_shift.o \
+	paw.o
+
+SOURCE_O2 = \
+	wave.o \
+	wave_gpu.o \
+	us.o \
+	LDApU.o
+
+SOURCE_IN= \
+	xcgrad.o \
+	xcspin.o
+
+SOURCE_GPU =  \
+	c2f_interface.o \
+	cuda_interface.o \
+	base.o \
+	base_gpu.o \
+	profiling.o \
+	openmp.o \
+	mpi_gpu.o \
+	smart_allocate.o \
+	xml.o \
+	constant.o \
+	jacobi.o \
+	main_mpi.o \
+	scala.o \
+	asa.o \
+	lattice.o \
+	poscar.o \
+	ini.o \
+	mgrid.o \
+	xclib.o \
+	vdw_nl.o \
+	xclib_grad_gpu.o \
+	radial.o \
+	pseudo.o \
+	gridq.o \
+	ebs.o \
+	mkpoints.o \
+	wave_gpu.o \
+	wave_mpi_gpu.o \
+	wave_high_gpu.o \
+	bext.o \
+	spinsym.o \
+	symlib.o \
+	symmetry.o \
+	lattlib.o \
+	random.o \
+	nonl.o \
+	nonlr_gpu.o \
+	nonl_high.o \
+	nonl_high_gpu.o \
+	dfast.o \
+	dfast_gpu.o \
+	choleski2_gpu.o \
+	mix.o \
+	hamil.o \
+	hamil_gpu.o \
+	xcgrad_gpu.o \
+	xcspin.o \
+	potex1.o \
+	potex2.o \
+	constrmag.o \
+	cl_shift.o \
+	relativistic.o \
+	LDApU.o \
+	paw_base.o \
+	metagga.o \
+	egrad.o \
+	pawsym.o \
+	pawfock.o \
+	pawlhf.o \
+	rhfatm.o \
+	hyperfine.o \
+	paw.o \
+	mkpoints_full.o \
+	charge.o \
+	charge_gpu.o \
+	Lebedev-Laikov.o \
+	stockholder.o \
+	dipol.o \
+	solvation.o\
+	pot.o \
+	pot_gpu.o \
+	dos.o \
+	elf.o \
+	tet.o \
+	tetweight.o \
+	hamil_rot.o \
+	chain.o \
+	dyna.o \
+	k-proj.o \
+	sphpro.o \
+	us.o \
+	core_rel.o \
+	aedens.o \
+	wavpre.o \
+	wavpre_noio_gpu.o \
+	broyden.o \
+	dynbr.o \
+	reader.o \
+	writer.o \
+	tutor.o \
+	xml_writer.o \
+	brent.o \
+	stufak.o \
+	fileio.o \
+	opergrid.o \
+	stepver.o \
+	chgloc.o \
+	fast_aug.o \
+	fock_multipole.o \
+	fock_gpu.o \
+	mkpoints_change.o \
+	subrot_cluster.o \
+	sym_grad.o \
+	mymath.o \
+	npt_dynamics.o \
+	subdftd3.o \
+	internals.o \
+	dynconstr.o \
+	dimer_heyden.o \
+	dvvtrajectory.o \
+	vdwforcefield.o \
+	hamil_high.o \
+	nmr.o \
+	pead.o \
+	subrot_gpu.o \
+	subrot_scf.o \
+	paircorrection.o \
+	rpa_force.o \
+	force.o \
+	pwlhf.o \
+	gw_model.o \
+	optreal.o \
+	steep.o \
+	rmm-diis_gpu.o \
+	davidson_gpu.o \
+	david_inner.o \
+	lcao_bare.o \
+	locproj.o \
+	electron_gpu.o \
+	rot.o \
+	electron_all.o \
+	shm.o \
+	pardens.o \
+	optics.o \
+	constr_cell_relax.o \
+	stm.o \
+	finite_diff.o \
+	elpol.o \
+	hamil_lr.o \
+	rmm-diis_lr.o \
+	subrot_lr.o \
+	lr_helper.o \
+	hamil_lrf.o \
+	elinear_response.o \
+	ilinear_response.o \
+	linear_optics.o \
+	setlocalpp.o \
+	wannier.o \
+	electron_OEP.o \
+	electron_lhf.o \
+	twoelectron4o.o \
+	gauss_quad.o \
+	m_unirnk.o \
+	varpro.o\
+	minimax.o \
+	mlwf.o \
+	wnpr.o \
+	ratpol.o \
+	pade_fit.o \
+	screened_2e.o \
+	wave_cacher.o \
+	crpa.o \
+	chi_base.o \
+	wpot.o \
+	local_field.o \
+	ump2.o \
+	ump2kpar.o \
+	fcidump.o \
+	ump2no.o \
+	bse_te.o \
+	bse.o \
+	acfdt.o \
+	main_gpu.o \
+	chi.o \
+	sydmat.o \
+	rmm-diis_mlr.o \
+	linear_response_NMR.o \
+	wannier_interpol.o \
+	linear_response.o \
+	dmft.o \
+	auger.o \
+	dmatrix.o \
+	elphon.o
diff -urN file_ini/pot.F file_modify/pot.F
--- file_ini/pot.F	2024-07-13 10:37:12.000000000 +0800
+++ file_modify/pot.F	2024-07-13 10:37:23.000000000 +0800
@@ -2,6 +2,24 @@
       MODULE pot
       USE prec
       USE charge
+      USE xcspin_interface
+
+      INTERFACE
+        SUBROUTINE POTHAR(GRIDC,LATT_CUR, CHTOT,CVD,DENC,QVEC_CART)
+        USE prec
+        USE mpimy
+        USE mgrid
+        USE lattice
+        USE constant
+        IMPLICIT COMPLEX(q) (C)
+        IMPLICIT REAL(q) (A-B,D-H,O-Z)
+
+        TYPE (grid_3d)     GRIDC
+        TYPE (latt)        LATT_CUR
+        COMPLEX(q) CVD(GRIDC%RC%NP),CHTOT(GRIDC%RC%NP)
+        REAL(q), OPTIONAL :: QVEC_CART(3)
+        END SUBROUTINE POTHAR
+      END INTERFACE
       CONTAINS
 !************************ SUBROUTINE POTLOK ****************************
 ! RCS:  $Id: pot.F,v 1.5 2003/06/27 13:22:22 kresse Exp kresse $
@@ -24,7 +42,7 @@
 
     SUBROUTINE POTLOK(GRID,GRIDC,GRID_SOFT, COMM_INTER, WDES,  &
                   INFO,P,T_INFO,E,LATT_CUR,  &
-                  CHTOT,CSTRF,CVTOT,DENCOR,SV, SOFT_TO_C,XCSIF )
+                  CHTOT,CSTRF,CVTOT,DENCOR,SV, SOFT_TO_C,XCSIF,CHTOT1_GGAcorr,QVEC_CART )
       USE prec
       USE mpimy
       USE mgrid
@@ -68,6 +86,9 @@
       COMPLEX(q), ALLOCATABLE::  CWORK1(:),CWORK(:,:)
       REAL(q) ELECTROSTATIC
       LOGICAL, EXTERNAL :: L_NO_LSDA_GLOBAL
+! First order density
+      COMPLEX(q), OPTIONAL :: CHTOT1_GGAcorr(GRIDC%MPLWV,WDES%NCDIJ)
+      REAL(q), OPTIONAL :: QVEC_CART(3)
 
 #ifdef libbeef
       LOGICAL LBEEFCALCBASIS, LBEEFBAS
@@ -118,6 +139,7 @@
 
         DO ISP=1,WDES%NCDIJ
            CALL FFT3D(CHTOT(1,ISP),GRIDC,1)
+           IF (PRESENT(CHTOT1_GGAcorr) .AND. PRESENT(QVEC_CART)) CALL FFT3D(CHTOT1_GGAcorr(1,ISP),GRIDC,1)
         ENDDO
 
 #ifdef libbeef	
@@ -133,7 +155,10 @@
 #endif
 
         IF (WDES%ISPIN==2) THEN
-
+          IF (PRESENT(CHTOT1_GGAcorr) .AND. PRESENT(QVEC_CART)) THEN
+             WRITE(*,*) 'DFPT ONLY SUPPORT NONCOLLINEAR CALCULATION'
+             STOP
+          ENDIF
           ! get the charge and the total magnetization
           CALL MAG_DENSITY(CHTOT, CWORK, GRIDC, WDES%NCDIJ)
 ! do LDA+U instead of LSDA+U
@@ -165,8 +190,13 @@
         ELSEIF (WDES%LNONCOLLINEAR) THEN
           IF (ISGGA()) THEN
              ! GGA potential
-             CALL FEXCGS(4, GRIDC, LATT_CUR, XCENCG, EXCG, CVZERG, TMPSIF, &
-                  CHTOT, CVTOT, DENCOR)
+             IF (PRESENT(CHTOT1_GGAcorr) .AND. PRESENT(QVEC_CART)) THEN
+                CALL FEXCGS(4, GRIDC, LATT_CUR, XCENCG, EXCG, CVZERG, TMPSIF, &
+                     CHTOT, CVTOT, DENCOR,CHTOT1_GGAcorr,QVEC_CART)
+             ELSE
+                CALL FEXCGS(4, GRIDC, LATT_CUR, XCENCG, EXCG, CVZERG, TMPSIF, &
+                     CHTOT, CVTOT, DENCOR)
+             ENDIF
           ENDIF
 
           ! FEXCF requires (up,down) density instead of (rho,mag)
@@ -187,6 +217,10 @@
                     
           CALL MAG_DIRECTION(CHTOT(1,1), CVTOT(1,1), GRIDC, WDES%NCDIJ)
        ELSE
+          IF (PRESENT(CHTOT1_GGAcorr) .AND. PRESENT(QVEC_CART)) THEN
+             WRITE(*,*) 'DFPT ONLY SUPPORT NONCOLLINEAR CALCULATION'
+             STOP
+          ENDIF
           IF (ISGGA()) THEN
              ! gradient corrections to LDA
              CALL FEXCG(GRIDC,LATT_CUR,XCENCG,EXCG,CVZERG,TMPSIF, &
@@ -258,7 +292,7 @@
       ELSE xc
          DO ISP=1,WDES%NCDIJ
             CALL FFT3D(CHTOT(1,ISP),GRIDC,1)
-         ENDDO
+        ENDDO
       ENDIF xc
 !-MM- changes to accomodate constrained moments
 !-----------------------------------------------------------------------
@@ -314,7 +348,11 @@
 !-----------------------------------------------------------------------
 ! add the hartree potential and the double counting corrections
 !-----------------------------------------------------------------------
-      CALL POTHAR(GRIDC, LATT_CUR, CHTOT, CWORK,E%DENC)
+      IF (PRESENT(CHTOT1_GGAcorr) .AND. PRESENT(QVEC_CART)) THEN
+         CALL POTHAR(GRIDC, LATT_CUR, CHTOT, CWORK,E%DENC,QVEC_CART)
+      ELSE
+         CALL POTHAR(GRIDC, LATT_CUR, CHTOT, CWORK,E%DENC)
+      ENDIF
       DO I=1,GRIDC%RC%NP
          CVTOT(I,1)=CVTOT(I,1)+CWORK(I,1)
       ENDDO
@@ -803,7 +841,7 @@
 !
 !***********************************************************************
 
-      SUBROUTINE POTHAR(GRIDC,LATT_CUR, CHTOT,CVD,DENC)
+      SUBROUTINE POTHAR(GRIDC,LATT_CUR, CHTOT,CVD,DENC,QVEC_CART)
       USE prec
       USE mpimy
       USE mgrid
@@ -815,6 +853,7 @@
       TYPE (grid_3d)     GRIDC
       TYPE (latt)        LATT_CUR
       COMPLEX(q) CVD(GRIDC%RC%NP),CHTOT(GRIDC%RC%NP)
+      REAL(q), OPTIONAL :: QVEC_CART(3)
 
       DENC=0._q
 !=======================================================================
@@ -840,6 +879,12 @@
         GY= (GRIDC%LPCTX(N1)*LATT_CUR%B(2,1)+GRIDC%LPCTY(N2)*LATT_CUR%B(2,2)+GRIDC%LPCTZ(N3)*LATT_CUR%B(2,3))
         GZ= (GRIDC%LPCTX(N1)*LATT_CUR%B(3,1)+GRIDC%LPCTY(N2)*LATT_CUR%B(3,2)+GRIDC%LPCTZ(N3)*LATT_CUR%B(3,3))
 
+        IF (PRESENT(QVEC_CART)) THEN
+           GX=GX+QVEC_CART(1)
+           GY=GY+QVEC_CART(2)
+           GZ=GZ+QVEC_CART(3)
+        ENDIF
+
         GSQU=GX**2+GY**2+GZ**2
 !=======================================================================
 ! since the G=0 coulomb contributions to the hartree, ewald and
@@ -849,6 +894,9 @@
         IF ((GRIDC%LPCTX(N1)==0).AND.(GRIDC%LPCTY(N2)==0).AND.(GRIDC%LPCTZ(N3)==0)) &
      & THEN
           CVD(NI)=(0.0_q,0.0_q)
+           IF (PRESENT(QVEC_CART)) THEN
+              IF (SQRT(SUM(QVEC_CART**2))>=1E-5_q) CVD(NI)=CHTOT(NI)/GSQU*SCALE
+           ENDIF
         ELSE
           CVD(NI)=CHTOT(NI)/GSQU*SCALE
         ENDIF
diff -urN file_ini/reader.F file_modify/reader.F
--- file_ini/reader.F	1970-01-01 08:00:00.000000000 +0800
+++ file_modify/reader.F	2024-07-13 10:37:23.000000000 +0800
@@ -0,0 +1,1767 @@
+#include "symbol.inc"
+      SUBROUTINE READER &
+     &       (IU5,IU0,INTERACTIVE,SZNAM1,ISTART,IALGO,IMIX,MAXMIX,MREMOVE, &
+     &        AMIX,BMIX,AMIX_MAG,BMIX_MAG,AMIN, &
+     &        WC,INIMIX,MIXPRE,MIXFIRST,LFOUND,LDIAG,LSUBROT,LREAL,LREALD, &
+     &        LPDENS,IBRION,ICHARG,INIWAV,NELM,NELMALL,NELMIN,NELMDL,EDIFF, &
+     &        EDIFFG,NSW,ISIF,IWAVPR,ISYM,NBLOCK,KBLOCK,ENMAX,POTIM, &
+     &        TEBEG,TEEND,NFREE, &
+     &        NPACO,APACO,NTYPIN,NTYPD,SMASS,SCALEE,POMASS, & 
+     &        DARWIN_V,DARWIN_R,VCA,LVCADER, &
+     &        RWIGS,NELECT,NUP_DOWN,TIME,EMIN,EMAX,EFERMI,ISMEAR,SPACING,LGAMMA, & 
+     &        PSTRESS,NDAV, &
+     &        SIGMA,LTET,WEIMIN,EBREAK,DEPER,NWRITE,LCORR, &
+     &        IDIOT,NIONS,NTYPP,lmusic,LOPTICS,STM, &
+     &        ISPIN,ATOMOM,NIOND,LWAVE,LDOWNSAMPLE,LCHARG,LVTOT,LVHAR,SZPREC, &
+     &        ENAUG,LORBIT,LELF,ROPT,ENINI, &
+     &        NGX,NGY,NGZ,NGXF,NGYF,NGZF,NBANDS,NEDOS,NBLK,LATT_CUR, &
+     &        LPLANE_WISE,LCOMPAT,LMAX_CALC,LMAX_MIX,NSIM,LPARD,LPAW,LADDGRID, &
+     &        LNONCOLLINEAR,LSORBIT,SAXIS,LMETAGGA, &
+     &        LSPIRAL,LZEROZ,QSPIRAL,LORBITALREAL, &
+     &        LASPH,TURBO,IRESTART,NREBOOT,NMIN,EREF, &
+     &        NLSPLINE,ISPECIAL,MDALGO &
+#ifdef libbeef
+     &       ,LBEEFENS,LBEEFBAS &
+#endif
+     &       )
+
+
+      USE prec
+      USE base
+      USE sym_prec
+      USE ini
+      USE lattice
+      USE scala
+      USE wave_mpi
+      USE constant
+      USE pseudo   ! for subroutine EXTYP
+      USE vaspxml
+      IMPLICIT COMPLEX(q) (C)
+      IMPLICIT REAL(q) (A-B,D-H,O-Z)
+
+      TYPE (latt)        LATT_CUR
+#ifdef LONGCHAR
+      CHARACTER (32767)INPLIN
+#else
+      CHARACTER (255)  INPLIN
+#endif
+      CHARACTER (1)    CHARAC, ALGO
+      CHARACTER (40)   SZNAM1
+      CHARACTER (40)   SZNAM
+      CHARACTER (6)    SZPREC
+      LOGICAL   LDUM,MIXFIRST,LFOUND,LDIAG,LSUBROT,LREAL,LREALD,LPDENS,LTET,LOPTICS, &
+     &          LCORR,LOPEN,lmusic,LWAVE,LDOWNSAMPLE,LCHARG,LVTOT,LVHAR, &
+     &          LORBIT_,LELF,LCOMPAT,LPARD,LPAW,LADDGRID, &
+     &          LNONCOLLINEAR,LSORBIT,LMETAGGA, &
+     &          LBEEFENS,LBEEFBAS, &
+     &          LPLANE_WISE, &
+     &          LASPH,INTERACTIVE,LORBITALREAL,LVCADER
+      DIMENSION POMASS(NTYPD),RWIGS(NTYPP), &
+     &          ROPT(NTYPD),DARWIN_V(NTYPD),DARWIN_R(NTYPD),VCA(NTYPD)
+      DIMENSION ATOMOM(*)
+      REAL(q)   SAXIS(3)
+      REAL(q)   NELECT,NUP_DOWN
+      REAL(q)   STM(7)
+      INTEGER   TURBO,IRESTART,NREBOOT,NMIN
+      REAL(q)   EREF
+      REAL(q)   SPACING
+      LOGICAL   LGAMMA
+      LOGICAL   NLSPLINE
+      INTEGER   ISPECIAL
+      INTEGER   MDALGO 
+!-MM- Spin spiral stuff      
+      LOGICAL   LSPIRAL,LZEROZ
+      REAL(q)   QSPIRAL(3)
+!-MM- end of addition
+
+! 'title'-string (defaults to 'unknown system'), keyword 'SYSTEM'
+      LOPEN=.FALSE.
+      OPEN(UNIT=IU5,FILE=INCAR,STATUS='OLD')
+
+      SZNAM='unknown system'
+      CALL RDATAB(LOPEN,INCAR,IU5,'SYSTEM','=','#',';','S', &
+     &            IDUM,RDUM,CDUM,LDUM,SZNAM,N,40,IERR)
+      IF ((IERR/=0).AND.(IERR/=3)) THEN
+         IF (IU0>=0) &
+         WRITE(IU0,*)'Error reading item ''SYSTEM'' from file INCAR.'
+         GOTO 150
+      ENDIF
+      CALL XML_INCAR('SYSTEM','S',IDUM,RDUM,CDUM,LDUM,SZNAM,N)
+
+      CALL STRIP(SZNAM,N,'L')
+      SZNAM1=SZNAM
+! start flag ISTART: a default value ISTART=1 should do the best job!
+      ISTART=1
+! ... of course if 'WAVECAR' doesnt exist --> take ISTART=0 ...
+      IF (.NOT.LFOUND) ISTART=0
+      CALL RDATAB(LOPEN,INCAR,IU5,'ISTART','=','#',';','I', &
+     &            ISTART,RDUM,CDUM,LDUM,CHARAC,N,1,IERR)
+      IF (((IERR/=0).AND.(IERR/=3)).OR. &
+     &                    ((IERR==0).AND.(N<1))) THEN
+         IF (IU0>=0) &
+         WRITE(IU0,*)'Error reading item ''ISTART'' from file INCAR.'
+         GOTO 150
+      ENDIF
+      CALL XML_INCAR('ISTART','I',ISTART,RDUM,CDUM,LDUM,CHARAC,N)
+! the 'idiot flag' (for VTUTOR ...), defaults to 3 ('complete idiot')
+      IDIOT=3
+      CALL RDATAB(LOPEN,INCAR,IU5,'IDIOT','=','#',';','I', &
+     &            IDIOT,RDUM,CDUM,LDUM,CHARAC,N,1,IERR)
+      IF (((IERR/=0).AND.(IERR/=3)).OR. &
+     &                    ((IERR==0).AND.(N<1))) THEN
+         IF (IU0>=0) &
+         WRITE(IU0,*)'Error reading item ''IDIOT'' from file INCAR.'
+         GOTO 150
+      ENDIF
+      IF (IDIOT<0) IDIOT=0
+      IF (IDIOT>3) IDIOT=3
+      CALL XML_INCAR('IDIOT','I',IDIOT,RDUM,CDUM,LDUM,CHARAC,N)
+! ... read in the required precision (low - medium - high)
+      SZNAM='NORMAL'
+      CALL RDATAB(LOPEN,INCAR,IU5,'PREC','=','#',';','S', &
+     &            IDUM,RDUM,CDUM,LDUM,SZNAM,N,40,IERR)
+      IF ((IERR/=0).AND.(IERR/=3)) THEN
+         IF (IU0>=0) &
+         WRITE(IU0,*)'Error reading item ''PREC'' from file INCAR.'
+         GOTO 150
+      ENDIF
+      CALL STRIP(SZNAM,N,'L')
+      CALL LOWER(SZNAM)
+      SZPREC=SZNAM(1:6)
+      CALL XML_INCAR('PREC','S',IDUM,RDUM,CDUM,LDUM,SZNAM,N)
+! algorithm: default is 8 (prec. CG)
+      IALGO=38
+      CALL RDATAB(LOPEN,INCAR,IU5,'IALGO','=','#',';','I', &
+     &            IALGO,RDUM,CDUM,LDUM,CHARAC,N,1,IERR)
+      IF (((IERR/=0).AND.(IERR/=3)).OR. &
+     &                    ((IERR==0).AND.(N<1))) THEN
+         IF (IU0>=0) &
+         WRITE(IU0,*)'Error reading item ''IALGO'' from file INCAR.'
+         GOTO 150
+      ENDIF
+      CALL XML_INCAR('IALGO','I',IALGO,RDUM,CDUM,LDUM,CHARAC,N)
+! algorithm: tag ALGO overwrites IALGO 
+      INPLIN="--"
+      CALL RDATAB(LOPEN,INCAR,IU5,'ALGO','=','#',';','S', &
+     &            IDUM,RDUM,CDUM,LDUM,INPLIN,N,40,IERR)
+      IF (((IERR/=0).AND.(IERR/=3)).OR. &
+     &                    ((IERR==0).AND.(N<1))) THEN
+         IF (IU0>=0) &
+         WRITE(IU0,*)'Error reading item ''ALGO'' from file INCAR.'
+         GOTO 150
+      ENDIF
+      CALL XML_INCAR('ALGO','S',IDUM,RDUM,CDUM,LDUM,INPLIN,N)
+      CALL STRIP(INPLIN,N,'L')
+      CALL LOWER(INPLIN)
+      ALGO=INPLIN(1:1)
+
+      IF ( INPLIN(1:4)=='fast') THEN
+         IALGO=68
+      ELSE IF ( INPLIN(1:1)=='f') THEN
+         IALGO=68
+      ELSE IF ( INPLIN(1:4)=='very') THEN
+         IALGO=48
+      ELSE IF ( INPLIN(1:1)=='v') THEN
+         IALGO=48
+      ELSE IF ( INPLIN(1:4)=='none') THEN
+         IALGO=2
+      ELSE IF ( INPLIN(1:7)=='nothing') THEN
+         IALGO=2
+      ELSE IF ( INPLIN(1:6)=='normal') THEN
+         IALGO=38
+      ELSE IF ( INPLIN(1:1)=='n') THEN
+         IALGO=38
+      ELSE IF ( INPLIN(1:4)=='diag') THEN
+         IALGO=90
+      ELSE IF ( INPLIN(1:5)=='exact') THEN
+         IALGO=90
+      ELSE IF ( INPLIN(1:6)=='davidi') THEN
+         IALGO=88
+      ELSE IF ( INPLIN(1:2)=='cf' .or. INPLIN(1:2)=='af' .or. INPLIN(1:4)=='allf'  ) THEN
+         IALGO=108
+      ELSE IF ( INPLIN(1:1)=='c') THEN
+         IALGO=58
+      ELSE IF ( INPLIN(1:1)=='a' .AND. INPLIN(1:2)/='ac' ) THEN
+         IALGO=58
+      ELSE IF ( INPLIN(1:6)=='damped') THEN
+         IALGO=53
+      ELSE IF ( INPLIN(1:1)=='d') THEN
+         IALGO=53
+      ELSE IF ( INPLIN(1:8)=='eigenval') THEN
+         IALGO=3
+      ELSE IF ( INPLIN(1:6)=='subrot') THEN
+         IALGO=4
+      ELSE IF ( INPLIN(1:1)=='s') THEN
+         IALGO=4
+      ELSE IF ( INPLIN(1:3)=='jdh' .OR. INPLIN(1:1)=='i') THEN
+         IALGO=78
+      ENDIF
+! max. number of iterations NRMM in RMM-DIIS (NDAV), default usually 4
+      NDAV=4
+      IF (IALGO>=70 .AND. IALGO<90) NDAV=40
+      CALL RDATAB(LOPEN,INCAR,IU5,'NRMM','=','#',';','I', &
+     &            NDAV,RDUM,CDUM,LDUM,CHARAC,N,1,IERR)
+      IF (((IERR/=0).AND.(IERR/=3)).OR. &
+     &                    ((IERR==0).AND.(N<1))) THEN
+         IF (IU0>=0) &
+         WRITE(IU0,*)'Error reading item ''NRMM'' from file INCAR.'
+         GOTO 150
+      ENDIF
+      CALL XML_INCAR('NRMM','I',NDAV,RDUM,CDUM,LDUM,CHARAC,N)
+! band blocking in RMM-DIIS and Davidson (and some other subroutines)
+      NSIM=4
+      ! deep iterations, do only few bands in one go
+      ! otherwise the diagonalization steps become very expensive
+      IF (IALGO>=70 .AND. IALGO<90) NSIM=2
+      ! for the Davidson it is advisable to increase blocking
+      CALL RDATAB(LOPEN,INCAR,IU5,'NSIM','=','#',';','I', &
+     &            NSIM,RDUM,CDUM,LDUM,CHARAC,N,1,IERR)
+      IF (((IERR/=0).AND.(IERR/=3)).OR. &
+     &                    ((IERR==0).AND.(N<1))) THEN
+         IF (IU0>=0) &
+         WRITE(IU0,*)'Error reading item ''NSIM'' from file INCAR.'
+         GOTO 150
+      ENDIF
+      CALL XML_INCAR('NSIM','I',NSIM,RDUM,CDUM,LDUM,CHARAC,N)
+! LDIAG -- use subspace diagonalization or not (default is TRUE):
+      LDIAG=.TRUE.
+      CALL RDATAB(LOPEN,INCAR,IU5,'LDIAG','=','#',';','L', &
+     &            IDUM,RDUM,CDUM,LDIAG,CHARAC,N,1,IERR)
+      IF (((IERR/=0).AND.(IERR/=3)).OR. &
+     &                    ((IERR==0).AND.(N<1))) THEN
+         IF (IU0>=0) &
+         WRITE(IU0,*)'Error reading item ''LDIAG'' from file INCAR.'
+         GOTO 150
+      ENDIF
+      CALL XML_INCAR('LDIAG','L',IDUM,RDUM,CDUM,LDIAG,CHARAC,N)
+! LSUBROT -- use subspace diagonalization or not (default is FALSE):
+      LSUBROT=.FALSE.
+      CALL RDATAB(LOPEN,INCAR,IU5,'LSUBROT','=','#',';','L', &
+     &            IDUM,RDUM,CDUM,LSUBROT,CHARAC,N,1,IERR)
+      IF (((IERR/=0).AND.(IERR/=3)).OR. &
+     &                    ((IERR==0).AND.(N<1))) THEN
+         IF (IU0>=0) &
+         WRITE(IU0,*)'Error reading item ''LSUBROT'' from file INCAR.'
+         GOTO 150
+      ENDIF
+      CALL XML_INCAR('LSUBROT','L',IDUM,RDUM,CDUM,LSUBROT,CHARAC,N)
+! LADDGRID -- use an additional grid for the calculation of the US-PP
+      LADDGRID=.FALSE.
+!      IF (SZPREC(1:1)=='a') LADDGRID=.TRUE.
+      CALL RDATAB(LOPEN,INCAR,IU5,'ADDGRID','=','#',';','L', &
+     &            IDUM,RDUM,CDUM,LADDGRID,CHARAC,N,1,IERR)
+      IF (((IERR/=0).AND.(IERR/=3)).OR. &
+     &                    ((IERR==0).AND.(N<1))) THEN
+         IF (IU0>=0) &
+         WRITE(IU0,*)'Error reading item ''LADDGRID'' from file INCAR.'
+         GOTO 150
+      ENDIF
+      CALL XML_INCAR('ADDGRID','L',IDUM,RDUM,CDUM,LADDGRID,CHARAC,N)
+! read in flag LSORBIT
+      LSORBIT=.FALSE.
+      CALL RDATAB(LOPEN,INCAR,IU5,'LSORBIT','=','#',';','L', &
+     &            IDUM,RDUM,CDUM,LSORBIT,CHARAC,N,1,IERR)
+      IF (((IERR/=0).AND.(IERR/=3)).OR. &
+     &                    ((IERR==0).AND.(N<1))) THEN
+         IF (IU0>=0) &
+         WRITE(IU0,*)'Error reading item ''LSORBIT'' from file INCAR.'
+         GOTO 150
+      ENDIF
+      CALL XML_INCAR('LSORBIT','L',IDUM,RDUM,CDUM,LSORBIT,CHARAC,N)
+! read in flag LNONCOLLINEAR
+      LNONCOLLINEAR=LSORBIT
+      CALL RDATAB(LOPEN,INCAR,IU5,'LNONCOLLINEAR','=','#',';','L', &
+     &            IDUM,RDUM,CDUM,LNONCOLLINEAR,CHARAC,N,1,IERR)
+      IF (((IERR/=0).AND.(IERR/=3)).OR. &
+     &                    ((IERR==0).AND.(N<1))) THEN
+         IF (IU0>=0) &
+         WRITE(IU0,*)'Error reading item ''LNONCOLLINEAR'' from file INCAR.'
+         GOTO 150
+      ENDIF
+      IF (LSORBIT) LNONCOLLINEAR=LSORBIT
+      CALL XML_INCAR('LNONCOLLINEAR','L',IDUM,RDUM,CDUM,LNONCOLLINEAR,CHARAC,N)
+
+! ... read spin quantisation axis
+      SAXIS(1)=0
+      SAXIS(2)=0
+      SAXIS(3)=1
+      CALL RDATAB(LOPEN,INCAR,IU5,'SAXIS','=','#',';','F', &
+     &            IDUM,SAXIS,CDUM,LDUM,CHARAC,N,3,IERR)
+      IF (((IERR/=0).AND.(IERR/=3)).OR. &
+     &                    ((IERR==0).AND.(N/=3))) THEN
+         IF (IU0>=0) &
+         WRITE(IU0,*)'Error reading item ''SAXIS'' from file INCAR.'
+         GOTO 150
+      ENDIF
+      CALL XML_INCAR_V('SAXIS','F',IDUM,SAXIS,CDUM,LDUM,CHARAC,N)
+
+#if defined(NGXhalf) ||  defined(NGZhalf)
+      IF (LNONCOLLINEAR) THEN
+         WRITE(*,*) 'ERROR: non collinear calculations require that VASP is compiled'
+         WRITE(*,*) ' without the flag -DNGXhalf and -DNGZhalf'
+         STOP
+      ENDIF
+#endif
+! spin polarized calculation? (1 is default)
+      ISPIN=1
+      CALL RDATAB(LOPEN,INCAR,IU5,'ISPIN','=','#',';','I', &
+     &            ISPIN,RDUM,CDUM,LDUM,CHARAC,N,1,IERR)
+      IF (((IERR/=0).AND.(IERR/=3)).OR. &
+     &                    ((IERR==0).AND.(N<1))) THEN
+         IF (IU0>=0) &
+         WRITE(IU0,*)'Error reading item ''ISPIN'' from file INCAR.'
+         GOTO 150
+      ENDIF
+      IF (ISPIN>=2) ISPIN=2
+      IF (ISPIN<=1) ISPIN=1
+
+      CALL XML_INCAR('ISPIN','I',ISPIN,RDUM,CDUM,LDUM,CHARAC,N)
+
+! Mixing parameters: by default use IMIX=4 (Broyden) with AMIX=0.8,
+! BMIX=1.0 (should work almost always ...), WC=100, INIMIX=1, MIXPRE=1
+      IMIX=4
+      CALL RDATAB(LOPEN,INCAR,IU5,'IMIX','=','#',';','I', &
+     &            IMIX,RDUM,CDUM,LDUM,CHARAC,N,1,IERR)
+      IF (((IERR/=0).AND.(IERR/=3)).OR. &
+     &                    ((IERR==0).AND.(N<1))) THEN
+         IF (IU0>=0) &
+         WRITE(IU0,*)'Error reading item ''IMIX'' from file INCAR.'
+         GOTO 150
+      ENDIF
+      CALL XML_INCAR('IMIX','I',IMIX,RDUM,CDUM,LDUM,CHARAC,N)
+
+! MIXFIRST mix before diagonalization
+      MIXFIRST=.FALSE.
+      CALL RDATAB(LOPEN,INCAR,IU5,'MIXFIRST','=','#',';','L', &
+     &            IDUM,RDUM,CDUM,MIXFIRST,CHARAC,N,1,IERR)
+      IF (((IERR/=0).AND.(IERR/=3)).OR. &
+     &                    ((IERR==0).AND.(N<1))) THEN
+         IF (IU0>=0) &
+         WRITE(IU0,*)'Error reading item ''MIXFIRST'' from file INCAR.'
+         GOTO 150
+      ENDIF
+      CALL XML_INCAR('MIXFIRST','L',IDUM,RDUM,CDUM,MIXFIRST,CHARAC,N)
+
+      MAXMIX=-45
+      CALL RDATAB(LOPEN,INCAR,IU5,'MAXMIX','=','#',';','I', &
+     &            MAXMIX,RDUM,CDUM,LDUM,CHARAC,N,1,IERR)
+      IF (((IERR/=0).AND.(IERR/=3)).OR. &
+     &                    ((IERR==0).AND.(N<1))) THEN
+         IF (IU0>=0) &
+         WRITE(IU0,*)'Error reading item ''MAXMIX'' from file INCAR.'
+         GOTO 150
+      ENDIF
+      CALL XML_INCAR('MAXMIX','I',MAXMIX,RDUM,CDUM,LDUM,CHARAC,N)
+
+      MREMOVE=5
+      CALL RDATAB(LOPEN,INCAR,IU5,'MREMOVE','=','#',';','I', &
+     &            MREMOVE,RDUM,CDUM,LDUM,CHARAC,N,1,IERR)
+      IF (((IERR/=0).AND.(IERR/=3)).OR. &
+     &                    ((IERR==0).AND.(N<1))) THEN
+         IF (IU0>=0) &
+         WRITE(IU0,*)'Error reading item ''MREMOVE'' from file INCAR.'
+         GOTO 150
+      ENDIF
+      CALL XML_INCAR('MREMOVE','I',MREMOVE,RDUM,CDUM,LDUM,CHARAC,N)
+
+
+      AMIX=0.8_q; IF (ISPIN == 2) AMIX = 0.4_q 
+      IF (LPAW) AMIX=0.4_q
+
+      CALL RDATAB(LOPEN,INCAR,IU5,'AMIX','=','#',';','F', &
+     &            IDUM,AMIX,CDUM,LDUM,CHARAC,N,1,IERR)
+      IF (((IERR/=0).AND.(IERR/=3)).OR. &
+     &                    ((IERR==0).AND.(N<1))) THEN
+         IF (IU0>=0) &
+         WRITE(IU0,*)'Error reading item ''AMIX'' from file INCAR.'
+         GOTO 150
+      ENDIF
+      CALL XML_INCAR('AMIX','F',IDUM,AMIX,CDUM,LDUM,CHARAC,N)
+
+      BMIX=1.0_q;
+      IF (LPAW) BMIX=1.0_q
+      CALL RDATAB(LOPEN,INCAR,IU5,'BMIX','=','#',';','F', &
+     &            IDUM,BMIX,CDUM,LDUM,CHARAC,N,1,IERR)
+      IF (((IERR/=0).AND.(IERR/=3)).OR. &
+     &                    ((IERR==0).AND.(N<1))) THEN
+         IF (IU0>=0) &
+         WRITE(IU0,*)'Error reading item ''BMIX'' from file INCAR.'
+         GOTO 150
+      ENDIF
+      CALL XML_INCAR('BMIX','F',IDUM,BMIX,CDUM,LDUM,CHARAC,N)
+
+      AMIX_MAG=AMIX*4
+      CALL RDATAB(LOPEN,INCAR,IU5,'AMIX_MAG','=','#',';','F', &
+     &            IDUM,AMIX_MAG,CDUM,LDUM,CHARAC,N,1,IERR)
+      IF (((IERR/=0).AND.(IERR/=3)).OR. &
+     &                    ((IERR==0).AND.(N<1))) THEN
+         IF (IU0>=0) &
+         WRITE(IU0,*)'Error reading item ''AMIX_MAG'' from file INCAR.'
+         GOTO 150
+      ENDIF
+      CALL XML_INCAR('AMIX_MAG','F',IDUM,AMIX_MAG,CDUM,LDUM,CHARAC,N)
+
+      AMIN=MIN(0.1_q, AMIX, AMIX_MAG)
+      CALL RDATAB(LOPEN,INCAR,IU5,'AMIN','=','#',';','F', &
+     &            IDUM,AMIN,CDUM,LDUM,CHARAC,N,1,IERR)
+      IF (((IERR/=0).AND.(IERR/=3)).OR. &
+     &                    ((IERR==0).AND.(N<1))) THEN
+         IF (IU0>=0) &
+         WRITE(IU0,*)'Error reading item ''AMIN'' from file INCAR.'
+         GOTO 150
+      ENDIF
+      CALL XML_INCAR('AMIN','F',IDUM,AMIN,CDUM,LDUM,CHARAC,N)
+
+      BMIX_MAG=BMIX
+      CALL RDATAB(LOPEN,INCAR,IU5,'BMIX_MAG','=','#',';','F', &
+     &            IDUM,BMIX_MAG,CDUM,LDUM,CHARAC,N,1,IERR)
+      IF (((IERR/=0).AND.(IERR/=3)).OR. &
+     &                    ((IERR==0).AND.(N<1))) THEN
+         IF (IU0>=0) &
+         WRITE(IU0,*)'Error reading item ''BMIX_MAG'' from file INCAR.'
+         GOTO 150
+      ENDIF
+      CALL XML_INCAR('BMIX_MAG','F',IDUM,BMIX_MAG,CDUM,LDUM,CHARAC,N)
+
+      WC=100._q
+      CALL RDATAB(LOPEN,INCAR,IU5,'WC','=','#',';','F', &
+     &            IDUM,WC,CDUM,LDUM,CHARAC,N,1,IERR)
+      IF (((IERR/=0).AND.(IERR/=3)).OR. &
+     &                    ((IERR==0).AND.(N<1))) THEN
+         IF (IU0>=0) &
+         WRITE(IU0,*)'Error reading item ''WC'' from file INCAR.'
+         GOTO 150
+      ENDIF
+      CALL XML_INCAR('WC','F',IDUM,WC,CDUM,LDUM,CHARAC,N)
+
+      INIMIX=1
+      CALL RDATAB(LOPEN,INCAR,IU5,'INIMIX','=','#',';','I', &
+     &            INIMIX,RDUM,CDUM,LDUM,CHARAC,N,1,IERR)
+      IF (((IERR/=0).AND.(IERR/=3)).OR. &
+     &                    ((IERR==0).AND.(N<1))) THEN
+         IF (IU0>=0) &
+         WRITE(IU0,*)'Error reading item ''INIMIX'' from file INCAR.'
+         GOTO 150
+      ENDIF
+      CALL XML_INCAR('INIMIX','I',INIMIX,RDUM,CDUM,LDUM,CHARAC,N)
+
+      MIXPRE=1
+      CALL RDATAB(LOPEN,INCAR,IU5,'MIXPRE','=','#',';','I', &
+     &            MIXPRE,RDUM,CDUM,LDUM,CHARAC,N,1,IERR)
+      IF (((IERR/=0).AND.(IERR/=3)).OR. &
+     &                    ((IERR==0).AND.(N<1))) THEN
+         IF (IU0>=0) &
+         WRITE(IU0,*)'Error reading item ''MIXPRE'' from file INCAR.'
+         GOTO 150
+      ENDIF
+      CALL XML_INCAR('MIXPRE','I',MIXPRE,RDUM,CDUM,LDUM,CHARAC,N)
+
+! initial charge density ICHARG (default 0, if startjob: default 2)
+      ICHARG=0
+      IF (ISTART==0) ICHARG=2
+      CALL RDATAB(LOPEN,INCAR,IU5,'ICHARG','=','#',';','I', &
+     &            ICHARG,RDUM,CDUM,LDUM,CHARAC,N,1,IERR)
+      IF (((IERR/=0).AND.(IERR/=3)).OR. &
+     &                    ((IERR==0).AND.(N<1))) THEN
+         IF (IU0>=0) &
+         WRITE(IU0,*)'Error reading item ''ICHARG'' from file INCAR.'
+         GOTO 150
+      ENDIF
+      CALL XML_INCAR('ICHARG','I',ICHARG,RDUM,CDUM,LDUM,CHARAC,N)
+
+      LPDENS=.FALSE.
+      IF (ICHARG<0) THEN
+         ICHARG=0
+         LPDENS=.TRUE.
+      ENDIF
+! initial wavefunctions (defaults is 1, warning: keyword is 'INIWAV')
+      INIWAV=1
+      CALL RDATAB(LOPEN,INCAR,IU5,'INIWAV','=','#',';','I', &
+     &            INIWAV,RDUM,CDUM,LDUM,CHARAC,N,1,IERR)
+      IF (((IERR/=0).AND.(IERR/=3)).OR. &
+     &                    ((IERR==0).AND.(N<1))) THEN
+         IF (IU0>=0) &
+         WRITE(IU0,*)'Error reading item ''INIWAV'' from file INCAR.'
+         GOTO 150
+      ENDIF
+      CALL XML_INCAR('INIWAV','I',INIWAV,RDUM,CDUM,LDUM,CHARAC,N)
+
+! max/min. number of electronic minimization steps, delay ... (default
+! shall be NELM=60, NELMIN=2, NELMDL=-5 if ISTART=0 and
+! NELM=60, NELMIN=2, NELMDL=0 if ISTART/=0 ...):
+      NELM=60
+      CALL RDATAB(LOPEN,INCAR,IU5,'NELM','=','#',';','I', &
+     &            NELM,RDUM,CDUM,LDUM,CHARAC,N,1,IERR)
+      IF (((IERR/=0).AND.(IERR/=3)).OR. &
+     &                    ((IERR==0).AND.(N<1))) THEN
+         IF (IU0>=0) &
+         WRITE(IU0,*)'Error reading item ''NELM'' from file INCAR.'
+         GOTO 150
+      ENDIF
+      CALL XML_INCAR('NELM','I',NELM,RDUM,CDUM,LDUM,CHARAC,N)
+
+      NELMALL=NELM
+      CALL RDATAB(LOPEN,INCAR,IU5,'NELMALL','=','#',';','I', &
+     &            NELMALL,RDUM,CDUM,LDUM,CHARAC,N,1,IERR)
+      IF (((IERR/=0).AND.(IERR/=3)).OR. &
+     &                    ((IERR==0).AND.(N<1))) THEN
+         IF (IU0>=0) &
+         WRITE(IU0,*)'Error reading item ''NELMALL'' from file INCAR.'
+         GOTO 150
+      ENDIF
+      CALL XML_INCAR('NELMALL','I',NELMALL,RDUM,CDUM,LDUM,CHARAC,N)
+
+      NELMDL=0
+      IF (ISTART==0 .AND. INIWAV==1) THEN
+         NELMDL=-5
+         IF (IALGO>=40 .AND. IALGO<=50) NELMDL=-12
+      ENDIF
+      CALL RDATAB(LOPEN,INCAR,IU5,'NELMDL','=','#',';','I', &
+     &            NELMDL,RDUM,CDUM,LDUM,CHARAC,N,1,IERR)
+      IF (((IERR/=0).AND.(IERR/=3)).OR. &
+     &                    ((IERR==0).AND.(N<1))) THEN
+         IF (IU0>=0) &
+         WRITE(IU0,*)'Error reading item ''NELMDL'' from file INCAR.'
+         GOTO 150
+      ENDIF
+      CALL XML_INCAR('NELMDL','I',NELMDL,RDUM,CDUM,LDUM,CHARAC,N)
+
+      NELMIN=2
+      CALL RDATAB(LOPEN,INCAR,IU5,'NELMIN','=','#',';','I', &
+     &            NELMIN,RDUM,CDUM,LDUM,CHARAC,N,1,IERR)
+      IF (((IERR/=0).AND.(IERR/=3)).OR. &
+     &                    ((IERR==0).AND.(N<1))) THEN
+         IF (IU0>=0) &
+         WRITE(IU0,*)'Error reading item ''NELMIN'' from file INCAR.'
+         GOTO 150
+      ENDIF
+      CALL XML_INCAR('NELMIN','I',NELMIN,RDUM,CDUM,LDUM,CHARAC,N)
+
+! conjugate gradient or quasi-Newton method? (default IBRION=0)
+      IBRION=0
+      CALL RDATAB(LOPEN,INCAR,IU5,'IBRION','=','#',';','I', &
+     &            IBRION,RDUM,CDUM,LDUM,CHARAC,N,1,IERR)
+      IF (((IERR/=0).AND.(IERR/=3)).OR. &
+     &                    ((IERR==0).AND.(N<1))) THEN
+         IF (IU0>=0) &
+         WRITE(IU0,*)'Error reading item ''IBRION'' from file INCAR.'
+         GOTO 150
+      ENDIF
+      CALL XML_INCAR('IBRION','I',IBRION,RDUM,CDUM,LDUM,CHARAC,N)
+
+! number of degrees of freedom
+      IF (IBRION==2) THEN
+         NFREE=1
+      ELSE
+         NFREE=0
+      ENDIF
+      CALL RDATAB(LOPEN,INCAR,IU5,'NFREE','=','#',';','I', &
+     &            NFREE,RDUM,CDUM,LDUM,CHARAC,N,1,IERR)
+      IF (((IERR/=0).AND.(IERR/=3)).OR. &
+     &                    ((IERR==0).AND.(N<1))) THEN
+         IF (IU0>=0) &
+         WRITE(IU0,*)'Error reading item ''NFREE'' from file INCAR.'
+         GOTO 150
+      ENDIF
+      CALL XML_INCAR('NFREE','I',NFREE,RDUM,CDUM,LDUM,CHARAC,N)
+
+! energy tolerances (defaults: EDIFF=1E-4, EDIFFG=1E-3)
+      EDIFF=1E-4_q
+      IF (IBRION==5 .OR. IBRION==6 .OR. IBRION==7 .OR. IBRION==8 .OR. IBRION==9 .OR. IBRION==19) EDIFF=1E-6_q
+      CALL RDATAB(LOPEN,INCAR,IU5,'EDIFF','=','#',';','F', &
+     &            IDUM,EDIFF,CDUM,LDUM,CHARAC,N,1,IERR)
+      IF (((IERR/=0).AND.(IERR/=3)).OR. &
+     &                    ((IERR==0).AND.(N<1))) THEN
+         IF (IU0>=0) &
+         WRITE(IU0,*)'Error reading item ''EDIFF'' from file INCAR.'
+         GOTO 150
+      ENDIF
+      CALL XML_INCAR('EDIFF','F',IDUM,EDIFF,CDUM,LDUM,CHARAC,N)
+      ! for reasons of safety (crazy user are present all over the world):
+      EDIFF=MAX(ABS(EDIFF),1.E-12_q)
+
+      EDIFFG=EDIFF*10
+      CALL RDATAB(LOPEN,INCAR,IU5,'EDIFFG','=','#',';','F', &
+     &            IDUM,EDIFFG,CDUM,LDUM,CHARAC,N,1,IERR)
+      IF (((IERR/=0).AND.(IERR/=3)).OR. &
+     &                    ((IERR==0).AND.(N<1))) THEN
+         IF (IU0>=0) &
+         WRITE(IU0,*)'Error reading item ''EDIFFG'' from file INCAR.'
+         GOTO 150
+      ENDIF
+      CALL XML_INCAR('EDIFFG','F',IDUM,EDIFFG,CDUM,LDUM,CHARAC,N)
+! number of ionic steps, calculate stresses? (default NSW=0, ISIF=2):
+      NSW=0
+      IF (IBRION==5 .OR. IBRION==6 .OR. IBRION==7 .OR. IBRION==8 .OR. IBRION==9 .OR. IBRION==19) NSW=1
+      CALL RDATAB(LOPEN,INCAR,IU5,'NSW','=','#',';','I', &
+     &            NSW,RDUM,CDUM,LDUM,CHARAC,N,1,IERR)
+      IF (((IERR/=0).AND.(IERR/=3)).OR. &
+     &                    ((IERR==0).AND.(N<1))) THEN
+         IF (IU0>=0) &
+         WRITE(IU0,*)'Error reading item ''NSW'' from file INCAR.'
+         GOTO 150
+      ENDIF
+      CALL XML_INCAR('NSW','I',NSW,RDUM,CDUM,LDUM,CHARAC,N)
+! IBRION is 'useless' if NSW=0, set this flag to -1 in this case ...
+      IF (NSW==0) IBRION=-1
+      ISIF=2
+      ! if MD is selected dont calculate stress
+      IF (IBRION==0) ISIF=0
+      CALL RDATAB(LOPEN,INCAR,IU5,'ISIF','=','#',';','I', &
+     &            ISIF,RDUM,CDUM,LDUM,CHARAC,N,1,IERR)
+      IF (((IERR/=0).AND.(IERR/=3)).OR. &
+     &                    ((IERR==0).AND.(N<1))) THEN
+         IF (IU0>=0) &
+         WRITE(IU0,*)'Error reading item ''ISIF'' from file INCAR.'
+         GOTO 150
+      ENDIF
+      CALL XML_INCAR('ISIF','I',ISIF,RDUM,CDUM,LDUM,CHARAC,N)
+! prediction of wavefunction:
+      IWAVPR=0
+! MDs
+      IF (IBRION==0) IWAVPR=2
+#ifdef MPI
+      IF (IWAVPR > 0) THEN
+         IWAVPR=IWAVPR+10
+      ENDIF
+#endif
+! relaxation: IWAVPR=1
+      IF (IBRION>0) IWAVPR=1
+      CALL RDATAB(LOPEN,INCAR,IU5,'IWAVPR','=','#',';','I', &
+     &            IWAVPR,RDUM,CDUM,LDUM,CHARAC,N,1,IERR)
+      IF (((IERR/=0).AND.(IERR/=3)).OR. &
+     &                    ((IERR==0).AND.(N<1))) THEN
+         IF (IU0>=0) &
+         WRITE(IU0,*)'Error reading item ''IWAVPR'' from file INCAR.'
+         GOTO 150
+      ENDIF
+      IF (IWAVPR==10) THEN
+        ! MD: IWAVPR=12
+        IF (IBRION==0) IWAVPR=12
+        ! relaxation: IWAVPR=11
+        IF (IBRION>0) IWAVPR=11
+      ENDIF
+      IF (IWAVPR==1) IWAVPR=11 ! makes the same but requires less memory :->
+
+#ifdef MPI
+      IWAVPR=MOD(IWAVPR,10)+10
+#endif
+      CALL XML_INCAR('IWAVPR','I',IWAVPR,RDUM,CDUM,LDUM,CHARAC,N)
+
+! switch on symmetry (default ISYM=1):
+      ISYM=1 ; IF (LPAW) ISYM=2
+      CALL RDATAB(LOPEN,INCAR,IU5,'ISYM','=','#',';','I', &
+     &            ISYM,RDUM,CDUM,LDUM,CHARAC,N,1,IERR)
+      IF (((IERR/=0).AND.(IERR/=3)).OR. &
+     &                    ((IERR==0).AND.(N<1))) THEN
+         IF (IU0>=0) &
+         WRITE(IU0,*)'Error reading item ''ISYM'' from file INCAR.'
+         GOTO 150
+      ENDIF
+      CALL XML_INCAR('ISYM','I',ISYM,RDUM,CDUM,LDUM,CHARAC,N)
+
+! for reasons of safety (crazy user are present all over the world):
+      TINY=1E-5
+      CALL RDATAB(LOPEN,INCAR,IU5,'SYMPREC','=','#',';','F', &
+     &            IDUM,TINY,CDUM,LDUM,CHARAC,N,1,IERR)
+      IF (((IERR/=0).AND.(IERR/=3)).OR. &
+     &                    ((IERR==0).AND.(N<1))) THEN
+         IF (IU0>=0) &
+         WRITE(IU0,*)'Error reading item ''SYMPREC'' from file INCAR.'
+         GOTO 150
+      ENDIF
+      CALL XML_INCAR('SYMPREC','F',IDUM,TINY,CDUM,LDUM,CHARAC,N)
+
+! how often to write some data; defaults to KBLOCK=NSW, NBLOCK=1:
+      NBLOCK=1
+      CALL RDATAB(LOPEN,INCAR,IU5,'NBLOCK','=','#',';','I', &
+     &            NBLOCK,RDUM,CDUM,LDUM,CHARAC,N,1,IERR)
+      IF (((IERR/=0).AND.(IERR/=3)).OR. &
+     &                    ((IERR==0).AND.(N<1))) THEN
+         IF (IU0>=0) &
+         WRITE(IU0,*)'Error reading item ''NBLOCK'' from file INCAR.'
+         GOTO 150
+      ENDIF
+      CALL XML_INCAR('NBLOCK','I',NBLOCK,RDUM,CDUM,LDUM,CHARAC,N)
+
+      KBLOCK=NSW
+      CALL RDATAB(LOPEN,INCAR,IU5,'KBLOCK','=','#',';','I', &
+     &            KBLOCK,RDUM,CDUM,LDUM,CHARAC,N,1,IERR)
+      IF (((IERR/=0).AND.(IERR/=3)).OR. &
+     &                    ((IERR==0).AND.(N<1))) THEN
+         IF (IU0>=0) &
+         WRITE(IU0,*)'Error reading item ''KBLOCK'' from file INCAR.'
+         GOTO 150
+      ENDIF
+      CALL XML_INCAR('KBLOCK','I',KBLOCK,RDUM,CDUM,LDUM,CHARAC,N)
+
+! plane wave cutoff energy for wavefunctions ..., no default!!!!
+      ENMAX=-1._q
+      CALL RDATAB(LOPEN,INCAR,IU5,'ENMAX','=','#',';','F', &
+     &            IDUM,ENMAX,CDUM,LDUM,CHARAC,N,1,IERR)
+      IF (((IERR/=0).AND.(IERR/=3)).OR. &
+     &                    ((IERR==0).AND.(N<1))) THEN
+         IF (IU0>=0) &
+         WRITE(IU0,*)'Error reading item ''ENMAX'' from file INCAR.'
+         GOTO 150
+      ENDIF
+      CALL XML_INCAR('ENMAX','F',IDUM,ENMAX,CDUM,LDUM,CHARAC,N)
+
+      CALL RDATAB(LOPEN,INCAR,IU5,'ENCUT','=','#',';','F', &
+     &            IDUM,ENMAX,CDUM,LDUM,CHARAC,N,1,IERR)
+      IF (((IERR/=0).AND.(IERR/=3)).OR. &
+     &                    ((IERR==0).AND.(N<1))) THEN
+         IF (IU0>=0) &
+         WRITE(IU0,*)'Error reading item ''ENCUT'' from file INCAR.'
+         GOTO 150
+      ENDIF
+      CALL XML_INCAR('ENCUT','F',IDUM,ENMAX,CDUM,LDUM,CHARAC,N)
+
+! plane wave cutoff energy for wavefunctions ..., no default!!!!
+      ENINI=-1._q
+      CALL RDATAB(LOPEN,INCAR,IU5,'ENINI','=','#',';','F', &
+     &            IDUM,ENINI,CDUM,LDUM,CHARAC,N,1,IERR)
+      IF (((IERR/=0).AND.(IERR/=3)).OR. &
+     &                    ((IERR==0).AND.(N<1))) THEN
+         IF (IU0>=0) &
+         WRITE(IU0,*)'Error reading item ''ENINI'' from file INCAR.'
+         GOTO 150
+      ENDIF
+      CALL XML_INCAR('ENINI','F',IDUM,ENINI,CDUM,LDUM,CHARAC,N)
+
+! cutoff for augmentation charge
+      ENAUG=-1
+      CALL RDATAB(LOPEN,INCAR,IU5,'ENAUG','=','#',';','F', &
+     &            IDUM,ENAUG,CDUM,LDUM,CHARAC,N,1,IERR)
+      IF (((IERR/=0).AND.(IERR/=3)).OR. &
+     &                    ((IERR==0).AND.(N<1))) THEN
+         IF (IU0>=0) &
+         WRITE(IU0,*)'Error reading item ''ENAUG'' from file INCAR.'
+         GOTO 150
+      ENDIF
+      CALL XML_INCAR('ENAUG','F',IDUM,ENAUG,CDUM,LDUM,CHARAC,N)
+
+! read in NGX, NGY, NGZ, NBANDS
+      NGX=-1
+      CALL RDATAB(LOPEN,INCAR,IU5,'NGX','=','#',';','I', &
+     &            NGX,RDUM,CDUM,LDUM,CHARAC,N,1,IERR)
+      IF (((IERR/=0).AND.(IERR/=3)).OR. &
+     &                    ((IERR==0).AND.(N<1))) THEN
+         IF (IU0>=0) &
+         WRITE(IU0,*)'Error reading item ''NGX'' from file INCAR.'
+         GOTO 150
+      ENDIF
+      CALL XML_INCAR('NGX','I',NGX,RDUM,CDUM,LDUM,CHARAC,N)
+
+      NGY=-1
+      CALL RDATAB(LOPEN,INCAR,IU5,'NGY','=','#',';','I', &
+     &            NGY,RDUM,CDUM,LDUM,CHARAC,N,1,IERR)
+      IF (((IERR/=0).AND.(IERR/=3)).OR. &
+     &                    ((IERR==0).AND.(N<1))) THEN
+         IF (IU0>=0) &
+         WRITE(IU0,*)'Error reading item ''NGY'' from file INCAR.'
+         GOTO 150
+      ENDIF
+      CALL XML_INCAR('NGY','I',NGY,RDUM,CDUM,LDUM,CHARAC,N)
+
+      NGZ=-1
+      CALL RDATAB(LOPEN,INCAR,IU5,'NGZ','=','#',';','I', &
+     &            NGZ,RDUM,CDUM,LDUM,CHARAC,N,1,IERR)
+      IF (((IERR/=0).AND.(IERR/=3)).OR. &
+     &                    ((IERR==0).AND.(N<1))) THEN
+         IF (IU0>=0) &
+         WRITE(IU0,*)'Error reading item ''NGZ'' from file INCAR.'
+         GOTO 150
+      ENDIF
+      CALL XML_INCAR('NGZ','I',NGZ,RDUM,CDUM,LDUM,CHARAC,N)
+
+      NGXF=-1
+      CALL RDATAB(LOPEN,INCAR,IU5,'NGXF','=','#',';','I', &
+     &            NGXF,RDUM,CDUM,LDUM,CHARAC,N,1,IERR)
+      IF (((IERR/=0).AND.(IERR/=3)).OR. &
+     &                    ((IERR==0).AND.(N<1))) THEN
+         IF (IU0>=0) &
+         WRITE(IU0,*)'Error reading item ''NGXF'' from file INCAR.'
+         GOTO 150
+      ENDIF
+      CALL XML_INCAR('NGXF','I',NGXF,RDUM,CDUM,LDUM,CHARAC,N)
+
+      NGYF=-1
+      CALL RDATAB(LOPEN,INCAR,IU5,'NGYF','=','#',';','I', &
+     &            NGYF,RDUM,CDUM,LDUM,CHARAC,N,1,IERR)
+      IF (((IERR/=0).AND.(IERR/=3)).OR. &
+     &                    ((IERR==0).AND.(N<1))) THEN
+         IF (IU0>=0) &
+         WRITE(IU0,*)'Error reading item ''NGYF'' from file INCAR.'
+         GOTO 150
+      ENDIF
+      CALL XML_INCAR('NGYF','I',NGYF,RDUM,CDUM,LDUM,CHARAC,N)
+
+      NGZF=-1
+      CALL RDATAB(LOPEN,INCAR,IU5,'NGZF','=','#',';','I', &
+     &            NGZF,RDUM,CDUM,LDUM,CHARAC,N,1,IERR)
+      IF (((IERR/=0).AND.(IERR/=3)).OR. &
+     &                    ((IERR==0).AND.(N<1))) THEN
+         IF (IU0>=0) &
+         WRITE(IU0,*)'Error reading item ''NGZF'' from file INCAR.'
+         GOTO 150
+      ENDIF
+      CALL XML_INCAR('NGZF','I',NGZF,RDUM,CDUM,LDUM,CHARAC,N)
+
+      NBANDS=-1
+      CALL RDATAB(LOPEN,INCAR,IU5,'NBANDS','=','#',';','I', &
+     &            NBANDS,RDUM,CDUM,LDUM,CHARAC,N,1,IERR)
+      IF (((IERR/=0).AND.(IERR/=3)).OR. &
+     &                    ((IERR==0).AND.(N<1))) THEN
+         IF (IU0>=0) &
+         WRITE(IU0,*)'Error reading item ''NBANDS'' from file INCAR.'
+         GOTO 150
+      ENDIF
+      CALL XML_INCAR('NBANDS','I',NBANDS,RDUM,CDUM,LDUM,CHARAC,N)
+
+! ionic time step, default is POTIM=0.5. for IBRION/=0, else no default!
+      POTIM=0.5_q
+      CALL RDATAB(LOPEN,INCAR,IU5,'POTIM','=','#',';','F', &
+     &            IDUM,POTIM,CDUM,LDUM,CHARAC,N,1,IERR)
+      IF (((IERR/=0).AND.(IERR/=3)).OR. &
+     &                    ((IERR==0).AND.(N<1))) THEN
+         IF (IU0>=0) &
+         WRITE(IU0,*)'Error reading item ''POTIM'' from file INCAR.'
+         GOTO 150
+      ENDIF
+      CALL XML_INCAR('POTIM','F',IDUM,POTIM,CDUM,LDUM,CHARAC,N)
+
+! if IBRION=0 (MD) then POTIM must be given, otherwise error ... !
+      IF (((IERR==3).OR.(N<1)).AND.(IBRION==0)) THEN
+         IF (IU0>=0) &
+         WRITE(IU0,*)'Fatal error! IBRION=0, but no entry for POTIM'// &
+     &               ' on file INCAR. MUST be specified!!'
+         IF (IU0>=0) &
+         WRITE(IU0,*)'                                          '// &
+     &               '                ----'
+         STOP
+      ENDIF
+! start temperature and end temperature (default is 1E-4 for both),
+      TEBEG=1.E-4_q
+      CALL RDATAB(LOPEN,INCAR,IU5,'TEBEG','=','#',';','F', &
+     &            IDUM,TEBEG,CDUM,LDUM,CHARAC,N,1,IERR)
+      IF (((IERR/=0).AND.(IERR/=3)).OR. &
+     &                    ((IERR==0).AND.(N<1))) THEN
+         IF (IU0>=0) &
+         WRITE(IU0,*)'Error reading item ''TEBEG'' from file INCAR.'
+         GOTO 150
+      ENDIF
+      TEEND=TEBEG
+      CALL XML_INCAR('TEBEG','F',IDUM,TEBEG,CDUM,LDUM,CHARAC,N)
+
+      CALL RDATAB(LOPEN,INCAR,IU5,'TEEND','=','#',';','F', &
+     &            IDUM,TEEND,CDUM,LDUM,CHARAC,N,1,IERR)
+      IF (((IERR/=0).AND.(IERR/=3)).OR. &
+     &                    ((IERR==0).AND.(N<1))) THEN
+         IF (IU0>=0) &
+         WRITE(IU0,*)'Error reading item ''TEEND'' from file INCAR.'
+         GOTO 150
+      ENDIF
+      CALL XML_INCAR('TEEND','F',IDUM,TEEND,CDUM,LDUM,CHARAC,N)
+
+! pair-correlation functions ..., defaults are NPACO=256, APACO=10
+      NPACO=256
+      CALL RDATAB(LOPEN,INCAR,IU5,'NPACO','=','#',';','I', &
+     &            NPACO,RDUM,CDUM,LDUM,CHARAC,N,1,IERR)
+      IF (((IERR/=0).AND.(IERR/=3)).OR. &
+     &                    ((IERR==0).AND.(N<1))) THEN
+         IF (IU0>=0) &
+         WRITE(IU0,*)'Error reading item ''NPACO'' from file INCAR.'
+         GOTO 150
+      ENDIF
+      CALL XML_INCAR('NPACO','I',NPACO,RDUM,CDUM,LDUM,CHARAC,N)
+
+      APACO=16._q
+      CALL RDATAB(LOPEN,INCAR,IU5,'APACO','=','#',';','F', &
+     &            IDUM,APACO,CDUM,LDUM,CHARAC,N,1,IERR)
+      IF (((IERR/=0).AND.(IERR/=3)).OR. &
+     &                    ((IERR==0).AND.(N<1))) THEN
+         IF (IU0>=0) &
+         WRITE(IU0,*)'Error reading item ''APACO'' from file INCAR.'
+         GOTO 150
+      ENDIF
+      CALL XML_INCAR('APACO','F',IDUM,APACO,CDUM,LDUM,CHARAC,N)
+
+! NEDOS subdivisions for DOS
+      NEDOS=301
+      CALL RDATAB(LOPEN,INCAR,IU5,'NEDOS','=','#',';','I', &
+     &            NEDOS,RDUM,CDUM,LDUM,CHARAC,N,1,IERR)
+      IF (((IERR/=0).AND.(IERR/=3)).OR. &
+     &                    ((IERR==0).AND.(N<1))) THEN
+         IF (IU0>=0) &
+         WRITE(IU0,*)'Error reading item ''NEDOS'' from file INCAR.'
+         GOTO 150
+      ENDIF
+      CALL XML_INCAR('NEDOS','I',NEDOS,RDUM,CDUM,LDUM,CHARAC,N)
+
+! NBLK blocking for some DGEMM commands
+      NBLK=-1
+      CALL RDATAB(LOPEN,INCAR,IU5,'NBLK','=','#',';','I', &
+     &            NBLK,RDUM,CDUM,LDUM,CHARAC,N,1,IERR)
+      IF (((IERR/=0).AND.(IERR/=3)).OR. &
+     &                    ((IERR==0).AND.(N<1))) THEN
+         IF (IU0>=0) &
+         WRITE(IU0,*)'Error reading item ''NBLK'' from file INCAR.'
+         GOTO 150
+      ENDIF
+      CALL XML_INCAR('NBLK','I',NBLK,RDUM,CDUM,LDUM,CHARAC,N)
+
+! default for SMASS is -3 (micro canonical MD)
+      SMASS=-3
+      CALL RDATAB(LOPEN,INCAR,IU5,'SMASS','=','#',';','F', &
+     &            IDUM,SMASS,CDUM,LDUM,CHARAC,N,1,IERR)
+      IF (((IERR/=0).AND.(IERR/=3)).OR. &
+     &                    ((IERR==0).AND.(N<1))) THEN
+         IF (IU0>=0) &
+         WRITE(IU0,*)'Error reading item ''SMASS'' from file INCAR.'
+         GOTO 150
+      ENDIF
+      CALL XML_INCAR('SMASS','F',IDUM,SMASS,CDUM,LDUM,CHARAC,N)
+
+! plane wave cutoff energy for wavefunctions ..., no default!!!!
+! default for SMASS is -3 (micro canonical MD)
+      SCALEE=1
+      CALL RDATAB(LOPEN,INCAR,IU5,'SCALEE','=','#',';','F', &
+     &            IDUM,SCALEE,CDUM,LDUM,CHARAC,N,1,IERR)
+      IF (((IERR/=0).AND.(IERR/=3)).OR. &
+     &                    ((IERR==0).AND.(N<1))) THEN
+         IF (IU0>=0) &
+         WRITE(IU0,*)'Error reading item ''SCALEE'' from file INCAR.'
+         GOTO 150
+      ENDIF
+      CALL XML_INCAR('SCALEE','F',IDUM,SCALEE,CDUM,LDUM,CHARAC,N)
+
+! Well, we supply the atomic masses on file POTCAR, but in some cases
+! one might wish to change them artificially (--> for example trying
+! some kind of 'pre-conditioning' by hand for relaxation runs ...):
+! by default we set all masses to negative numbers (this shall be the
+! 'signal' to take the values from file POTCAR ...).
+! same applies to VCA parameter which are defaulted from POTCAR files
+! VCA parameters allow to weigh the potentials by a number supplied as
+! VCA (Virtual Crystal Approximation) parameter (usually between 0 and 1)
+      POMASS=-1._q
+      RWIGS=-1._q
+      ROPT=0
+      VCA=-1.0_q
+
+      CALL RDATAB(LOPEN,INCAR,IU5,'POMASS','=','#',';','F', &
+     &            IDUM,POMASS,CDUM,LDUM,CHARAC,N,NTYPIN,IERR)
+      IF (((IERR/=0).AND.(IERR/=3)).OR. &
+     &                    ((IERR==0).AND.(N<NTYPIN))) THEN
+         IF (IU0>=0) &
+         WRITE(IU0,*)'Error reading item ''POMASS'' from file INCAR.'
+         GOTO 150
+      ENDIF
+      CALL XML_INCAR_V('POMASS','F',IDUM,POMASS,CDUM,LDUM,CHARAC,N)
+
+
+! "Cutoff radii" (Wigner-Seitz-radii) for l-projections (default is -1.)
+      CALL RDATAB(LOPEN,INCAR,IU5,'RWIGS','=','#',';','F', &
+     &            IDUM,RWIGS,CDUM,LDUM,CHARAC,N,NTYPP,IERR)
+      IF (((IERR/=0).AND.(IERR/=3)).OR. &
+     &                    ((IERR==0).AND.(N<NTYPP))) THEN
+         IF (IU0>=0) &
+         WRITE(IU0,*)'Error reading item ''RWIGS'' from file INCAR.'
+         GOTO 150
+      ENDIF
+      CALL XML_INCAR_V('RWIGS','F',IDUM,RWIGS,CDUM,LDUM,CHARAC,N)
+
+
+! atom weight in virtual crystal approximation (VCA)
+      CALL RDATAB(LOPEN,INCAR,IU5,'VCA','=','#',';','F', &
+     &            IDUM,VCA,CDUM,LDUM,CHARAC,N,NTYPP,IERR)
+      IF (((IERR/=0).AND.(IERR/=3)).OR. &
+     &                    ((IERR==0).AND.(N<NTYPP))) THEN
+         IF (IU0>=0) &
+         WRITE(IU0,*)'Error reading item ''VCA'' from file INCAR.'
+         GOTO 150
+      ENDIF
+      CALL XML_INCAR_V('VCA','F',IDUM,VCA,CDUM,LDUM,CHARAC,N)
+
+! LVCADER -- calculate derivative with respect to VCA parameter
+! for all ions with VCA not equal 1 
+      LVCADER=.FALSE.
+
+      CALL RDATAB(LOPEN,INCAR,IU5,'LVCADER','=','#',';','L', &
+     &            IDUM,RDUM,CDUM,LVCADER,CHARAC,N,1,IERR)
+      IF (((IERR/=0).AND.(IERR/=3)).OR. &
+     &                    ((IERR==0).AND.(N<1))) THEN
+         IF (IU0>=0) &
+         WRITE(IU0,*)'Error reading item ''LVCADER'' from file INCAR.'
+         GOTO 150
+      ENDIF
+      CALL XML_INCAR('LVCADER','L',IDUM,RDUM,CDUM,LVCADER,CHARAC,N)
+! read in DARWIN_V and DARWIN_R
+      DARWIN_R=0
+      DARWIN_V=1
+      CALL RDATAB(LOPEN,INCAR,IU5,'DARWINR','=','#',';','F', &
+     &            IDUM,DARWIN_R,CDUM,LDUM,CHARAC,N,NTYPP,IERR)
+      IF (((IERR/=0).AND.(IERR/=3)).OR. &
+     &                    ((IERR==0).AND.(N<NTYPP))) THEN
+         IF (IU0>=0) &
+         WRITE(IU0,*)'Error reading item ''DARWINR'' from file INCAR.'
+         GOTO 150
+      ENDIF
+      CALL XML_INCAR_V('DARWINR','F',IDUM,DARWIN_R,CDUM,LDUM,CHARAC,N)
+
+      CALL RDATAB(LOPEN,INCAR,IU5,'DARWINV','=','#',';','F', &
+     &            IDUM,DARWIN_V,CDUM,LDUM,CHARAC,N,NTYPP,IERR)
+      IF (((IERR/=0).AND.(IERR/=3)).OR. &
+     &                    ((IERR==0).AND.(N<NTYPP))) THEN
+         IF (IU0>=0) &
+         WRITE(IU0,*)'Error reading item ''DARWINV'' from file INCAR.'
+         GOTO 150
+      ENDIF
+      CALL XML_INCAR_V('DARWINV','F',IDUM,DARWIN_V,CDUM,LDUM,CHARAC,N)
+
+! number of up down electrons
+      NUP_DOWN=-1._q
+      CALL RDATAB(LOPEN,INCAR,IU5,'NUPDOWN','=','#',';','F', &
+     &            IDUM,NUP_DOWN,CDUM,LDUM,CHARAC,N,1,IERR)
+      IF (((IERR/=0).AND.(IERR/=3)).OR. &
+     &                    ((IERR==0).AND.(N<1))) THEN
+         IF (IU0>=0) &
+         WRITE(IU0,*)'Error reading item ''NUPDOWN'' from file INCAR.'
+         GOTO 150
+      ENDIF
+      CALL XML_INCAR('NUPDOWN','F',IDUM,NUP_DOWN,CDUM,LDUM,CHARAC,N)
+
+! Initial magnetic moments for each atom (default is 1. for all ions)
+      AINI=1
+      IF (NUP_DOWN >=0) THEN
+        AINI=NUP_DOWN/ NIONS
+      ENDIF
+
+      NMAGMOM=NIONS
+      IF (LNONCOLLINEAR) NMAGMOM=3*NIONS
+      DO NI=1,NMAGMOM
+         ATOMOM(NI)=AINI
+      ENDDO
+      CALL RDATAB(LOPEN,INCAR,IU5,'MAGMOM','=','#',';','F', &
+     &            IDUM,ATOMOM,CDUM,LDUM,CHARAC,N,NMAGMOM,IERR)
+      IF (((IERR/=0).AND.(IERR/=3)).OR. &
+     &                    ((IERR==0).AND.(N<NMAGMOM))) THEN
+         IF (IU0>=0) &
+         WRITE(IU0,*)'Error reading item ''MAGMOM'' from file INCAR.'
+         GOTO 150
+      ENDIF
+      CALL XML_INCAR_V('MAGMOM','F',IDUM,ATOMOM,CDUM,LDUM,CHARAC,N)
+
+! number of electrons ..., default is NELECT=0 (= neutral cell)
+      NELECT=0._q
+      CALL RDATAB(LOPEN,INCAR,IU5,'NELECT','=','#',';','F', &
+     &            IDUM,NELECT,CDUM,LDUM,CHARAC,N,1,IERR)
+      IF (((IERR/=0).AND.(IERR/=3)).OR. &
+     &                    ((IERR==0).AND.(N<1))) THEN
+         IF (IU0>=0) &
+         WRITE(IU0,*)'Error reading item ''NELECT'' from file INCAR.'
+         GOTO 150
+      ENDIF
+      CALL XML_INCAR('NELECT','F',IDUM,NELECT,CDUM,LDUM,CHARAC,N)
+
+! Real-space projection: default should be POTCAR-dependent ... (if
+! one finds 'optimization flag' then set LREAL=.TRUE., else .FALSE.)
+      LREAL=.FALSE.
+      CALL RDATAB(LOPEN,INCAR,IU5,'LREAL','=','#',';','L', &
+     &            IDUM,RDUM,CDUM,LREAL,CHARAC,N,1,IERR)
+      CALL XML_INCAR('LREAL','L',IDUM,RDUM,CDUM,LREAL,CHARAC,N)
+
+! no input --> remind it and choose later the appropriate value ...
+      LREALD=(IERR==3)
+      IF (IERR==5) THEN
+        INPLIN="--"
+        CALL RDATAB(LOPEN,INCAR,IU5,'LREAL','=','#',';','S', &
+     &            IDUM,RDUM,CDUM,LDUM,INPLIN,N,40,IERR)
+        LREAL=.TRUE.
+        CALL XML_INCAR('LREAL','S',IDUM,RDUM,CDUM,LDUM,INPLIN,N)
+
+        CALL STRIP(INPLIN,N,'L')
+        IF (INPLIN(1:1)=='O' .OR. INPLIN(1:1)=='o' .OR. &
+            INPLIN(1:1)=='A' .OR. INPLIN(1:1)=='a' ) THEN
+          IF ( INPLIN(1:1)=='A' .OR. INPLIN(1:1)=='a' ) THEN
+            ROPTV=-2E-3
+            IF  (SZPREC(1:1)=='l') ROPTV=-1E-2
+            IF  (SZPREC(1:1)=='n') ROPTV=-5E-4
+            IF  (SZPREC(1:1)=='s') ROPTV=-5E-4
+            IF  (SZPREC(1:1)=='h') ROPTV=-4E-4
+            IF  (SZPREC(1:1)=='a') ROPTV=-2.5E-4
+          ELSE
+             ROPTV=1.0_q
+             IF  (SZPREC(1:1)=='l') ROPTV=1/1.5
+             IF  (SZPREC(1:1)=='h') ROPTV=1.5
+          ENDIF
+          DO NTYP=1,NTYPIN
+            ROPT(NTYP)=ROPTV
+          ENDDO
+          CALL RDATAB(LOPEN,INCAR,IU5,'ROPT','=','#',';','F', &
+     &            IDUM,ROPT,CDUM,LDUM,CHARAC,N,NTYPIN,IERR)
+          IF (((IERR/=0).AND.(IERR/=3)).OR. &
+     &                    ((IERR==0).AND.(N<NTYPIN))) THEN
+            IF (IU0>=0) &
+            WRITE(IU0,*)'Error reading item ''ROPT'' from file INCAR.'
+            GOTO 150
+          ENDIF
+          IF ( INPLIN(1:1)=='A' .OR. INPLIN(1:1)=='a' ) THEN
+            ROPT=-ABS(ROPT)
+          ELSE
+            ROPT=ABS(ROPT)
+          ENDIF
+          CALL XML_INCAR_V('ROPT','F',IDUM,ROPT,CDUM,LDUM,CHARAC,N)
+        ELSE
+          IERR=5
+        ENDIF
+      ENDIF
+      IF (((IERR/=0).AND.(IERR/=3)).OR. &
+     &                    ((IERR==0).AND.(N<1))) THEN
+         IF (IU0>=0) &
+         WRITE(IU0,*)'Error reading item ''LREAL'' from file INCAR.'
+         GOTO 150
+      ENDIF
+! plane by plane distribution of data
+      LPLANE_WISE=.TRUE.
+      CALL RDATAB(LOPEN,INCAR,IU5,'LPLANE','=','#',';','L', &
+     &            IDUM,RDUM,CDUM,LPLANE_WISE,CHARAC,N,1,IERR)
+      IF (((IERR/=0).AND.(IERR/=3)).OR. &
+     &                    ((IERR==0).AND.(N<1))) THEN
+         IF (IU0>=0) &
+         WRITE(IU0,*)'Error reading item ''LPLANE_WISE'' from file INCAR.'
+         GOTO 150
+      ENDIF
+      CALL XML_INCAR('LPLANE','L',IDUM,RDUM,CDUM,LPLANE_WISE,CHARAC,N)
+
+! LCOMPAT .TRUE. means full compatibility
+      LCOMPAT = .FALSE.
+      CALL RDATAB(LOPEN,INCAR,IU5,'LCOMPAT','=','#',';','L', &
+     &            IDUM,RDUM,CDUM,LCOMPAT,CHARAC,N,1,IERR)
+      IF (((IERR/=0).AND.(IERR/=3)).OR. &
+     &                    ((IERR==0).AND.(N<1))) THEN
+         IF (IU0>=0) &
+         WRITE(IU0,*)'Error reading item ''LCOMPAT'' from file INCAR.'
+         GOTO 150
+      ENDIF
+      CALL XML_INCAR('LCOMPAT','L',IDUM,RDUM,CDUM,LCOMPAT,CHARAC,N)
+! electronic timestep
+      TIME=0.4_q
+      CALL RDATAB(LOPEN,INCAR,IU5,'TIME','=','#',';','F', &
+     &            IDUM,TIME,CDUM,LDUM,CHARAC,N,1,IERR)
+      IF (((IERR/=0).AND.(IERR/=3)).OR. &
+     &                    ((IERR==0).AND.(N<1))) THEN
+         IF (IU0>=0) &
+         WRITE(IU0,*)'Error reading item ''TIME'' from file INCAR.'
+         GOTO 150
+      ENDIF
+      CALL XML_INCAR('TIME','F',IDUM,TIME,CDUM,LDUM,CHARAC,N)
+
+! energy range for DOS (default is EMIN=10.,EMAX=-10. = automatic):
+      EMIN=10._q
+      CALL RDATAB(LOPEN,INCAR,IU5,'EMIN','=','#',';','F', &
+     &            IDUM,EMIN,CDUM,LDUM,CHARAC,N,1,IERR)
+      IF (((IERR/=0).AND.(IERR/=3)).OR. &
+     &                    ((IERR==0).AND.(N<1))) THEN
+         IF (IU0>=0) &
+         WRITE(IU0,*)'Error reading item ''EMIN'' from file INCAR.'
+         GOTO 150
+      ENDIF
+      CALL XML_INCAR('EMIN','F',IDUM,EMIN,CDUM,LDUM,CHARAC,N)
+
+      EMAX=-10._q
+      CALL RDATAB(LOPEN,INCAR,IU5,'EMAX','=','#',';','F', &
+     &            IDUM,EMAX,CDUM,LDUM,CHARAC,N,1,IERR)
+      IF (((IERR/=0).AND.(IERR/=3)).OR. &
+     &                    ((IERR==0).AND.(N<1))) THEN
+         IF (IU0>=0) &
+         WRITE(IU0,*)'Error reading item ''EMAX'' from file INCAR.'
+         GOTO 150
+      ENDIF
+      CALL XML_INCAR('EMAX','F',IDUM,EMAX,CDUM,LDUM,CHARAC,N)
+
+! reference energy read from INCAR
+      EREF=0
+      CALL RDATAB(LOPEN,INCAR,IU5,'EREF','=','#',';','F', &
+     &            IDUM,EREF,CDUM,LDUM,CHARAC,N,1,IERR)
+      IF (((IERR/=0).AND.(IERR/=3)).OR. &
+     &                    ((IERR==0).AND.(N<1))) THEN
+         IF (IU0>=0) &
+         WRITE(IU0,*)'Error reading item ''EREF'' from file INCAR.'
+         GOTO 150
+      ENDIF
+      CALL XML_INCAR('EREF','F',IDUM,EREF,CDUM,LDUM,CHARAC,N)
+! Fermi level read from INCAR (defaults to EREF)
+      EFERMI=EREF
+      CALL RDATAB(LOPEN,INCAR,IU5,'EFERMI','=','#',';','F', &
+     &            IDUM,EFERMI,CDUM,LDUM,CHARAC,N,1,IERR)
+      IF (((IERR/=0).AND.(IERR/=3)).OR. &
+     &                    ((IERR==0).AND.(N<1))) THEN
+         IF (IU0>=0) &
+         WRITE(IU0,*)'Error reading item ''EFERMI'' from file INCAR.'
+         GOTO 150
+      ENDIF
+      CALL XML_INCAR('EFERMI','F',IDUM,EFERMI,CDUM,LDUM,CHARAC,N)
+! z range for STM data
+      STM=0
+      CALL RDATAB(LOPEN,INCAR,IU5,'STM','=','#',';','F', &
+     &            IDUM,STM,CDUM,LDUM,CHARAC,N,7,IERR)
+      IF (((IERR/=0).AND.(IERR/=3)).OR. &
+     &                    ((IERR==0).AND.(N<6))) THEN
+         IF (IU0>=0) &
+         WRITE(IU0,*)'Error reading item ''STM'' from file INCAR.'
+         GOTO 150
+      ENDIF
+      CALL XML_INCAR_V('STM','F',IDUM,STM,CDUM,LDUM,CHARAC,N)
+
+! BZ-integration type, default is ISMEAR=1 and SIGMA=0.2 ...
+      ISMEAR=1
+      CALL RDATAB(LOPEN,INCAR,IU5,'ISMEAR','=','#',';','I', &
+     &            ISMEAR,RDUM,CDUM,LDUM,CHARAC,N,1,IERR)
+      IF (((IERR/=0).AND.(IERR/=3)).OR. &
+     &                    ((IERR==0).AND.(N<1))) THEN
+         IF (IU0>=0) &
+         WRITE(IU0,*)'Error reading item ''ISMEAR'' from file INCAR.'
+         GOTO 150
+      ENDIF
+      CALL XML_INCAR('ISMEAR','I',ISMEAR,RDUM,CDUM,LDUM,CHARAC,N)
+
+      SIGMA=0.2_q
+! If we provide fermi-weights on file INCAR the main intention is mostly
+! to do calculations at given fixed occupancies -> this requires SIGMA=0
+      IF (ISMEAR==-2) SIGMA=0._q
+      CALL RDATAB(LOPEN,INCAR,IU5,'SIGMA','=','#',';','F', &
+     &            IDUM,SIGMA,CDUM,LDUM,CHARAC,N,1,IERR)
+      IF (((IERR/=0).AND.(IERR/=3)).OR. &
+     &                    ((IERR==0).AND.(N<1))) THEN
+         IF (IU0>=0) &
+         WRITE(IU0,*)'Error reading item ''SIGMA'' from file INCAR.'
+         GOTO 150
+      ENDIF
+      CALL XML_INCAR('SIGMA','F',IDUM,SIGMA,CDUM,LDUM,CHARAC,N)
+! ISMEAR<=-4 and ISMEAR>=30 means tetrahedron method for DOS ...,
+! ISMEAR==-4,-5 and <=-7: also tetrahedron method for occ. numbers
+      LTET=((ISMEAR<=-4).OR.(ISMEAR>=30))
+      IF (ISMEAR==-6) ISMEAR=-1
+      IF (ISMEAR>=0) ISMEAR=MOD(ISMEAR,30)
+
+! k-point spacing 
+      SPACING=0.5_q
+      CALL RDATAB(LOPEN,INCAR,IU5,'KSPACING','=','#',';','F', &
+     &            IDUM,SPACING,CDUM,LDUM,CHARAC,N,1,IERR)
+      IF (((IERR/=0).AND.(IERR/=3)).OR. &
+     &                    ((IERR==0).AND.(N<1))) THEN
+         IF (IU0>=0) &
+         WRITE(IU0,*)'Error reading item ''KSPACING'' from file INCAR.'
+         GOTO 150
+      ENDIF
+      CALL XML_INCAR('KSPACING','F',IDUM,SPACING,CDUM,LDUM,CHARAC,N)
+! include gamma point in k-points
+      LGAMMA=.TRUE.
+      CALL RDATAB(LOPEN,INCAR,IU5,'KGAMMA','=','#',';','L', &
+     &            IDUM,RDUM,CDUM,LGAMMA,CHARAC,N,1,IERR)
+      IF (((IERR/=0).AND.(IERR/=3)).OR. &
+     &                    ((IERR==0).AND.(N<1))) THEN
+         IF (IU0>=0) &
+         WRITE(IU0,*)'Error reading item ''KGAMMA'' from file INCAR.'
+         GOTO 150
+      ENDIF
+      CALL XML_INCAR('KGAMMA','L',IDUM,RDUM,CDUM,LGAMMA,CHARAC,N) 
+
+! min. occupation number for 'high quality update' (default: WEIMIN=0)
+      WEIMIN=0._q
+! MD and relaxation: take WEIMIN=0.001
+      IF (IBRION>=0) WEIMIN=0.001_q
+      CALL RDATAB(LOPEN,INCAR,IU5,'WEIMIN','=','#',';','F', &
+     &            IDUM,WEIMIN,CDUM,LDUM,CHARAC,N,1,IERR)
+      IF (((IERR/=0).AND.(IERR/=3)).OR. &
+     &                    ((IERR==0).AND.(N<1))) THEN
+         IF (IU0>=0) &
+         WRITE(IU0,*)'Error reading item ''WEIMIN'' from file INCAR.'
+         GOTO 150
+      ENDIF
+      CALL XML_INCAR('WEIMIN','F',IDUM,WEIMIN,CDUM,LDUM,CHARAC,N)
+
+! break condition for intra-band min. (default: 0.25*EDIFF/NBANDS)
+! because we allow to be EDIFFG smaller than EDIFF also consider
+! EDIFFG
+      EBREAK=-1
+      CALL RDATAB(LOPEN,INCAR,IU5,'EBREAK','=','#',';','F', &
+     &            IDUM,EBREAK,CDUM,LDUM,CHARAC,N,1,IERR)
+      IF (((IERR/=0).AND.(IERR/=3)).OR. &
+     &                    ((IERR==0).AND.(N<1))) THEN
+         IF (IU0>=0) &
+         WRITE(IU0,*)'Error reading item ''EBREAK'' from file INCAR.'
+         GOTO 150
+      ENDIF
+      CALL XML_INCAR('EBREAK','F',IDUM,EBREAK,CDUM,LDUM,CHARAC,N)
+
+! relative break condition for intra-band minimization (default is 0.3)
+      DEPER=0.3_q
+      CALL RDATAB(LOPEN,INCAR,IU5,'DEPER','=','#',';','F', &
+     &            IDUM,DEPER,CDUM,LDUM,CHARAC,N,1,IERR)
+      IF (((IERR/=0).AND.(IERR/=3)).OR. &
+     &                    ((IERR==0).AND.(N<1))) THEN
+         IF (IU0>=0) &
+         WRITE(IU0,*)'Error reading item ''DEPER'' from file INCAR.'
+         GOTO 150
+      ENDIF
+      CALL XML_INCAR('DEPER','F',IDUM,DEPER,CDUM,LDUM,CHARAC,N)
+
+! 'verbosity' (default: 2):
+      NWRITE=2
+      CALL RDATAB(LOPEN,INCAR,IU5,'NWRITE','=','#',';','I', &
+     &            NWRITE,RDUM,CDUM,LDUM,CHARAC,N,1,IERR)
+      IF (((IERR/=0).AND.(IERR/=3)).OR. &
+     &                    ((IERR==0).AND.(N<1))) THEN
+         IF (IU0>=0) &
+         WRITE(IU0,*)'Error reading item ''NWRITE'' from file INCAR.'
+         GOTO 150
+      ENDIF
+   ! allowed range is 0...4, if <0 assume 0, if >4 assume 4 ...
+      IF (NWRITE<0) NWRITE=0
+      IF (NWRITE>4) NWRITE=4
+      CALL XML_INCAR('NWRITE','I',NWRITE,RDUM,CDUM,LDUM,CHARAC,N)
+
+! Harris corrections for Hellman-Feynman forces ... (default yes):
+      LCORR=.TRUE.
+      CALL RDATAB(LOPEN,INCAR,IU5,'LCORR','=','#',';','L', &
+     &            IDUM,RDUM,CDUM,LCORR,CHARAC,N,1,IERR)
+      IF (((IERR/=0).AND.(IERR/=3)).OR. &
+     &                    ((IERR==0).AND.(N<1))) THEN
+         IF (IU0>=0) &
+         WRITE(IU0,*)'Error reading item ''LCORR'' from file INCAR.'
+         GOTO 150
+      ENDIF
+      CALL XML_INCAR('LCORR','L',IDUM,RDUM,CDUM,LCORR,CHARAC,N) 
+! Pullay pressure (one could also say external pressure), default 0.
+      PSTRESS=0._q
+      CALL RDATAB(LOPEN,INCAR,IU5,'PSTRESS','=','#',';','F', &
+     &            IDUM,PSTRESS,CDUM,LDUM,CHARAC,N,1,IERR)
+      IF (((IERR/=0).AND.(IERR/=3)).OR. &
+     &                    ((IERR==0).AND.(N<1))) THEN
+         IF (IU0>=0) &
+         WRITE(IU0,*)'Error reading item ''PSTRESS'' from file INCAR.'
+         GOTO 150
+      ENDIF
+      CALL XML_INCAR('PSTRESS','F',IDUM,PSTRESS,CDUM,LDUM,CHARAC,N)
+! max. L for onsite charge expansion in PAW method
+      LMAX_CALC=-100
+      CALL RDATAB(LOPEN,INCAR,IU5,'LMAXPAW','=','#',';','I', &
+     &            LMAX_CALC,RDUM,CDUM,LDUM,CHARAC,N,1,IERR)
+      IF (((IERR/=0).AND.(IERR/=3)).OR. &
+     &                    ((IERR==0).AND.(N<1))) THEN
+         IF (IU0>=0) &
+         WRITE(IU0,*)'Error reading item ''LMAXPAW'' from file INCAR.'
+         GOTO 150
+      ENDIF
+      CALL XML_INCAR('LMAXPAW','I',LMAX_CALC,RDUM,CDUM,LDUM,CHARAC,N)
+! max. L for the mixing and CHGCAR for the onsite charge expansion in PAW method
+      LMAX_MIX=2
+      CALL RDATAB(LOPEN,INCAR,IU5,'LMAXMIX','=','#',';','I', &
+     &            LMAX_MIX,RDUM,CDUM,LDUM,CHARAC,N,1,IERR)
+      IF (((IERR/=0).AND.(IERR/=3)).OR. &
+     &                    ((IERR==0).AND.(N<1))) THEN
+         IF (IU0>=0) &
+         WRITE(IU0,*)'Error reading item ''LMAXMIX'' from file INCAR.'
+         GOTO 150
+      ENDIF
+      CALL XML_INCAR('LMAXMIX','I',LMAX_MIX,RDUM,CDUM,LDUM,CHARAC,N)
+
+! some "music" ? (--> default is no ...)
+      lmusic=.false.
+      CALL RDATAB(LOPEN,INCAR,IU5,'LMUSIC','=','#',';','L', &
+     &            IDUM,RDUM,CDUM,LMUSIC,CHARAC,N,1,IERR)
+      IF (((IERR/=0).AND.(IERR/=3)).OR. &
+     &                    ((IERR==0).AND.(N<1))) THEN
+         IF (IU0>=0) &
+         WRITE(IU0,*)'Error reading item ''LMUSIC'' from file INCAR.'
+         GOTO 150
+      ENDIF
+      CALL XML_INCAR('LMUSIC','L',IDUM,RDUM,CDUM,LMUSIC,CHARAC,N)
+
+! Sometimes we not interested in any WAVECAR file at all ...
+      LWAVE=.TRUE.
+      CALL RDATAB(LOPEN,INCAR,IU5,'LWAVE','=','#',';','L', &
+     &            IDUM,RDUM,CDUM,LWAVE,CHARAC,N,1,IERR)
+      IF (((IERR/=0).AND.(IERR/=3)).OR. &
+     &                    ((IERR==0).AND.(N<1))) THEN
+         IF (IU0>=0) &
+         WRITE(IU0,*)'Error reading item ''LWAVE'' from file INCAR.'
+         GOTO 150
+      ENDIF
+      CALL XML_INCAR('LWAVE','L',IDUM,RDUM,CDUM,LWAVE,CHARAC,N)
+
+! Sometimes we need to read a WAVECAR of a denser k-grid ...
+      LDOWNSAMPLE=.FALSE.
+      CALL RDATAB(LOPEN,INCAR,IU5,'LDOWNSAMPLE','=','#',';','L', &
+     &            IDUM,RDUM,CDUM,LDOWNSAMPLE,CHARAC,N,1,IERR)
+      IF (((IERR/=0).AND.(IERR/=3)).OR. &
+     &                    ((IERR==0).AND.(N<1))) THEN
+         IF (IU0>=0) &
+         WRITE(IU0,*)'Error reading item ''LDOWNSAMPLE'' from file INCAR.'
+         GOTO 150
+      ENDIF
+      CALL XML_INCAR('LDOWNSAMPLE','L',IDUM,RDUM,CDUM,LDOWNSAMPLE,CHARAC,N)
+
+! ... and maybe not even in any CHGCAR / CHG file ...
+      LCHARG=.TRUE.
+      CALL RDATAB(LOPEN,INCAR,IU5,'LCHARG','=','#',';','L', &
+     &            IDUM,RDUM,CDUM,LCHARG,CHARAC,N,1,IERR)
+      IF (((IERR/=0).AND.(IERR/=3)).OR. &
+     &                    ((IERR==0).AND.(N<1))) THEN
+         IF (IU0>=0) &
+         WRITE(IU0,*)'Error reading item ''LCHARG'' from file INCAR.'
+         GOTO 150
+      ENDIF
+      CALL XML_INCAR('LCHARG','L',IDUM,RDUM,CDUM,LCHARG,CHARAC,N)
+
+! ... interested in partial charge density ?
+      LPARD = .FALSE.
+      CALL RDATAB(LOPEN,INCAR,IU5,'LPARD','=','#',';','L', &
+     &            IDUM,RDUM,CDUM,LPARD,CHARAC,N,1,IERR)
+      IF (((IERR/=0).AND.(IERR/=3)).OR. &
+     &                    ((IERR==0).AND.(N<1))) THEN
+         IF (IU0>=0) &
+         WRITE(IU0,*)'Error reading item ''LPARD'' from file INCAR.'
+         GOTO 150
+      ENDIF
+      CALL XML_INCAR('LPARD','L',IDUM,RDUM,CDUM,LPARD,CHARAC,N)
+
+! ... a WAVECAR must exist
+      IF (.NOT.LFOUND) LPARD = .FALSE.
+! ... but maybe in the total potential?
+      LVTOT=.FALSE.
+      CALL RDATAB(LOPEN,INCAR,IU5,'LVTOT','=','#',';','L', &
+     &            IDUM,RDUM,CDUM,LVTOT,CHARAC,N,1,IERR)
+      IF (((IERR/=0).AND.(IERR/=3)).OR. &
+     &                    ((IERR==0).AND.(N<1))) THEN
+         IF (IU0>=0) &
+         WRITE(IU0,*)'Error reading item ''LVTOT'' from file INCAR.'
+         GOTO 150
+      ENDIF
+      CALL XML_INCAR('LVTOT','L',IDUM,RDUM,CDUM,LVTOT,CHARAC,N)
+
+! ... but maybe in the Hartree potential?
+      LVHAR=.FALSE.
+      CALL RDATAB(LOPEN,INCAR,IU5,'LVHAR','=','#',';','L', &
+     &            IDUM,RDUM,CDUM,LVHAR,CHARAC,N,1,IERR)
+      IF (((IERR/=0).AND.(IERR/=3)).OR. &
+     &                    ((IERR==0).AND.(N<1))) THEN
+         IF (IU0>=0) &
+         WRITE(IU0,*)'Error reading item ''LVHAR'' from file INCAR.'
+         GOTO 150
+      ENDIF
+      CALL XML_INCAR('LVHAR','L',IDUM,RDUM,CDUM,LVHAR,CHARAC,N)
+      ! if one request the Hartree potential LVHAR supercedes the LVTOT
+      IF (LVHAR) LVTOT=.FALSE.
+
+! read in flag LORBIT
+      LORBIT_=.FALSE.
+      LORBIT=0
+      CALL RDATAB(LOPEN,INCAR,IU5,'LORBIT','=','#',';','L', &
+     &            IDUM,RDUM,CDUM,LORBIT_,CHARAC,N,1,IERR)
+      IF (IERR==5) THEN
+      CALL RDATAB(LOPEN,INCAR,IU5,'LORBIT','=','#',';','I', &
+     &            LORBIT,RDUM,CDUM,LDUM,CHARAC,N,1,IERR)
+      ELSE
+         IF (LORBIT_) LORBIT=5
+      ENDIF
+
+      IF (((IERR/=0).AND.(IERR/=3)).OR. &
+     &                    ((IERR==0).AND.(N<1))) THEN
+         IF (IU0>=0) &
+         WRITE(IU0,*)'Error reading item ''LORBIT'' from file INCAR.'
+         GOTO 150
+      ENDIF
+      CALL XML_INCAR('LORBIT','I',LORBIT,RDUM,CDUM,LDUM,CHARAC,N)
+
+! read in flag LELF
+      LELF=.FALSE.
+      CALL RDATAB(LOPEN,INCAR,IU5,'LELF','=','#',';','L', &
+     &            IDUM,RDUM,CDUM,LELF,CHARAC,N,1,IERR)
+      IF (((IERR/=0).AND.(IERR/=3)).OR. &
+     &                    ((IERR==0).AND.(N<1))) THEN
+         IF (IU0>=0) &
+         WRITE(IU0,*)'Error reading item ''LELF'' from file INCAR.'
+         GOTO 150
+      ENDIF
+      CALL XML_INCAR('LELF','L',IDUM,RDUM,CDUM,LELF,CHARAC,N)
+
+! read in flag LOPTICS
+      LOPTICS=.FALSE.
+#ifndef noPAW
+      CALL RDATAB(LOPEN,INCAR,IU5,'LOPTICS','=','#',';','L', &
+     &            IDUM,RDUM,CDUM,LOPTICS,CHARAC,N,1,IERR)
+      IF (((IERR/=0).AND.(IERR/=3)).OR. &
+     &                    ((IERR==0).AND.(N<1))) THEN
+         IF (IU0>=0) &
+         WRITE(IU0,*)'Error reading item ''LOPTICS'' from file INCAR.'
+         GOTO 150
+      ENDIF
+      CALL XML_INCAR('LOPTICS','L',IDUM,RDUM,CDUM,LOPTICS,CHARAC,N)
+#endif
+! if scaLAPACK is used it can be switched of in the INCAR file
+      IF (LscaLAPACK) THEN
+      CALL RDATAB(LOPEN,INCAR,IU5,'LSCALAPACK','=','#',';','L', &
+     &            IDUM,RDUM,CDUM,LscaLAPACK,CHARAC,N,1,IERR)
+      IF (((IERR/=0).AND.(IERR/=3)).OR. &
+     &                    ((IERR==0).AND.(N<1))) THEN
+         IF (IU0>=0) &
+         WRITE(IU0,*)'Error reading item ''LSCALPACK'' from file INCAR.'
+         GOTO 150
+      ENDIF
+      IF (IU0>0) THEN
+         IF (LscaLAPACK) THEN
+            WRITE(IU0,*) 'scaLAPACK will be used'
+         ELSE
+            WRITE(IU0,*) 'scaLAPACK is switched off'
+         ENDIF
+      ENDIF
+      ENDIF
+      CALL XML_INCAR('LSCALAPACK','L',IDUM,RDUM,CDUM,LscaLAPACK,CHARAC,N)
+
+      LSCALU= .FALSE.
+! the parallel LU decomposition might be slower than the serial 
+! one, hence we can switch it off
+      CALL RDATAB(LOPEN,INCAR,IU5,'LSCALU','=','#',';','L', &
+     &            IDUM,RDUM,CDUM,LSCALU,CHARAC,N,1,IERR)
+      IF (((IERR/=0).AND.(IERR/=3)).OR. &
+     &                    ((IERR==0).AND.(N<1))) THEN
+         IF (IU0>=0) &
+         WRITE(IU0,*)'Error reading item ''LSCALU'' from file INCAR.'
+         GOTO 150
+      ENDIF
+      CALL XML_INCAR('LSCALU','L',IDUM,RDUM,CDUM,LSCALU,CHARAC,N)
+
+      LSCAAWARE=LscaLAPACK
+      LscaAWARE_read=.FALSE.
+! the parallel LU decomposition might be slower than the serial 
+! one, hence we can switch it off
+      CALL RDATAB(LOPEN,INCAR,IU5,'LSCAAWARE','=','#',';','L', &
+     &            IDUM,RDUM,CDUM,LSCAAWARE,CHARAC,N,1,IERR)
+      IF (IERR==0 .AND. N==1) LscaAWARE_read=.TRUE.
+      IF (((IERR/=0).AND.(IERR/=3)).OR. &
+     &                    ((IERR==0).AND.(N<1))) THEN
+         IF (IU0>=0) &
+         WRITE(IU0,*)'Error reading item ''LSCAAWARE'' from file INCAR.'
+         GOTO 150
+      ENDIF
+      CALL XML_INCAR('LSCAAWARE','L',IDUM,RDUM,CDUM,LSCAAWARE,CHARAC,N)
+
+! try to overlap communication with calculations ?
+      CALL RDATAB(LOPEN,INCAR,IU5,'LASYNC','=','#',';','L', &
+     &            IDUM,RDUM,CDUM,LASYNC,CHARAC,N,1,IERR)
+      IF (((IERR/=0).AND.(IERR/=3)).OR. &
+     &                    ((IERR==0).AND.(N<1))) THEN
+         IF (IU0>=0) &
+         WRITE(IU0,*)'Error reading item ''LASYNC'' from file INCAR.'
+         GOTO 150
+      ENDIF
+      CALL XML_INCAR('LASYNC','L',IDUM,RDUM,CDUM,LASYNC,CHARAC,N)
+
+! read in flag LASPH
+      LASPH=.FALSE.
+      CALL RDATAB(LOPEN,INCAR,IU5,'LASPH','=','#',';','L', &
+     &            IDUM,RDUM,CDUM,LASPH,CHARAC,N,1,IERR)
+      IF (((IERR/=0).AND.(IERR/=3)).OR. &
+     &                    ((IERR==0).AND.(N<1))) THEN
+         IF (IU0>=0) &
+         WRITE(IU0,*)'Error reading item ''LASPH'' from file INCAR.'
+         GOTO 150
+      ENDIF
+      CALL XML_INCAR('LASPH','L',IDUM,RDUM,CDUM,LASPH,CHARAC,N)
+! read in flag LORBITALREAL
+      LORBITALREAL=.FALSE.
+      CALL RDATAB(LOPEN,INCAR,IU5,'LORBITALREAL','=','#',';','L', &
+     &            IDUM,RDUM,CDUM,LORBITALREAL,CHARAC,N,1,IERR)
+      IF (((IERR/=0).AND.(IERR/=3)).OR. &
+     &                    ((IERR==0).AND.(N<1))) THEN
+         IF (IU0>=0) &
+         WRITE(IU0,*)'Error reading item ''LORBITALREAL'' from file INCAR.'
+         GOTO 150
+      ENDIF
+      CALL XML_INCAR('LORBITALREAL','L',IDUM,RDUM,CDUM,LORBITALREAL,CHARAC,N)
+
+! read in flag LMETAGGA 
+      LMETAGGA=.FALSE.
+      CALL RDATAB(LOPEN,INCAR,IU5,'LMETAGGA','=','#',';','L', &
+     &            IDUM,RDUM,CDUM,LMETAGGA,CHARAC,N,1,IERR)
+      IF (((IERR/=0).AND.(IERR/=3)).OR. &
+     &                    ((IERR==0).AND.(N<1))) THEN
+         IF (IU0>=0) &
+         WRITE(IU0,*)'Error reading item ''LMETAGGA'' from file INCAR.'
+         GOTO 150
+      ENDIF
+      CALL XML_INCAR('LMETAGGA','L',IDUM,RDUM,CDUM,LMETAGGA,CHARAC,N)
+
+! set LASPH if LMETAGGA is chosen (metagga only calculated aspherically)
+      IF (LMETAGGA) LASPH=.TRUE.
+
+!-MM- spin spiral stuff
+! if LSPIRAL
+      LSPIRAL=.FALSE.
+      LZEROZ =.FALSE.
+      QSPIRAL=0._q
+      CALL RDATAB(LOPEN,INCAR,IU5,'LSPIRAL','=','#',';','L', &
+     &            IDUM,RDUM,CDUM,LSPIRAL,CHARAC,N,1,IERR)
+      IF (((IERR/=0).AND.(IERR/=3)).OR. &
+     &                    ((IERR==0).AND.(N<1))) THEN
+         IF (IU0>=0) &
+         WRITE(IU0,*)'Error reading item ''LSPIRAL'' from file INCAR.'
+         GOTO 150
+      ENDIF
+      CALL XML_INCAR('LSPIRAL','L',IDUM,RDUM,CDUM,LSPIRAL,CHARAC,N)
+
+! if LSPIRAL=.TRUE. we also need QSPIRAL, and possibly LZEROZ
+      IF (LSPIRAL) THEN
+! ... read propagation vector of spin spiral
+         CALL RDATAB(LOPEN,INCAR,IU5,'QSPIRAL','=','#',';','F', &
+     &               IDUM,QSPIRAL,CDUM,LDUM,CHARAC,N,3,IERR)
+         IF (((IERR/=0).AND.(IERR/=3)).OR. &
+     &                       ((IERR==0).AND.(N/=3))) THEN
+            IF (IU0>=0) &
+            WRITE(IU0,*)'Error reading item ''QSPIRAL'' from file INCAR.'
+            GOTO 150
+         ENDIF
+         CALL XML_INCAR_V('QSPIRAL','F',IDUM,QSPIRAL,CDUM,LDUM,CHARAC,N)
+! ... look for LZEROZ
+         LZEROZ=.TRUE.
+         CALL RDATAB(LOPEN,INCAR,IU5,'LZEROZ','=','#',';','L', &
+     &               IDUM,RDUM,CDUM,LZEROZ,CHARAC,N,1,IERR)
+         IF (((IERR/=0).AND.(IERR/=3)).OR. &
+     &                       ((IERR==0).AND.(N<1))) THEN
+            IF (IU0>=0) &
+            WRITE(IU0,*)'Error reading item ''LZEROZ'' from file INCAR.'
+            GOTO 150
+         ENDIF
+         CALL XML_INCAR('LZEROZ','L',IDUM,RDUM,CDUM,LZEROZ,CHARAC,N)
+      ENDIF
+! read in flag INTERACTIVE
+      INTERACTIVE=.FALSE.
+      CALL RDATAB(LOPEN,INCAR,IU5,'INTERACTIVE','=','#',';','L', &
+     &            IDUM,RDUM,CDUM,INTERACTIVE,CHARAC,N,1,IERR)
+      IF (((IERR/=0).AND.(IERR/=3)).OR. &
+     &                    ((IERR==0).AND.(N<1))) THEN
+         IF (IU0>=0) &
+         WRITE(IU0,*)'Error reading item ''INTERACTIVE'' from file INCAR.'
+         GOTO 150
+      ENDIF
+      CALL XML_INCAR('INTERACTIVE','L',IDUM,RDUM,CDUM,INTERACTIVE,CHARAC,N)
+      IF (INTERACTIVE) IBRION=11
+! read in flag TURBO
+      TURBO=0
+      CALL RDATAB(LOPEN,INCAR,IU5,'TURBO','=','#',';','I', &
+     &            TURBO,RDUM,CDUM,LDUM,CHARAC,N,1,IERR)
+      IF (((IERR/=0).AND.(IERR/=3)).OR. &
+     &                    ((IERR==0).AND.(N<1))) THEN
+         IF (IU0>=0) &
+         WRITE(IU0,*)'Error reading item ''TURBO'' from file INCAR.'
+         GOTO 150
+      ENDIF
+      CALL XML_INCAR('TURBO','I',TURBO,RDUM,CDUM,LDUM,CHARAC,N)
+! read in flag IRESTART
+      IRESTART=0
+      CALL RDATAB(LOPEN,INCAR,IU5,'IRESTART','=','#',';','I', &
+     &            IRESTART,RDUM,CDUM,LDUM,CHARAC,N,1,IERR)
+      IF (((IERR/=0).AND.(IERR/=3)).OR. &
+     &                    ((IERR==0).AND.(N<1))) THEN
+         IF (IU0>=0) &
+         WRITE(IU0,*)'Error reading item ''IRESTART'' from file INCAR.'
+         GOTO 150
+      ENDIF
+      CALL XML_INCAR('IRESTART','I',IRESTART,RDUM,CDUM,LDUM,CHARAC,N)
+! read in flag NREBOOT
+      NREBOOT=0
+      CALL RDATAB(LOPEN,INCAR,IU5,'NREBOOT','=','#',';','I', &
+     &            NREBOOT,RDUM,CDUM,LDUM,CHARAC,N,1,IERR)
+      IF (((IERR/=0).AND.(IERR/=3)).OR. &
+     &                    ((IERR==0).AND.(N<1))) THEN
+         IF (IU0>=0) &
+         WRITE(IU0,*)'Error reading item ''NREBOOT'' from file INCAR.'
+         GOTO 150
+      ENDIF
+      CALL XML_INCAR('NREBOOT','I',NREBOOT,RDUM,CDUM,LDUM,CHARAC,N)
+! read in flag NMIN
+      NMIN=0
+      CALL RDATAB(LOPEN,INCAR,IU5,'NMIN','=','#',';','I', &
+     &            NMIN,RDUM,CDUM,LDUM,CHARAC,N,1,IERR)
+      IF (((IERR/=0).AND.(IERR/=3)).OR. &
+     &                    ((IERR==0).AND.(N<1))) THEN
+         IF (IU0>=0) &
+         WRITE(IU0,*)'Error reading item ''NMIN'' from file INCAR.'
+         GOTO 150
+      ENDIF
+      CALL XML_INCAR('NMIN','I',NMIN,RDUM,CDUM,LDUM,CHARAC,N)
+! read in flag NLSPLINE
+      NLSPLINE=.FALSE.
+      CALL RDATAB(LOPEN,INCAR,IU5,'NLSPLINE','=','#',';','L', &
+     &            IDUM,RDUM,CDUM,NLSPLINE,CHARAC,N,1,IERR)
+      IF (((IERR/=0).AND.(IERR/=3)).OR. &
+     &                    ((IERR==0).AND.(N<1))) THEN
+         IF (IU0>=0) &
+         WRITE(IU0,*)'Error reading item ''NLSPLINE'' from file INCAR.'
+         GOTO 150
+      ENDIF
+      CALL XML_INCAR('NLSPLINE','L',IDUM,RDUM,CDUM,NLSPLINE,CHARAC,N)
+! ISPECIAL: allows to select undocumented and unsupported special features
+      ISPECIAL=0
+      CALL RDATAB(LOPEN,INCAR,IU5,'ISPECIAL','=','#',';','I', &
+     &            ISPECIAL,RDUM,CDUM,LDUM,CHARAC,N,1,IERR)
+      IF (((IERR/=0).AND.(IERR/=3)).OR. &
+     &                    ((IERR==0).AND.(N<1))) THEN
+         IF (IU0>=0) &
+         WRITE(IU0,*)'Error reading item ''ISPECIAL'' from file INCAR.'
+         GOTO 150
+      ENDIF
+      CALL XML_INCAR('ISPECIAL','I',ISPECIAL,RDUM,CDUM,LDUM,CHARAC,N)
+
+! ISPECIAL: allows to select undocumented and unsupported special features
+      MDALGO=0
+      CALL RDATAB(LOPEN,INCAR,IU5,'MDALGO','=','#',';','I', &
+     &            MDALGO,RDUM,CDUM,LDUM,CHARAC,N,1,IERR)
+      IF (((IERR/=0).AND.(IERR/=3)).OR. &
+     &                    ((IERR==0).AND.(N<1))) THEN
+         IF (IU0>=0) &
+         WRITE(IU0,*)'Error reading item ''MDALGO'' from file INCAR.'
+         GOTO 150
+      ENDIF
+      CALL XML_INCAR('MDALGO','I',MDALGO,RDUM,CDUM,LDUM,CHARAC,N)
+      IF (MDALGO<0) MDALGO=0
+
+#ifdef libbeef
+! read in flag LBEEFENS 
+      LBEEFENS=.FALSE.
+      CALL RDATAB(LOPEN,INCAR,IU5,'LBEEFENS','=','#',';','L', &
+     &            IDUM,RDUM,CDUM,LBEEFENS,CHARAC,N,1,IERR)
+      IF (((IERR/=0).AND.(IERR/=3)).OR. &
+     &                    ((IERR==0).AND.(N<1))) THEN
+         IF (IU0>=0) &
+         WRITE(IU0,*)'Error reading item ''LBEEFENS'' from file INCAR.'
+         GOTO 150
+      ENDIF
+      CALL XML_INCAR('LBEEFENS','L',IDUM,RDUM,CDUM,LBEEFENS,CHARAC,N)
+
+! read in flag LBEEFBAS
+      LBEEFBAS=.FALSE.
+      CALL RDATAB(LOPEN,INCAR,IU5,'LBEEFBAS','=','#',';','L', &
+     &            IDUM,RDUM,CDUM,LBEEFBAS,CHARAC,N,1,IERR)
+      IF (((IERR/=0).AND.(IERR/=3)).OR. &
+     &                    ((IERR==0).AND.(N<1))) THEN
+         IF (IU0>=0) &
+         WRITE(IU0,*)'Error reading item ''LBEEFBAS'' from file INCAR.'
+         GOTO 150
+      ENDIF
+      CALL XML_INCAR('LBEEFBAS','L',IDUM,RDUM,CDUM,LBEEFBAS,CHARAC,N)
+#endif
+! Thats all from INCAR (for the first ...):
+      CLOSE(IU5)
+      RETURN
+
+  150 CONTINUE
+      IF (IU0>=0) &
+      WRITE(IU0,151) IERR,N
+  151 FORMAT(' Error code was IERR=',I1,' ... . Found N=',I5,' data.')
+      STOP
+
+      END
diff -urN file_ini/rmm-diis_lr.F file_modify/rmm-diis_lr.F
--- file_ini/rmm-diis_lr.F	2024-07-13 10:37:12.000000000 +0800
+++ file_modify/rmm-diis_lr.F	2024-07-13 10:37:23.000000000 +0800
@@ -37,9 +37,8 @@
 !
 !
 !***********************************************************************
-
   SUBROUTINE LINEAR_RESPONSE_DIIS(GRID,INFO,LATT_CUR,NONLR_S,NONL_S,W,WXI,W0,WDES, &
-       LMDIM,CDIJ,CQIJ, RMS,DESUM,ICOUEV, SV, CSHIFT, IU6, IU0, LRESET, IERROR)
+       LMDIM,CDIJ,CQIJ, RMS,DESUM,ICOUEV, SV, CSHIFT, IU6, IU0, LRESET, IERROR,OMEGA,NLS,LSBREAK,LSDEPER,RMS_FINAL)
     USE prec
 
     USE wave
@@ -73,6 +72,7 @@
     OVERLAP CQIJ(LMDIM,LMDIM,WDES%NIONS,WDES%NCDIJ)
     REAL(q) DESUM                    ! total change of e(1) related to phi(1)
     REAL(q) RMS                      ! magnitude of the residual vector
+    REAL(q) RMS_FINAL_
     INTEGER ICOUEV                   ! number of H | phi> evaluations
     REAL(q) CSHIFT                   ! complex shift
     INTEGER IU0, IU6                 ! units for output
@@ -113,6 +113,11 @@
     REAL(q) :: ESTART
     COMPLEX(q) :: C
 
+    REAL(q), OPTIONAL :: OMEGA
+    INTEGER, OPTIONAL :: NLS
+    REAL(q), OPTIONAL :: LSBREAK
+    REAL(q), OPTIONAL :: LSDEPER
+    REAL(q), OPTIONAL :: RMS_FINAL
 
     PROFILING_START('linear_response_diis')
 
@@ -134,10 +139,15 @@
     NSIM=WDES%NSIM
     ! at least 6 iterations are required for save convergence
     ! since there is no other backup algorithm, safety first
-    NITER=MAX(INFO%NDAV,6)
+    IF (PRESENT(NLS)) THEN
+       NITER=MAX(INFO%NDAV,NLS)
+    ELSE
+       NITER=MAX(INFO%NDAV,6)
+    ENDIF
     NRES =NITER
 
     RMS   =0
+    RMS_FINAL_=0
     DESUM =0
     ESTART=0
     ICOUEV=0
@@ -204,7 +214,11 @@
 #endif
              IF (IDUMP>=2) WRITE(*,*)
              IF (IDUMP>=2) WRITE(*,'(I3,1X)',ADVANCE='NO') N
-             EVALUE0(NP) =W0%CELEN(N,NK,ISP)
+             IF (PRESENT(OMEGA)) THEN
+                EVALUE0(NP) =W0%CELEN(N,NK,ISP)+OMEGA
+             ELSE
+                EVALUE0(NP) =W0%CELEN(N,NK,ISP)
+             ENDIF
              EVALUE0_C(NP)=EVALUE0(NP) +CMPLX(0.0_q,2.0_q*CSHIFT,q)
 
              !   calculate the preconditioning matrix
@@ -300,13 +314,15 @@
 
           CALLMPI( M_sum_s(WDES%COMM_INB, 3, FNORM_, ORTH, EVAR_, 0._q))
 
-          FNORM(NP)=FNORM_
+          
           IF (IDUMP>=2) WRITE(*,'(E9.2,"R")',ADVANCE='NO') SQRT(ABS(FNORM_))
           IF (IDUMP>=2) WRITE(*,'(E9.2,"O")',ADVANCE='NO') ORTH
           IF (IDUMP>=2) WRITE(*,'(E9.2,"E")',ADVANCE='NO') EVAR_
           IF (ITER==1) THEN
              ! total norm of error vector at start
-             RMS=RMS+WDES%RSPIN*WDES%WTKPT(NK)*W0%FERWE(N,NK,ISP)* &
+            ! IF (WDES%WTKPT(NK)<0) WRITE(*,*) "BZint weight at NK: ",NK, " is negative :", WDES%WTKPT(NK)
+            ! IF (W0%FERWE(N,NK,ISP)<0) WRITE(*,*) "weight of wavefunction at N,NK,ISP: ",N,NK,ISP, " is negative :", W0%FERWE(N,NK,ISP)
+            RMS=RMS+WDES%RSPIN*WDES%WTKPT(NK)*W0%FERWE(N,NK,ISP)* &
                   &      SQRT(ABS(FNORM_))/WDES%NB_TOT
              ESTART=ESTART+WDES%RSPIN*WDES%WTKPT(NK)*W0%FERWE(N,NK,ISP)*EVAR_
           ELSE
@@ -316,17 +332,42 @@
           ! store variational quantity
           W%CELEN(N,NK,ISP)=EVAR_
 
+         !  IF (ITER/=1) THEN
+         !    IF ((FNORM_-FNORM(NP))/FNORM_<0.05_q) THEN
+         !       W1(NP)%LDO=.FALSE.
+         !        RMS_FINAL_=RMS_FINAL_+WDES%RSPIN*WDES%WTKPT(NK)*W0%FERWE(N,NK,ISP)* &
+         !          &      SQRT(ABS(FNORM_))/WDES%NB_TOT
+         !       cycle i2
+         !    ENDIF
+         ! ENDIF
+         FNORM(NP)=FNORM_
           ! norm of total error vector before start
           ! norm smaller than EBREAK stop |e -e(app)| < | Residuum |
 
-          IF (ABS(FNORM_)<INFO%EBREAK/10) THEN
-             IF (IDUMP>=2) WRITE(*,'("X")',ADVANCE='NO')
-             W1(NP)%LDO=.FALSE.
-             CYCLE i2
+          IF (PRESENT(LSBREAK)) THEN
+             IF (ABS(FNORM_)<LSBREAK .or. ABS(W0%FERWE(N,NK,ISP)) < 1E-10_q ) THEN
+                IF (IDUMP>=2) WRITE(*,'("X")',ADVANCE='NO')
+                W1(NP)%LDO=.FALSE.
+                RMS_FINAL_=RMS_FINAL_+WDES%RSPIN*WDES%WTKPT(NK)*W0%FERWE(N,NK,ISP)* &
+                  &      SQRT(ABS(FNORM_))/WDES%NB_TOT
+                CYCLE i2
+             ENDIF
+          ELSE
+             IF (ABS(FNORM_)<INFO%EBREAK/10) THEN
+                IF (IDUMP>=2) WRITE(*,'("X")',ADVANCE='NO')
+                W1(NP)%LDO=.FALSE.
+                RMS_FINAL_=RMS_FINAL_+WDES%RSPIN*WDES%WTKPT(NK)*W0%FERWE(N,NK,ISP)* &
+                  &      SQRT(ABS(FNORM_))/WDES%NB_TOT
+                CYCLE i2
+             ENDIF
           ENDIF
 
           ! break now before filling WOPT%CW if ITER > NITER
-          IF (ITER>NITER) W1(NP)%LDO=.FALSE.
+          IF (ITER>NITER) THEN 
+            W1(NP)%LDO=.FALSE.
+            ! RMS_FINAL_=RMS_FINAL_+WDES%RSPIN*WDES%WTKPT(NK)*W0%FERWE(N,NK,ISP)* &
+                  ! &      SQRT(ABS(FNORM_))/WDES%NB_TOT
+          ENDIF 
 !-----------------------------------------------------------------------
 ! fill current wavefunctions into work array WOPT%CW at position ITER
 !-----------------------------------------------------------------------
@@ -385,10 +426,14 @@
              IF (PRESENT(IERROR)) THEN
                 IERROR=IERROR+1
                 W1(NP)%LDO=.FALSE.
+                RMS_FINAL_=RMS_FINAL_+WDES%RSPIN*WDES%WTKPT(NK)*W0%FERWE(N,NK,ISP)* &
+                  &      SQRT(ABS(FNORM_))/WDES%NB_TOT
                 CYCLE i2
              ELSE
                 WRITE(0,*) 'internal ERROR: LINEAR_RESPONSE_DIIS matrix is zero, try to call with LRESET',N,NK,ITER,CHAM(1:ITER,1:ITER),B(1:ITER)
-             STOP
+                IF (.NOT. PRESENT(OMEGA)) THEN
+                   STOP
+                ENDIF
              ENDIF
           ENDIF
 
@@ -426,6 +471,8 @@
                   WRITE(IU0,219) IFAIL,ITER,N
              !  try to save things somehow, goto next band
              W1(NP)%LDO=.FALSE.
+             RMS_FINAL_=RMS_FINAL_+WDES%RSPIN*WDES%WTKPT(NK)*W0%FERWE(N,NK,ISP)* &
+                  &      SQRT(ABS(FNORM_))/WDES%NB_TOT
              CYCLE i2
 219          FORMAT('WARNING in EDDRMM_LR: call to GGETRF failed, returncode =',I4,I2,I2)
           ENDIF
@@ -487,12 +534,24 @@
 
           ICOUEV=ICOUEV+1
 
-          IF (ABS(FNORM(NP))<FBREAK(NP)) W1(NP)%LDO=.FALSE.
+          IF (ABS(FNORM(NP))<FBREAK(NP)) THEN 
+            W1(NP)%LDO=.FALSE.
+            RMS_FINAL_=RMS_FINAL_+WDES%RSPIN*WDES%WTKPT(NK)*W0%FERWE(N,NK,ISP)* &
+                  &      SQRT(ABS(FNORM(NP)))/WDES%NB_TOT
+          ENDIF
           IF (ITER==1) THEN
-             FBREAK(NP)=ABS(FNORM(NP))*INFO%DEPER
+             IF (PRESENT(LSDEPER)) THEN
+                FBREAK(NP)=ABS(FNORM(NP))*LSDEPER
+             ELSE
+                FBREAK(NP)=ABS(FNORM(NP))*INFO%DEPER
+             ENDIF
           ENDIF
           ! evaluate residual vector in last step as well (just for testing)
-          IF (ITER == NITER .AND. .NOT. IDUMP==2) W1(NP)%LDO=.FALSE.
+          IF (ITER == NITER .AND. .NOT. IDUMP==2) THEN 
+            W1(NP)%LDO=.FALSE.
+            RMS_FINAL_=RMS_FINAL_+WDES%RSPIN*WDES%WTKPT(NK)*W0%FERWE(N,NK,ISP)* &
+                  &      SQRT(ABS(FNORM(NP)))/WDES%NB_TOT
+          ENDIF
        ENDDO i3
 
        ! one band just finished ?, set NB(NP) also to 0 and finish everything
@@ -518,6 +577,8 @@
     ENDIF
     CALLMPI( M_sum_d(WDES%COMM_INTER, RMS, 1))
     CALLMPI( M_sum_d(WDES%COMM_KINTER, RMS, 1))
+    CALLMPI( M_sum_d(WDES%COMM_INTER, RMS_FINAL_, 1))
+    CALLMPI( M_sum_d(WDES%COMM_KINTER, RMS_FINAL_, 1))
 
     CALLMPI( M_sum_d(WDES%COMM_INTER, DESUM, 1))
     CALLMPI( M_sum_d(WDES%COMM_KINTER, DESUM, 1))
@@ -525,6 +586,10 @@
     CALLMPI( M_sum_i(WDES%COMM_INTER, ICOUEV ,1))
     CALLMPI( M_sum_i(WDES%COMM_KINTER, ICOUEV ,1))
 
+    IF (PRESENT(RMS_FINAL)) THEN 
+      RMS_FINAL=RMS_FINAL_
+    ENDIF
+
     DO NP=1,NSIM
        CALL DELWAV_R(W1(NP))
     ENDDO
diff -urN file_ini/subrot_lr.F file_modify/subrot_lr.F
--- file_ini/subrot_lr.F	2024-07-13 10:37:12.000000000 +0800
+++ file_modify/subrot_lr.F	2024-07-13 10:37:23.000000000 +0800
@@ -1,728 +1,758 @@
-!#define dotiming
-!#define debug
-#include "symbol.inc"
-
-MODULE subrot_lr
-  USE prec
-  USE dfast
-CONTAINS
-!************************ SUBROUTINE EDDIAG_LR *************************
-! RCS:  $Id: subrot.F,v 1.10 2003/06/27 13:22:23 kresse Exp kresse $
-! 
-! this subroutine performs Loewdin perturbation theory  in the
-! sub space spanned by the calculated orbitals
-! more specifically it recalculates the wavefunctions W
-!
-!                            |phi(0)_j> <phi(0)_j| xi_i> +  K_ji
-! phi_i(1) ->phi_i(1) +sum_j -------------------------------------------
-!                                      e(0)_i - e(0)_j
-!
-! where    K_ji =  <phi(0)_j| (H(0) - e_i(0)S(0))  |phi_i(1)>
-!          K_ji =  (e_j - e_i(0))  <phi(0)_j| S(0) |phi_i(1)>
-!
-! this leads to the update equation
-!                             |phi(0)_j> <phi(0)_j| xi_i>
-! phi_i(1) ->phi_i(1) +sum_j ---------------------------  - O_ji
-!                                     e(0)_i - e(0)_j
-!
-! with     O_ji =  <phi(0)_j| S(0) |phi(1)_i>
-!
-! upon exit of the k-points and spin loop CHAM contains
-!                    <phi(0)_j| xi_i>
-!  CHAM(j,i) =   ---------------------------
-!                    e(0)_i - e(0)_j
-!
-!***********************************************************************
-
-  SUBROUTINE EDDIAG_LR(W,W0,WXI,LMDIM,CQIJ,LOVERL,LHERM,CSHIFT,IU0,DEG_CLUSTER,RESOLVE_DEG)
-      USE prec
-      USE wave_mpi
-      USE wave_high
-      USE mpimy
-      USE nonl_high
-      USE hamil
-      USE constant
-      USE main_mpi
-      USE subrot_cluster
-
-      IMPLICIT NONE
-
-      TYPE (wavespin)    W
-      TYPE (wavespin)    W0
-      TYPE (wavespin)    WXI
-
-      INTEGER LMDIM
-      OVERLAP CQIJ(LMDIM,LMDIM,W0%WDES%NIONS,W0%WDES%NCDIJ)
-      INTEGER IU0                    ! debug output
-      LOGICAL LOVERL                 ! overlap matrix used (i.e. US-PP, PAW)
-      LOGICAL LHERM                  ! <phi(0)_j| xi_i> hermitian or not
-      TYPE (eigenf_cluster_pointer), OPTIONAL:: DEG_CLUSTER(:,:)
-      LOGICAL , OPTIONAL:: RESOLVE_DEG
-      REAL(q) CSHIFT
-      
-! local variables
-      GDEF    CSUM
-      INTEGER ISP, NK, N_TO, NSTRIP
-      INTEGER NPOS, NSTRIP_ACT, N
-      INTEGER NB_TOT, NB_TOT_W0, NDONE, NP, ISPINOR, M, MM, NPOS_RED, NSTRIP_RED
-      INTEGER N1, N2
-      REAL(q) DIFCEL, FAKT
-      COMPLEX(q) CROT
-      LOGICAL :: LSETCHAM=.TRUE.        ! reset the matrix
-
-      TYPE (wavedes1)    WDES1          ! descriptor for one k-point
-      TYPE (wavedes1)    WDES1_W0       ! descriptor for one k-point for W0
-      TYPE (wavefuna)    WA             ! array to store wavefunction
-      TYPE (wavefuna)    WAXI           ! array to store wavefunction
-      TYPE (wavefuna)    WNONL          ! array to hold non local part D * wave function character
-
-      GDEF,ALLOCATABLE,TARGET::  CHAM(:,:),COVL(:,:)
-! redistributed plane wave coefficients
-      INTEGER NCPU
-
-      PROFILING_START('eddiag_lr')
-
-#ifdef MPI
-      NCPU   =W0%WDES%COMM_INTER%NCPU ! number of procs involved in band dis.
-#else
-      NCPU=1
-#endif
-!-----------------------------------------------------------------------
-! determine whether redistribution is required
-!-----------------------------------------------------------------------
-      NB_TOT   =W %WDES%NB_TOT
-      NB_TOT_W0=W0%WDES%NB_TOT
-      IF (PRESENT(DEG_CLUSTER) .AND. PRESENT(RESOLVE_DEG) .AND. NB_TOT/=NB_TOT_W0) THEN
-         WRITE(0,*)'internal error in EDDIAG_LR: resolving degeneracies is presently not tested for non square matrices'
-         STOP
-      ENDIF
-
-      ! set NSTRIP between [1 and 32]
-      NSTRIP=NSTRIP_STANDARD_GLOBAL
-
-      CALL SETWDES(W%WDES,WDES1,0)
-      CALL NEWWAVA_PROJ(WNONL, WDES1)
-
-      ALLOCATE(CHAM(NB_TOT_W0,NB_TOT),COVL(NB_TOT_W0,NB_TOT))
-!=======================================================================
-      spin:  DO ISP=1,W0%WDES%ISPIN
-      kpoint: DO NK=1,W0%WDES%NKPTS
-#ifdef MPI
-      IF (MOD(NK-1,W%WDES%COMM_KINTER%NCPU).NE.W%WDES%COMM_KINTER%NODE_ME-1) CYCLE
-#endif
-!=======================================================================
-      CALL SETWDES(W%WDES ,WDES1,NK)
-      CALL SETWDES(W0%WDES,WDES1_W0,NK)
-      WA  =ELEMENTS(W, WDES1, ISP)
-      WAXI=ELEMENTS(WXI, WDES1, ISP)
-!=======================================================================
-!  calculate Hamiltonian CHAM
-!                <phi(0)_j| xi_i>
-!  CHAM(j,i) =   ----------------
-!                e(0)_i - e(0)_j
-!=======================================================================
-   IF (LSETCHAM) THEN
-
-      CALL OVERL(WDES1, .TRUE.,LMDIM,CQIJ(1,1,1,ISP),W%CPROJ(1,1,NK,ISP),WNONL%CPROJ(1,1))
-    ! redistribute the projected wavefunctions
-    ! wavefunctions are still required at this point
-      IF (W0%WDES%DO_REDIS) THEN
-        CALL REDIS_PROJ(WDES1, W%WDES%NBANDS, WNONL%CPROJ(1,1))
-        CALL REDIS_PW  (WDES1_W0, W0%WDES%NBANDS, W0%CW   (1,1,NK,ISP))
-        CALL REDIS_PROJ(WDES1_W0, W0%WDES%NBANDS, W0%CPROJ(1,1,NK,ISP))
-        CALL REDIS_PW  (WDES1, W%WDES%NBANDS, W%CW    (1,1,NK,ISP))
-        CALL REDIS_PROJ(WDES1, W%WDES%NBANDS, W%CPROJ (1,1,NK,ISP))
-        CALL REDIS_PW  (WDES1, W%WDES%NBANDS, WXI%CW  (1,1,NK,ISP))
-        CALL REDIS_PROJ(WDES1, W%WDES%NBANDS, WXI%CPROJ(1,1,NK,ISP))
-      ENDIF
-
-      CHAM=0
-      NDONE=0
-
-! first calculate CHAM(j,i) =  <phi(0)_j| xi_i>
-      DO NPOS=1,NB_TOT,NSTRIP
-         NSTRIP_ACT=MIN(NB_TOT+1-NPOS, NSTRIP)
-
-         IF (LOVERL .OR. .NOT. LHERM) THEN
-         ! this matrix is Hermitian only if no overlap matrix exists
-            CALL ORTH2( &
-                 W0%CW(1,1,NK,ISP),WAXI%CW_RED(1,NPOS),W0%CPROJ(1,1,NK,ISP), &
-                 WNONL%CPROJ_RED(1,NPOS),NB_TOT_W0, &
-                 NPOS,NSTRIP_ACT,WDES1%NPL_RED,0,WDES1%NRPLWV_RED,WDES1%NPROD_RED,CHAM(1,1))
-         ELSE
-            CALL ORTH1("U", &
-                 W0%CW(1,1,NK,ISP),WAXI%CW_RED(1,NPOS),W0%CPROJ(1,1,NK,ISP), &
-                 WNONL%CPROJ_RED(1,NPOS),NB_TOT_W0, &
-                 NPOS,NSTRIP_ACT,WDES1%NPL_RED,0,WDES1%NRPLWV_RED,WDES1%NPROD_RED,CHAM(1,1))
-         ENDIF
-
-      ENDDO
-      CALLMPI( M_sum_g(W0%WDES%COMM_KIN,CHAM(1,1),NB_TOT_W0*NB_TOT))
-#ifdef debug
-      IF (IU0>=0) CALL DUMP_HAM( "<phi(0)_j| xi_i>",W0%WDES, CHAM)
-#endif
-1     FORMAT(1I2,3X,20F9.5)
-2     FORMAT(1I2,3X,20E9.1)
-
-
-! add Hermitian elements
-      IF (.NOT. (LOVERL .OR. .NOT. LHERM)) THEN
-         DO N2=1,NB_TOT_W0
-         DO N1=1,N2-1
-            CHAM(N2,N1)=GCONJG(CHAM(N1,N2))
-         ENDDO
-         ENDDO
-      ENDIF
-!
-! resolve degeneragy problem
-! this should be done via the DEG_CLUSTER structure which
-! stores a list of degenerated eigenvalue/eigenfunction pairs
-!
-      IF (PRESENT(DEG_CLUSTER).AND.PRESENT(RESOLVE_DEG)) THEN
-         CALL SETUP_DEG_CLUSTERS(DEG_CLUSTER(NK,ISP)%DEG_CLUSTER, CHAM,  &
-              WXI%CELTOT(:,NK,ISP), W0%CELTOT(:,NK,ISP))
-      ELSE IF(PRESENT(DEG_CLUSTER).AND.CSHIFT==0) THEN
-         CALL ZERO_HAM_DEG_CLUSTERS(DEG_CLUSTER(NK,ISP)%DEG_CLUSTER, CHAM)
-      ENDIF
-! now set CHAM(j,i) =  <phi(0)_j| xi_i> / ((e0(i)-e0(j))
-!  (Loewdin perturbation theory)
-      DO N2=1,NB_TOT
-      DO N1=1,NB_TOT_W0
-         DIFCEL= REAL( W0%CELTOT(N2,NK,ISP)-W0%CELTOT(N1,NK,ISP) ,KIND=q)
-         IF (ABS(DIFCEL)<1E-10 .AND. CSHIFT==0) THEN
-            CHAM(N1,N2)=0
-         ELSE
-            CHAM(N1,N2)=CHAM(N1,N2)/(DIFCEL+CMPLX(0.0_q,2.0_q*CSHIFT,q))
-         ENDIF
-      ENDDO
-      ENDDO
-   END IF
-!-----------------------------------------------------------------------
-! calculate the overlap matrix
-! OVERL(j,i) =  <phi(0)_j| S(0) |phi(1)_i>
-!-----------------------------------------------------------------------
-      COVL=(0._q,0._q)
-
-      DO NPOS=1,NB_TOT,NSTRIP
-         NSTRIP_ACT=MIN(NB_TOT+1-NPOS, NSTRIP)
-
-         CALL ORTH2( &
-              W0%CW(1,1,NK,ISP),WA%CW_RED(1,NPOS),W0%CPROJ(1,1,NK,ISP), &
-              WNONL%CPROJ_RED(1,NPOS),NB_TOT_W0, &
-              NPOS,NSTRIP_ACT,WDES1%NPL_RED,WDES1%NPRO_O_RED,WDES1%NRPLWV_RED,WDES1%NPROD_RED,COVL(1,1))
-      ENDDO
-
-      CALLMPI( M_sum_g(W0%WDES%COMM_KIN,COVL(1,1),NB_TOT_W0*NB_TOT))
-#ifdef debug
-      IF (IU0>=0) CALL DUMP_HAM( "<phi(0)_j| S(0) |phi(1)_i>",W0%WDES, COVL)
-#endif
-!=======================================================================
-! now add COVL to CHAM
-!=======================================================================
-      DO N2=1,NB_TOT
-      DO N1=1,NB_TOT_W0
-            CHAM(N1,N2)=CHAM(N1,N2)-COVL(N1,N2)
-      ENDDO
-      ENDDO
-#ifdef debug
-      IF (IU0>=0) CALL DUMP_HAM( "matrix H_ij for transform H_ij |phi(0)_j>",W0%WDES, CHAM)
-#endif
-!=======================================================================
-! rotate wavefunctions
-!=======================================================================
-      IF (WDES1%NPL_RED/=0) &
-      CALL GGEMM('N', 'N', m_ WDES1%NPL_RED, NB_TOT, NB_TOT_W0, one, &
-     &               W0%CW(1,1,NK,ISP), m_ WDES1%NRPLWV_RED, CHAM(1,1), &
-     &               NB_TOT_W0, one, W%CW(1,1,NK,ISP) , m_ WDES1%NRPLWV_RED)
-      IF (WDES1%NPRO_RED/=0) &
-      CALL GGEMM('N', 'N', WDES1%NPRO_RED, NB_TOT, NB_TOT_W0, one, &
-     &               W0%CPROJ(1,1,NK,ISP), WDES1%NPROD_RED, CHAM(1,1), &
-     &               NB_TOT_W0, one, W%CPROJ(1,1,NK,ISP) , WDES1%NPROD_RED)
-
-      DWRITE "lincom ok"
-
-      IF (PRESENT(DEG_CLUSTER) .AND. PRESENT(RESOLVE_DEG)) THEN
-      IF (ASSOCIATED(DEG_CLUSTER(NK,ISP)%DEG_CLUSTER)) THEN
-      CALL SUBROT_DEG_CLUSTERS(W0%WDES, WDES1%NPL_RED, WDES1%NPRO_RED, WDES1%NRPLWV_RED, WDES1%NPROD_RED, &
-          W0%CW(:,:,NK,ISP), W0%CPROJ(:,:,NK,ISP), DEG_CLUSTER(NK,ISP)%DEG_CLUSTER, .FALSE., .FALSE.)
-      CALL SUBROT_DEG_CLUSTERS(W0%WDES, WDES1%NPL_RED, WDES1%NPRO_RED, WDES1%NRPLWV_RED, WDES1%NPROD_RED, &
-          W%CW(:,:,NK,ISP),  W%CPROJ(:,:,NK,ISP), DEG_CLUSTER(NK,ISP)%DEG_CLUSTER, .FALSE., .FALSE.)
-      CALL SUBROT_DEG_CLUSTERS(W0%WDES, WDES1%NPL_RED, WDES1%NPRO_RED, WDES1%NRPLWV_RED, WDES1%NPROD_RED, &
-          WXI%CW(:,:,NK,ISP), WXI%CPROJ(:,:,NK,ISP), DEG_CLUSTER(NK,ISP)%DEG_CLUSTER, .FALSE., .FALSE.)
-      ENDIF
-      ENDIF
-      
-      IF (W0%WDES%DO_REDIS) THEN
-         CALL REDIS_PW  (WDES1_W0, W0%WDES%NBANDS, W0%CW   (1,1,NK,ISP))
-         CALL REDIS_PROJ(WDES1_W0, W0%WDES%NBANDS, W0%CPROJ(1,1,NK,ISP))
-         CALL REDIS_PW  (WDES1, W%WDES%NBANDS, W%CW    (1,1,NK,ISP))
-         CALL REDIS_PROJ(WDES1, W%WDES%NBANDS, W%CPROJ (1,1,NK,ISP))
-         CALL REDIS_PW  (WDES1, W%WDES%NBANDS, WXI%CW  (1,1,NK,ISP))
-         CALL REDIS_PROJ(WDES1, W%WDES%NBANDS, WXI%CPROJ(1,1,NK,ISP))
-         DWRITE "redis ok"
-      ENDIF
-
-!=======================================================================
-! restore CHAM
-!=======================================================================
-      DO N2=1,NB_TOT
-      DO N1=1,NB_TOT_W0
-            CHAM(N1,N2)=CHAM(N1,N2)+COVL(N1,N2)
-      ENDDO
-      ENDDO
-
-!=======================================================================
-      ENDDO kpoint
-      ENDDO spin
-!=======================================================================
-      CALL DELWAVA_PROJ(WNONL)
-      DEALLOCATE(CHAM,COVL)
-
-      PROFILING_STOP('eddiag_lr')
-
-      RETURN
-      END SUBROUTINE EDDIAG_LR
-
-!************************ SUBROUTINE ORTHO_LR **************************
-!
-! this subroutine removes any hermitian or anti-hermitian (unitary)
-! part from the first order change of wave functions phi(1)
-! upon calling
-!
-! W%CW must store     <G | phi(1)>
-! W%CPROJ must store  <p(1) |  phi(0)> + <p(0) | phi(1)>
-!   (i.e. total change of wave function character)
-! 
-! after the call the first order change of the orbitals is
-! essentially S orthogonal to the occupied bands
-! i.e. after calling the routine the following equation holds:
-! anti-hermitian case:
-!     <phi(0)_j | S(0) | phi(1)_i> + <phi(0)_i | S(0) | phi(1)_j>* 
-!   + <phi(0)_j | S(1) | phi(0)_i>   = 0
-! where S(1) is the first order change of the overlap operator
-! hermitian case:
-!     <phi(0)_j | S(0) | phi(1)_i> - <phi(0)_i | S(0) | phi(1)_j>*
-!   + <phi(0)_j | S(1) | phi(0)_i>   = 0
-!
-! furthermore the routine also removes the diagonal part
-!     <phi(0)_i | S(0) | phi(1)_i> + <phi(1)_i | S(0) | phi(0)_i>
-!   + <phi(0)_i | S(1) | phi(0)_i>   = 0
-! This is required since the orbital must remain S orthogonal
-!   <phi(0)_i+delta phi(1)_i| S(0)+ delta S(1) |phi(0)_i+delta phi(1)_i>=1
-!
-! note that all linear response routine yields a response compatible with
-!   <phi(0)_i | S(0) | phi(1)_i> = 0
-! which is obviously not quite right and should rather be  
-!   <phi(0)_i | S(0) | phi(1)_i> + <phi(0)_i | S(1) | phi(0)_i> = 0
-!
-!***********************************************************************
-
-  SUBROUTINE ORTHO_LR(W,W0,WDES,LMDIM,CQIJ,LOVERL,IU0,LHERM)
-      USE prec
-      USE wave_mpi
-      USE wave
-      USE wave_high
-      USE mpimy
-
-      IMPLICIT NONE
-
-      TYPE (wavespin)    W
-      TYPE (wavespin)    W0
-      TYPE (wavedes)     WDES
-
-      INTEGER LMDIM
-      OVERLAP CQIJ(LMDIM,LMDIM,WDES%NIONS,WDES%NCDIJ)
-      INTEGER IU0                    ! debug output
-      LOGICAL LOVERL                 ! overlap matrix used (i.e. US-PP, PAW)
-      LOGICAL LHERM
-! local variables
-      INTEGER ISP, NK, NBANDS, NSTRIP
-      INTEGER NPOS,  N
-      INTEGER NB_TOT
-      INTEGER N1, N2
-! work arrays (do max of 16 strips simultaneously)
-      TYPE (wavedes1)    WDES1          ! descriptor for one k-point
-
-      GDEF,ALLOCATABLE,TARGET::  COVL(:,:)
-! redistributed plane wave coefficients
-      TYPE (wavefuna)    WA             ! array to store wavefunction
-      TYPE (wavefuna)    WNONL          ! array to hold non local part D * wave function character
-      INTEGER NCPU
-      COMPLEX(q) :: C
-
-      PROFILING_START('ortho_lr')
-
-#ifdef MPI
-      NCPU   =WDES%COMM_INTER%NCPU ! number of procs involved in band dis.
-#else
-      NCPU=1
-#endif
-!-----------------------------------------------------------------------
-! determine whether redistribution is required
-!-----------------------------------------------------------------------
-      NB_TOT=WDES%NB_TOT
-      NBANDS=WDES%NBANDS
-
-      ! set NSTRIP between [1 and 32]
-      NSTRIP=NSTRIP_STANDARD_GLOBAL
-
-      CALL SETWDES(WDES,WDES1,0)
-      CALL NEWWAVA_PROJ(WNONL, WDES1)
-
-! allocate work space
-      ALLOCATE(COVL(NB_TOT,NB_TOT))
-
-!=======================================================================
-      spin:  DO ISP=1,WDES%ISPIN
-      kpoint: DO NK=1,WDES%NKPTS
-#ifdef MPI
-      IF (MOD(NK-1,W%WDES%COMM_KINTER%NCPU).NE.W%WDES%COMM_KINTER%NODE_ME-1) CYCLE
-#endif
-!=======================================================================
-      CALL SETWDES(WDES,WDES1,NK)
-      WA=ELEMENTS(W, WDES1, ISP)
-
-!-----------------------------------------------------------------------
-! calculate the overlap matrix
-! OVERL(j,i) =  <phi(0)_j| S(0) |phi(1)_i>
-!-----------------------------------------------------------------------
-      CALL OVERL(WDES1, .TRUE.,LMDIM,CQIJ(1,1,1,ISP),W%CPROJ(1,1,NK,ISP),WNONL%CPROJ(1,1))
-    ! redistribute the projected wavefunctions
-    ! wavefunctions are still required at this point
-      IF (WDES%DO_REDIS) THEN
-        CALL REDISTRIBUTE_PROJ(WNONL)
-        CALL REDIS_PW  (WDES1, NBANDS, W0%CW   (1,1,NK,ISP))
-        CALL REDIS_PROJ(WDES1, NBANDS, W0%CPROJ(1,1,NK,ISP))
-        CALL REDIS_PW  (WDES1, NBANDS, W%CW    (1,1,NK,ISP))
-        CALL REDIS_PROJ(WDES1, NBANDS, W%CPROJ (1,1,NK,ISP))
-      ENDIF
-
-      COVL=(0._q,0._q)
-
-      DO NPOS=1,NB_TOT-NSTRIP,NSTRIP
-         CALL ORTH2( &
-              W0%CW(1,1,NK,ISP),WA%CW_RED(1,NPOS),W0%CPROJ(1,1,NK,ISP), &
-              WNONL%CPROJ_RED(1,NPOS),NB_TOT, &
-              NPOS,NSTRIP,WDES1%NPL_RED,WDES1%NPRO_O_RED,WDES1%NRPLWV_RED,WDES1%NPROD_RED,COVL(1,1))
-      ENDDO
-
-      CALL ORTH2( &
-           W0%CW(1,1,NK,ISP),WA%CW_RED(1,NPOS),W0%CPROJ(1,1,NK,ISP), &
-           WNONL%CPROJ_RED(1,NPOS),NB_TOT, &
-           NPOS,NB_TOT-NPOS+1,WDES1%NPL_RED,WDES1%NPRO_O_RED,WDES1%NRPLWV_RED,WDES1%NPROD_RED,COVL(1,1))
-
-      CALLMPI( M_sum_g(WDES%COMM_KIN,COVL(1,1),NB_TOT*NB_TOT))
-#ifdef debug
-      IF (IU0>=0) CALL DUMP_HAM( "ORTHO_LR: <phi(0)_j| S(0) |phi_i(1)>",WDES, COVL)
-#endif
-1     FORMAT(1I2,3X,20F9.5)
-2     FORMAT(1I2,3X,20E9.1)
-!-----------------------------------------------------------------------
-! now remove unitary part or Hermitian part of the rotation matrix
-! (unitary part for Hermitian perturbation, Hermitian part for
-!              anti-Hermitian perturbation)
-! after reconsideration of the equations
-! Anything in the occupied manyfold must be removed since
-! non unitary contributions would violate the orthogonality constraint 
-! and can be only the result of noise indicative of numerical errors
-! the errors are a result of huge rotations among states close in energy
-!-----------------------------------------------------------------------
-#define remove_all_rotations_from_occupied_space
-#ifdef remove_all_rotations_from_occupied_space
-      DO N2=1,NB_TOT
-      DO N1=1,NB_TOT
-         IF (FILLED(W0%FERTOT(N1,NK,ISP)) .AND. FILLED(W0%FERTOT(N2,NK,ISP)) ) THEN
-            COVL(N1,N2)=-COVL(N1,N2)
-         ELSE
-            COVL(N1,N2)=0
-         ENDIF
-      ENDDO
-      ENDDO
-#else
-      IF (LHERM) THEN
-      ! for odd anti-Hermitian (anti-symmetric) perturbations
-      ! remove Hermitian part
-      ! we need this to handle first order changes with respect to k in the 
-      ! Gamma only version
-      DO N2=1,NB_TOT
-      DO N1=1,N2-1
-         IF (FILLED(W0%FERTOT(N1,NK,ISP)) .AND. FILLED(W0%FERTOT(N2,NK,ISP)) ) THEN
-            C=(COVL(N1,N2)+GCONJG(COVL(N2,N1)))/2
-            COVL(N1,N2)=-C
-            COVL(N2,N1)=-GCONJG(C)
-         ELSE
-            COVL(N1,N2)=0
-            COVL(N2,N1)=0
-         ENDIF
-      ENDDO
-      COVL(N2,N2)=-COVL(N2,N2)
-      ENDDO
-      ELSE
-      ! for usual Hermitian perturbations 
-      ! remove anti Hermitian part (resulting in unitary rotation among occupied
-      ! many-fold)
-      DO N2=1,NB_TOT
-      DO N1=1,N2-1
-         IF (FILLED(W0%FERTOT(N1,NK,ISP)) .AND. FILLED(W0%FERTOT(N2,NK,ISP)) ) THEN
-            C=(COVL(N1,N2)-GCONJG(COVL(N2,N1)))/2
-            COVL(N1,N2)=-C
-            COVL(N2,N1)= GCONJG(C)
-         ELSE
-            COVL(N1,N2)=0
-            COVL(N2,N1)=0
-         ENDIF
-      ENDDO
-      COVL(N2,N2)=-COVL(N2,N2)
-      ENDDO
-      ENDIF
-#endif
-!=======================================================================
-! rotate wavefunctions
-!=======================================================================
-      IF (WDES1%NPL_RED/=0) &
-      CALL GGEMM('N', 'N', m_ WDES1%NPL_RED, NB_TOT, NB_TOT, one, &
-     &               W0%CW(1,1,NK,ISP), m_ WDES1%NRPLWV_RED, COVL(1,1), &
-     &               NB_TOT, one, W%CW(1,1,NK,ISP) , m_ WDES1%NRPLWV_RED)
-      IF (WDES1%NPRO_RED/=0) &
-      CALL GGEMM('N', 'N', WDES1%NPRO_RED, NB_TOT, NB_TOT, one, &
-     &               W0%CPROJ(1,1,NK,ISP), WDES1%NPROD_RED, COVL(1,1), &
-     &               NB_TOT, one, W%CPROJ(1,1,NK,ISP) , WDES1%NPROD_RED)
-
-      DWRITE "lincom ok"
-
-      IF (WDES%DO_REDIS) THEN
-         CALL REDIS_PW  (WDES1, NBANDS, W0%CW   (1,1,NK,ISP))
-         CALL REDIS_PROJ(WDES1, NBANDS, W0%CPROJ(1,1,NK,ISP))
-         CALL REDIS_PW  (WDES1, NBANDS, W%CW    (1,1,NK,ISP))
-         CALL REDIS_PROJ(WDES1, NBANDS, W%CPROJ (1,1,NK,ISP))
-         DWRITE "redis ok"
-      ENDIF
-!=======================================================================
-      ENDDO kpoint
-      ENDDO spin
-!=======================================================================
-      CALL DELWAVA_PROJ(WNONL)
-      DEALLOCATE(COVL)
-
-      PROFILING_STOP('ortho_lr')
-
-      RETURN
-    END SUBROUTINE ORTHO_LR
-
-!************************ SUBROUTINE ORTHO_LR_TEST *********************
-! 
-! this subroutine is similar to the one above
-! but only dumps the "overlap" matrix
-! it also assumes the W%CPROJ has already been multiplied by 
-! CQIJ
-!
-!***********************************************************************
-
-  SUBROUTINE ORTHO_LR_TEST(W,W0,WDES,LMDIM,CQIJ,LOVERL,IU0,LHERM)
-      USE prec
-      USE wave_mpi
-      USE wave
-      USE wave_high
-      USE mpimy
-
-      IMPLICIT NONE
-
-      TYPE (wavespin)    W
-      TYPE (wavespin)    W0
-      TYPE (wavedes)     WDES
-
-      INTEGER LMDIM
-      OVERLAP CQIJ(LMDIM,LMDIM,WDES%NIONS,WDES%NCDIJ)
-      INTEGER IU0                    ! debug output
-      LOGICAL LOVERL                 ! overlap matrix used (i.e. US-PP, PAW)
-      LOGICAL LHERM
-! local variables
-      INTEGER ISP, NK, NBANDS, NSTRIP
-      INTEGER NPOS,  N
-      INTEGER NB_TOT
-      INTEGER N1, N2
-! work arrays (do max of 16 strips simultaneously)
-      TYPE (wavedes1)    WDES1          ! descriptor for one k-point
-
-      GDEF,ALLOCATABLE,TARGET::  COVL(:,:)
-! redistributed plane wave coefficients
-      TYPE (wavefuna)    WA             ! array to store wavefunction
-      INTEGER NCPU
-      COMPLEX(q) :: C
-      GDEF CRESUL(WDES%NPRO)
-
-#ifdef MPI
-      NCPU   =WDES%COMM_INTER%NCPU ! number of procs involved in band dis.
-#else
-      NCPU=1
-#endif
-!-----------------------------------------------------------------------
-! determine whether redistribution is required
-!-----------------------------------------------------------------------
-      NB_TOT=WDES%NB_TOT
-      NBANDS=WDES%NBANDS
-
-      ! set NSTRIP between [1 and 32]
-      NSTRIP=NSTRIP_STANDARD_GLOBAL
-
-      CALL SETWDES(WDES,WDES1,0)
-
-! allocate work space
-      ALLOCATE(COVL(NB_TOT,NB_TOT))
-
-!=======================================================================
-      spin:  DO ISP=1,WDES%ISPIN
-      kpoint: DO NK=1,WDES%NKPTS
-#ifdef MPI
-      IF (MOD(NK-1,W%WDES%COMM_KINTER%NCPU).NE.W%WDES%COMM_KINTER%NODE_ME-1) CYCLE
-#endif
-!=======================================================================
-      CALL SETWDES(WDES,WDES1,NK)
-      WA=ELEMENTS(W, WDES1, ISP)
-
-!-----------------------------------------------------------------------
-! calculate the overlap matrix
-! OVERL(j,i) =  <phi(0)_j| S(0) |phi(1)_i>
-!----------------------------------------------------------------------
-    ! redistribute the projected wavefunctions
-    ! wavefunctions are still required at this point
-      IF (WDES%DO_REDIS) THEN
-        CALL REDIS_PW  (WDES1, NBANDS, W0%CW   (1,1,NK,ISP))
-        CALL REDIS_PROJ(WDES1, NBANDS, W0%CPROJ(1,1,NK,ISP))
-        CALL REDIS_PW  (WDES1, NBANDS, W%CW    (1,1,NK,ISP))
-        CALL REDIS_PROJ(WDES1, NBANDS, W%CPROJ (1,1,NK,ISP))
-      ENDIF
-
-      COVL=(0._q,0._q)
-
-      DO NPOS=1,NB_TOT-NSTRIP,NSTRIP
-         CALL ORTH2( &
-              W0%CW(1,1,NK,ISP),WA%CW_RED(1,NPOS),W0%CPROJ(1,1,NK,ISP), &
-              WA%CPROJ_RED(1,NPOS),NB_TOT, &
-              NPOS,NSTRIP,WDES1%NPL_RED,WDES1%NPRO_O_RED,WDES1%NRPLWV_RED,WDES1%NPROD_RED,COVL(1,1))
-      ENDDO
-
-      CALL ORTH2( &
-           W0%CW(1,1,NK,ISP),WA%CW_RED(1,NPOS),W0%CPROJ(1,1,NK,ISP), &
-           WA%CPROJ_RED(1,NPOS),NB_TOT, &
-           NPOS,NB_TOT-NPOS+1,WDES1%NPL_RED,WDES1%NPRO_O_RED,WDES1%NRPLWV_RED,WDES1%NPROD_RED,COVL(1,1))
-
-      CALLMPI( M_sum_g(WDES%COMM_KIN,COVL(1,1),NB_TOT*NB_TOT))
-!#ifdef debug
-      IF (IU0>=0) CALL DUMP_HAM( "ORTHO_LR: <phi(0)_j| S(0) |phi_i(1)>",WDES, COVL)
-!#endif
-1     FORMAT(1I2,3X,20F9.5)
-2     FORMAT(1I2,3X,20E9.1)
-!-----------------------------------------------------------------------
-! now remove the hermitian or unitary part of the rotation matrix
-!-----------------------------------------------------------------------
-      IF (LHERM) THEN
-      DO N2=1,NB_TOT
-      DO N1=1,N2-1
-         IF (FILLED(W0%FERTOT(N1,NK,ISP)) .AND. FILLED(W0%FERTOT(N2,NK,ISP)) ) THEN
-            C=(COVL(N1,N2)+GCONJG(COVL(N2,N1)))/2
-            COVL(N1,N2)=-C
-            COVL(N2,N1)=-GCONJG(C)
-         ELSE
-            COVL(N1,N2)=0
-            COVL(N2,N1)=0
-         ENDIF
-      ENDDO
-      ENDDO
-      ELSE
-      DO N2=1,NB_TOT
-      DO N1=1,N2-1
-         IF (FILLED(W0%FERTOT(N1,NK,ISP)) .AND. FILLED(W0%FERTOT(N2,NK,ISP)) ) THEN
-            C=(COVL(N1,N2)-GCONJG(COVL(N2,N1)))/2
-            COVL(N1,N2)=-C
-            COVL(N2,N1)= GCONJG(C)
-         ELSE
-            COVL(N1,N2)=0
-            COVL(N2,N1)=0
-         ENDIF
-      ENDDO
-      ENDDO
-      ENDIF
-!=======================================================================
-! rotate wavefunctions
-!=======================================================================
-      DWRITE "lincom ok"
-
-      IF (WDES%DO_REDIS) THEN
-         CALL REDIS_PW  (WDES1, NBANDS, W0%CW   (1,1,NK,ISP))
-         CALL REDIS_PROJ(WDES1, NBANDS, W0%CPROJ(1,1,NK,ISP))
-         CALL REDIS_PW  (WDES1, NBANDS, W%CW    (1,1,NK,ISP))
-         CALL REDIS_PROJ(WDES1, NBANDS, W%CPROJ (1,1,NK,ISP))
-         DWRITE "redis ok"
-      ENDIF
-
-!=======================================================================
-      ENDDO kpoint
-      ENDDO spin
-!=======================================================================
-      DEALLOCATE(COVL)
-
-      RETURN
-    END SUBROUTINE ORTHO_LR_TEST
-
-!***********************************************************************
-! 
-! function that yields .TRUE. if a state is fully occupied
-! this is a little bit ambiguous  the threshold is presently set
-! to something 0.99 electrons
-!
-!***********************************************************************
-
-  FUNCTION FILLED(F)
-    USE prec
-    IMPLICIT NONE
-    LOGICAL FILLED
-    REAL(q) :: F
-    IF (ABS(F-1)<0.1) THEN
-       FILLED=.TRUE.
-    ELSE
-       FILLED=.FALSE.
-    ENDIF
-  END FUNCTION FILLED
-
-!***********************************************************************
-!
-! add the first order change of the orbitals parallel to phi(0)
-! this involves adding the term
-!  phi(1) +=  -<phi(0)| S(1) |phi(0)> phi(0) /2
-! it is essential for stability reasons to do this at the very end,
-! since outherwise the norm of the residual vector (rmm-diis_lr) 
-! converges to a small non zero value, which decreases the stability
-! the routine EDDIAG_LR therefore removes this element
-! (i.e.  <phi(0)_i| S(0) |phi(1)_i> = 0 )
-!
-!***********************************************************************
-
-    SUBROUTINE NORM_LR( W1, W0, WXI,WDES)
-      USE wave_mpi
-      USE wave
-      
-      IMPLICIT NONE
-      
-      TYPE (wavespin)    W1
-      TYPE (wavespin)    W0
-      TYPE (wavespin)    WXI
-      TYPE (wavedes)     WDES
-
-      INTEGER ISP, NK, N
-
-      DO ISP=1,WDES%ISPIN
-         DO NK=1,WDES%NKPTS
-#ifdef MPI
-            IF (MOD(NK-1,WDES%COMM_KINTER%NCPU).NE.WDES%COMM_KINTER%NODE_ME-1) CYCLE
-#endif
-            DO N=1,WDES%NBANDS
-               W1%CW(:,N,NK,ISP)   =W1%CW(:,N,NK,ISP)   - W0%CW(:,N,NK,ISP)*WXI%FERWE(N,NK,ISP)/2
-               W1%CPROJ(:,N,NK,ISP)=W1%CPROJ(:,N,NK,ISP)- W0%CPROJ(:,N,NK,ISP)*WXI%FERWE(N,NK,ISP)/2
-            ENDDO
-         ENDDO
-      ENDDO
-
-    END SUBROUTINE NORM_LR
-
-END MODULE subrot_lr
+!#define dotiming
+!#define debug
+#include "symbol.inc"
+
+MODULE subrot_lr
+  USE prec
+  USE dfast
+CONTAINS
+!************************ SUBROUTINE EDDIAG_LR *************************
+! RCS:  $Id: subrot.F,v 1.10 2003/06/27 13:22:23 kresse Exp kresse $
+! 
+! this subroutine performs Loewdin perturbation theory  in the
+! sub space spanned by the calculated orbitals
+! more specifically it recalculates the wavefunctions W
+!
+!                            |phi(0)_j> <phi(0)_j| xi_i> +  K_ji
+! phi_i(1) ->phi_i(1) +sum_j -------------------------------------------
+!                                      e(0)_i - e(0)_j
+!
+! where    K_ji =  <phi(0)_j| (H(0) - e_i(0)S(0))  |phi_i(1)>
+!          K_ji =  (e_j - e_i(0))  <phi(0)_j| S(0) |phi_i(1)>
+!
+! this leads to the update equation
+!                             |phi(0)_j> <phi(0)_j| xi_i>
+! phi_i(1) ->phi_i(1) +sum_j ---------------------------  - O_ji
+!                                     e(0)_i - e(0)_j
+!
+! with     O_ji =  <phi(0)_j| S(0) |phi(1)_i>
+!
+! upon exit of the k-points and spin loop CHAM contains
+!                    <phi(0)_j| xi_i>
+!  CHAM(j,i) =   ---------------------------
+!                    e(0)_i - e(0)_j
+!
+!***********************************************************************
+
+  SUBROUTINE EDDIAG_LR(W,W0,WXI,LMDIM,CQIJ,LOVERL,LHERM,CSHIFT,IU0,DEG_CLUSTER,RESOLVE_DEG,OMEGA,EPRO,LNOIMAG,LCLEAN)
+      USE prec
+      USE wave_mpi
+      USE wave_high
+      USE mpimy
+      USE nonl_high
+      USE hamil
+      USE constant
+      USE main_mpi
+      USE subrot_cluster
+
+      IMPLICIT NONE
+
+      TYPE (wavespin)    W
+      TYPE (wavespin)    W0
+      TYPE (wavespin)    WXI
+
+      INTEGER LMDIM
+      OVERLAP CQIJ(LMDIM,LMDIM,W0%WDES%NIONS,W0%WDES%NCDIJ)
+      INTEGER IU0                    ! debug output
+      LOGICAL LOVERL                 ! overlap matrix used (i.e. US-PP, PAW)
+      LOGICAL LHERM                  ! <phi(0)_j| xi_i> hermitian or not
+      TYPE (eigenf_cluster_pointer), OPTIONAL:: DEG_CLUSTER(:,:)
+      LOGICAL , OPTIONAL:: RESOLVE_DEG
+      REAL(q) CSHIFT
+      REAL(q), OPTIONAL :: OMEGA
+      REAL(q), OPTIONAL :: EPRO
+      LOGICAL, OPTIONAL :: LNOIMAG
+      LOGICAL, OPTIONAL :: LCLEAN
+! local variables
+      GDEF    CSUM
+      INTEGER ISP, NK, N_TO, NSTRIP
+      INTEGER NPOS, NSTRIP_ACT, N
+      INTEGER NB_TOT, NB_TOT_W0, NDONE, NP, ISPINOR, M, MM, NPOS_RED, NSTRIP_RED
+      INTEGER N1, N2
+      REAL(q) DIFCEL, FAKT
+      COMPLEX(q) CROT
+      LOGICAL :: LSETCHAM=.TRUE.        ! reset the matrix
+
+      TYPE (wavedes1)    WDES1          ! descriptor for one k-point
+      TYPE (wavedes1)    WDES1_W0       ! descriptor for one k-point for W0
+      TYPE (wavefuna)    WA             ! array to store wavefunction
+      TYPE (wavefuna)    WAXI           ! array to store wavefunction
+      TYPE (wavefuna)    WNONL          ! array to hold non local part D * wave function character
+
+      GDEF,ALLOCATABLE,TARGET::  CHAM(:,:),COVL(:,:)
+! redistributed plane wave coefficients
+      INTEGER NCPU
+
+      PROFILING_START('eddiag_lr')
+
+#ifdef MPI
+      NCPU   =W0%WDES%COMM_INTER%NCPU ! number of procs involved in band dis.
+#else
+      NCPU=1
+#endif
+!-----------------------------------------------------------------------
+! determine whether redistribution is required
+!-----------------------------------------------------------------------
+      NB_TOT   =W %WDES%NB_TOT
+      NB_TOT_W0=W0%WDES%NB_TOT
+      IF (PRESENT(DEG_CLUSTER) .AND. PRESENT(RESOLVE_DEG) .AND. NB_TOT/=NB_TOT_W0) THEN
+         WRITE(0,*)'internal error in EDDIAG_LR: resolving degeneracies is presently not tested for non square matrices'
+         STOP
+      ENDIF
+
+      ! set NSTRIP between [1 and 32]
+      NSTRIP=NSTRIP_STANDARD_GLOBAL
+
+      CALL SETWDES(W%WDES,WDES1,0)
+      CALL NEWWAVA_PROJ(WNONL, WDES1)
+
+      ALLOCATE(CHAM(NB_TOT_W0,NB_TOT),COVL(NB_TOT_W0,NB_TOT))
+!=======================================================================
+      spin:  DO ISP=1,W0%WDES%ISPIN
+      kpoint: DO NK=1,W0%WDES%NKPTS
+#ifdef MPI
+      IF (MOD(NK-1,W%WDES%COMM_KINTER%NCPU).NE.W%WDES%COMM_KINTER%NODE_ME-1) CYCLE
+#endif
+!=======================================================================
+      CALL SETWDES(W%WDES ,WDES1,NK)
+      CALL SETWDES(W0%WDES,WDES1_W0,NK)
+      WA  =ELEMENTS(W, WDES1, ISP)
+      WAXI=ELEMENTS(WXI, WDES1, ISP)
+!=======================================================================
+!  calculate Hamiltonian CHAM
+!                <phi(0)_j| xi_i>
+!  CHAM(j,i) =   ----------------
+!                e(0)_i - e(0)_j
+!=======================================================================
+   IF (LSETCHAM) THEN
+
+      CALL OVERL(WDES1, .TRUE.,LMDIM,CQIJ(1,1,1,ISP),W%CPROJ(1,1,NK,ISP),WNONL%CPROJ(1,1))
+    ! redistribute the projected wavefunctions
+    ! wavefunctions are still required at this point
+      IF (W0%WDES%DO_REDIS) THEN
+        CALL REDIS_PROJ(WDES1, W%WDES%NBANDS, WNONL%CPROJ(1,1))
+        CALL REDIS_PW  (WDES1_W0, W0%WDES%NBANDS, W0%CW   (1,1,NK,ISP))
+        CALL REDIS_PROJ(WDES1_W0, W0%WDES%NBANDS, W0%CPROJ(1,1,NK,ISP))
+        CALL REDIS_PW  (WDES1, W%WDES%NBANDS, W%CW    (1,1,NK,ISP))
+        CALL REDIS_PROJ(WDES1, W%WDES%NBANDS, W%CPROJ (1,1,NK,ISP))
+        CALL REDIS_PW  (WDES1, W%WDES%NBANDS, WXI%CW  (1,1,NK,ISP))
+        CALL REDIS_PROJ(WDES1, W%WDES%NBANDS, WXI%CPROJ(1,1,NK,ISP))
+      ENDIF
+
+      CHAM=0
+      NDONE=0
+
+! first calculate CHAM(j,i) =  <phi(0)_j| xi_i>
+      DO NPOS=1,NB_TOT,NSTRIP
+         NSTRIP_ACT=MIN(NB_TOT+1-NPOS, NSTRIP)
+
+         IF (LOVERL .OR. .NOT. LHERM) THEN
+         ! this matrix is Hermitian only if no overlap matrix exists
+            CALL ORTH2( &
+                 W0%CW(1,1,NK,ISP),WAXI%CW_RED(1,NPOS),W0%CPROJ(1,1,NK,ISP), &
+                 WNONL%CPROJ_RED(1,NPOS),NB_TOT_W0, &
+                 NPOS,NSTRIP_ACT,WDES1%NPL_RED,0,WDES1%NRPLWV_RED,WDES1%NPROD_RED,CHAM(1,1))
+         ELSE
+            CALL ORTH1("U", &
+                 W0%CW(1,1,NK,ISP),WAXI%CW_RED(1,NPOS),W0%CPROJ(1,1,NK,ISP), &
+                 WNONL%CPROJ_RED(1,NPOS),NB_TOT_W0, &
+                 NPOS,NSTRIP_ACT,WDES1%NPL_RED,0,WDES1%NRPLWV_RED,WDES1%NPROD_RED,CHAM(1,1))
+         ENDIF
+
+      ENDDO
+      CALLMPI( M_sum_g(W0%WDES%COMM_KIN,CHAM(1,1),NB_TOT_W0*NB_TOT))
+#ifdef debug
+      IF (IU0>=0) CALL DUMP_HAM( "<phi(0)_j| xi_i>",W0%WDES, CHAM)
+#endif
+1     FORMAT(1I2,3X,20F9.5)
+2     FORMAT(1I2,3X,20E9.1)
+
+
+! add Hermitian elements
+      IF (.NOT. (LOVERL .OR. .NOT. LHERM)) THEN
+         DO N2=1,NB_TOT_W0
+         DO N1=1,N2-1
+            CHAM(N2,N1)=GCONJG(CHAM(N1,N2))
+         ENDDO
+         ENDDO
+      ENDIF
+!
+! resolve degeneragy problem
+! this should be done via the DEG_CLUSTER structure which
+! stores a list of degenerated eigenvalue/eigenfunction pairs
+!
+      IF (PRESENT(DEG_CLUSTER).AND.PRESENT(RESOLVE_DEG)) THEN
+         CALL SETUP_DEG_CLUSTERS(DEG_CLUSTER(NK,ISP)%DEG_CLUSTER, CHAM,  &
+              WXI%CELTOT(:,NK,ISP), W0%CELTOT(:,NK,ISP))
+      ELSE IF(PRESENT(DEG_CLUSTER).AND.CSHIFT==0) THEN
+         CALL ZERO_HAM_DEG_CLUSTERS(DEG_CLUSTER(NK,ISP)%DEG_CLUSTER, CHAM)
+      ENDIF
+! now set CHAM(j,i) =  <phi(0)_j| xi_i> / ((e0(i)-e0(j))
+!  (Loewdin perturbation theory)
+      DO N2=1,NB_TOT
+      DO N1=1,NB_TOT_W0
+         IF (PRESENT(OMEGA)) THEN
+            ! Passing e_nk in W and e_nk+q in W0
+            DIFCEL= REAL( W%CELTOT(N2,NK,ISP)+OMEGA-W0%CELTOT(N1,NK,ISP) ,KIND=q)
+         ELSE
+            DIFCEL= REAL( W0%CELTOT(N2,NK,ISP)-W0%CELTOT(N1,NK,ISP) ,KIND=q)
+         ENDIF
+         IF (ABS(DIFCEL)<1E-10 .AND. CSHIFT==0) THEN
+            CHAM(N1,N2)=0
+         ELSE
+            IF (PRESENT(LNOIMAG) .AND. LNOIMAG==.TRUE.) THEN
+                  CHAM(N1,N2)=CHAM(N1,N2)*REAL(1.0_q/(DIFCEL+CMPLX(0.0_q,2.0_q*CSHIFT,q)),KIND=q)
+            ELSE
+                  CHAM(N1,N2)=CHAM(N1,N2)/(DIFCEL+CMPLX(0.0_q,2.0_q*CSHIFT,q))
+            ENDIF
+         ENDIF
+      ENDDO
+      ENDDO
+   END IF
+!-----------------------------------------------------------------------
+! calculate the overlap matrix
+! OVERL(j,i) =  <phi(0)_j| S(0) |phi(1)_i>
+!-----------------------------------------------------------------------
+      COVL=(0._q,0._q)
+
+      DO NPOS=1,NB_TOT,NSTRIP
+         NSTRIP_ACT=MIN(NB_TOT+1-NPOS, NSTRIP)
+
+         CALL ORTH2( &
+              W0%CW(1,1,NK,ISP),WA%CW_RED(1,NPOS),W0%CPROJ(1,1,NK,ISP), &
+              WNONL%CPROJ_RED(1,NPOS),NB_TOT_W0, &
+              NPOS,NSTRIP_ACT,WDES1%NPL_RED,WDES1%NPRO_O_RED,WDES1%NRPLWV_RED,WDES1%NPROD_RED,COVL(1,1))
+      ENDDO
+
+      CALLMPI( M_sum_g(W0%WDES%COMM_KIN,COVL(1,1),NB_TOT_W0*NB_TOT))
+#ifdef debug
+      IF (IU0>=0) CALL DUMP_HAM( "<phi(0)_j| S(0) |phi(1)_i>",W0%WDES, COVL)
+#endif
+!=======================================================================
+! now add COVL to CHAM
+!=======================================================================
+      DO N2=1,NB_TOT
+      DO N1=1,NB_TOT_W0
+         IF (PRESENT(EPRO)) THEN
+            IF (REAL(W0%CELTOT(N1,NK,ISP)) > EPRO) THEN
+               CHAM(N1,N2)=0.0_q
+            ELSE
+               IF (PRESENT(LCLEAN)) THEN
+                  CHAM(N1,N2) = -COVL(N1,N2)
+               ELSE
+                  IF (ABS(W%FERTOT(N2,NK,ISP))<1E-10_q) THEN    
+                        CHAM(N1,N2)=-COVL(N1,N2)
+                  ELSEIF (ABS(W0%FERTOT(N1,NK,ISP)-W%FERTOT(N2,NK,ISP))< 1E-6_q ) THEN
+                        CHAM(N1,N2)=-COVL(N1,N2)
+                  ELSE
+                        CHAM(N1,N2)=CHAM(N1,N2)-COVL(N1,N2)
+                  ENDIF
+               ENDIF
+            ENDIF
+         ELSE
+            CHAM(N1,N2)=CHAM(N1,N2)-COVL(N1,N2)
+         ENDIF
+      ENDDO
+      ENDDO
+#ifdef debug
+      IF (IU0>=0) CALL DUMP_HAM( "matrix H_ij for transform H_ij |phi(0)_j>",W0%WDES, CHAM)
+#endif
+!=======================================================================
+! rotate wavefunctions
+!=======================================================================
+      IF (WDES1%NPL_RED/=0) &
+      CALL GGEMM('N', 'N', m_ WDES1%NPL_RED, NB_TOT, NB_TOT_W0, one, &
+     &               W0%CW(1,1,NK,ISP), m_ WDES1%NRPLWV_RED, CHAM(1,1), &
+     &               NB_TOT_W0, one, W%CW(1,1,NK,ISP) , m_ WDES1%NRPLWV_RED)
+      IF (WDES1%NPRO_RED/=0) &
+      CALL GGEMM('N', 'N', WDES1%NPRO_RED, NB_TOT, NB_TOT_W0, one, &
+     &               W0%CPROJ(1,1,NK,ISP), WDES1%NPROD_RED, CHAM(1,1), &
+     &               NB_TOT_W0, one, W%CPROJ(1,1,NK,ISP) , WDES1%NPROD_RED)
+
+      DWRITE "lincom ok"
+
+      IF (PRESENT(DEG_CLUSTER) .AND. PRESENT(RESOLVE_DEG)) THEN
+      IF (ASSOCIATED(DEG_CLUSTER(NK,ISP)%DEG_CLUSTER)) THEN
+      CALL SUBROT_DEG_CLUSTERS(W0%WDES, WDES1%NPL_RED, WDES1%NPRO_RED, WDES1%NRPLWV_RED, WDES1%NPROD_RED, &
+          W0%CW(:,:,NK,ISP), W0%CPROJ(:,:,NK,ISP), DEG_CLUSTER(NK,ISP)%DEG_CLUSTER, .FALSE., .FALSE.)
+      CALL SUBROT_DEG_CLUSTERS(W0%WDES, WDES1%NPL_RED, WDES1%NPRO_RED, WDES1%NRPLWV_RED, WDES1%NPROD_RED, &
+          W%CW(:,:,NK,ISP),  W%CPROJ(:,:,NK,ISP), DEG_CLUSTER(NK,ISP)%DEG_CLUSTER, .FALSE., .FALSE.)
+      CALL SUBROT_DEG_CLUSTERS(W0%WDES, WDES1%NPL_RED, WDES1%NPRO_RED, WDES1%NRPLWV_RED, WDES1%NPROD_RED, &
+          WXI%CW(:,:,NK,ISP), WXI%CPROJ(:,:,NK,ISP), DEG_CLUSTER(NK,ISP)%DEG_CLUSTER, .FALSE., .FALSE.)
+      ENDIF
+      ENDIF
+      
+      IF (W0%WDES%DO_REDIS) THEN
+         CALL REDIS_PW  (WDES1_W0, W0%WDES%NBANDS, W0%CW   (1,1,NK,ISP))
+         CALL REDIS_PROJ(WDES1_W0, W0%WDES%NBANDS, W0%CPROJ(1,1,NK,ISP))
+         CALL REDIS_PW  (WDES1, W%WDES%NBANDS, W%CW    (1,1,NK,ISP))
+         CALL REDIS_PROJ(WDES1, W%WDES%NBANDS, W%CPROJ (1,1,NK,ISP))
+         CALL REDIS_PW  (WDES1, W%WDES%NBANDS, WXI%CW  (1,1,NK,ISP))
+         CALL REDIS_PROJ(WDES1, W%WDES%NBANDS, WXI%CPROJ(1,1,NK,ISP))
+         DWRITE "redis ok"
+      ENDIF
+
+!=======================================================================
+! restore CHAM
+!=======================================================================
+      DO N2=1,NB_TOT
+      DO N1=1,NB_TOT_W0
+            CHAM(N1,N2)=CHAM(N1,N2)+COVL(N1,N2)
+      ENDDO
+      ENDDO
+
+!=======================================================================
+      ENDDO kpoint
+      ENDDO spin
+!=======================================================================
+      CALL DELWAVA_PROJ(WNONL)
+      DEALLOCATE(CHAM,COVL)
+
+      PROFILING_STOP('eddiag_lr')
+
+      RETURN
+      END SUBROUTINE EDDIAG_LR
+
+!************************ SUBROUTINE ORTHO_LR **************************
+!
+! this subroutine removes any hermitian or anti-hermitian (unitary)
+! part from the first order change of wave functions phi(1)
+! upon calling
+!
+! W%CW must store     <G | phi(1)>
+! W%CPROJ must store  <p(1) |  phi(0)> + <p(0) | phi(1)>
+!   (i.e. total change of wave function character)
+! 
+! after the call the first order change of the orbitals is
+! essentially S orthogonal to the occupied bands
+! i.e. after calling the routine the following equation holds:
+! anti-hermitian case:
+!     <phi(0)_j | S(0) | phi(1)_i> + <phi(0)_i | S(0) | phi(1)_j>* 
+!   + <phi(0)_j | S(1) | phi(0)_i>   = 0
+! where S(1) is the first order change of the overlap operator
+! hermitian case:
+!     <phi(0)_j | S(0) | phi(1)_i> - <phi(0)_i | S(0) | phi(1)_j>*
+!   + <phi(0)_j | S(1) | phi(0)_i>   = 0
+!
+! furthermore the routine also removes the diagonal part
+!     <phi(0)_i | S(0) | phi(1)_i> + <phi(1)_i | S(0) | phi(0)_i>
+!   + <phi(0)_i | S(1) | phi(0)_i>   = 0
+! This is required since the orbital must remain S orthogonal
+!   <phi(0)_i+delta phi(1)_i| S(0)+ delta S(1) |phi(0)_i+delta phi(1)_i>=1
+!
+! note that all linear response routine yields a response compatible with
+!   <phi(0)_i | S(0) | phi(1)_i> = 0
+! which is obviously not quite right and should rather be  
+!   <phi(0)_i | S(0) | phi(1)_i> + <phi(0)_i | S(1) | phi(0)_i> = 0
+!
+!***********************************************************************
+
+  SUBROUTINE ORTHO_LR(W,W0,WDES,LMDIM,CQIJ,LOVERL,IU0,LHERM)
+      USE prec
+      USE wave_mpi
+      USE wave
+      USE wave_high
+      USE mpimy
+
+      IMPLICIT NONE
+
+      TYPE (wavespin)    W
+      TYPE (wavespin)    W0
+      TYPE (wavedes)     WDES
+
+      INTEGER LMDIM
+      OVERLAP CQIJ(LMDIM,LMDIM,WDES%NIONS,WDES%NCDIJ)
+      INTEGER IU0                    ! debug output
+      LOGICAL LOVERL                 ! overlap matrix used (i.e. US-PP, PAW)
+      LOGICAL LHERM
+! local variables
+      INTEGER ISP, NK, NBANDS, NSTRIP
+      INTEGER NPOS,  N
+      INTEGER NB_TOT
+      INTEGER N1, N2
+! work arrays (do max of 16 strips simultaneously)
+      TYPE (wavedes1)    WDES1          ! descriptor for one k-point
+
+      GDEF,ALLOCATABLE,TARGET::  COVL(:,:)
+! redistributed plane wave coefficients
+      TYPE (wavefuna)    WA             ! array to store wavefunction
+      TYPE (wavefuna)    WNONL          ! array to hold non local part D * wave function character
+      INTEGER NCPU
+      COMPLEX(q) :: C
+
+      PROFILING_START('ortho_lr')
+
+#ifdef MPI
+      NCPU   =WDES%COMM_INTER%NCPU ! number of procs involved in band dis.
+#else
+      NCPU=1
+#endif
+!-----------------------------------------------------------------------
+! determine whether redistribution is required
+!-----------------------------------------------------------------------
+      NB_TOT=WDES%NB_TOT
+      NBANDS=WDES%NBANDS
+
+      ! set NSTRIP between [1 and 32]
+      NSTRIP=NSTRIP_STANDARD_GLOBAL
+
+      CALL SETWDES(WDES,WDES1,0)
+      CALL NEWWAVA_PROJ(WNONL, WDES1)
+
+! allocate work space
+      ALLOCATE(COVL(NB_TOT,NB_TOT))
+
+!=======================================================================
+      spin:  DO ISP=1,WDES%ISPIN
+      kpoint: DO NK=1,WDES%NKPTS
+#ifdef MPI
+      IF (MOD(NK-1,W%WDES%COMM_KINTER%NCPU).NE.W%WDES%COMM_KINTER%NODE_ME-1) CYCLE
+#endif
+!=======================================================================
+      CALL SETWDES(WDES,WDES1,NK)
+      WA=ELEMENTS(W, WDES1, ISP)
+
+!-----------------------------------------------------------------------
+! calculate the overlap matrix
+! OVERL(j,i) =  <phi(0)_j| S(0) |phi(1)_i>
+!-----------------------------------------------------------------------
+      CALL OVERL(WDES1, .TRUE.,LMDIM,CQIJ(1,1,1,ISP),W%CPROJ(1,1,NK,ISP),WNONL%CPROJ(1,1))
+    ! redistribute the projected wavefunctions
+    ! wavefunctions are still required at this point
+      IF (WDES%DO_REDIS) THEN
+        CALL REDISTRIBUTE_PROJ(WNONL)
+        CALL REDIS_PW  (WDES1, NBANDS, W0%CW   (1,1,NK,ISP))
+        CALL REDIS_PROJ(WDES1, NBANDS, W0%CPROJ(1,1,NK,ISP))
+        CALL REDIS_PW  (WDES1, NBANDS, W%CW    (1,1,NK,ISP))
+        CALL REDIS_PROJ(WDES1, NBANDS, W%CPROJ (1,1,NK,ISP))
+      ENDIF
+
+      COVL=(0._q,0._q)
+
+      DO NPOS=1,NB_TOT-NSTRIP,NSTRIP
+         CALL ORTH2( &
+              W0%CW(1,1,NK,ISP),WA%CW_RED(1,NPOS),W0%CPROJ(1,1,NK,ISP), &
+              WNONL%CPROJ_RED(1,NPOS),NB_TOT, &
+              NPOS,NSTRIP,WDES1%NPL_RED,WDES1%NPRO_O_RED,WDES1%NRPLWV_RED,WDES1%NPROD_RED,COVL(1,1))
+      ENDDO
+
+      CALL ORTH2( &
+           W0%CW(1,1,NK,ISP),WA%CW_RED(1,NPOS),W0%CPROJ(1,1,NK,ISP), &
+           WNONL%CPROJ_RED(1,NPOS),NB_TOT, &
+           NPOS,NB_TOT-NPOS+1,WDES1%NPL_RED,WDES1%NPRO_O_RED,WDES1%NRPLWV_RED,WDES1%NPROD_RED,COVL(1,1))
+
+      CALLMPI( M_sum_g(WDES%COMM_KIN,COVL(1,1),NB_TOT*NB_TOT))
+#ifdef debug
+      IF (IU0>=0) CALL DUMP_HAM( "ORTHO_LR: <phi(0)_j| S(0) |phi_i(1)>",WDES, COVL)
+#endif
+1     FORMAT(1I2,3X,20F9.5)
+2     FORMAT(1I2,3X,20E9.1)
+!-----------------------------------------------------------------------
+! now remove unitary part or Hermitian part of the rotation matrix
+! (unitary part for Hermitian perturbation, Hermitian part for
+!              anti-Hermitian perturbation)
+! after reconsideration of the equations
+! Anything in the occupied manyfold must be removed since
+! non unitary contributions would violate the orthogonality constraint 
+! and can be only the result of noise indicative of numerical errors
+! the errors are a result of huge rotations among states close in energy
+!-----------------------------------------------------------------------
+#define remove_all_rotations_from_occupied_space
+#ifdef remove_all_rotations_from_occupied_space
+      DO N2=1,NB_TOT
+      DO N1=1,NB_TOT
+         IF (FILLED(W0%FERTOT(N1,NK,ISP)) .AND. FILLED(W0%FERTOT(N2,NK,ISP)) ) THEN
+            COVL(N1,N2)=-COVL(N1,N2)
+         ELSE
+            COVL(N1,N2)=0
+         ENDIF
+      ENDDO
+      ENDDO
+#else
+      IF (LHERM) THEN
+      ! for odd anti-Hermitian (anti-symmetric) perturbations
+      ! remove Hermitian part
+      ! we need this to handle first order changes with respect to k in the 
+      ! Gamma only version
+      DO N2=1,NB_TOT
+      DO N1=1,N2-1
+         IF (FILLED(W0%FERTOT(N1,NK,ISP)) .AND. FILLED(W0%FERTOT(N2,NK,ISP)) ) THEN
+            C=(COVL(N1,N2)+GCONJG(COVL(N2,N1)))/2
+            COVL(N1,N2)=-C
+            COVL(N2,N1)=-GCONJG(C)
+         ELSE
+            COVL(N1,N2)=0
+            COVL(N2,N1)=0
+         ENDIF
+      ENDDO
+      COVL(N2,N2)=-COVL(N2,N2)
+      ENDDO
+      ELSE
+      ! for usual Hermitian perturbations 
+      ! remove anti Hermitian part (resulting in unitary rotation among occupied
+      ! many-fold)
+      DO N2=1,NB_TOT
+      DO N1=1,N2-1
+         IF (FILLED(W0%FERTOT(N1,NK,ISP)) .AND. FILLED(W0%FERTOT(N2,NK,ISP)) ) THEN
+            C=(COVL(N1,N2)-GCONJG(COVL(N2,N1)))/2
+            COVL(N1,N2)=-C
+            COVL(N2,N1)= GCONJG(C)
+         ELSE
+            COVL(N1,N2)=0
+            COVL(N2,N1)=0
+         ENDIF
+      ENDDO
+      COVL(N2,N2)=-COVL(N2,N2)
+      ENDDO
+      ENDIF
+#endif
+!=======================================================================
+! rotate wavefunctions
+!=======================================================================
+      IF (WDES1%NPL_RED/=0) &
+      CALL GGEMM('N', 'N', m_ WDES1%NPL_RED, NB_TOT, NB_TOT, one, &
+     &               W0%CW(1,1,NK,ISP), m_ WDES1%NRPLWV_RED, COVL(1,1), &
+     &               NB_TOT, one, W%CW(1,1,NK,ISP) , m_ WDES1%NRPLWV_RED)
+      IF (WDES1%NPRO_RED/=0) &
+      CALL GGEMM('N', 'N', WDES1%NPRO_RED, NB_TOT, NB_TOT, one, &
+     &               W0%CPROJ(1,1,NK,ISP), WDES1%NPROD_RED, COVL(1,1), &
+     &               NB_TOT, one, W%CPROJ(1,1,NK,ISP) , WDES1%NPROD_RED)
+
+      DWRITE "lincom ok"
+
+      IF (WDES%DO_REDIS) THEN
+         CALL REDIS_PW  (WDES1, NBANDS, W0%CW   (1,1,NK,ISP))
+         CALL REDIS_PROJ(WDES1, NBANDS, W0%CPROJ(1,1,NK,ISP))
+         CALL REDIS_PW  (WDES1, NBANDS, W%CW    (1,1,NK,ISP))
+         CALL REDIS_PROJ(WDES1, NBANDS, W%CPROJ (1,1,NK,ISP))
+         DWRITE "redis ok"
+      ENDIF
+!=======================================================================
+      ENDDO kpoint
+      ENDDO spin
+!=======================================================================
+      CALL DELWAVA_PROJ(WNONL)
+      DEALLOCATE(COVL)
+
+      PROFILING_STOP('ortho_lr')
+
+      RETURN
+    END SUBROUTINE ORTHO_LR
+
+!************************ SUBROUTINE ORTHO_LR_TEST *********************
+! 
+! this subroutine is similar to the one above
+! but only dumps the "overlap" matrix
+! it also assumes the W%CPROJ has already been multiplied by 
+! CQIJ
+!
+!***********************************************************************
+
+  SUBROUTINE ORTHO_LR_TEST(W,W0,WDES,LMDIM,CQIJ,LOVERL,IU0,LHERM)
+      USE prec
+      USE wave_mpi
+      USE wave
+      USE wave_high
+      USE mpimy
+
+      IMPLICIT NONE
+
+      TYPE (wavespin)    W
+      TYPE (wavespin)    W0
+      TYPE (wavedes)     WDES
+
+      INTEGER LMDIM
+      OVERLAP CQIJ(LMDIM,LMDIM,WDES%NIONS,WDES%NCDIJ)
+      INTEGER IU0                    ! debug output
+      LOGICAL LOVERL                 ! overlap matrix used (i.e. US-PP, PAW)
+      LOGICAL LHERM
+! local variables
+      INTEGER ISP, NK, NBANDS, NSTRIP
+      INTEGER NPOS,  N
+      INTEGER NB_TOT
+      INTEGER N1, N2
+! work arrays (do max of 16 strips simultaneously)
+      TYPE (wavedes1)    WDES1          ! descriptor for one k-point
+
+      GDEF,ALLOCATABLE,TARGET::  COVL(:,:)
+! redistributed plane wave coefficients
+      TYPE (wavefuna)    WA             ! array to store wavefunction
+      INTEGER NCPU
+      COMPLEX(q) :: C
+      GDEF CRESUL(WDES%NPRO)
+
+#ifdef MPI
+      NCPU   =WDES%COMM_INTER%NCPU ! number of procs involved in band dis.
+#else
+      NCPU=1
+#endif
+!-----------------------------------------------------------------------
+! determine whether redistribution is required
+!-----------------------------------------------------------------------
+      NB_TOT=WDES%NB_TOT
+      NBANDS=WDES%NBANDS
+
+      ! set NSTRIP between [1 and 32]
+      NSTRIP=NSTRIP_STANDARD_GLOBAL
+
+      CALL SETWDES(WDES,WDES1,0)
+
+! allocate work space
+      ALLOCATE(COVL(NB_TOT,NB_TOT))
+
+!=======================================================================
+      spin:  DO ISP=1,WDES%ISPIN
+      kpoint: DO NK=1,WDES%NKPTS
+#ifdef MPI
+      IF (MOD(NK-1,W%WDES%COMM_KINTER%NCPU).NE.W%WDES%COMM_KINTER%NODE_ME-1) CYCLE
+#endif
+!=======================================================================
+      CALL SETWDES(WDES,WDES1,NK)
+      WA=ELEMENTS(W, WDES1, ISP)
+
+!-----------------------------------------------------------------------
+! calculate the overlap matrix
+! OVERL(j,i) =  <phi(0)_j| S(0) |phi(1)_i>
+!----------------------------------------------------------------------
+    ! redistribute the projected wavefunctions
+    ! wavefunctions are still required at this point
+      IF (WDES%DO_REDIS) THEN
+        CALL REDIS_PW  (WDES1, NBANDS, W0%CW   (1,1,NK,ISP))
+        CALL REDIS_PROJ(WDES1, NBANDS, W0%CPROJ(1,1,NK,ISP))
+        CALL REDIS_PW  (WDES1, NBANDS, W%CW    (1,1,NK,ISP))
+        CALL REDIS_PROJ(WDES1, NBANDS, W%CPROJ (1,1,NK,ISP))
+      ENDIF
+
+      COVL=(0._q,0._q)
+
+      DO NPOS=1,NB_TOT-NSTRIP,NSTRIP
+         CALL ORTH2( &
+              W0%CW(1,1,NK,ISP),WA%CW_RED(1,NPOS),W0%CPROJ(1,1,NK,ISP), &
+              WA%CPROJ_RED(1,NPOS),NB_TOT, &
+              NPOS,NSTRIP,WDES1%NPL_RED,WDES1%NPRO_O_RED,WDES1%NRPLWV_RED,WDES1%NPROD_RED,COVL(1,1))
+      ENDDO
+
+      CALL ORTH2( &
+           W0%CW(1,1,NK,ISP),WA%CW_RED(1,NPOS),W0%CPROJ(1,1,NK,ISP), &
+           WA%CPROJ_RED(1,NPOS),NB_TOT, &
+           NPOS,NB_TOT-NPOS+1,WDES1%NPL_RED,WDES1%NPRO_O_RED,WDES1%NRPLWV_RED,WDES1%NPROD_RED,COVL(1,1))
+
+      CALLMPI( M_sum_g(WDES%COMM_KIN,COVL(1,1),NB_TOT*NB_TOT))
+!#ifdef debug
+      IF (IU0>=0) CALL DUMP_HAM( "ORTHO_LR: <phi(0)_j| S(0) |phi_i(1)>",WDES, COVL)
+!#endif
+1     FORMAT(1I2,3X,20F9.5)
+2     FORMAT(1I2,3X,20E9.1)
+!-----------------------------------------------------------------------
+! now remove the hermitian or unitary part of the rotation matrix
+!-----------------------------------------------------------------------
+      IF (LHERM) THEN
+      DO N2=1,NB_TOT
+      DO N1=1,N2-1
+         IF (FILLED(W0%FERTOT(N1,NK,ISP)) .AND. FILLED(W0%FERTOT(N2,NK,ISP)) ) THEN
+            C=(COVL(N1,N2)+GCONJG(COVL(N2,N1)))/2
+            COVL(N1,N2)=-C
+            COVL(N2,N1)=-GCONJG(C)
+         ELSE
+            COVL(N1,N2)=0
+            COVL(N2,N1)=0
+         ENDIF
+      ENDDO
+      ENDDO
+      ELSE
+      DO N2=1,NB_TOT
+      DO N1=1,N2-1
+         IF (FILLED(W0%FERTOT(N1,NK,ISP)) .AND. FILLED(W0%FERTOT(N2,NK,ISP)) ) THEN
+            C=(COVL(N1,N2)-GCONJG(COVL(N2,N1)))/2
+            COVL(N1,N2)=-C
+            COVL(N2,N1)= GCONJG(C)
+         ELSE
+            COVL(N1,N2)=0
+            COVL(N2,N1)=0
+         ENDIF
+      ENDDO
+      ENDDO
+      ENDIF
+!=======================================================================
+! rotate wavefunctions
+!=======================================================================
+      DWRITE "lincom ok"
+
+      IF (WDES%DO_REDIS) THEN
+         CALL REDIS_PW  (WDES1, NBANDS, W0%CW   (1,1,NK,ISP))
+         CALL REDIS_PROJ(WDES1, NBANDS, W0%CPROJ(1,1,NK,ISP))
+         CALL REDIS_PW  (WDES1, NBANDS, W%CW    (1,1,NK,ISP))
+         CALL REDIS_PROJ(WDES1, NBANDS, W%CPROJ (1,1,NK,ISP))
+         DWRITE "redis ok"
+      ENDIF
+
+!=======================================================================
+      ENDDO kpoint
+      ENDDO spin
+!=======================================================================
+      DEALLOCATE(COVL)
+
+      RETURN
+    END SUBROUTINE ORTHO_LR_TEST
+
+!***********************************************************************
+! 
+! function that yields .TRUE. if a state is fully occupied
+! this is a little bit ambiguous  the threshold is presently set
+! to something 0.99 electrons
+!
+!***********************************************************************
+
+  FUNCTION FILLED(F)
+    USE prec
+    IMPLICIT NONE
+    LOGICAL FILLED
+    REAL(q) :: F
+    IF (ABS(F-1)<0.1) THEN
+       FILLED=.TRUE.
+    ELSE
+       FILLED=.FALSE.
+    ENDIF
+  END FUNCTION FILLED
+
+!***********************************************************************
+!
+! add the first order change of the orbitals parallel to phi(0)
+! this involves adding the term
+!  phi(1) +=  -<phi(0)| S(1) |phi(0)> phi(0) /2
+! it is essential for stability reasons to do this at the very end,
+! since outherwise the norm of the residual vector (rmm-diis_lr) 
+! converges to a small non zero value, which decreases the stability
+! the routine EDDIAG_LR therefore removes this element
+! (i.e.  <phi(0)_i| S(0) |phi(1)_i> = 0 )
+!
+!***********************************************************************
+
+    SUBROUTINE NORM_LR( W1, W0, WXI,WDES)
+      USE wave_mpi
+      USE wave
+      
+      IMPLICIT NONE
+      
+      TYPE (wavespin)    W1
+      TYPE (wavespin)    W0
+      TYPE (wavespin)    WXI
+      TYPE (wavedes)     WDES
+
+      INTEGER ISP, NK, N
+
+      DO ISP=1,WDES%ISPIN
+         DO NK=1,WDES%NKPTS
+#ifdef MPI
+            IF (MOD(NK-1,WDES%COMM_KINTER%NCPU).NE.WDES%COMM_KINTER%NODE_ME-1) CYCLE
+#endif
+            DO N=1,WDES%NBANDS
+               W1%CW(:,N,NK,ISP)   =W1%CW(:,N,NK,ISP)   - W0%CW(:,N,NK,ISP)*WXI%FERWE(N,NK,ISP)/2
+               W1%CPROJ(:,N,NK,ISP)=W1%CPROJ(:,N,NK,ISP)- W0%CPROJ(:,N,NK,ISP)*WXI%FERWE(N,NK,ISP)/2
+            ENDDO
+         ENDDO
+      ENDDO
+
+    END SUBROUTINE NORM_LR
+
+END MODULE subrot_lr
diff -urN file_ini/symlib.F file_modify/symlib.F
--- file_ini/symlib.F	2024-07-13 10:37:12.000000000 +0800
+++ file_modify/symlib.F	2024-07-13 10:37:23.000000000 +0800
@@ -3801,6 +3801,7 @@
      &          S(1,2)*S(2,3)*S(3,1)-S(1,2)*S(2,1)*S(3,3) + &
      &          S(1,3)*S(2,1)*S(3,2)-S(1,3)*S(2,2)*S(3,1)
             VECROT(IA,:,ISP,3)=DET*VECROT(IA,:,ISP,3)
+            VECROT(IA,:,ISP,4)=DET*VECROT(IA,:,ISP,4)
 #endif
     2    CONTINUE
 ! Order the rotated atomic coordiantes ... :
diff -urN file_ini/symmetry.F file_modify/symmetry.F
--- file_ini/symmetry.F	2024-07-13 10:37:12.000000000 +0800
+++ file_modify/symmetry.F	2024-07-13 10:37:23.000000000 +0800
@@ -444,7 +444,7 @@
     END SUBROUTINE INISYM
 #else
       SUBROUTINE INISYM(A,POSION,VEL,LSFOR,LSDYN,NTYP,NITYP,NIOND, &
-     &           PTRANS,NRTK,NPCLL,ROTMAP,TAU,TAUROT,WRKROT,INDROT,ATOMOM,SAXIS,MAGROT,ISPIN,IU6)
+     &           PTRANS,NRTK,NPCLL,ROTMAP,TAU,TAUROT,WRKROT,INDROT,ATOMOM,SAXIS,MAGROT,ISPIN,IU6,B_DFPT)
       USE prec
 ! bexternal__
       USE bexternal
@@ -455,11 +455,14 @@
       LOGICAL LSDYN,LSFOR(3,NIOND)
       REAL(q) MAGROT(48,NIOND),SAXIS(3),ALPHA,BETA,ATOMOM_(3)
       INTEGER, POINTER ::  ROTMAP(:,:,:)
+! DFPT with magnetic field
+      REAL(q), OPTIONAL:: B_DFPT(3) ! cartesian coordinates
 
       DIMENSION A(3,3),POSION(3,NIOND),VEL(3,NIOND),NITYP(NTYP)
       DIMENSION TAU(NIOND,3),TAUROT(NIOND,3),WRKROT(3*(NIOND+2))
       DIMENSION PTRANS(NIOND+2,3),INDROT(NIOND+2),ATOMOM(3*NIOND)
-      DIMENSION TMP(NIOND,3,5),VEC(NIOND,3,3),SPIN(NIOND)
+      !DIMENSION TMP(NIOND,3,5),VEC(NIOND,3,3),SPIN(NIOND)
+      DIMENSION TMP(NIOND,3,6),VEC(NIOND,3,4),SPIN(NIOND) ! increase dimension for B_DFPT
 
       DIMENSION A1(3),A2(3),A3(3),IOPS(3,3,48),CELDIM(6),PDIM(6)
       DIMENSION COO1(3),COO2(3),B1(3),B2(3),B3(3),P1(3),P2(3),P3(3)
@@ -524,7 +527,7 @@
       TAU=TMP(:,:,1); VEC=0._q; SPIN=0._q
 
       CALL PRICELV(IBRAV,CELDIM,A(1,1),A(1,2),A(1,3),TAU,VEC,SPIN,P1,P2,P3,PTRANS, &
-     &    NPCELL,IPTYP,PDIM,NTYP,1,NITYP,NIOND,3,TAUROT,INDROT,WRKROT,IU6)
+     &    NPCELL,IPTYP,PDIM,NTYP,1,NITYP,NIOND,4,TAUROT,INDROT,WRKROT,IU6)
 
       AP(1,1)=P1(1)
       AP(2,1)=P1(2)
@@ -542,7 +545,7 @@
       TAU=TMP(:,:,2); VEC=0._q; SPIN=0._q
 
       CALL SETGRPV(ISYMOP,IOPS,GTRANS,NROT,NROTK,TAU,VEC,SPIN,IBRAV,NOP, &
-     &                      TAUROT,NTYP,1,NITYP,NIOND,3,INDROT,WRKROT,IU6)
+     &                      TAUROT,NTYP,1,NITYP,NIOND,4,INDROT,WRKROT,IU6)
 
       CALL PGROUP(ISYMOP,NROT,IPGIND,GRPNAM)
       IF (IU6>0) &
@@ -576,7 +579,7 @@
       VEC(:,:,1)=TMP(:,:,3)
 
       CALL PRICELV(IBRAV,CELDIM,A(1,1),A(1,2),A(1,3),TAU,VEC,SPIN,P1,P2,P3,PTRANS, &
-     &    NPCELL,IPTYP,PDIM,NTYP,1,NITYP,NIOND,3,TAUROT,INDROT,WRKROT,IU6)
+     &    NPCELL,IPTYP,PDIM,NTYP,1,NITYP,NIOND,4,TAUROT,INDROT,WRKROT,IU6)
 
       AP(1,1)=P1(1)
       AP(2,1)=P1(2)
@@ -595,7 +598,7 @@
       ENDDO
 
       CALL SETGRPV(ISYMOP,IOPS,GTRANS,NROT,NROTK,TAU,VEC,SPIN,IBRAV,NOP, &
-     &                      TAUROT,NTYP,1,NITYP,NIOND,3,INDROT,WRKROT,IU6)
+     &                      TAUROT,NTYP,1,NITYP,NIOND,4,INDROT,WRKROT,IU6)
       CALL PGROUP(ISYMOP,NROT,IPGIND,GRPNAM)
       IF (IU6>0) &
       WRITE(IU6,'(/4A)') 'The dynamic configuration has the ', &
@@ -650,7 +653,7 @@
          VEC(:,:,1)=TMP(:,:,3); VEC(:,:,2)=TMP(:,:,4)
 
          CALL PRICELV(IBRAV,CELDIM,A(1,1),A(1,2),A(1,3),TAU,VEC,SPIN,P1,P2,P3,PTRANS, &
-     &       NPCELL,IPTYP,PDIM,NTYP,1,NITYP,NIOND,3,TAUROT,INDROT,WRKROT,IU6)
+     &       NPCELL,IPTYP,PDIM,NTYP,1,NITYP,NIOND,4,TAUROT,INDROT,WRKROT,IU6)
 
          AP(1,1)=P1(1)
          AP(2,1)=P1(2)
@@ -670,7 +673,7 @@
          ENDDO
 
          CALL SETGRPV(ISYMOP,IOPS,GTRANS,NROT,NROTK,TAU,VEC,SPIN,IBRAV,NOP, &
-     &                         TAUROT,NTYP,1,NITYP,NIOND,3,INDROT,WRKROT,IU6)
+     &                         TAUROT,NTYP,1,NITYP,NIOND,4,INDROT,WRKROT,IU6)
          CALL PGROUP(ISYMOP,NROT,IPGIND,GRPNAM)
          IF (IU6>0) &
          WRITE(IU6,'(/4A)') 'The constrained configuration has the ', &
@@ -724,7 +727,7 @@
          SPIN=TMP(:,3,5)
 
          CALL PRICELV(IBRAV,CELDIM,A(1,1),A(1,2),A(1,3),TAU,VEC,SPIN,P1,P2,P3,PTRANS, &
-        &    NPCELL,IPTYP,PDIM,NTYP,1,NITYP,NIOND,3,TAUROT,INDROT,WRKROT,IU6)
+        &    NPCELL,IPTYP,PDIM,NTYP,1,NITYP,NIOND,4,TAUROT,INDROT,WRKROT,IU6)
 
          AP(1,1)=P1(1)
          AP(2,1)=P1(2)
@@ -745,7 +748,7 @@
          SPIN=TMP(:,3,5)
 
          CALL SETGRPV(ISYMOP,IOPS,GTRANS,NROT,NROTK,TAU,VEC,SPIN,IBRAV,NOP, &
-     &                         TAUROT,NTYP,1,NITYP,NIOND,3,INDROT,WRKROT,IU6)
+     &                         TAUROT,NTYP,1,NITYP,NIOND,4,INDROT,WRKROT,IU6)
          CALL PGROUP(ISYMOP,NROT,IPGIND,GRPNAM)
          IF (IU6>0) &
          WRITE(IU6,'(/4A)') 'The magnetic configuration has the ', &
@@ -817,13 +820,22 @@
             TMP(IA,1,5)=ATOMOM_(1)*B1(1)+ATOMOM_(2)*B1(2)+ATOMOM_(3)*B1(3)
             TMP(IA,2,5)=ATOMOM_(1)*B2(1)+ATOMOM_(2)*B2(2)+ATOMOM_(3)*B2(3)
             TMP(IA,3,5)=ATOMOM_(1)*B3(1)+ATOMOM_(2)*B3(2)+ATOMOM_(3)*B3(3)
+! Bring to direct coordinates and store in TMP(:,:,6) for DFPT with magnetic field
+            IF (PRESENT(B_DFPT)) THEN
+                TMP(IA,1,6)=B_DFPT(1)*B1(1)+B_DFPT(2)*B1(2)+B_DFPT(3)*B1(3)
+                TMP(IA,2,6)=B_DFPT(1)*B2(1)+B_DFPT(2)*B2(2)+B_DFPT(3)*B2(3)
+                TMP(IA,3,6)=B_DFPT(1)*B3(1)+B_DFPT(2)*B3(2)+B_DFPT(3)*B3(3)
+            ENDIF     
          ENDDO
 
          TAU=TMP(:,:,1)
          VEC(:,:,1)=TMP(:,:,3); VEC(:,:,2)=TMP(:,:,4); VEC(:,:,3)=TMP(:,:,5)
+         IF (PRESENT(B_DFPT)) THEN
+            VEC(:,:,4)=TMP(:,:,6)
+         ENDIF
 
          CALL PRICELV(IBRAV,CELDIM,A(1,1),A(1,2),A(1,3),TAU,VEC,SPIN,P1,P2,P3,PTRANS, &
-        &    NPCELL,IPTYP,PDIM,NTYP,1,NITYP,NIOND,3,TAUROT,INDROT,WRKROT,IU6)
+        &    NPCELL,IPTYP,PDIM,NTYP,1,NITYP,NIOND,4,TAUROT,INDROT,WRKROT,IU6)
 
          AP(1,1)=P1(1)
          AP(2,1)=P1(2)
@@ -837,14 +849,21 @@
 
          TAU=TMP(:,:,2)
          VEC(:,:,1)=TMP(:,:,3); VEC(:,:,2)=TMP(:,:,4); VEC(:,:,3)=TMP(:,:,5)
+         IF (PRESENT(B_DFPT)) THEN
+            VEC(:,:,4)=TMP(:,:,6)
+         ENDIF
+
          DO IA=1,NATOMS
             CALL VECCON(VEC(IA,1:3,1),VEC(IA,1:3,1),1,A(1,1),A(1,2),A(1,3),A1,A2,A3)
             CALL VECCON(VEC(IA,1:3,2),VEC(IA,1:3,2),1,A(1,1),A(1,2),A(1,3),A1,A2,A3)
             CALL VECCON(VEC(IA,1:3,3),VEC(IA,1:3,3),1,A(1,1),A(1,2),A(1,3),A1,A2,A3)
+            IF (PRESENT(B_DFPT)) THEN
+                CALL VECCON(VEC(IA,1:3,4),VEC(IA,1:3,4),1,A(1,1),A(1,2),A(1,3),A1,A2,A3)
+            ENDIF
          ENDDO
 
          CALL SETGRPV(ISYMOP,IOPS,GTRANS,NROT,NROTK,TAU,VEC,SPIN,IBRAV,NOP, &
-     &                         TAUROT,NTYP,1,NITYP,NIOND,3,INDROT,WRKROT,IU6)
+     &                         TAUROT,NTYP,1,NITYP,NIOND,4,INDROT,WRKROT,IU6)
          CALL PGROUP(ISYMOP,NROT,IPGIND,GRPNAM)
          IF (IU6>0) &
          WRITE(IU6,'(/4A)') 'The (compounded) configuration has the ', &
diff -urN file_ini/us.F file_modify/us.F
--- file_ini/us.F	2024-07-13 10:37:12.000000000 +0800
+++ file_modify/us.F	2024-07-13 10:37:23.000000000 +0800
@@ -56,7 +56,7 @@
   END INTERFACE
   INTERFACE
     SUBROUTINE SETDIJ_(WDES, GRIDC_,GRIDUS,C_TO_US,LATT_CUR,P,T_INFO, LOVERL, &
-        LMDIM,CDIJ,CQIJ, CVTOT_, LDIAGONAL_TERMS, IRDMAA,IRDMAX, DISPL)
+        LMDIM,CDIJ,CQIJ, CVTOT_, LDIAGONAL_TERMS, IRDMAA,IRDMAX, DISPL, QVEC_CART, LREAL)
       USE prec
       USE pseudo
       USE poscar
@@ -86,6 +86,9 @@
       LOGICAL  LOVERL
       REAL(q)  DISPL(3,T_INFO%NIONS)
       LOGICAL  LDIAGONAL_TERMS
+      ! DFPT
+      REAL(q), OPTIONAL :: QVEC_CART(3)
+      LOGICAL, OPTIONAL :: LREAL
     END SUBROUTINE SETDIJ_
   END INTERFACE
   INTERFACE
@@ -124,6 +127,38 @@
     END SUBROUTINE DEPLE
   END INTERFACE
   INTERFACE
+    SUBROUTINE DEPLE_ADD(WDES, GRID_SOFT,GRIDC,GRIDUS,C_TO_US, &
+        LATT_CUR,P,T_INFO,SYMM, LOVERL, SOFT_TO_C,&
+        LMDIM,CRHODE, CHTOT,CHDEN, IRDMAX, QVEC_CART, LCOS)
+      USE base
+      USE pseudo
+      USE poscar
+      USE mgrid
+      USE lattice
+      USE wave
+      IMPLICIT NONE
+
+      TYPE (type_info)   T_INFO
+      TYPE (potcar)      P(T_INFO%NTYP)
+      TYPE (grid_3d)     GRID_SOFT,GRIDC,GRIDUS
+      TYPE (transit)     C_TO_US
+      TYPE (transit)     SOFT_TO_C
+      TYPE (latt)        LATT_CUR
+      TYPE (wavedes)     WDES
+      TYPE (symmetry)    SYMM
+
+      INTEGER    LMDIM
+      INTEGER    IRDMAX
+      OVERLAP    CRHODE(LMDIM,LMDIM,WDES%NIONS,WDES%NCDIJ)
+      RGRID      CHTOT(DIMREAL(GRIDC%MPLWV),WDES%NCDIJ)
+      COMPLEX(q) CHDEN(GRID_SOFT%MPLWV,WDES%NCDIJ)
+      LOGICAL    LOVERL
+      ! DFPT
+      REAL(q), OPTIONAL :: QVEC_CART(3)
+      LOGICAL, OPTIONAL :: LCOS
+    END SUBROUTINE DEPLE_ADD
+  END INTERFACE
+  INTERFACE
     SUBROUTINE SETDIJ_AVEC_(WDES, GRIDC_,GRIDUS,C_TO_US,LATT_CUR,P,T_INFO, LOVERL, &
           LMDIM,CDIJ,AVTOT_, NONLR_S, NONL_S, IRDMAX, DISPL )
       USE prec
@@ -187,7 +222,7 @@
     SUBROUTINE AUGMENTATION_CHARGE( &
            WDES, GRIDC_, GRIDUS, C_TO_US, &
            LATT_CUR, P, T_INFO, SYMM, LOVERL, &
-           LMDIM, CRHODE, CHTOT_, IRDMAX, DISPL)
+           LMDIM, CRHODE, CHTOT_, IRDMAX, DISPL, QVEC_CART, LCOS)
       USE prec
       USE base
       USE charge
@@ -219,6 +254,9 @@
       RGRID,TARGET  :: CHTOT_(DIMREAL(GRIDC_%MPLWV),WDES%NCDIJ)
       LOGICAL   LOVERL,LADDITIONAL
       REAL(q)   DISPL(3,T_INFO%NIONS)
+      ! DFPT
+      REAL(q), OPTIONAL :: QVEC_CART(3)
+      LOGICAL, OPTIONAL :: LCOS
     END SUBROUTINE AUGMENTATION_CHARGE
   END INTERFACE
 
@@ -543,13 +581,15 @@
 !
 !***********************************************************************
 
-      SUBROUTINE DEPSUM1(W0, W1, WDES, LMDIM, CRHODE, LOVERL)
+      SUBROUTINE DEPSUM1(W0, W1, WDES, LMDIM, CRHODE, LOVERL, W2, W0_)
       USE prec
       USE wave
       IMPLICIT NONE
 
       TYPE (wavespin)    W0
-      TYPE (wavespin)    W1
+      TYPE (wavespin)    W1            ! W1_k+q
+      TYPE (wavespin), OPTIONAL :: W2  ! W1_k-q
+      TYPE (wavespin), OPTIONAL :: W0_  ! W0_k+q
       TYPE (wavedes)     WDES
       LOGICAL LOVERL
       INTEGER LMDIM
@@ -557,7 +597,7 @@
 
       INTEGER ISP, NT, NK, N, ISPINOR, ISPINOR_, LMBASE, LMBASE_, NIS, &
            LMMAXC, NI, L, LP
-      REAL(q) WEIGHT0, WEIGHT1
+      REAL(q) WEIGHT0, WEIGHT1, WEIGHT2, WEIGHT0_
 
 
       IF (.NOT.LOVERL) RETURN
@@ -577,6 +617,8 @@
 
       WEIGHT0=WDES%RSPIN*W0%FERWE(N,NK,ISP)*WDES%WTKPT(NK)
       WEIGHT1=WDES%RSPIN*W1%FERWE(N,NK,ISP)*WDES%WTKPT(NK)
+      IF (PRESENT(W2)) WEIGHT2=WDES%RSPIN*W2%FERWE(N,NK,ISP)*WDES%WTKPT(NK)
+      IF (PRESENT(W0_)) WEIGHT0_=WDES%RSPIN*W0_%FERWE(N,NK,ISP)*WDES%WTKPT(NK)
 
       spinor: DO ISPINOR =0,WDES%NRSPINORS-1
       DO ISPINOR_=0,WDES%NRSPINORS-1
@@ -597,10 +639,24 @@
 !DIR$ IVDEP
 !OCL NOVREC
         DO LP=1,LMMAXC
-           CRHODE(LP,L,NI,ISP+ISPINOR_+2*ISPINOR)=CRHODE(LP,L,NI,ISP+ISPINOR_+2*ISPINOR)+ &
-                WEIGHT1*W0%CPROJ(L+LMBASE,N,NK,ISP)*GCONJG(W0%CPROJ(LP+LMBASE_,N,NK,ISP))+ &
-                WEIGHT0*W1%CPROJ(L+LMBASE,N,NK,ISP)*GCONJG(W0%CPROJ(LP+LMBASE_,N,NK,ISP))+ &
-                WEIGHT0*W0%CPROJ(L+LMBASE,N,NK,ISP)*GCONJG(W1%CPROJ(LP+LMBASE_,N,NK,ISP))
+           IF (PRESENT(W2)) THEN
+              CRHODE(LP,L,NI,ISP+ISPINOR_+2*ISPINOR)=CRHODE(LP,L,NI,ISP+ISPINOR_+2*ISPINOR)+ &
+                   (WEIGHT1+(0._q,1._q)*WEIGHT2)*W0%CPROJ(L+LMBASE,N,NK,ISP)*GCONJG(W0%CPROJ(LP+LMBASE_,N,NK,ISP))+ &
+                   WEIGHT0*W1%CPROJ(L+LMBASE,N,NK,ISP)*GCONJG(W0%CPROJ(LP+LMBASE_,N,NK,ISP))
+              IF (PRESENT(W0_)) THEN
+              ! Given W0_k+q, indicate that W1_k-q is shifted from k-q to k
+                 CRHODE(LP,L,NI,ISP+ISPINOR_+2*ISPINOR)=CRHODE(LP,L,NI,ISP+ISPINOR_+2*ISPINOR)+ &
+                    WEIGHT0_*W0_%CPROJ(L+LMBASE,N,NK,ISP)*GCONJG(W2%CPROJ(LP+LMBASE_,N,NK,ISP))
+              ELSE
+                 CRHODE(LP,L,NI,ISP+ISPINOR_+2*ISPINOR)=CRHODE(LP,L,NI,ISP+ISPINOR_+2*ISPINOR)+ &
+                    WEIGHT0*W0%CPROJ(L+LMBASE,N,NK,ISP)*GCONJG(W2%CPROJ(LP+LMBASE_,N,NK,ISP))
+              ENDIF
+           ELSE
+              CRHODE(LP,L,NI,ISP+ISPINOR_+2*ISPINOR)=CRHODE(LP,L,NI,ISP+ISPINOR_+2*ISPINOR)+ &
+                   WEIGHT1*W0%CPROJ(L+LMBASE,N,NK,ISP)*GCONJG(W0%CPROJ(LP+LMBASE_,N,NK,ISP))+ &
+                   WEIGHT0*W1%CPROJ(L+LMBASE,N,NK,ISP)*GCONJG(W0%CPROJ(LP+LMBASE_,N,NK,ISP))+ &
+                   WEIGHT0*W0%CPROJ(L+LMBASE,N,NK,ISP)*GCONJG(W1%CPROJ(LP+LMBASE_,N,NK,ISP))
+           ENDIF
         ENDDO
         ENDDO
       
@@ -1546,7 +1602,7 @@
 
 !
     SUBROUTINE SETDIJ_(WDES, GRIDC_,GRIDUS,C_TO_US,LATT_CUR,P,T_INFO, LOVERL, &
-        LMDIM,CDIJ,CQIJ, CVTOT_, LDIAGONAL_TERMS, IRDMAA,IRDMAX, DISPL)
+        LMDIM,CDIJ,CQIJ, CVTOT_, LDIAGONAL_TERMS, IRDMAA,IRDMAX, DISPL, QVEC_CART, LREAL)
       USE prec
       USE pseudo
       USE poscar
@@ -1577,6 +1633,10 @@
       REAL(q)  DISPL(3,T_INFO%NIONS)
       LOGICAL  LDIAGONAL_TERMS
                            ! add atomic reference diagonal terms
+      ! DFPT
+      REAL(q), OPTIONAL :: QVEC_CART(3)
+      LOGICAL, OPTIONAL :: LREAL
+      REAL(q) QR_DFPT
 !  work arrays
       LOGICAL LADDITIONAL
       REAL(q)   DLM(256)
@@ -1587,9 +1647,10 @@
       REAL(q),ALLOCATABLE :: XS(:),YS(:),ZS(:)
       INTEGER :: LYDIM, LMYDIM, ISP, ISP_INC, NI, NIP, LOW, NT, LYMAX, MPLOW, & 
                  LL, LLP, LMP, LM, N, INDMAX, LDEP_INDEX, L, LP, M, MP, & 
-                 INDYLM, INDPYL, IND, QDEP_FOCK_INDEX
+                 INDYLM, INDPYL, IND, QDEP_FOCK_INDEX,I,J
       TYPE (potcar), POINTER :: PP
       INTEGER, EXTERNAL :: ONE_CENTER_NMAX_FOCKAE
+      REAL(q)  :: truncate_sig_fig
 #ifdef MPI
       ! mind: in the MPI version CTMP holds all elements
       ! to achieve good load balancing CDIJ is calculated locally on all nodes,
@@ -1631,7 +1692,7 @@
          QVEC(2)=WDES%QSPIRAL(1)*LATT_CUR%B(2,1)+WDES%QSPIRAL(2)*LATT_CUR%B(2,2)+WDES%QSPIRAL(3)*LATT_CUR%B(2,3)
          QVEC(3)=WDES%QSPIRAL(1)*LATT_CUR%B(3,1)+WDES%QSPIRAL(2)*LATT_CUR%B(3,2)+WDES%QSPIRAL(3)*LATT_CUR%B(3,3)
       ENDIF
- 
+
  spin:DO ISP=1,WDES%NCDIJ
 
       IF (LADDITIONAL) THEN
@@ -1676,7 +1737,16 @@
       IRDMAA=MAX(IRDMAA,INDMAX)
 
       DO N=1,INDMAX
-         POT(N)=CVTOT(NLI(N))
+         IF (PRESENT(QVEC_CART).AND.PRESENT(LREAL)) THEN
+            QR_DFPT=QVEC_CART(1)*XS(N)+QVEC_CART(2)*YS(N)+QVEC_CART(3)*ZS(N)
+            IF (LREAL) THEN
+               POT(N)=REAL(CVTOT(NLI(N))*EXP(CITPI*QR_DFPT),KIND=q)
+            ELSE
+               POT(N)=AIMAG(CVTOT(NLI(N))*EXP(CITPI*QR_DFPT))
+            ENDIF
+         ELSE
+            POT(N)=CVTOT(NLI(N))
+         ENDIF
       ENDDO
 !=======================================================================
 ! US-PP
@@ -1811,6 +1881,25 @@
        !  IF (L<=1) WRITE(0,'("DLM",I2,10F7.4)') L,(1E6*DLM(L**2+M),M=1,(L*2)+1)
       ENDDO
       CALL CALC_DLLMM( CTMP(:,:,NI,ISP), DLM, PP)
+! !-----------------------------------------------------------------------
+!    IF (PRESENT(QVEC_CART).AND.PRESENT(LREAL)) THEN
+!       LM =1
+!       DO L =1,PP%LMAX
+!       LMP=LM
+!       DO LP=L,PP%LMAX
+!     ! quantum numbers l and lp of these two channels
+!       LL =PP%LPS(L )
+!       LLP=PP%LPS(LP)
+!       IF (ABS(MOD(LL-LLP,2))==1) THEN
+!          CTMP(LM:LM+2*LL,LMP:LMP+2*LLP,NI,ISP)=0
+!          CTMP(LMP:LMP+2*LLP,LM:LM+2*LL,NI,ISP)=0
+!       ENDIF
+!       LMP=LMP+2*LLP+1
+!       ENDDO
+!       LM =LM +2*LL +1
+!       ENDDO
+!    ENDIF
+! !-----------------------------------------------------------------------
 !=======================================================================
 ! PAW contributions from accurate augmentation 
 ! currently spin spirals are no supported
@@ -1884,6 +1973,15 @@
 #ifdef MPI
            CDIJ(:,:,NIP,ISP)=CTMP(:,:,NI,ISP)
 #endif
+         ! IF (PRESENT(QVEC_CART).AND.PRESENT(LREAL)) THEN
+         !    DO J =1,LMDIM
+         !    DO I =1,LMDIM
+         !       DTMP1 = REAL(CDIJ(I,J,NIP,ISP),KIND=q)
+         !       DTMP2 = AIMAG(CDIJ(I,J,NIP,ISP))
+         !       CDIJ(I,J,NIP,ISP) = CMPLX(truncate_sig_fig(DTMP1,8),truncate_sig_fig(DTMP2,8),KIND=q)
+         !    ENDDO
+         !    ENDDO
+         ! ENDIF
         ENDDO
 
         LOW=1
@@ -1967,6 +2065,16 @@
       RETURN
     END SUBROUTINE SETDIJ_
 
+! function truncate_sig_fig(x, n)
+!       use prec
+!    implicit none
+!    REAL(q), intent(in) :: x
+!    integer, intent(in) :: n
+!    REAL(q) :: factor,truncate_sig_fig
+ 
+!    factor = 10._q ** (n - aint(log10(abs(x)+1E-8_q) + 1))
+!    truncate_sig_fig = aint(x * factor) / factor
+! end function truncate_sig_fig
 
 !************************ SUBROUTINE SETDIJ_AVEC_ **********************
 !
@@ -2821,7 +2929,7 @@
 
       SUBROUTINE DEPLE_ADD(WDES, GRID_SOFT,GRIDC,GRIDUS,C_TO_US, &
         LATT_CUR,P,T_INFO,SYMM, LOVERL, SOFT_TO_C,&
-        LMDIM,CRHODE, CHTOT,CHDEN, IRDMAX )
+        LMDIM,CRHODE, CHTOT,CHDEN, IRDMAX, QVEC_CART, LCOS)
       USE base
       USE pseudo
       USE poscar
@@ -2847,7 +2955,9 @@
       COMPLEX(q) CHDEN(GRID_SOFT%MPLWV,WDES%NCDIJ)
       LOGICAL    LOVERL,LADDITIONAL
       REAL(q)    DISPL(3,T_INFO%NIONS)
-
+      ! DFPT
+      REAL(q), OPTIONAL :: QVEC_CART(3)
+      LOGICAL, OPTIONAL :: LCOS
   ! local
       INTEGER    ISP
 !=======================================================================
@@ -2864,11 +2974,17 @@
 ! calculate augmentation charge 
 !=======================================================================
       DISPL=0
-      CALL AUGMENTATION_CHARGE( &
-           WDES, GRIDC, GRIDUS, C_TO_US, &
-           LATT_CUR, P, T_INFO, SYMM, LOVERL, &
-           LMDIM, CRHODE, CHTOT, IRDMAX, DISPL)
-
+      IF (PRESENT(QVEC_CART).AND.PRESENT(LCOS)) THEN
+         CALL AUGMENTATION_CHARGE( &
+              WDES, GRIDC, GRIDUS, C_TO_US, &
+              LATT_CUR, P, T_INFO, SYMM, LOVERL, &
+              LMDIM, CRHODE, CHTOT, IRDMAX, DISPL, QVEC_CART, LCOS)
+      ELSE
+         CALL AUGMENTATION_CHARGE( &
+              WDES, GRIDC, GRIDUS, C_TO_US, &
+              LATT_CUR, P, T_INFO, SYMM, LOVERL, &
+              LMDIM, CRHODE, CHTOT, IRDMAX, DISPL)
+      ENDIF
       DO ISP=1,WDES%NCDIJ
          CALL ADD_GRID(GRIDC, GRID_SOFT, SOFT_TO_C,CHDEN(1,ISP),CHTOT(1,ISP))
 
@@ -2895,7 +3011,7 @@
     SUBROUTINE AUGMENTATION_CHARGE( &
            WDES, GRIDC_, GRIDUS, C_TO_US, &
            LATT_CUR, P, T_INFO, SYMM, LOVERL, &
-           LMDIM, CRHODE, CHTOT_, IRDMAX, DISPL)
+           LMDIM, CRHODE, CHTOT_, IRDMAX, DISPL, QVEC_CART, LCOS)
       USE prec
       USE base
       USE charge
@@ -2927,6 +3043,10 @@
       RGRID,TARGET  :: CHTOT_(DIMREAL(GRIDC_%MPLWV),WDES%NCDIJ)
       LOGICAL   LOVERL,LADDITIONAL
       REAL(q)   DISPL(3,T_INFO%NIONS)
+      ! DFPT
+      REAL(q), OPTIONAL :: QVEC_CART(3)
+      LOGICAL, OPTIONAL :: LCOS
+      REAL(q) QR_DFPT
 !  work arrays
       TYPE (potcar), POINTER :: PP
       RGRID,POINTER :: CHTOT(:)
@@ -3271,7 +3391,16 @@
 !=======================================================================
       SUMN=0
       DO IND=1,INDMAX
-        CHTOT(NLI(IND))=CHTOT(NLI(IND))+SUM(IND)
+        IF (PRESENT(QVEC_CART).AND.PRESENT(LCOS)) THEN
+           QR_DFPT=TPI*(QVEC_CART(1)*XS(IND)+QVEC_CART(2)*YS(IND)+QVEC_CART(3)*ZS(IND))
+           IF (LCOS) THEN
+             CHTOT(NLI(IND))=CHTOT(NLI(IND))+SUM(IND)*COS(-QR_DFPT)
+           ELSE
+             CHTOT(NLI(IND))=CHTOT(NLI(IND))+SUM(IND)*SIN(-QR_DFPT)
+           ENDIF
+        ELSE
+           CHTOT(NLI(IND))=CHTOT(NLI(IND))+SUM(IND)
+        ENDIF
         SUMN=SUMN+SUM(IND)
       ENDDO
 !-----------------------------------------------------------------------
diff -urN file_ini/xcspin.F file_modify/xcspin.F
--- file_ini/xcspin.F	2024-07-13 10:37:12.000000000 +0800
+++ file_modify/xcspin.F	2024-07-13 10:37:23.000000000 +0800
@@ -1,4 +1,58 @@
 #include "symbol.inc"
+
+  MODULE xcspin_interface
+    INTERFACE
+      SUBROUTINE FEXCGS(NCDIJ,GRIDC,LATT_CUR,XCENC,EXC,CVZERO,XCSIF, &
+                  CHTOT,CWORK,DENCOR,CHTOT1_GGAcorr,QVEC_CART)
+      USE prec
+      USE lattice
+      USE mgrid
+
+      IMPLICIT COMPLEX(q) (C)
+      IMPLICIT REAL(q) (A-B,D-H,O-Z)
+
+      TYPE (grid_3d)     GRIDC
+      TYPE (latt)        LATT_CUR
+
+      COMPLEX(q) CHTOT(GRIDC%MPLWV,NCDIJ),CWORK(GRIDC%MPLWV,NCDIJ)
+      RGRID      DENCOR(GRIDC%RL%NP)
+      DIMENSION XCSIF(3,3)
+! First order density
+      COMPLEX(q), OPTIONAL :: CHTOT1_GGAcorr(GRIDC%MPLWV,NCDIJ)
+      REAL(q), OPTIONAL :: QVEC_CART(3)
+      END SUBROUTINE FEXCGS
+    END INTERFACE
+    INTERFACE
+      SUBROUTINE FEXCGS_NONCOL_(NCDIJ,GRIDC,LATT_CUR,XCENC,EXC,CVZERO,XCSIF, &
+     &            CWGRAD,CHTOT,CWORK, &
+     &            DWGRAD,DHTOT,DWORK, &
+     &            DENCOR,DWORKG,DWORK1,DWORK2,DWORK3,DVC,CHTOT1_GGAcorr,QVEC_CART)
+      USE prec
+      USE lattice
+      USE mgrid
+
+      IMPLICIT COMPLEX(q) (C)
+      IMPLICIT REAL(q) (A-B,D-H,O-Z)
+
+      TYPE (grid_3d)     GRIDC
+      TYPE (latt)        LATT_CUR
+
+      COMPLEX(q) CHTOT(GRIDC%MPLWV,NCDIJ),CWORK(GRIDC%MPLWV,NCDIJ), &
+              CWGRAD(GRIDC%MPLWV,NCDIJ)
+      COMPLEX(q)   DHTOT(DIMREAL(GRIDC%MPLWV),NCDIJ),DWORK(DIMREAL(GRIDC%MPLWV),NCDIJ), &
+              DWGRAD(DIMREAL(GRIDC%MPLWV),NCDIJ)
+      RGRID   DENCOR(GRIDC%RL%NP)
+      REAL(q) XCSIF(3,3)
+      REAL(q) DWORKG(GRIDC%RL%NP,NCDIJ/2),DWORK1(GRIDC%RL%NP,NCDIJ), &
+              DWORK2(GRIDC%RL%NP,NCDIJ),DWORK3(GRIDC%RL%NP,NCDIJ), &
+              DVC(GRIDC%RL%NP)
+! First order density
+      COMPLEX(q), OPTIONAL :: CHTOT1_GGAcorr(GRIDC%MPLWV,NCDIJ)
+      REAL(q), OPTIONAL :: QVEC_CART(3)
+      END SUBROUTINE FEXCGS_NONCOL_
+    END INTERFACE
+  END MODULE xcspin_interface
+
 !************************ SUBROUTINE FEXGCS *****************************
 ! RCS:  $Id: xcspin.F,v 1.6 2003/06/27 13:22:24 kresse Exp kresse $
 !
@@ -24,12 +78,13 @@
 !*********** ************************************************************
 
       SUBROUTINE FEXCGS(NCDIJ,GRIDC,LATT_CUR,XCENC,EXC,CVZERO,XCSIF, &
-                  CHTOT,CWORK,DENCOR)
+                  CHTOT,CWORK,DENCOR,CHTOT1_GGAcorr,QVEC_CART)
       USE prec
       USE lattice
       USE mpimy
       USE mgrid
       USE setexm
+      USE xcspin_interface, ONLY: FEXCGS_NONCOL_
 
       IMPLICIT COMPLEX(q) (C)
 
@@ -49,7 +104,9 @@
       REAL(q),ALLOCATABLE :: DWORK4(:), DWORK6(:), DWORK7(:)
       RGRID ,ALLOCATABLE ::  DWORK5(:)
 !vdw jk
-      
+! First order density
+      COMPLEX(q), OPTIONAL :: CHTOT1_GGAcorr(GRIDC%MPLWV,NCDIJ)
+      REAL(q), OPTIONAL :: QVEC_CART(3)
 
       IF (.NOT. ISGGA()) THEN
          WRITE(*,*) 'internal ERROR:  FEXCGS called with non gradient corrected functional'
@@ -85,10 +142,17 @@
          ALLOCATE(CWGRAD(GRIDC%MPLWV,NCDIJ), DWORKG(NP1,NCDIJ/2), &
            DWORK1(NP1,NCDIJ),DWORK2(NP1,NCDIJ),DWORK3(NP1,NCDIJ),DVC(NP1))
 
-         CALL FEXCGS_NONCOL_(NCDIJ,GRIDC,LATT_CUR,XCENC,EXC,CVZERO,XCSIF, &
-        &            CWGRAD,CHTOT,CWORK, &
-        &            CWGRAD,CHTOT,CWORK, &
-        &            DENCOR,DWORKG,DWORK1,DWORK2,DWORK3,DVC)
+         IF (PRESENT(CHTOT1_GGAcorr) .AND. PRESENT(QVEC_CART)) THEN
+            CALL FEXCGS_NONCOL_(NCDIJ,GRIDC,LATT_CUR,XCENC,EXC,CVZERO,XCSIF, &
+           &            CWGRAD,CHTOT,CWORK, &
+           &            CWGRAD,CHTOT,CWORK, &
+           &            DENCOR,DWORKG,DWORK1,DWORK2,DWORK3,DVC,CHTOT1_GGAcorr,QVEC_CART)
+         ELSE
+            CALL FEXCGS_NONCOL_(NCDIJ,GRIDC,LATT_CUR,XCENC,EXC,CVZERO,XCSIF, &
+           &            CWGRAD,CHTOT,CWORK, &
+           &            CWGRAD,CHTOT,CWORK, &
+           &            DENCOR,DWORKG,DWORK1,DWORK2,DWORK3,DVC)
+         ENDIF
 
          DEALLOCATE(CWGRAD,DWORKG,DWORK1,DWORK2,DWORK3,DVC)         
 !-MM- end of changes to calculation of gga in noncollinear case
@@ -564,6 +628,7 @@
       USE mpimy
       USE mgrid
       USE setexm
+      USE xcspin_interface, ONLY: FEXCGS_NONCOL_
 
       IMPLICIT COMPLEX(q) (C)
 
@@ -1076,7 +1141,7 @@
       SUBROUTINE FEXCGS_NONCOL_(NCDIJ,GRIDC,LATT_CUR,XCENC,EXC,CVZERO,XCSIF, &
      &            CWGRAD,CHTOT,CWORK, &
      &            DWGRAD,DHTOT,DWORK, &
-     &            DENCOR,DWORKG,DWORK1,DWORK2,DWORK3,DVC)
+     &            DENCOR,DWORKG,DWORK1,DWORK2,DWORK3,DVC,CHTOT1_GGAcorr,QVEC_CART)
       USE prec
       USE lattice
       USE mpimy
@@ -1102,6 +1167,10 @@
               DVC(GRIDC%RL%NP)
       REAL(q) MAG_NORM,NABMAG(3)
       REAL(q) :: CHGMIN=1E-10
+! First order density
+      COMPLEX(q), OPTIONAL :: CHTOT1_GGAcorr(GRIDC%MPLWV,NCDIJ)
+      REAL(q), OPTIONAL :: QVEC_CART(3)
+      COMPLEX(q) CWORK1(GRIDC%MPLWV,NCDIJ)
 
 ! set to one for error-dumps
 #ifdef MPI
@@ -1145,6 +1214,11 @@
       CALL OPSYNC(DWORK(1,ISP),CWORK(1,ISP),GRIDC%NPLWV)
       CALL FFT3D(CWORK(1,ISP),GRIDC,-1)
       CALL TRUNC_HIGH_FREQU(LATT_CUR, GRIDC, CWORK(1,ISP))
+      IF (PRESENT(CHTOT1_GGAcorr) .AND. PRESENT(QVEC_CART)) THEN
+         DO I=1,GRIDC%RL%NP
+            CWORK1(I,ISP)=CHTOT1_GGAcorr(I,ISP)/LATT_CUR%OMEGA
+         ENDDO
+      ENDIF
 !=======================================================================
 ! now calculate the gradients
 !=======================================================================
@@ -1169,6 +1243,9 @@
       CALL OPSYNC(DWORK(1,ISP),CWORK(1,ISP),GRIDC%NPLWV)
       DO I=1,GRIDC%RL%NP
          DWORK1(I,ISP)= REAL( DWORK(I,ISP) ,KIND=q)
+         IF (PRESENT(CHTOT1_GGAcorr) .AND. PRESENT(QVEC_CART)) THEN
+            DWORK1(I,ISP)=DWORK1(I,ISP)-REAL(CWORK1(I,ISP),KIND=q)*QVEC_CART(1)*TPI
+         ENDIF
       ENDDO
 !
 ! y-component:
@@ -1192,6 +1269,9 @@
       CALL OPSYNC(DWORK(1,ISP),CWORK(1,ISP),GRIDC%NPLWV)
       DO I=1,GRIDC%RL%NP
          DWORK2(I,ISP)= REAL( DWORK(I,ISP) ,KIND=q)
+         IF (PRESENT(CHTOT1_GGAcorr) .AND. PRESENT(QVEC_CART)) THEN
+            DWORK2(I,ISP)=DWORK2(I,ISP)-REAL(CWORK1(I,ISP),KIND=q)*QVEC_CART(2)*TPI
+         ENDIF
       ENDDO
 !
 ! z-component:
@@ -1215,6 +1295,9 @@
       CALL OPSYNC(DWORK(1,ISP),CWORK(1,ISP),GRIDC%NPLWV)
       DO I=1,GRIDC%RL%NP
          DWORK3(I,ISP)= REAL( DWORK(I,ISP) ,KIND=q)
+         IF (PRESENT(CHTOT1_GGAcorr) .AND. PRESENT(QVEC_CART)) THEN
+            DWORK3(I,ISP)=DWORK3(I,ISP)-REAL(CWORK1(I,ISP),KIND=q)*QVEC_CART(3)*TPI
+         ENDIF
       ENDDO
       ENDDO spin
 
@@ -1429,6 +1512,9 @@
          N3= GRIDC%RC%I3(NC)
 
          GX=(GRIDC%LPCTX(N1)*LATT_CUR%B(1,1)+GRIDC%LPCTY(N2)*LATT_CUR%B(1,2)+GRIDC%LPCTZ(N3)*LATT_CUR%B(1,3))
+         IF (PRESENT(CHTOT1_GGAcorr) .AND. PRESENT(QVEC_CART)) THEN
+            GX=GX+QVEC_CART(1)
+         ENDIF
          CWGRAD(I,ISP)=CWORK(I,ISP)*GX*CITPI
       ENDDO
 
@@ -1447,6 +1533,9 @@
          N3= GRIDC%RC%I3(NC)
 
          GY=(GRIDC%LPCTX(N1)*LATT_CUR%B(2,1)+GRIDC%LPCTY(N2)*LATT_CUR%B(2,2)+GRIDC%LPCTZ(N3)*LATT_CUR%B(2,3))
+         IF (PRESENT(CHTOT1_GGAcorr) .AND. PRESENT(QVEC_CART)) THEN
+            GY=GY+QVEC_CART(2)
+         ENDIF
          CWGRAD(I,ISP)=CWGRAD(I,ISP)+CWORK(I,ISP)*GY*CITPI
       ENDDO
 
@@ -1465,6 +1554,9 @@
          N3= GRIDC%RC%I3(NC)
 
          GZ=(GRIDC%LPCTX(N1)*LATT_CUR%B(3,1)+GRIDC%LPCTY(N2)*LATT_CUR%B(3,2)+GRIDC%LPCTZ(N3)*LATT_CUR%B(3,3))
+         IF (PRESENT(CHTOT1_GGAcorr) .AND. PRESENT(QVEC_CART)) THEN
+            GZ=GZ+QVEC_CART(3)
+         ENDIF
          CWGRAD(I,ISP)=CWGRAD(I,ISP)+CWORK(I,ISP)*GZ*CITPI
       ENDDO
 
@@ -1498,8 +1590,13 @@
 
          VXC1=DWORKG(I,1)- REAL( DWGRAD(I,1) ,KIND=q) *RINPL
          VXC2=DWORKG(I,2)- REAL( DWGRAD(I,2) ,KIND=q) *RINPL
-         DWORK(I,1)=VXC1
-         DWORK(I,2)=VXC2
+         IF (PRESENT(CHTOT1_GGAcorr) .AND. PRESENT(QVEC_CART)) THEN
+            DWORK(I,1)=DWORKG(I,1)- DWGRAD(I,1)*RINPL
+            DWORK(I,2)=DWORKG(I,2)- DWGRAD(I,2)*RINPL
+         ELSE
+            DWORK(I,1)=VXC1
+            DWORK(I,2)=VXC2
+         ENDIF
          VXC = 0.5_q*(VXC1+VXC2)
          CVZERO=CVZERO+VXC
          XCENCC=XCENCC-VXC1*RHO1*LATT_CUR%OMEGA-VXC2*RHO2*LATT_CUR%OMEGA
